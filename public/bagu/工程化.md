#### webpack vite区别

#### loader plugin区别

#### webpack场景配置项

首先是入口和输出配置，比如 `entry` 和 `output`，用于定义构建的入口文件以及最终打包产物的输出路径和文件名。

其次是模块解析和处理相关的配置，包括 `resolve`，用于配置文件后缀名解析和路径别名，以及 `module.rules` 中的 loader，用来处理不同类型的资源文件。

然后是插件相关配置，通过 `plugins` 在 webpack 构建的各个生命周期阶段执行特定逻辑。

另外还有一些环境和开发相关的配置，比如 `mode` 区分开发和生产环境，`devServer` 用于本地开发配置，`devtool` 用于 source map 设置。

最后是 `optimization`，用于构建优化，比如代码压缩、`splitChunks` 做代码分包，以及 `runtimeChunk` 抽离运行时代码以支持长期缓存。

#### Rollup 的适用场景

ESM的项目或者打包库

#### Parcel

提供一个**极速、开箱即用**的现代前端开发体验，让开发者可以专注于代码本身，而不是复杂的构建配置

**零配置**这是 Parcel 最大的卖点。对于大多数常见的项目类型（如 JavaScript、CSS、HTML、图片等），它不需要任何配置文件 (`parcel.config.js` 或 `webpack.config.js`) 就能直接工作。

极速打包**Parcel 利用 **多核处理 (Worker 进程)** 来并行编译资源，并使用文件系统缓存。这使得它的初始构建和二次构建速度都非常快。*

自动转换**它能自动检测和转换代码，例如：如果发现使用了 **Babel**、**PostCSS** 或 **TypeScript**，它会自动使用相应的工具进行转换，无需手动配置 Loader 或 Plugin。

资源支持**Parcel 天生支持各种文件类型，包括 JS、CSS、HTML、图片、字体等，并且能自动处理它们之间的依赖关系，不需要额外的插件。

代码分割****零配置**支持基于 ES 模块的**动态导入 (`import()`)**，并自动将应用分割成更小的块，实现按需加载。

HMR (热模块替换)**在开发模式下，Parcel 默认启用快速的热模块替换，可以保留应用状态并即时更新模块，提高开发效率。

Parcel 与传统的打包工具（如 Webpack）的主要区别在于**配置哲学**：

- **Webpack：** 是一种高度可配置的工具，通过复杂的配置文件（Entry、Loader、Plugin）来实现强大的功能和定制性。

- **Parcel：** 追求**极简主义**，通过内置的智能模块解析和转换机制，在大多数情况下实现零配置，牺牲部分定制性来换取极高的开发效率和易用性。

**总结：** Parcel 是一个适合快速启动、中小型项目，以及追求简单配置和极致开发速度的开发者的优秀选择。

#### <mark>Tree shaking原理和条件</mark>

Tree Shaking 的原理可以概括为两步：**标记（Marking）和清除（Sweeping）**。

1. 标记：基于 ES Module 的静态分析

Tree Shaking 依赖于 **ES Module (ESM)** 的**静态特性**。

- **静态结构：** ESM 的 `import` 和 `export` 语句在代码执行前就已经确定了模块之间的依赖关系和导出的名称。这意味着，构建工具可以在**编译阶段（编译时）**，而不是运行阶段，确定哪些代码被使用了，哪些没有。

- **依赖图构建：** 构建工具会从入口文件开始，构建一个完整的模块依赖图（Module Dependency Graph）。

- **使用标记：** 在遍历依赖图的过程中，构建工具会标记出**实际被导入和使用的**模块、函数或变量。没有被任何地方导入或引用的代码则会被标记为“未使用”。
2. 清除：移除未标记的代码
- 在标记阶段完成后，优化器（通常是 UglifyJS 或 Terser）会执行清除操作。

- 它会遍历所有模块，**物理性地移除**那些被标记为“未使用”（即 Dead Code）的代码块。

✅ Tree Shaking 的生效条件

 1. 必须使用 ES Module 语法

- **导出：** 必须使用 `export` 或 `export default`。

- **导入：** 必须使用 `import` 语句。

- ESM 的 `import()` 动态导入不会阻止 Tree Shaking，反而会成为 Tree Shaking 的起点，实现更精细的按需加载。

- 在这个动态导入的场景中，Tree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。
2. 保证代码是“无副作用的” (Side-Effect Free)

Tree Shaking 的机制是安全的移除**没有副作用**的代码。

- **定义：** “副作用”是指执行该模块时，除了导出值之外，还会修改全局状态或执行其他操作（例如：修改 DOM、调用 API、修改原型链）。

- **标记：** 如果一个模块被标记为有副作用，即使它的导出没有被使用，构建工具也可能出于安全考虑保留整个模块。

- **实践：`package.json` 的 `"sideEffects": false`** 为了告诉构建工具一个库（或文件）是完全无副作用的，可以在项目的 `package.json` 中添加

3.配置生产模式优化，通过设置 `mode: 'production'` 启用，因为它默认包含了像 Terser 这样的代码压缩工具，而压缩工具是执行最终清除（Sweeping）步骤的关键。

4.转换工具的配置。如果使用了 Babel 等工具进行代码转换，必须配置它**不将 ES Module 转换成 CommonJS 模块**。

- 例如，在 Babel 配置中，需要确保 `@babel/preset-env` 中**没有**设置 `modules: 'commonjs'`，或者明确设置为 `modules: false`：

#### <mark>Code Splitting 的多种方案</mark>

1.入口点分割 (Entry Points)

这是最基础的分割方式。开发者手动在配置文件中定义多个入口文件，Webpack 会为每一个入口点生成一个独立的 Bundle。

- **实现方式：** 在 `webpack.config.js` 的 `entry` 配置中定义多个键值对。

- **适用场景：** 传统多页应用 (MPA)，每个页面对应一个入口；或者当你有两个完全独立的 SPA，想用一个 Webpack 配置打包时。

- 示例 entry: {
   pageA: './src/page-a.js',
   pageB: './src/page-b.js',
   },

- **缺点：** 无法动态加载，且公共依赖代码（如 React 库）会被重复打包到每个入口的 Bundle 中

当构建工具遇到 `import('./moduleA')` 时，它会将 `moduleA` 及其所有依赖单独打包成一个或多个 **Chunk（代码块）**，并在运行时异步加载。

Tree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。

2.动态导入 (Dynamic Imports / 运行时加载)

这是最常用、最灵活的代码分割方案，基于 ES Module 的 `import()` 语法，在运行时根据需要加载代码。

- **实现方式：** 在代码中使用 `import('./path/to/module')`。

- **适用场景：**
  
  - **路由懒加载：** 将每个路由页面打包成独立的 Chunk。
  
  - **组件懒加载：** 将不常用或在视口外的组件进行懒加载。
  
  - **条件加载：** 例如，用户点击某个按钮或满足某个条件时才加载特定的库。

- **优点：** 实现了真正的**按需加载 (On-demand)**，大幅减少初始加载体积。

- **缺点：** 必须处理加载状态（如使用 Suspense 或 Loading 占位符）。

3.提取公共模块 (Vendor/Commons)

目的是将多个模块（入口或动态导入）共享的依赖（如 React, Lodash, jQuery 等第三方库）提取出来，形成一个独立的公共 Chunk，以利用客户端的**缓存机制**。

- **实现方式：** 使用 Webpack 的 `optimization.splitChunks` 配置。

- **适用场景：** 任何包含大量第三方依赖或有多个入口点的应用。

- **配置策略 (`optimization.splitChunks`)：**
  
  - **`vendors` (第三方库)：** 将所有来自 `node_modules` 的模块打包在一起。
  
  - **`default` (公共模块)：** 将应用内被多个模块（通常是两个以上）引用的代码提取出来。

- **优点：** 充分利用浏览器缓存，核心库代码（如 React）稳定后，用户无需重复下载。

- 示例 

```js
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: 'all', // 对所有类型的 Chunk 生效
      cacheGroups: {
        // 自动提取 node_modules 中的库
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: -10,
        },
        // 提取被多次使用的公共模块
        default: {
          minChunks: 2, 
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
};
```

#### 优化代码分割产物加载速度的机制

- **实现方式：** 使用 Webpack 内联注释（Magic Comments）或 HTML 标签。
  
  - **`/* webpackPreload: true */`**
  
  - **`/* webpackPrefetch: true */`**

- **适用场景：**
  
  - **`Preload` (预加载)：** 用于当前页面**很快就会需要**的资源（如当前路由的字体、关键图片或首个动态加载的 Chunk）。它会和父 Chunk 并行加载，优先级较高。
  
  - **`Prefetch` (预取)：** 用于用户**未来可能会需要**的资源（如用户可能会跳转到的下一个路由页面）。它会在浏览器空闲时加载，优先级较低。

#### <mark>Babel编译原理和插件开发</mark>

Babel 的编译过程严格遵循计算机科学中的编译器原理，可以划分为三个核心阶段：**解析 (Parse)**、**转换 (Transform)** 和 **生成 (Generate)**。

阶段一：解析：此阶段的目标是将原始源代码转换为抽象语法树 (AST)。

1. **词法分析 (Lexical Analysis/Tokenizing):**
   
   - 将输入的代码字符串分解成一个个独立的、最小的语法单元，称为 **Token**（标记）。
   
   - 例如：`const a = 1;` 会被分解为 `const`, `a`, `=`, `1`, `;` 等 Token。

2. **语法分析 (Syntactic Analysis/Parsing):**
   
   - 将 Token 流组合成一个树状的结构，即 **AST (Abstract Syntax Tree)**。
   
   - AST 中的每个节点都代表了代码中的一个结构，如变量声明 (`VariableDeclaration`)、标识符 (`Identifier`)、函数调用 (`CallExpression`) 等。
   
   - Babel 默认使用 **`@babel/parser`** (以前叫 Babylon) 来进行解析。

获得的AST是个很大超大的JSON，好在Webpack 或 Babel 是**逐个文件**读取和处理的。并且AST不存储时，是临时的数据

阶段二：转换 (Transformation)

这是 Babel 工作的核心，**插件**主要在这个阶段发挥作用。

1. **遍历 (Traversing):**
   
   - Babel 会深度优先遍历整个 AST。

2. **插件执行:**
   
   - 当遍历器遇到特定的节点类型时，它会调用注册了该节点类型的 **Babel 插件**。
   
   - 插件通过操作 AST 节点（增、删、改、替换），将高版本语法转换为目标环境支持的语法。
   
   - 例如，将 ES6 的箭头函数 (`ArrowFunctionExpression`) 节点转换成 ES5 的普通函数表达式 (`FunctionExpression`) 节点。

3. **Babel 默认使用 **`@babel/traverse`** 来进行 AST 遍历和节点操作。

阶段三：生成 (Generating)

此阶段的目标是将转换后的 AST 重新渲染为目标代码字符串。

1. **递归生成:** Babel 递归地遍历修改后的 AST，将每个节点打印成对应的代码字符串。

2. **Source Map:** 同时，还会生成 **Source Map**，用于将转译后的代码映射回原始源代码，以便于调试。

3. **Babel 默认使用 **`@babel/generator`** 来进行代码生成。

#### 自动化测试策略

#### <mark>Webpack 构建流程和原理</mark>

阶段一：初始化 (Initialization)：Webpack 从启动到开始处理文件前的准备阶段。

1. **参数合并:** 读取并合并 `webpack.config.js` 中的配置参数、Shell 命令行参数以及默认配置。

2. **创建 Compiler:** 创建一个 `Compiler` 实例。`Compiler` 是 Webpack 的核心对象，它贯穿整个生命周期，负责协调整个构建流程。

3. **加载插件:** 遍历配置中的 `plugins` 数组，依次执行插件的 `apply` 方法，注册各种 Hook（钩子）函数，监听 Compiler 或 Compilation 的事件。

阶段二：构建模块 (Building Modules)：此阶段的核心是根据入口文件递归地构建**模块依赖图 (Module Dependency Graph)**。

1. **确定入口:** 从配置中定义的 `entry` 入口文件开始。

2. **创建 Compilation:** 创建一个 `Compilation` 实例。`Compilation` 对象负责本次构建过程的资源管理，包括模块、依赖图、Chunk、生成的资源文件等信息。

3. **Module 构建循环:** Webpack 进入模块处理的循环：
   
   - **加载 (Loading):** 根据模块路径读取文件内容。
   
   - **解析 (Resolving):** 使用配置好的 `resolve` 规则，确定模块的绝对路径。
   
   - **处理 (Processing):**
     
     - 将文件内容传递给匹配的 **`Loader`**。Loader 负责将非 JS 类型的资源（如 TS, Sass, Vue 文件）转换为有效的 JavaScript 模块内容，或进行转换（如 Babel 转译）。
     
     - Loader 链式执行，前一个 Loader 的输出是后一个 Loader 的输入。
   
   - **依赖分析:** 使用 **`Parser`** (解析器) 遍历经过 Loader 处理后的代码内容。解析器会识别出代码中的 `import`、`require()`、`import()` 等模块导入语句。
   
   - **递归:** 每识别到一个依赖，就将其加入到依赖图，并对该依赖文件重复整个构建循环，直到所有依赖都被处理。

阶段三：生成资源 (Sealing & Emitting)

在依赖图构建完成后，Webpack 开始将模块组合成可部署的资源文件。

1. **Chunk 分组:** 将构建好的模块根据它们的关系进行分组，形成 **Chunks** (代码块)。
   
   - **Entry Chunk:** 对应入口文件及其同步依赖。
   
   - **Lazy Chunk:** 对应通过 `import()` 动态导入形成的异步加载模块。
   
   - **Vendor/Common Chunk:** 对应通过 `SplitChunksPlugin` 提取的公共/第三方模块。

2. **Chunk 优化 (Tree Shaking/Code Splitting):** 运行优化步骤，如 Tree Shaking 移除未使用的代码，以及 `splitChunks` 配置提取公共代码。

3. **生成 Bundle:** 将 Chunk 映射到最终的输出文件（Bundle）。Webpack 为每个 Chunk 添加 runtime 代码（用于加载和执行模块）和模块包装器。

4. **写入文件:** 最终，执行 `emitAssets` 钩子，将内存中生成的 Bundle 文件内容写入到输出目录（`output` 配置）。

#### **Webpack 的持久化缓存**，如何判断文件是否需要重新编译

将上一次构建的结果（包括解析的模块、生成的 AST、转译后的代码等）存储到磁盘上，这样在后续构建中，如果文件或其依赖没有变化，就可以**跳过整个 Loader 链和模块构建过程**，直接复用缓存结果。这使得二次构建（特别是使用 HMR 时的开发构建）的速度大大加快。

持久化缓存通过在 `webpack.config.js` 中设置 `cache` 属性来启用：

```js
module.exports = {
  // ... 其他配置
  cache: {
    type: 'filesystem', // 启用基于文件系统的持久化缓存
    buildDependencies: {
      // 告诉 Webpack 哪些文件变动会导致缓存失效
      config: [__filename], 
    },
    // 默认缓存目录是 node_modules/.cache/webpack
    // name: 'my-app-cache', // 可自定义缓存名称
  },
  // ...
};
```

如何判断和检查是否可以用缓存：

- **检查全局配置：** Webpack 检查自身的版本、Node.js 版本以及配置文件的哈希是否匹配。如果不匹配，清空所有缓存。

- **检查模块哈希：** Webpack 检查当前文件的内容哈希。如果不匹配，缓存失效。

- **检查 Loader/Plugin 配置：** Webpack 检查作用于该文件的 Loader 链和 Plugin 选项是否与缓存中记录的一致。如果不一致，缓存失效。

- **检查依赖哈希：** Webpack 检查该模块所依赖的其他模块的哈希是否匹配。只要一个依赖项发生变化，当前模块的缓存就失效。

#### 联邦模块

它允许**多个独立的 Webpack 构建应用**在运行时共享代码和依赖，从而实现了真正的**前端微服务架构**。

它让一个应用（Host）可以在运行时动态加载另一个独立应用（Remote）的代码模块，就像加载本地模块一样。

Remote (远程方)：独立打包的应用。暴露 (Expose) 自己的部分代码模块供其他应用使用。Host (主机方)：独立打包的应用。消费 (Consume) 远程应用暴露出的模块。

两个应用都需要的公共依赖，如 React、Vue。确保所有应用共享同一份依赖实例，避免重复加载和版本冲突

Module Federation 通过在 Webpack 构建输出中添加特殊的 **“容器 (Container)”** 机制来实现：
