#### 浏览器点击url发生什么

> 当在浏览器输入 URL 并回车后，整体可以分为 **网络阶段** 和 **渲染阶段** 两大部分。

1. **URL 解析 & DNS 查询**  
    浏览器解析 URL，判断协议、域名和路径，通过 DNS 将域名解析成 IP
2. **建立连接**
    - HTTP：TCP 三次握手
    - HTTPS：在 TCP 之上增加 TLS 握手，完成证书校验和密钥协商
3. **发送 HTTP 请求并接收响应**  
    - 请求HTML文件并解析。
    - 解析HTML的过程中请求css js及其他资源，过程中css的请求和解析不阻塞构建 DOM 树但会阻塞渲染，js的请求和解析会阻塞 HTML 解析和渲染（使用 defer 可以避免阻塞解析，而 async 则不保证执行时机和顺序，适合独立脚本。）
4. **浏览器解析与渲染**
    - HTML → DOM：构建 DOM 树
    - CSS → CSSOM：解析 CSS 样式，生成 CSSOM (CSS Object Model) 树。
    - 合成 Render Tree ：将 DOM 树和 CSSOM 树合并，排除不可见的节点
    - 计算布局并绘制
5. **JS 文件加载后开始执行**  
    JS 执行过程中可能修改 DOM/CSS，触发重新渲染。

👉 **优化点**：DNS 缓存、HTTP 缓存、资源并行加载、减少阻塞资源、SSR/SSG。


#### 浏览器渲染流程

浏览器的渲染流程本质是把 HTML 和 CSS 转换成像素。

核心步骤：
1. **HTML 解析生成 DOM**
2. **CSS 解析生成 CSSOM**
3. **DOM + CSSOM → Render Tree**
4. **Layout（回流）**：计算元素几何信息
5. **Paint（重绘）**：绘制样式
6. **Composite（合成）**：GPU 合成图层

👉 追问：
- 哪些操作会触发 **回流 / 重绘** 
- 为什么 `transform / opacity` 性能好（只走合成层）
	- `transform` 和 `opacity` 不会影响元素的布局和绘制，只会影响**合成阶段**。
#### window document

在浏览器环境中，所有全局变量和函数都是 `window` 的属性。它同时是全局作用域的代表。也是**DOM 和 BOM 的入口：** `document` (DOM) 和 `navigator`, `screen` 等 (BOM)。

`document` 对象代表**浏览器窗口中加载的整个 HTML 文档**。是**DOM (Document Object Model) 的入口**。通过它，我们可以操作网页中的所有元素、内容和样式。

DOM ：文档对象模型，提供了与页面内容和结构交互的能力（如查找元素、修改文本）

BOM： 浏览器对象模型，提供了与浏览器窗口和环境交互的能力（如导航、历史记录、计时器），核心对象是window

 `window.document === document`

👉 常见追问：
- 全局变量为什么会挂到 window 上
	- 在浏览器环境中，`window` 是全局对象，**非模块环境下**，使用 `var` 或直接声明的全局变量会成为 `window` 的属性。
	- 常见风险：全局变量容易造成命名冲突和内存泄漏。
- document 什么时候可用
	- `DOMContentLoaded` 事件表示 **DOM 树已经构建完成**，但不保证图片、样式等资源加载完成。
	- `window.load` 事件表示整个页面及其所有资源加载完成，包括：HTML、CSS、JS、**图片、字体、iframe**，注意只等资源下载完成，不等 JS 执行结束

#### requestAnimationFrame & 帧机制

 **`requestAnimationFrame`** 会在浏览器**下一帧渲染前执行回调**。特点是：
- 与屏幕刷新率同步（≈16.6ms）
- 页面不可见时自动暂停

**浏览器帧机制：**
浏览器通常以约 60FPS 的刷新率进行渲染，也就是每帧大约 16.7ms，但 rAF 并不是固定 60FPS，而是跟随设备的实际刷新率。
在一帧中，浏览器会先执行 JavaScript，包括 rAF 回调，然后进行样式计算、布局、绘制和合成。由于 rAF 的执行时机在渲染之前，因此非常适合用来更新动画相关的样式。

rAF 优势：
- 跟随刷新率
- 页面不可见自动暂停
- 比 setTimeout 更省电、更流畅
适合：
- 频繁更新的动画
- 与渲染强相关的状态更新

用法：
`requestAnimationFrame` 接收一个 **回调函数**，该回调会被传入一个 **高精度时间戳参数**。timestamp 是从页面加载开始到当前帧的时间（毫秒），是高精度（浮点数）

示例
```
let last = 0
function animate(timestamp) {
  const delta = timestamp - last // 获取两次回调的时间差
  ...
  requestAnimationFrame(animate)
}

requestAnimationFrame(animate)
```

#### 重排 (Reflow) 重绘 (Repaint) 合成层

- **重排**：布局变，**代价高**
	- 修改 width / height / padding / margin
	- 修改 display、position
	- 添加 / 删除 DOM 节点
	- 获取 layout 信息（offsetTop、getBoundingClientRect）并穿插写操作
- **重绘**：样式变化，不影响布局，代价相对低
	-  修改 color / background / box-shadow
	- visibility 变化
- **合成**：transform/opacity
	- 浏览器会把元素提升到**独立合成层**
	- 动画只在 GPU 中做矩阵变换或透明度计算
	- **跳过 布局计算 和 绘制**

回流一定会引起重绘，但重绘不一定回流。

👉 优化原则：
- 批量 DOM 操作
- 读写分离
- 动画优先用 transform

#### IntersectionObserver 作用

`IntersectionObserver` 是一个**异步 API**，用于监听目标元素与一个参照区域（root）之间的**位置关系变化**，**不依赖滚动事件**，性能更好。它关注的是：
- **是否相交**
- **相交比例**
- **相交发生的时机**
本质是：**“元素是否进入 / 离开某个区域”**

使用场景：
- 图片懒加载
- 无限滚动
- 曝光埋点
优势：
- 异步执行
- 不阻塞主线程
- 浏览器原生优化

示例
```
new IntersectionObserver(entries => {
  entries.forEach(entry => {
    entry.isIntersecting       // 是否相交
    entry.intersectionRatio   // 相交比例
    entry.boundingClientRect  // 元素自身位置
    entry.rootBounds          // root 区域
    entry.intersectionRect    // 实际相交区域
  }),
  {
	  root: container,  // 要校验的参照区域
	  threshold: 1, // 相交阈值，达到阈值会触发回调函数，也可以是数组
	  rootMargin: '200px' //要校验的相交关系
  }
)
```

总结：`IntersectionObserver` 本质是浏览器原生的‘位置关系监听器’，可以基于 root、rootMargin 和 threshold 精确描述元素与容器的相交状态，用来做懒加载、曝光埋点和位置校验，比手写滚动监听更高效。

#### JS 执行机制 & 事件循环

浏览器是单线程执行 JS，通过事件循环机制来处理异步任务。

核心机制：
1. 主线程执行同步代码
2. 遇到异步任务，交给 Web APIs
3. 回调按类型进入任务队列：
    - **微任务**：Promise.then、MutationObserver
    - **宏任务**：setTimeout、setInterval、I/O
4. 每轮循环顺序：
    - 执行一个宏任务
    - 清空所有微任务

👉 关键点：
- 微任务会阻塞渲染，如果微任务不断追加（比如递归 Promise），浏览器就**无法进入渲染阶段**，页面会卡住。高频陷阱：大量 Promise.then 会导致页面假死。
- 微任务优先级高于宏任务

#### 浏览器缓存机制

浏览器缓存的目标是减少网络请求、提升加载性能。
HTTP 缓存两类：

 缓存层级：
- 内存缓存
	- - 速度最快
	- 生命周期短（页面关闭即失效）
	- 常用于当前页面重复请求的资源
- 磁盘缓存
	- 速度慢于内存
	- 持久化存储
	- 跨页面、跨会话复用
- HTTP 缓存
	1. **强缓存**
	    - `Cache-Control`、`Expires`
	    - 命中后**不发请求**
	2. **协商缓存**
	    - `ETag / If-None-Match`
	    - `Last-Modified / If-Modified-Since`
	    - 返回 304，不传资源

具体使用哪种由浏览器根据资源大小、使用频率自动决定。

#### 什么是跨域？什么是同源策略？为什么需要跨域？常见解决方案

浏览器的同源策略要求：**协议、域名、端口** 三者一致，否则就是跨域。

为什么有同源策略？
- 防止恶意网站读取用户隐私数据
- 属于浏览器的安全机制
为什么需要跨域？
- 前后端分离
- 多服务、多子域部署

跨域解决方案：
1. **CORS（跨域资源共享）**：服务器设置响应头（如`Access-Control-Allow-Origin`）允许跨域。
2. **JSONP**：利用`<script>`标签不受同源策略限制，通过回调函数获取数据。
3. **WebSocket**：不受同源策略限制，可跨域通信。
4. **postMessage**：iframe允许不同源窗口间通信。l
5. **nginx反向代理**：配置nginx将请求代理到目标服务器。

#### 浏览器存储体系

| 类型             | 特点            |
| -------------- | ------------- |
| Cookie         | 小、随请求发送、受同源限制 |
| localStorage   | 持久化、同步 API    |
| sessionStorage | 会话级           |
| IndexedDB      | 大、异步、结构化      |
- 为什么 cookie 不适合存 token
- 为什么 localStorage 不适合高频读写

#### <mark> V8垃圾回收</mark>

总结 V8 GC 流程
1. **新生代：** 高频、快速的 **Scavenge 算法**，负责快速清理短期对象。
2. **老生代：** 低频、复杂的  标记-清除（Mark-Sweep） 和 标记-整理（Mark-Compact）。算法，通过 增量标记 和 并发/并行技术来减少 减少停顿时间。

核心思想：
- 大多数对象“朝生夕死”
- 减少全量扫描，提升性能

👉 追问：
- 为什么闭包容易导致内存问题
	- 闭包会让内部变量被外部函数持续引用，导致变量**无法被 GC 回收**。
	- 解决思路：使用完后断开引用；避免在闭包中持有不必要的大对象
- GC 会不会阻塞 JS
	- 会阻塞，但 V8 通过增量 GC 降低了阻塞时间。GC 本质要暂停 JS 执行；V8 将一次大 GC 拆成多次小步骤，在 JS 执行间隙逐步完成回收

#### <mark>内存泄漏</mark>

内存泄漏指的是对象不再使用，但仍被引用，无法被 GC 回收。

常见原因：
1. 意外的全局变量
2. 未清除的定时器
3. 未移除的事件监听器
4. 闭包引用外部大对象
5. 未清除的DOM 引用

排查：Chrome DevTools 的 **Memory** 面板
1. 录制堆快照-复现操作-录制快照
2. 对比分析：重点关注 “Delta”：特别是那些**数量持续增加且没有被回收**的构造函数。找到泄露的对象
3. 分析原因：**保留树**显示了**为什么这个对象没有被垃圾回收**。它列出了从全局根 (Root) 到该对象的引用链。顺着保留树向上查找，直到找到阻止 GC 回收的**不必要的全局引用、闭包、或 DOM 引用**。

解决思路：
- 组件卸载时清理副作用和事件监听器
- 避免不必要的全局引用
- 节点移除时清理事件监听器
- 慎用闭包

#### 浏览器内核

浏览器内核（或称渲染引擎，Rendering Engine）是浏览器的核心组件，主要负责：
1. **渲染**：解析 HTML/XML/CSS，构建渲染树，并负责页面的布局和绘制。
2. **脚本执行**：虽然 JavaScript 引擎（如 V8）是独立的部分，但渲染引擎需要协同 JavaScript 引擎。

主流：
blink: chrome edge 
WebKit: Safari
Gecko: Firefox
Trident: IE

注：JS 引擎（如 V8）是独立模块，但与渲染引擎紧密配合

#### 了解哪些浏览器渲染引擎？渲染机制举例

主流浏览器渲染引擎包括 Blink、WebKit、Gecko，整体渲染机制一致，都是 DOM + CSSOM → Render Tree → Layout → Paint → Composite。

举例：
- Chrome 使用 Blink + V8
- Safari 使用 WebKit + JavaScriptCore
#### V8 引擎优化机制

V8 通过 **JIT 编译 + 隐藏类 + 内联缓存** 提升 JS 执行性能。

关键点：
- **JIT**：热点代码从解释执行转为机器码
- **Hidden Class**：对象结构稳定 → 访问更快
- **Inline Cache**：缓存属性访问路径

👉 开发建议：
- 保持对象结构稳定
- 避免频繁增删属性
- 避免混合类型数组
#### JavaScript 执行性能优化

JS 性能优化的核心是减少阻塞主线程。

常见手段：
- 减少长任务（>50ms）
- 合理拆分任务（结合setTimeout / requestAnimationFrame）
- 避免频繁操作 DOM，减少重排 (Reflow) 和重绘 (Repaint)
- 优化 JavaScript 执行效率：避免全局查找，减少复杂运算，减少作用域链查找
- 内存管理：避免内存泄漏，及时释放大对象和事件监听器
- 节流 (Throttle) 和防抖 (Debounce)
- 使用 Web Workers：对于复杂的、耗时的计算任务（如大量数据处理），将其放在 **Web Worker** 中，避免阻塞主线程，确保 UI 响应流畅。

#### navigator.sendBeacon 是什么？怎么用

`navigator.sendBeacon` 是浏览器提供的**专门用于上报少量数据的异步接口**，核心特点是：  
**在页面卸载（unload / pagehide）阶段也能可靠发送请求，且不阻塞页面跳转。**

它最典型的用途就是：**埋点、日志、性能数据上报**。

传统方案的问题
- 在 `beforeunload / unload` 阶段：
    - `fetch` / `XHR` **很容易被浏览器直接中断**
    - 同步请求会 **阻塞页面关闭（被限制甚至禁止）**
 `sendBeacon` 的设计目标
- 页面即将关闭 / 跳转
- **保证“尽最大可能把数据送到服务端”**
- 不影响用户体验

特点：
- 返回值是 `boolean`
    - `true`：浏览器已接管发送任务
    - `false`：参数非法或发送失败
- **不返回 Promise**
- **拿不到响应结果**
缺点：
- **只适合小数据量**（通常 < 64KB，浏览器实现不同）
- 只能用 **POST**
- 不能自定义 header（如 Authorization）
- 不能读取响应
- 不适合业务请求

示例：
```
navigator.sendBeacon('/log', JSON.stringify({
  event: 'page_leave',
  time: Date.now()
}))
```

追问：对比 fetch keepalive
`fetch keepalive` 确实能在页面卸载时继续请求，但：
- 有严格的体积限制
- 不同浏览器支持不一致
- 仍然不如 `sendBeacon` 稳定
所以在**埋点上报**这种场景，优先使用 `sendBeacon`。

#### 如何判断页面要离开/卸载/隐藏

1. `pagehide`（最推荐，离开/进入 bfcache 都覆盖）
**用途**：页面即将被卸载，或被放入 **bfcache**（前进后退缓存）时触发。  
**优点**：比 `unload/beforeunload` 更可靠，移动端也相对稳。

2.  `visibilitychange` + `document.visibilityState === 'hidden'`（隐藏/切后台最通用）
**用途**：页面从可见变为隐藏（切 Tab、切后台、锁屏、打开系统任务切换）时触发。  
**优点**：覆盖“隐藏”场景很全面；不一定意味着卸载，但对上报很实用。

3. `beforeunload`（老方案：可拦截离开，但限制多）
**用途**：尝试在离开页面前做确认提示（比如表单未保存）。  
**现实**：现代浏览器对自定义文案基本禁用，而且触发时机/条件很多限制。

4. 辅助方案：结合 组件卸载，路由变化等