##### 小程序登录 支付

小程序登录本质是：
前端通过 wx.login 获取临时 code，把code发送给后端，后端再通过微信接口换取 openid 和 session_key，并建立自己的业务登录态，通过set-cookie下发token等会话登录态标志。
- 微信登录 ≠ 业务登录
- 微信只负责 **身份识别**
- 业务权限、用户体系仍在自己后端

小程序支付：前端只负责调起支付，所有金额、订单和校验都在后端完成。
前端向后端发起支付请求
后端校验订单合法性，然后调用微信「统一下单接口」，得到 **prepay_id**，返回支付参数给前端
前端通过 wx.requestPayment 调起支付
用户完成支付后微信异步通知后端，作为支付成功的唯一依据
支付后 前端应：不直接信任 `success`，再次请求后端

##### 选框架 uniapp taroapp

总体：需要考虑**技术栈一致性、平台范围、性能边界、团队协作方式**。

1.团队主要技术栈是vue还是react
2.考量目标平台需求：如果覆盖的平台更广，比如需要发布到 App 端，需要覆盖最多平台，优选 uni-app
3.考虑业务需求可能的大型复杂交互，比如长列表，结合框架是否有成熟的支持
3.如果更注重小程序性能 unia-app（taro由于底层基于 React Virtual DOM，相较于原生小程序的渲染可能会有轻微性能损耗，但在绝大多数场景下足够使用。）
4.生态：**uni-app**：生态集中（插件/组件/工具链/统一 API），交付效率高；**Taro**：更“开放”，更像 Web 工程化；但你可能更需要自己补齐一些工程/规范/组件方案。

更注重H5性能的大型项目 优选taro  由于基于 React 体系，更适合大型项目中的组件化、状态管理和架构规范。

##### 小程序rpx和px在不同手机上有误差

rpx 是小程序里的相对单位，规定屏幕宽度等于 750rpx，不同设备上会根据屏幕宽度换算成不同的 px。
px 是绝对单位，在不同设备上不自适应；  rpx 是相对单位，理论上 rpx 可以适配不同设备，但在实际渲染时，由于屏幕宽度和 DPR 不同，rpx 换算成 px 时会出现小数，最终需要取整，不同平台的取整和渲染机制也存在差异，因此在不同手机上可能会有细微误差。  误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。

解决：
避免使用极小的 `rpx` 值。尽量使用偶数的 rpx 值，必要时利用 CSS transform 缩放结合微元素 伪类解决
尽量用 flex / 自适应布局，减少“精确像素依赖”
##### 小程序和h5的性能和用户体验差异对比

运行环境差异（最根本）：小程序运行在 **平台容器**（微信 / 支付宝），双线程，沙箱受限，低端机慢；H5 运行在 **浏览器**，浏览器内存大，可用 Worker，所以性能上限高

首次加载：小程序需下载框架和代码包，H5 可按需加载。小程序通过主包限制和分包机制约束体积，H5 则依赖代码分割和浏览器加载能力；

热启动：小程序更快，H5取决于缓存策略

渲染性能：小程序有双线程能避免 JS 阻塞渲染，交互更流畅；H5容易因为 JS 阻塞导致渲染掉帧。

操作DOM：小程序框架底层对DOM 操作有更严格控制，但是频繁地setData也可能会导致性能瓶颈；H5类似的操作DOM可能会导致性能瓶颈，一般要依赖框架的响应式数据更新或者渲染优化。

在页面切换和交互体验上，小程序更稳定，由原生页面栈实现，返回、切换体验稳定状态保留相对自然，但是分包可能轻微延迟；H5 路由切换快，单页应用路由切换 = 组件卸载/挂载，需要通过keep-alive、预加载、状态缓存等方法优化。

生态及api：小程序：依托微信生态丰富，登录、支付等微信能力更流畅，容易接入官方API，用户触达 分享等方面更有微信的优势。H5：浏览器 API功能无限制，技术栈成熟、生态丰富，拉新/留存不如小程序便利

##### 小程序底层架构详解

小程序采用的是双线程（Dual-Thread）的运行模型，这是其架构的基石。这个模型将页面的逻辑处理和界面渲染分别放在两个独立的运行环境中，通过异步消息通道通信。开发者编写的**逻辑代码**运行在一个根本，是一个没有 DOM 逻辑层和 BOM 的独立环境中。

逻辑层 (JS Thread) 由独立的 JavaScript 引擎 实现 。

渲染层 (View Thread) 基于浏览器的 WebView，负责渲染页面的容器。

（**WebView 是一种宿主环境提供的、内嵌式的浏览器内核功能。它允许应用程序（App）或小程序框架在原生界面中加载和渲染 Web 内容，它包含了浏览器的大部分核心功能，它运行在原生 App 内部，本质上就是一个浏览器内核组件**）

这种分离架构的好处是解决传统 Web 应用的**性能瓶颈**（双线程）和**安全问题**（无法直接操作DOM），同时保证**跨平台能力**（渲染层可以对不同平台做不同的渲染）。

缺点是：增加了一层数据传输，可能带来通信延迟，增加了调试复杂性，增加一定的内存占用；开发者无法使用完整的浏览器 API和一些成熟的web库；频繁调用setData可能会引起性能问题，因为涉及了两个线程之间的**跨线程通信**和**数据处理**

##### 为什么小程序在复杂业务下更容易保持性能稳定？

小程序在复杂业务下更容易保持性能稳定，核心原因并不只是双线程，而是多重平台约束共同作用的结果。

一方面，小程序采用逻辑线程与渲染线程分离的双线程模型，避免了 JS 执行直接阻塞渲染；另一方面，小程序通过主包大小限制和分包机制，强制将复杂业务拆分到不同页面和分包中，减少单一上下文的复杂度。

同时，小程序以页面为单位管理生命周期和状态，更容易在页面切换时回收资源；而 SPA 运行在单一 JS 上下文中，如果工程拆分和状态管理不当，复杂业务下更容易出现性能退化。

因此，小程序的稳定性更多来自平台约束，而不是单纯的执行效率优势。

##### 小程序没有dom是如何渲染的

小程序没有浏览器 DOM，它采用逻辑层和渲染层分离的双线程架构。逻辑层负责运行 JS 和业务逻辑，渲染层负责根据 WXML 和数据进行视图渲染。开发者通过 setData 更新状态，框架会把数据变更同步到渲染层，由渲染层重新计算并更新 UI。这样的设计可以提升性能稳定性、保证跨平台一致性，但也要求开发者控制 setData 的频率和数据量。
 
编译阶段：将开发者定义的 WXML/WXSS 转换为渲染指令（类似虚拟DOM的结构对象）和和css
运行阶段：根据渲染指令（类似VDOM）构建真实DOM，数据发生更新时，先diff然后把增量数据发给渲染层，渲染层精确更新 DOM

##### 小程序开发中最常见的性能瓶颈是什么？你会怎么定位和优化？

1）逻辑层 ↔ 渲染层通信过多（setData 过频 / 数据量大）
**现象**
- 列表滚动卡、交互延迟、页面掉帧
- 频繁 setData 或一次 setData payload 很大
**优化**
- 合并 setData：把多次更新合并成一次
- 缩小更新范围：只更新必要字段（避免 whole data 替换）
- 降低频率：节流/批处理（尤其 scroll、drag、实时输入）
- 列表用 **分页 + 虚拟列表/分片渲染**（长列表核心）
- 大对象避免频繁深拷贝：尽量扁平化数据结构

2）长列表/复杂节点导致渲染压力大
**现象**
- 页面首屏慢、滚动掉帧
- 节点层级深、wxml 结构复杂
**定位**
- 开发者工具看 **渲染耗时、节点数**
- 观察是否存在“超长列表一次性渲染”
**优化**
- 虚拟列表 / 分批渲染（分帧渲染）
- 减少节点层级、减少不必要的 view 包裹
- 能用 `hidden` 就别频繁 `wx:if`（避免反复创建销毁）
- 图片列表：固定尺寸 + 懒加载 + 合理占位
 
3）图片/资源加载（尤其首屏大图、弱网）

**定位**
- Network：图片体积、并发、是否命中缓存  
    **优化**
- 压缩、裁剪、WebP（看平台支持）
- 首屏优先：关键图优先，其余懒加载
- CDN + 缓存策略（本地缓存、版本化 URL）

##### 说说小程序的性能优化方案

1）小程序最常见的瓶颈
1. **setData 通信成本**：频率高、数据量大、更新范围大
2. **渲染压力**：节点数多、层级深、长列表一次性渲染
3. **首屏慢**：资源大、请求多、逻辑初始化重
4. **图片与网络**：大图、弱网、并发、缓存不佳
5. **交互卡顿**：scroll/touch 高频事件 + 频繁 setData
2）怎么定位（面试要点）
- 微信开发者工具：**性能面板 / 渲染性能 / Network**  
    重点看：
    - setData **次数、单次 payload 大小、耗时**
    - **渲染耗时、节点数、重排重绘**
    - 首屏关键请求、图片体积、是否命中缓存
- **真机测试**（尤其 Android 中低端）：工具数据 + 真实体感一起看

3）**优化**
1. setData（最关键、最常考）
	- 把多次 setData **合并成一次**
	- 对高频更新（scroll、drag、input）做 **节流/批处理**
	- 避免 `this.setData({ list: newList })` 这种整块替换
	- 用路径更新：只改变动字段
	    - `this.setData({ ['list[3].checked']: true })`
	- 数据结构尽量**扁平化**，减少深层对象整体替换
2. 渲染优化：
	- 长列表：只渲染可视区 + 缓冲区，或首屏先渲染一部分，剩下分帧追加
	- 降低节点复杂度，减少 view 套娃，控制层级
	- 列表项组件化，但注意组件层级也别过深
	- `wx:if` 频繁切换成本高；仅切换显示优先 `hidden`
	- 选择合适的滚动容器，避免在 scroll 中频繁触发布局相关逻辑
3. 首屏优化（用户最敏感）
	- 关键接口优先，非关键延后（骨架屏/占位）
	- 减少首屏请求数：合并接口、并发控制、缓存
	- 图片：压缩/裁剪、固定尺寸、首屏优先加载、其余懒加载
	- 静态资源上 CDN，做好缓存版本策略
4. 交互与动画优化
	- 高频事件：节流/防抖，减少 setData
	- 动画优先用 **CSS/小程序动画能力**，避免 JS 驱动大量帧更新
	- 减少昂贵样式（阴影/滤镜等）在大面积区域使用
##### 自定义组件和原生组件渲染有什么区别？

**总结：原生组件由客户端原生直接渲染，性能最好但层级受限；自定义组件运行在 WebView 渲染层，灵活但性能和层级不如原生组件。**

小程序中的原生组件由客户端原生直接渲染，不在 WebView 内，性能最好，但存在层级限制，样式和遮罩控制能力有限。
自定义组件运行在渲染层 WebView 中，参与 WXML 的布局和层级计算，交互和样式更灵活，但性能受 setData 和渲染复杂度影响。实际开发中通常根据性能需求和 UI 复杂度选择合适的组件类型。

#### 小程序为什么长列表特别容易卡？

核心原因是：节点数量大 + setData 通信和 diff 成本高 + 渲染层重排重绘压力大。核心思路就是减少节点、减少 setData、减少不必要的计算。

1 节点数量爆炸（最直接原因），渲染层需要维护一个**非常大的节点树**
2 setData 的通信 & diff 成本被放大（核心瓶颈），由于小程序的双线程
3 如果滚动过程中的频繁更新，触发 setData，会导致JS 线程和渲染线程互相拖慢

和H5对比：
- H5：
    - JS 和 DOM 在同一线程
    - 可以直接操作 DOM
    - 虚拟列表成熟
- 小程序：
    - JS ↔ 渲染层通信，每次更新都有“桥”的成本
    - 所以 **更怕大数据量**

优化方案：
1 虚拟列表：只渲染**可视区域 + 缓冲区**
2 分片 / 分帧渲染：首屏先渲染一部分，剩余用 `setTimeout / requestAnimationFrame` 分批塞
3 降低 setData 频率：滚动事件节流，- 合并多次更新