小程序登录 支付

##### 选框架 uniapp taroapp

团队主栈

需要发布到 App 端 优选**uni-app**

需要覆盖最多平台 uni-app

更注重小程序性能 unia-app（taro由于底层基于 React Virtual DOM，相较于原生小程序的渲染可能会有轻微性能损耗，但在绝大多数场景下足够使用。）

更注重H5性能的大型项目 优选taro  由于基于 React 体系，更适合大型项目中的组件化、状态管理和架构规范。

##### 小程序和H5的性能差异，结合小程序分包和SPA

| 特性    | 小程序       | H5 SPA           | 建议场景                     |
| ----- | --------- | ---------------- | ------------------------ |
| 首屏性能  | 可控，分包优点明显 | 首屏大包阻塞可能慢        | 小程序更适合首次访问频繁的轻量应用        |
| 页面切换  | 分包可能轻微延迟  | 路由切换快            | SPA 优势在页面多切换且包已加载        |
| 渲染性能  | 跨桥更新瓶颈    | DOM 操作瓶颈         | 大列表：SPA diff+虚拟 DOM 优势更大 |
| JS 执行 | 沙箱受限，低端机慢 | 浏览器内存大，可用 Worker | 计算密集型 SPA 更适合浏览器         |
| 数据请求  | 并发有限      | 并发可控             | 高并发数据接口 SPA 更灵活**        |

小程序：依托微信生态丰富，登录、支付等微信能力更流畅，容易接入官方API，用户触达 分享等方面更有微信的优势，结合分包机制能按需加载，减少首屏 JS。但性能略差，大量组件或频繁 UI 更新时可能卡顿，无法自由访问浏览器原生 API。

H5：交互灵活，渲染性能可优化，浏览器 API功能无限制，技术栈成熟、生态丰富，SPA首屏性能压力大，拉新/留存不如小程序便利

##### 小程序和h5的渲染性能对比

首次加载：小程序需下载框架和代码包，H5 可按需加载。

热启动：小程序更快，H5取决于缓存策略

渲染性能：小程序有双线程，能 避免 JS 阻塞渲染，交互更流畅。

操作DOM：小程序框架底层对DOM 操作有更严格控制，但是频繁地setData也可能会导致性能瓶颈；H5类似的操作DOM可能会导致性能瓶颈，一般要依赖框架的响应式数据更新或者渲染优化

##### 小程序底层架构详解

小程序采用的是双线程（Dual-Thread）的运行模型，这是其架构的基石。这个模型将页面的逻辑处理和界面渲染分别放在两个独立的运行环境中，通过异步消息通道通信。开发者编写的**逻辑代码**运行在一个根本，是一个没有 DOM 逻辑层和 BOM 的独立环境中。

逻辑层 (JS Thread) 由独立的 JavaScript 引擎 实现 。

渲染层 (View Thread) 基于浏览器的 WebView，负责渲染页面的容器。

（**WebView 是一种宿主环境提供的、内嵌式的浏览器内核功能。它允许应用程序（App）或小程序框架在原生界面中加载和渲染 Web 内容，它包含了浏览器的大部分核心功能，它运行在原生 App 内部，本质上就是一个浏览器内核组件**）

这种分离架构的好处是解决传统 Web 应用的**性能瓶颈**（双线程）和**安全问题**（无法直接操作DOM），同时保证**跨平台能力**（渲染层可以对不同平台做不同的渲染）。

缺点是：增加了一层数据传输，可能带来通信延迟，增加了调试复杂性，增加一定的内存占用；开发者无法使用完整的浏览器 API和一些成熟的web库；频繁调用setData可能会引起性能问题，因为涉及了两个线程之间的**跨线程通信**和**数据处理**：

##### 小程序没有dom是如何渲染的

编译阶段：将开发者定义的 WXML/WXSS 转换为渲染指令（类似虚拟DOM的结构对象）和和css

运行阶段：根据渲染指令（类似VDOM）构建真实DOM，数据发生更新时，先diff然后把增量数据发给渲染层，渲染层精确更新 DOM
