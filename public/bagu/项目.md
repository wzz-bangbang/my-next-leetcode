项目介绍

某个复杂模块的设计思路、遇到的性能瓶颈及解决方案

nextjs项目性能瓶颈，怎么解决

选择一个你主导的或者深度参与的复杂项目，详细阐述其架构设计、技术难点和如何解决

项目有什么改进的地方

业务方怎么拿到反馈的，就是做的这个东西具体有什么用

#### B端项目

##### 核心技术流程详解

A. 编辑器初始化与回显

当用户编辑一个已存在的页面时：

1. 配置解析: 遍历后端返回的 JSON 配置 (configList)。

2. 实例化: 通过 KitController.getKit(name) 获取组件类，并调用 .instance() 生成带有唯一 guid 的实例。

3. 动态注入: 关键代码 injectReducer(guid, KitController.initKitStore(guid, state))。这行代码动态创建了该组件实例的 Redux reducer，并用历史数据初始化它。

4. 渲染: 更新 kitRenderList 并触发 renderKit()。

B. 拖拽添加组件流程

这是一个典型的 "占位符" 交互模式：

1. 开始拖拽: 用户从左侧面板拖拽组件。

2. 创建占位: 调用 a_createPlaceHolderKit 或 a_addPlaceHolderKit，在 kitRenderList 中插入一个类型为 COMP_DROP_PLACEHOLDER 的特殊组件。

3. 放置 (Drop): 当用户释放鼠标时，调用 a_createKit(kitName)。

4. 替换逻辑:  特殊规则的校验，找到占位符，实例化真实组件，注入Redux Store，将占位符替换为真实组件。

C. 跨窗口渲染同步：数据快照的生成。将 Redux 中扁平化的数据聚合为渲染所需的

#### 难点

1. 复杂的拖拽交互体验

问题: 用户在拖拽过程中需要知道组件将落在哪，且支持 "插入前"、"插入后" 和 "取消"。

解决方案:  虚拟占位符+原子化操作，提供向前向后插入

2. 复杂的业务逻辑校验与特殊定位

问题: 某些组件（如弹窗）不能随意排序，或者某些组件有数量限制（如 "倒计时" 只能有一个）。

解决方案: 配置化约束，组件定义中包含特殊校验的 属性

3. 组件的多实例状态隔离
   
   问题: 如果页面上有两个 "轮播图" 组件，如何在 Redux 中区分它们的数据？
   
   解决方案:  GUID 生成，基于ID创建store以及移除时清理removeReducer

##### 已有的性能优化：

createSlice避免不必要的重复渲染
组件表单修改加防抖，减少频繁更新
各组件表单配置部分keepalive，避免重新渲染

##### 以后的优化方向：

有修改时增量更新，之前不支持增量更新，每次都全部传数据并重新算所有组件的位置，可以针对修改的组件给C端发消息，C端也根据组件类型只返回需要重新渲染的组件位置，这样既避免全量发消息，也避免每次全量重新渲染蒙层（好像渲染蒙层收益不算很大？

#### C端项目

##### 已有的性能优化：

图片懒加载，结合Intersection Observer API

第三方库异步加载

页面级代码分割

以后的优化方向：

动态加载组件，组件用动态 import() 语法，配合vue的动态加载组件。API 非常强大。当 :is 绑定的是一个返回 Promise 的函数时，Vue 会自动等待 Promise resolve，然后渲染解析出的组件

配合B端支持增量更新，目前是为了简化逻辑每次都全部重新渲染，但是需要给修改后的组件创建新的唯一key

开启splitChunks配置 代码拆分
// splitChunks: {
 // chunks: 'all', // 对所有类型的 chunks 进行分割
 // cacheGroups: {
 // //公用模块抽离
 // common: {
 // chunks: 'initial',
 // minSize: 0, //大于0个字节
 // minChunks: 2 //抽离公共代码时，这个代码块最小被引用的次数
 // },
 // }
 // }

#### 设计师项目

##### 性能瓶颈

在使用 framer-motion 的 AnimatePresence 进行全页路由切换时，是前端性能的一个潜在瓶颈。
简单来说，AnimatePresence 的 mode="sync"（默认模式）会导致新旧两个页面同时存在于 DOM 中。旧页面正在执行退出动画（exit）。新页面已经被挂载（Mount）并执行进入动画（initial -> animate）。
这意味着在转场的几秒钟内，浏览器需要同时处理两倍的 DOM 节点、两倍的样式计算和布局重排。如果页面包含大量图片或复杂组件，卡顿（Jank）风险极高。

优化思路

1 交互锁 防止“雪上加霜”，动画过程中全局存储状态，禁止用户交互、页面滚动、导航栏跳转等交互
2 懒加载策略 利用 IntersectionObserver 监听图片是否进入视口。当转场遮罩褪去、用户真正看到页面时，图片才开始请求和渲染。这极大地减少了转场瞬间的内存和网络压力。
3 减少重排和利用 GPU 加速：使用 transform 代替 top/left，使用will-change
4 优先webp，校验并限制图片大小

##### 面向非技术人员的构建时数据管道和文件系统

维护者是非技术人员, 维护json成本太高
设计了一套基于文件系统和 Excel 的构建时 文件系统架构

1. 数据清洗与解析：Excel 的数据是非结构化的（比如合并单元格）。我在 Node.js 脚本中处理了复杂的解析逻辑，把二维的表格数据转换成前端组件需要的树状 JSON 结构。同时做了强校验：检查对应目录下是否存在该文件，如果不存在会抛出警告或错误，防止部署上去出现 404
2. 封装了 Shell 脚本。用户更新完 Excel 后，双击脚本即可完成 git add/commit/push 并触发 CI/CD 流程

思路：

基于excel的低代码维护流程，使用者维护excel更容易
读多写少，不需要数据库，通过excel的数据处理来保证前端拿到的数据是规范的 JSON
封装了 Shell 脚本支持一键部署，不需要后台也可以完成一键部署发布
缺点是 每次修改内容必须重新构建部署
