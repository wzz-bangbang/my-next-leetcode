###### 谈谈你对 React 的了解

React 是一个用于构建 UI 的库，它的核心是**用组件来描述 UI**，并通过**状态驱动视图**来让 UI 随数据变化而更新。  
从机制上看，React 有三块比较关键：

1. **声明式渲染 + 单向数据流**：开发者描述“在某个 state 下 UI 应该长什么样”，React 负责把它变成真实 DOM；数据自上而下流动，边界清晰，利于大型项目可维护。

2. **协调与渲染分离（Reconciler + Renderer）**：React 先在 render 阶段计算“需要改什么”（reconcile/diff），再在 commit 阶段把变更提交到宿主环境（DOM/Native）。React DOM 只是其中一个 renderer。

3. **Fiber 架构与并发能力（React 16+，18+ 更明显）**：把更新拆成可调度的小任务，引入优先级与可中断渲染；18 的并发特性让 React 能在交互、动画、数据渲染之间更好地平衡体验（比如自动批处理、Transitions 等）。

工程实践上，我会把 React 当成“**UI 运行时**”：组件设计、状态归属、性能边界（memo、拆分、列表 key、避免无效渲染）和工程化（路由懒加载、SSR/CSR 取舍）是高级前端更看重的点。

###### React 中 key 的作用是什么

key 的作用是帮助 React 在**同一层级的子节点列表**中建立“身份标识”，从而在 diff 时更准确地判断：哪些节点是新增/删除/移动，哪些可以复用。  
它带来的核心收益是：

- **稳定复用**：key 稳定时，React 能复用对应的 Fiber/DOM，减少不必要的卸载与重建。

- **保持局部状态**：列表项里如果有 input、组件内部 state，稳定 key 能让它们跟随“同一项数据”而不是“同一位置”。

- **更高效的 diff**：在存在插入、排序、过滤时，key 能显著减少误判与 DOM 操作。

最佳实践是：**使用稳定且唯一的业务 id**，不要用 index（除非列表永不重排/增删，且项内无状态/无输入）。index 作为 key 常见问题是：插入/排序会导致“状态串位”和不必要的重渲染。

###### 说说对受控组件和非受控组件的理解，以及应用场景

- **受控组件（Controlled Component）**  
  表单的值完全由 React state 控制，input 的 value / checked 来自 state，用户输入通过 onChange 触发 setState。  
  优点是**数据来源单一、状态可控**，非常适合做校验、联动、回填、表单回显等复杂逻辑。  
  缺点是更新频繁时可能带来额外渲染成本，需要注意拆分组件或做性能优化。

- **非受控组件（Uncontrolled Component）**  
  表单值由 DOM 自己维护，React 只在需要时通过 ref 读取，或者用 defaultValue 初始化。  
  优点是实现简单、性能开销小，适合一次性提交、简单表单、第三方表单组件或富文本场景。  
  缺点是状态分散在 DOM 中，不利于复杂业务逻辑管理。

实际项目中更多是**以受控为主、非受控为辅**，在性能或实现成本更重要的场景下使用非受控。

###### 什么是无状态组件，与有状态组件的区别？本质区别是什么？现在还推荐这样区分吗？

无状态组件通常指**不维护自身状态、只根据 props 渲染 UI** 的组件，更多承担展示职责。  
有状态组件则内部维护 state，负责交互和业务逻辑。

在早期 React 中，这种区分基本等同于：

- 无状态组件 → 函数组件

- 有状态组件 → 类组件

但在 Hooks 引入后，函数组件同样可以拥有完整状态和副作用能力，因此**这种区分已经不再是技术层面的限制**。

现在更推荐从**组件职责**出发：

- 状态是否应该属于这个组件

- 是否可以下沉/上提状态

- 是否是纯展示组件

而不是纠结“有没有 state”。

###### 

###### 说说 react 中引入 CSS 的方式有哪几种？区别？

常见方式包括：

1. **全局 CSS / SCSS**：简单直接，但容易命名冲突

2. **CSS Modules**：通过构建工具生成局部作用域，适合组件化项目

3. **CSS-in-JS（styled-components、emotion）**：样式即组件，动态能力强，但运行时有成本

4. **内联 style**：适合少量动态样式，但不支持伪类、媒体查询

5. **原子化方案（Tailwind）**：通过组合 class 构建 UI，提高一致性，但对团队规范要求高

选择时主要看：**项目规模、团队习惯、动态样式复杂度和运行时性能要求**。

###### 怎么给 children 添加额外的属性？

常见方式有三种：

1. `React.cloneElement`：在不改变 children 结构的前提下追加 props

2. render props：通过函数形式显式传递参数

3. Context：适合跨层级、全局性信息

其中 `cloneElement` 适合对子组件做增强，但要注意它**只能作用于 ReactElement，且会增加耦合度**，不适合滥用。

###### 对比类组件和函数组件，有什么本质区别？代码层面如何判断

本质区别在于：

- 类组件是**基于实例的模型**，状态和生命周期绑定在实例上

- 函数组件是**基于函数执行和闭包的模型**，每次 render 都是一次全新执行

代码层面判断很简单：

- 是否 `extends React.Component`

- 是否存在 `this`、生命周期方法

现代 React 推荐函数组件 + Hooks，它在逻辑复用、组合能力、类型推导上都更有优势。

###### React 组件高度抽象和复用的自由有没有代价？

有，而且代价不小。

常见问题包括：

- 过度抽象导致组件层级过深、调试困难

- props 设计不合理导致使用成本高

- 复用场景被“假设”，反而限制业务演进

高级前端更关注：**恰到好处的抽象**，优先服务当前真实需求，而不是追求“看起来通用”。

###### 为什么虚拟 DOM 会提高性能？一定能提高性能吗？

虚拟 DOM 是对真实 DOM 的一层 JS 抽象，用来描述 UI 结构。

它提升性能的关键不在于“操作更快”，而在于：

- **最小化真实 DOM 操作**：通过 diff 算法计算最小更新集

- **批量更新**：多次状态变化合并后统一提交

- **跨平台能力**：让渲染逻辑与宿主环境解耦

但虚拟 DOM **并不保证所有场景都更快**：

- UI 结构极其简单、几乎不更新时，diff 本身是额外成本

- 高频动画、Canvas、WebGL 等场景不适合

- 不合理的组件设计仍然会导致性能问题

虚拟 DOM 的本质价值是：**提升整体可维护性与复杂场景下的性能上限，而不是极限性能**。

###### 为什么说 react 更适合 B 端大型项目

我觉得 React 更适合 B 端，核心不是“性能更好”，而是**对复杂度的容忍度更高**。

第一，B 端项目的复杂点往往不在页面样式，而在**状态多、交互复杂、业务规则多**。React 是典型的“状态驱动 UI”，组件就是函数，UI = state 的映射，这种模型在复杂场景下更容易拆解和维护。

第二，React 的**组件和逻辑抽象能力非常强**。比如 Hooks，本质就是普通函数，你可以把一整套业务逻辑抽成一个 Hook，在多个页面复用，这在后台系统、配置台里非常常见。

第三，**生态和工程化成熟**。B 端项目通常生命周期很长，React 从状态管理、路由、表单、表格、权限体系，到 SSR、微前端，都有大量成熟方案可选。

简单说，React 更像一个 **UI 运行时 + 架构工具箱**，而不是“拿来即用的完整框架”，这点在大型 B 端项目里反而是优势。

###### React 组合能力强会带来哪些坑？

组合能力强，本身就是一把双刃剑。

最常见的坑是：**抽象过度**。  
比如 Hook 拆得太细，一个页面引七八个 Hook，逻辑分散在不同文件里，新人根本不知道一段行为是从哪来的。

第二是**隐式依赖**。  
有些自定义 Hook 内部偷偷用 Context、全局状态，表面上看参数很少，但实际上依赖一大堆外部环境，用错地方就出问题。

第三是**性能问题更隐蔽**。  
组合之后，谁在触发 re-render、哪个 Hook 闭包不对，很难第一时间看出来，排查成本高。

所以在实际项目里，我会刻意控制：

- Hook 不追求“极致通用”

- 抽象只覆盖真实复用场景

- 组合层级不要太深

否则组合能力反而会变成维护负担。

###### 为什么说 react 的组件和逻辑抽象和复用比 vue 强

我觉得本质原因在于：**React 的抽象完全建立在 JavaScript 函数之上**。

在 React 里：

- 组件是函数

- Hook 也是函数

- 逻辑复用就是函数组合

你不需要理解太多框架“特殊规则”，就是 JS 思维，这点在复杂逻辑复用时非常舒服。

Vue 虽然现在有了 Composition API，但整体还是**模板 + 指令 + 响应式语法**的模型，抽象能力更多依赖框架约定，而不是纯语言能力。

举个例子：  
在 React 里，我可以很自然地写一个 `useTable`、`usePermission`，内部怎么拆、怎么组合完全自由；  
而 Vue 里你要同时考虑响应式、生命周期、模板使用方式，约束会更多。

当然代价也很明显：**React 更考验开发者的架构能力**，自由度越高，犯错空间也越大。

###### 组件状态保存 keep-alive 怎么用？原理是什么？

React 本身没有官方 keep-alive，这点和 Vue 不一样。

但本质上，所谓 keep-alive 就一句话：**不要让组件被 unmount**。

常见做法有几类：  
第一类，最简单的，用 CSS 控制显示隐藏，而不是条件渲染销毁组件。  
第二类，路由缓存，比如 react-activation，本质是把组件实例缓存起来，下次直接复用。  
第三类，把关键 state 提到更高层，比如路由外层，这样即使页面切换，状态也还在。

原理上非常简单：  
React 一旦 unmount，state、effect、ref 全都会被清掉。  
keep-alive 只是想办法绕开“卸载”这一步。

但一定要注意：  
keep-alive 是**用内存换体验**，用不好很容易内存膨胀、逻辑混乱。

###### 路由懒加载原理

路由懒加载的核心其实就一句话：**按路由拆包，按需加载**。

实现上一般是：

- 使用 `import()`

- 构建工具把不同路由打成不同 chunk

- 用户访问某个路由时，才下载对应 JS

在 React 里常见写法是 `React.lazy + Suspense`。

它解决的是一个非常现实的问题：  
后台系统路由多、页面多，如果全部打进首包，首屏一定很慢。

懒加载的本质是：**把“第一次看不到的代码”延后加载**。

###### react 的 Link 标签和 a 标签的区别

这个问题我一般会直接从“是否刷新页面”讲。

`a` 标签是浏览器原生跳转：

- 会刷新整个页面

- JS 状态全部丢失

- 重新请求资源

`Link` 是前端路由跳转：

- 通过 history API 改 URL

- 不刷新页面

- 应用状态全部保留

- 只切换组件

所以在 SPA 内部跳转，一定用 `Link`；  
只有跳外部网站，或者明确需要刷新时，才用 `a`。

###### 分别讲讲 react 16 / 17 / 18 / 19 新特性

React 16 是一个**架构级版本**，大的变化是引入了 Fiber 架构，把原来同步、不可中断的递归渲染，改成了可拆分、可中断的工作单元模型。为后续并发渲染打地基。但是

React 17 主要做了两件事：
一是重构事件系统，把事件从 document 下移到 root，减少对全局的侵入；
二是为并发模式、渐进升级铺路，让多个 React 版本可以共存。

React 18 是真正对业务产生明显影响的版本。
核心是并发特性正式可用，包括：

自动批处理（不再区分 React 事件还是原生事件）

startTransition / useTransition，区分紧急和非紧急更新

新的 root API，为并发调度提供入口

18 的目标很明确：在复杂更新场景下，保证交互优先级和页面响应性。

React 19 更偏向方向和能力整合，而不是一次 API 爆炸。
重点包括：

Server Components 更成熟

编译期优化能力增强，减少手写 memo、useCallback 的心智负担

更进一步弱化“开发者手动性能调优”的必要性

###### 什么是 JSX？为什么浏览器无法读取 JSX

JSX 本质就是 **JavaScript 的语法糖**，用来更直观地写 UI 结构。

浏览器不能直接识别 JSX，是因为 JSX 根本不是合法的 JS 语法。

它必须先经过编译，比如 Babel，把 JSX 转成 `createElement` 调用，浏览器才能执行。

所以 JSX 只是开发体验层面的东西，运行时根本不存在 JSX。

###### 说说 jsx 转 DOM 的过程和原理

这个过程我一般会拆成 **三层：编译期、运行时计算、提交阶段**。

第一层是**编译期**。  
JSX 本身不是合法的 JavaScript，必须通过 Babel 等工具，把 JSX 转成 `React.createElement` 或等价函数调用。  
这一步做的事情只是：**把语法糖变成普通 JS 表达式**。

第二层是**运行时生成虚拟 DOM**。  
`createElement` 执行后，会生成一个 React Element，本质是一个普通对象，用来描述节点类型、props、children。  
注意这里的 React Element 不是 Fiber，也不是 DOM，只是**UI 描述数据**。

第三层是**协调与提交**。  
React 在 render 阶段，会根据新旧 React Element 构建 Fiber 树，并通过 diff 算法计算出需要变更的部分；  
在 commit 阶段，再把这些变更一次性映射成真实 DOM 操作。

所以 JSX 到 DOM 并不是“直接生成 DOM”，而是：  
**JSX → React Element → Fiber → DOM**  
JSX 只是最前面的语法入口。

###### react diff 算法核心，和 vue 的 diff 有什么区别

React diff 的核心设计思路是：**在可接受复杂度内，尽量减少 DOM 操作**。

它有几个非常关键的假设：  
第一，不同类型的节点，直接销毁重建  
第二，只在**同一层级**做 diff，不跨层比较  
第三，列表通过 key 来标识节点身份，而不是位置

基于这些假设，React 可以把 diff 的复杂度控制在 O(n)，代价是：  
如果 key 设计不合理，或者结构变化剧烈，更新效率会下降。

Vue 的 diff 思路和 React 不太一样，更依赖 **响应式系统 + 静态分析**：

- 编译阶段标记静态节点

- 运行时 diff 范围更小

- 更新路径更明确

所以可以这样总结：

- React diff 更偏**运行时策略 + 调度能力**

- Vue diff 更偏**编译期优化 + 精确依赖追踪**

###### 讲讲 react 项目的性能优化

一般会从 **“更新为什么会发生、更新发生在哪、怎么减少无效更新”** 这三个层面来讲

第一层是 **渲染边界控制**。  
React 的性能问题，本质上大多数都是“**不该 re-render 的组件 re-render 了**”。所以核心是控制 render 边界：

- 拆分组件，让 state 尽量就近

- 对纯展示组件使用 `React.memo`

- 配合 `useMemo / useCallback` 稳定 props 引用  
  但我会强调一点：memo 不是越多越好，而是用来**明确哪些组件可以跳过更新**。

第二层是 **状态设计和更新粒度**。  
很多性能问题不是出在 React，而是 state 设计不合理，比如：

- 一个 state 牵动一大片组件

- 把临时状态、派生状态也放进 state  
  这类问题通过**拆 state、下沉 state、减少不必要的 state**，往往比任何 memo 都有效。

第三层是 **列表和计算场景**。  
包括：

- key 是否稳定、是否使用 index

- 大列表是否需要虚拟滚动

- 昂贵计算是否需要缓存  
  这是 React 项目里非常常见、也非常实际的性能瓶颈。

第四层是 **调度和工程层面**。  
比如：

- 路由懒加载、代码分割

- React 18 的 `startTransition` 区分更新优先级

- 必要时使用 SSR / Streaming  
  这些是解决“页面是否卡顿”“首屏是否慢”的关键。

###### 说说 hooks 的思想和原理

Hooks 的思想核心不是“语法糖”，而是**组件模型的转变**。

在 class 组件里，state 和生命周期是挂在实例上的，逻辑复用只能通过继承或 HOC，这会带来很强的结构耦合。  
Hooks 做的是：**把状态和副作用能力，从实例模型，转移到函数执行模型中**。

从原理上讲：

- 每个函数组件在 render 时，React 都会为它维护一份 Hook 状态

- `useState / useEffect` 这些 Hook，本质是在当前组件对应的 Fiber 上，按顺序读写这份状态

- React 并不关心 Hook 的名字，而是**依赖调用顺序来关联状态**

所以 Hooks 能够做到：

- 不依赖 class

- 逻辑可以自由拆分、组合  
  代价就是：**必须保证调用顺序稳定**。

###### react hook 如何以链表存储

在实现层面，React 是用**链表**来存 Hook 状态的。

每个函数组件对应一个 Fiber 节点，Fiber 上有一个 `memoizedState`，它指向 Hook 链表的头。  
在 render 阶段：

- React 会维护一个指针

- 每调用一次 Hook，就顺序访问或创建一个 Hook 节点

- Hook 节点里会存 state、更新队列、effect 信息等

选择链表而不是数组，主要是为了：

- 更好地配合 Fiber 的 workInProgress 机制

- 在更新、复用时成本更低

但这个设计直接导致了一个前提：**Hook 的调用顺序必须一致**。

###### 为什么 hook 只能写在顶层

这是一个**实现层面的硬约束**。

React 是通过“第 N 次调用 Hook ↔ 第 N 个 Hook 节点”来匹配状态的。  
如果 Hook 写在条件、循环或提前 return 里，那么某次 render 调用顺序发生变化，后面的 Hook 就会全部错位。

一旦错位：

- state 会读错

- effect 会乱执行

- 行为不可预测

所以 Hook 只能写在顶层，不是语法限制，而是**为了保证 Hook 链表和调用顺序的一致性**。

###### 看过 hooks 相关的草案吗

看过 Hooks 的 RFC。

当时的设计思路其实非常明确：

- 目标是解决 class 组件的复用和复杂度问题

- 明确接受“依赖调用顺序”和“规则约束”这类 trade-off

- 优先选择工程上可落地、可维护的方案，而不是理论最优

总体来说 Hooks 的设计是一次**非常务实、非常工程化的取舍**。

###### 说说 react 里你常用的 hook

在实际项目中，我常用的 Hook 基本分几类：

- **状态类**：`useState`，复杂状态时用 `useReducer`

- **副作用类**：`useEffect`，处理请求、订阅、生命周期逻辑

- **性能与引用控制**：`useMemo`、`useCallback`，明确 render 边界

- **引用类**：`useRef`，保存跨 render 的可变值、解决闭包问题

- **共享状态**：`useContext`，用于低频、全局性数据

但从工程角度看，最有价值的是**自定义 Hook**，它能把状态、副作用和业务规则封装成可复用的逻辑单元，让组件本身保持非常“薄”。

###### React 中 refs 的作用是什么

refs 的核心作用可以概括为一句话：**在 React 的声明式渲染模型之外，持有一个稳定、可变的引用**。

React 的 state / props 都是参与渲染的，只要变了就会触发一次 render；但在实际工程中，总会存在一些数据或对象：

- **变化不应该触发重新渲染**

- 但又需要在多次 render 之间被保留下来

这正是 refs 存在的意义。

在实践中，refs 主要有三类典型用途：  
第一，**直接访问或操作 DOM**，比如 focus、scroll、测量尺寸，这是声明式模型无法完全覆盖的场景。  
第二，**保存跨 render 的可变数据**，例如定时器 id、上一次的值、外部实例对象，这类数据如果用 state 反而会制造多余更新。  
第三，**与非 React 管理的第三方库对接**，比如图表、编辑器，它们往往需要一个长期存在的实例引用。

关键点在于：**ref 的变化不会触发组件重新渲染**，它是 React 提供的一条“逃生通道”，但不应该被滥用。

###### useRef 和 useState 的区别

useRef 和 useState 的本质区别并不在“是不是 Hook”，而在于**是否参与渲染流程**。

`useState` 的语义是：

- 状态变化会影响 UI

- 更新会触发重新 render

- React 会基于新 state 重新计算 UI

`useRef` 的语义是：

- 只是保存一个可变引用

- 更新 `ref.current` 不会触发 render

- 更像是一个“组件级的实例变量”

还有一个在高级场景里非常重要的差异：  
**闭包捕获行为不同**。  
函数组件的闭包会捕获某一次 render 的 state 值，但捕获到的 ref 是同一个对象引用，因此通过 `ref.current` 读取到的永远是最新值，这也是 useRef 常被用来解决闭包问题的原因。

所以结论很明确：

- 影响 UI 的，用 state

- 不影响 UI、但要跨 render 保存的，用 ref

###### 为什么 useState 返回数组而不是对象

这是一个典型的 **API 设计取舍问题**。

从使用层面看，数组有两个明显优势：  
第一，**解构时可以自由命名**，不依赖固定的 key 名，这对 API 使用体验更友好。  
第二，数组的语义是“有顺序的返回值”，而 Hooks 的实现恰好是**强依赖调用顺序**的。

从实现角度看，React 内部并不关心返回值的结构，它只关心：  
“这是当前组件第几个 Hook”。  
数组这种形式，正好和 Hooks 依赖顺序的模型保持一致。

所以 useState 返回数组，并不是随意选择，而是**和 Hooks 整体设计哲学高度一致的结果**。

###### useState 如何实现？怎么获得下一次更新后的值

useState 在内部并不是“直接改值”，而是基于 **更新队列（update queue）** 的模型。

每一个 useState 对应一个 Hook 节点，这个节点上会维护：

- 当前 state

- 一个 update queue，用来存储多次 setState 产生的更新

当调用 `setState` 时，React 做的事情是：

- 创建一个 update

- 把 update 放进当前 Hook 的更新队列

- 标记当前 Fiber 需要更新

真正的 state 计算发生在**下一次 render 阶段**，React 会按顺序处理 update queue，得到新的 state。

如果需要基于旧值计算新值，正确且唯一可靠的方式是：

`setState(prev => next)`

至于“怎么拿到更新后的值”，答案其实是：  
**拿不到同步结果**。  
React 不提供同步读取“下一次 state”的能力，只能在下一次 render 或通过 `useEffect` 感知 state 变化，这也是 React 保持渲染可控性的一个重要前提。

###### 调用 setState 之后发生了什么

从内部机制上看，调用 setState 之后大致会经历这样一条链路：

第一步，**生成 update 对象**  
setState 不会立刻修改 state，而是生成一条“状态更新描述”。

第二步，**update 入队**  
update 被放入当前 Hook 或 class 组件对应的更新队列中。

第三步，**调度更新**  
React 会根据当前更新的优先级，把这个 Fiber 标记为需要更新，并交给调度器决定何时执行。

第四步，**render 阶段**  
React 从当前 Fiber 开始，重新执行函数组件或调用 render，构建新的 Fiber 树，并计算 UI 差异。

第五步，**commit 阶段**  
把 render 阶段计算出的结果一次性提交到 DOM，并执行副作用（effect、ref 更新等）。

所以从设计上讲，`setState` 做的事情非常克制：  
它只是**发起一次更新请求**，而不是“命令 React 立刻更新 UI”，这也是 React 能做调度、并发和批处理的基础。

###### setState 何时同步何时异步?

严格来说，**setState 从来不是“同步或异步”的问题，而是“是否被批处理”**。

在 React 的模型里，setState 做的事情只是**创建 update 并触发一次更新调度**，并不等价于“立刻改 state”。

- **React 18 之前**
  
  - 在 React 事件系统（如 onClick）中，更新会被批处理
  
  - 在原生事件、Promise、setTimeout 中，更新不会被批处理，看起来像“同步”

- **React 18 之后**
  
  - 默认开启 **自动批处理（automatic batching）**
  
  - 不论是 React 事件、Promise、setTimeout，都会合并更新
  
  - 统一交给 Scheduler 决定何时 render

如果真的需要强制同步更新，只能使用 `flushSync`，但这会打断调度机制，属于兜底手段，不建议常用。

###### useEffect 是如何实现的？

useEffect 的实现要分清 **render 阶段** 和 **commit 阶段**。

在 **render 阶段**：

- React 只做一件事：**收集 effect 描述**

- 判断依赖数组是否变化，决定这个 effect 是否需要在本次提交后执行

在 **commit 阶段**：

- DOM 更新完成后

- 先执行上一次 effect 的 cleanup

- 再执行新的 effect 回调

这也是为什么 useEffect：

- 不会阻塞页面渲染

- 执行时机一定晚于 DOM 更新

本质上，useEffect 是一个**延迟到提交之后执行的副作用调度机制**。

###### useLayoutEffect 和 useEffect 的区别

两者的核心区别只有一个：**执行时机不同**。

- **useLayoutEffect**
  
  - DOM 更新完成
  
  - 浏览器绘制之前
  
  - 同步执行，会阻塞浏览器绘制

- **useEffect**
  
  - 浏览器完成绘制之后
  
  - 异步执行

因此 useLayoutEffect 适合：

- 读取布局信息（如 getBoundingClientRect）

- 需要在首帧绘制前同步修改 DOM 的场景

其余绝大多数情况，优先使用 useEffect，避免阻塞渲染。

##### React.memo 的第二个参数是什么？作用是什么

React.memo 的第二个参数是一个 **自定义 props 比较函数**：

`React.memo(Component, (prevProps, nextProps) => boolean)`

默认情况下，React.memo 使用 **浅比较**。  
提供第二个参数后，你可以**完全接管“是否重新渲染”的判断逻辑**。

适用场景：

- props 结构复杂

- 默认浅比较不够用

- 组件渲染成本很高

但需要注意：

- 比较函数本身有执行成本

- 写错容易导致组件不更新或状态不一致

所以它是一个**高风险、高收益**的优化点，一般只在性能瓶颈明确时使用。

##### ref / useRef / forwardRef 区别和作用

这三个概念解决的是同一类问题：如何在函数组件体系中持有和传递引用，但分工不同。

ref：引用这个概念本身，最终目的是访问或控制某个对象（通常是 DOM 或实例）

useRef：在函数组件中创建一个稳定的 ref，对应 { current }，在多次 render 之间保持同一个引用

forwardRef：让函数组件能够接收父组件传下来的 ref，并继续向内部传递

useRef 的关键特性是：

修改 ref.current 不会触发重新渲染

闭包捕获的是 ref 对象本身，而不是某次 render 的值

forwardRef 的核心价值在于：
在不破坏组件封装的前提下，向外暴露必要的控制能力，
这在组件库（Input、Select、Modal 等）中几乎是必需的能力。

##### 说说 useReducer 是什么，怎么用

useReducer 是 useState 的一种“结构化升级”。

它引入了 reducer 的概念：

- state 的变化不再分散在各处

- 所有更新逻辑集中在 reducer 中

- 通过 dispatch action 驱动状态变化

适合的场景是：

- state 结构复杂

- 更新规则清晰

- 多种行为影响同一份 state

从模型上看，useReducer 更接近一个**局部状态机**。

##### 对比 useReducer 和 useState

这两个 Hook 的**底层能力是等价的**，差异主要体现在**状态建模方式和复杂度管理**上。

`useState` 更偏向**值级别的状态管理**：

- 一个 state 对应一块独立的值

- 更新逻辑通常写在调用点

- 适合状态简单、更新路径单一的场景

`useReducer` 更偏向**行为驱动的状态管理**：

- state 的变化由 reducer 统一描述

- 通过 dispatch action 驱动更新

- 更新逻辑集中，可读性和可维护性更好

从实现上看，`useState` 本质上就是一个**简化版的 useReducer**（内部同样是 update queue + reducer 逻辑）。  
所以在实际项目里，一般的选择策略是：

- **状态简单 → useState**

- **状态复杂 / 多种行为影响同一状态 → useReducer**

关键不是“哪个更高级”，而是**状态复杂度是否已经超过 useState 的舒适区**。

##### 18 以前为什么 useState 不能批量更新，18 以后为什么可以？

这个问题的核心不在 useState，而在 **React 的调度模型是否统一**。

**React 18 以前**：

- 只有 React 自己控制的事件系统（如 onClick）里，更新才会被批处理

- 原生事件、Promise、setTimeout 中的 setState，被认为处在“脱离 React 控制流”的执行上下文

- React 无法安全地判断这些更新是否属于同一批次，因此默认不合并

**React 18 之后**：

- 引入了统一的调度入口（Scheduler）

- 不再根据“事件来源”决定是否批处理

- 所有更新都会先进入调度系统，再由调度器决定合并和执行时机

所以 18 之后 useState 能批量更新，不是 API 行为改变，而是：  
**React 终于具备了跨异步边界统一调度更新的能力**，这是并发架构的直接结果。

React 18 之所以能跨异步边界批量更新，本质原因是它把所有状态更新统一收编进 Scheduler，通过 concurrent root + lane 模型，让 React 自己掌握更新的合并和调度时机，而不再依赖事件来源是否“可控”。

##### react 自定义 hooks 和 Vue3 composable 本质区别？

两者在“形式”上很像，但**底层模型完全不同**。

React 自定义 Hook：

- 本质是**普通函数**

- 状态管理依赖 **Hook 调用顺序 + 内部链表**

- 不具备自动依赖追踪

- 数据流完全由开发者显式控制

Vue3 composable：

- 基于 **响应式系统**

- 状态是 reactive / ref

- 依赖关系由系统自动收集

- 更偏“声明数据 → 自动更新”

这带来的差异是：

- React Hook 更自由、更贴近 JavaScript 语义，但规则更严格（调用顺序、依赖数组）

- Vue composable 更自动化、心智负担更低，但抽象层更厚，对框架依赖更强

从工程角度看：  
React 的自定义 Hook 更像**逻辑层抽象工具**；  
Vue 的 composable 更像**响应式能力的复用单元**。

##### useContext 是什么作用？有什么优缺点？

useContext 的作用是**跨层级共享数据，避免 props drilling**。

优点：

- 使用简单

- 数据流清晰

- 适合全局配置、主题、权限等低频变化数据

缺点：

- 更新粒度粗

- Context value 变化会导致所有消费者重新渲染

- 不适合高频、复杂状态

常见优化方式包括：

- 拆分 Context

- 保持 value 引用稳定

- 在复杂场景中配合 selector 或状态管理库使用



##### React Fiber 是什么? 说说 fiber 架构的工作原理?

React Fiber 本质上是 **React 的新协调（reconciliation）架构**，它解决的核心问题只有一个：  
**让渲染过程从“同步、不可中断”，变成“可中断、可恢复、可调度”。**

在 Fiber 之前（Stack Reconciler），React 渲染是一次深度递归：

- 一旦开始 render，就必须把整棵组件树算完

- 过程中无法中断

- 主线程被长期占用，容易造成掉帧、输入卡顿

Fiber 引入之后，React 把“一次 render”拆成了很多**以 Fiber Node 为单位的小任务**。

从结构上看：

- 每个组件实例对应一个 Fiber Node

- Fiber Node 同时是：
  
  - 组件的“数据结构表示”
  
  - 一个“工作单元（work unit）”

从执行模型上看：

- render 阶段不再是递归，而是**可暂停的循环**

- React 每处理完一个 Fiber，就判断：
  
  - 时间片是否用完
  
  - 是否有更高优先级任务

- 如果需要，就中断当前渲染，稍后从中断点继续

一句话总结 Fiber 的工作原理：**把一次大而不可控的渲染任务，拆成很多可调度的小任务，由 React 自己掌控执行节奏。**



##### 为什么 react 需要 fiber 架构，而 Vue 却不需要?

React 需要 Fiber，而 Vue 不需要，本质原因是两者的更新模型不同。

Vue 是**以数据为核心的响应式系统**，通过依赖收集和发布订阅机制，精确地知道哪些组件、哪些计算属性依赖了某个数据，因此在数据变化时，可以直接定位到需要更新的最小范围，更新路径是明确且可控的。

而 React 是**以组件为核心的更新模型**，当组件状态发生变化时，默认会从该组件开始，重新执行组件函数，并向下递归子组件来计算新的 UI，这在组件树很大时，可能会形成一次耗时很长的渲染任务。

在 Fiber 架构之前，React 的 reconciler 是同步、不可中断的，一旦开始渲染，就会一直占用主线程，容易造成页面卡顿，影响用户输入和滚动等交互。

Fiber 架构的核心作用是把一次大的渲染任务拆分成多个以 Fiber 节点为单位的小任务，引入时间切片和优先级调度机制，在 render 阶段可以随时中断，把执行权交还给浏览器，等空闲时再继续执行，而 commit 阶段则一次性提交所有副作用，保证 UI 一致性。

所以总结来说，**React 由于组件级整体更新的特性，需要 Fiber 来解决可中断调度的问题，而 Vue 基于依赖追踪的更新模型，本身不需要这种级别的调度体系。**



##### 讲讲 React Fiber 是如何实现更新过程可控的

“可控”是 Fiber 的核心价值，具体体现在 **三件事** 上：

1. 第一，渲染任务可拆分（incremental work）

Fiber 把渲染拆成一个个 Fiber Node：

- 每个 Fiber 只做很小的一步工作

- React 可以在任意 Fiber 节点处暂停

这让 React 能避免“长时间霸占主线程”。

2. 第二，渲染过程可中断、可恢复

在 render 阶段：

- React 使用 `workInProgress` Fiber 树

- 每完成一个 Fiber，就记录当前进度

- 一旦被打断，下次可以从中断的 Fiber 继续，而不是重来

这是 Fiber 和旧架构**本质上的差异**。

3. 第三，render 和 commit 严格分离

Fiber 明确区分两个阶段：

- **render 阶段**：
  
  - 纯计算
  
  - 可中断
  
  - 不产生副作用

- **commit 阶段**：
  
  - 一次性提交 DOM
  
  - 不可中断
  
  - 保证 UI 一致性

这种分离，是 React 能做并发调度的前提。



##### react 如何确定具体场景的执行优先级

React 的优先级系统在 Fiber 中是通过 **Lane 模型 + Scheduler** 实现的。

1. Lane：优先级的“数据表示”

每一次更新（setState）都会被分配一个 lane：

- lane 是一个 bitmask

- 不同 lane 表示不同紧急程度
  
  - 同步输入（点击、输入）
  
  - 动画
  
  - 普通更新
  
  - transition
  
  - idle

lane 的本质作用是：**告诉 React：这个更新有多急，能不能等。**

2. Scheduler：优先级的“执行者”

Scheduler 会：

- 收集当前所有 pending updates

- 根据 lane 决定：
  
  - 先执行哪个
  
  - 哪些可以合并
  
  - 是否可以打断当前 render

React 会优先保证输入响应，而不是把时间花在低优先级渲染上。

3. 场景优先级的来源

优先级的来源主要包括：

- 更新发生的上下文（事件、transition）

- 开发者显式标记（如 `startTransition`）

- 内部默认策略（如初次渲染、同步更新）

React 18 的并发特性，本质上就是**开发者可以参与优先级标注**。



##### fiber 怎么进行任务的终止和恢复的？为什么不直接使用 requestldleCallback?

React Fiber 通过把一次渲染拆分成多个小的工作单元（Fiber Node），使渲染过程变成**可中断、可恢复的增量执行过程**。

在渲染阶段，React 每次只处理一个 Fiber 节点，处理完成后会判断当前时间片是否用尽，如果有更高优先级任务或者时间不够，就主动让出主线程。

中断时，React 会保存当前的 `workInProgress Fiber`，等下次调度继续从这个 Fiber 节点开始执行，而不是从头重新渲染整棵树。

React 并不是直接依赖浏览器调度，而是自己实现了一套 Scheduler。 通过 MessageChannel 来创建一个**稳定、可控、优先级更高的异步调度入口**，用来触发一次新的调度循环，而不是用来通信任务完成状态。

requestIdleCallback 的最大问题是： **调度时机完全由浏览器决定，React 无法精确控制优先级和执行时长。** 回调时机不可预测：浏览器“觉得”空闲才会调用，在动画、输入密集时可能长期不执行
优先级控制能力弱：只区分是否空闲而没有优先级
与 React 的调度模型不匹配：React 需要在不同优先级任务之间频繁切换，rIC 不适合高频、精细的任务切分

总结：Fiber 的本质是把同步、不可中断的递归渲染，改造成基于 Fiber Node 的可中断工作流；React 通过自建 Scheduler 控制调度节奏，而不是把渲染节奏完全交给浏览器。

##### 详细说说 fiber 架构的 commit 阶段过程

commit 阶段的核心特征只有一句话：  
**不可中断，一次性提交所有副作用。**

commit 阶段通常分为 **三个子阶段**：

1. 第一阶段：before mutation

这一阶段主要做两件事：

- 执行 `getSnapshotBeforeUpdate`

- 读取 DOM 状态（在 DOM 变更之前）

这是给类组件和部分底层逻辑用的。

2. 第二阶段：mutation

这是 commit 的核心阶段：

- 执行 DOM 插入、更新、删除

- 更新 ref

- 执行 layout effect 的 cleanup（旧的）

所有 DOM 变更都发生在这里，而且**顺序是严格保证的**。

3. 第三阶段：layout

在 DOM 已经更新完成后：

- 执行 `useLayoutEffect`

- 执行 class 组件的 `componentDidMount / componentDidUpdate`

这一阶段仍然是同步的，会阻塞浏览器绘制。





##### 详细说说 fiber 架构的 render 阶段过程

render 阶段是 **Fiber 的核心工作阶段**，特点是：  
**纯计算、可中断、不触碰 DOM。**

整个过程可以理解为一个循环，而不是递归。

1. beginWork（向下）
- 从 root Fiber 开始

- 对每个 Fiber 执行 `beginWork`

- 根据 props/state 计算子 Fiber

- 标记副作用（flags）

这是“向下构建 Fiber 树”的过程。

2. completeWork（向上）
- 当一个 Fiber 的子节点处理完成

- 执行 `completeWork`

- 收集子节点的副作用

- 构建 effect list（flags 链）

这是“向上归并结果”的过程。

3. 可中断点

在任意一个 Fiber 处理完成后：

- React 都可以检查时间片

- 如果需要：
  
  - 暂停 render
  
  - 把控制权还给浏览器
  
  - 之后从当前 Fiber 继续
4. render 阶段的产出

render 阶段的最终产物是：

- 一棵 **workInProgress Fiber Tree**

- 一份完整的副作用描述（flags）

但 **不会产生任何真实 DOM 变更**。



##### react 如何实现时间切片

时间切片（Time Slicing）本质上是：  **把一次长时间占用主线程的渲染任务，拆成多个短任务，在合适的时机主动让出主线程。**

React 能实现时间切片，靠的是 **Fiber + Scheduler + cooperative scheduling（协作式调度）** 这一整套机制。

**第一步：把渲染任务拆成最小工作单元**

在 Fiber 架构下：

- 每一个 Fiber Node 就是一个**最小可执行单元**

- render 阶段不再是递归调用，而是一个循环

- 每处理完一个 Fiber，React 都有机会“停下来看看要不要继续”

这是时间切片的**结构前提**。  
如果还是递归，一次函数调用栈跑完，根本没有中断点。

**第二步：在 render 阶段引入“可让出点”**

React 在 render 阶段，每完成一个 Fiber 的 `beginWork / completeWork` 后，都会检查：

- 当前时间是否超过了本次分配的时间片

- 是否有更高优先级的任务（如用户输入）

一旦判断“该让出主线程了”：

- 当前 render 立即暂停

- 保存当前 `workInProgress` 指针

- 把控制权还给浏览器（让输入、动画先执行）

**第三步：通过 Scheduler 决定何时继续**

React 并不是随便继续渲染的，而是通过 Scheduler：

- 把剩余的 Fiber 工作挂到一个任务队列里

- 等浏览器空闲、或者当前优先级允许时

- 从上一次中断的 Fiber 继续执行，而不是重头开始

这一步的关键在于：  
**render 阶段是可恢复的**，这是 Fiber 架构才能做到的事情。


#### fiber 为什么是性能飞跃

Fiber 被称为性能飞跃，不是因为“单次渲染更快”，而是因为**性能模型发生了根本变化**。

可以从三个层面理解。

**第一，Fiber 解决的是“卡顿问题”，不是“跑得快不快”**
旧架构的问题不是平均性能，而是**最坏情况**：
- 一次更新渲染几百个组件
- 主线程被占用几十毫秒
- 用户输入、滚动直接卡死
Fiber 的价值在于：  
👉 **把不可控的长任务，变成可控的短任务**
这直接提升的是**交互稳定性**，而不是 benchmark 分数。

**第二，Fiber 让“优先级”成为调度原则**
在 Fiber 之前：
- 更新基本是 FIFO
- 用户输入和低优先级更新没有本质区别
Fiber 之后：
- 每个更新都有优先级（lane）
- 高优先级更新可以打断低优先级渲染
- 非紧急更新可以被延后甚至丢弃重算
这让 React 能做到：  
**页面再复杂，也优先保证用户交互不卡。**

**第三，Fiber 为并发能力打开了天花板**
Fiber 本身不是并发，但它是并发的**必要前提**。
没有 Fiber：
- render 不可中断
- 无法调度
- 不可能并发
有了 Fiber：
- render 可暂停、可恢复
- Scheduler 可以插队、合并、延迟
- 才有 React 18 的并发渲染、自动批处理、transition

**一句话总结 Fiber 为什么是性能飞跃**：Fiber 的性能飞跃不在于加快一次渲染，而在于把渲染从同步、不可控的长任务，变成可调度、可中断的工作流，从而在复杂场景下保证交互优先级和系统稳定性，这也是 React 并发能力的基础。



##### redux 的使用原则

我理解 Redux 的使用原则可以总结为三点：**该不该用、怎么用、用到什么程度**。

第一，**不是所有状态都适合放 Redux**。  
Redux 主要解决的是**跨组件、跨页面、生命周期长、需要可预测性的状态**，比如用户信息、权限、全局配置、复杂业务流程状态。  
组件内部 UI 状态、临时状态，用 Redux 反而会增加复杂度。

第二，**Redux store 里的状态必须是“业务状态”**。  
不要把派生状态、纯 UI 状态、一次性状态塞进 store，否则 reducer 会变得难以维护。

第三，**更新路径必须可追踪、可预测**。  
Redux 的核心价值在于“状态变更有明确入口”，如果 dispatch 到处乱飞、action 语义混乱，Redux 的优势会被完全抵消。

一句话原则是：

> Redux 用来管理“重要且复杂的共享状态”，而不是“所有状态”。


##### 说说 Redux 的核心方法和工作流程

Redux 的核心其实非常少，主要就是 **store、action、reducer** 这三件事。

从工作流程看是一个**严格的单向数据流**：

1）UI 触发一个 action（一个普通对象，描述发生了什么）  
2）action 被 dispatch 到 store  
3）store 调用 reducer，传入旧 state 和 action  
4）reducer 根据 action 返回一个新的 state  
5）store 保存新 state，并通知所有订阅者  
6）UI 读取最新 state，重新渲染

这里有两个非常关键的点：
- reducer 必须是**纯函数**
- state 必须是**不可变更新**

正是这两个约束，保证了 Redux 的可预测性和可调试性。

##### redux 的优缺点

Redux 的优点：
第一，**状态可预测、可追溯**。  
所有状态变化都通过 action 发生，时间线非常清晰，调试和回溯成本低。
第二，**适合复杂业务状态**。  
当状态更新逻辑变复杂时，Redux 反而更清晰，因为规则都集中在 reducer 里。
第三，**生态成熟**。  
中间件、调试工具、最佳实践非常完善。

但缺点也同样明显：
第一，**样板代码多**。  
action、reducer、types，一旦规模不控制，很容易膨胀。
第二，**心智负担偏重**。  
对简单场景来说，Redux 明显是“重武器”。

所以 Redux 非常适合复杂中大型项目，但并不适合所有项目。

##### 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？

Redux 中间件的本质是：  
**在 dispatch action 和 reducer 处理 action 之间，插入一层可扩展的拦截逻辑**。

常见中间件包括：
- `redux-thunk`：支持 action 返回函数
- `redux-saga`：用 generator 处理复杂异步流程
- `redux-logger`：日志和调试
- `redux-promise`：处理 Promise action

实现原理并不复杂：  
Redux 在创建 store 时，会把原始的 `dispatch` 包装成一层层函数链，每个中间件都可以：
- 拦截 action
- 执行额外逻辑
- 决定是否、何时、以什么形式继续 dispatch

所以中间件解决的是：  
**扩展 Redux 能力，但不污染 reducer 纯度**。

##### Redux 中异步的请求怎么处理

Redux 本身是同步的，不支持直接在 reducer 里做异步。

处理异步主要有三类方案：
第一类，**Thunk 模式**。  
action 返回一个函数，在函数里做异步请求，完成后再 dispatch 普通 action，适合简单异步。
第二类，**Saga 模式**。  
通过 generator + effect 描述异步流程，更适合复杂的并发、取消、重试场景。
第三类，**请求层与 Redux 解耦**。  
比如请求在组件或 service 层完成，只把结果 dispatch 进 Redux，这在工程实践中非常常见。

选择哪种，取决于**异步复杂度**，而不是“哪个更高级”。

##### React 中组件之间进行数据通信有哪些方式？

从低到高大致可以分几层：

第一，**props 传递**，父子组件最基本方式  
第二，**回调函数**，子组件向父组件通信  
第三，**Context**，解决跨层级传参  
第四，**全局状态管理（Redux、Zustand 等）**  
第五，**外部事件系统 / pub-sub**，极少数特殊场景

原则是：

> 优先选择最简单的通信方式，复杂度不够时再升级方案。

##### 对比 redux 和 zustand

Redux 和 Zustand 的核心差异，不在 API，而在**设计目标和约束强度**。

**Redux 的定位是“强约束的全局状态管理方案”**：
- 单一 store、单向数据流
- 所有状态变化必须通过 action → reducer
- 强调可预测性、可追溯性、可调试性
这使得 Redux 非常适合：
- 复杂业务状态
- 状态变更规则多、流程长
- 多人协作、长期维护的项目
代价也很明显：
- 样板代码多
- 心智负担重
- 简单场景下显得过度设计

**Zustand 的定位是“轻量、贴近 React 的状态容器”**：
- 基于 hook
- 没有 reducer、action 的强制约束
- 按需订阅，更新粒度细
Zustand 更像是： “一个可共享的 useState + useCallback 集合”
它非常适合：
- 中小规模项目
- 对开发效率和简洁性要求高的场景

总结一句话：
- **Redux 用规则换确定性**
- **Zustand 用自由换效率**

在实际工程中，我更倾向于：
- 复杂业务核心状态 → Redux
- 中小型项目，强调开发效率 → Zustand

##### React 中组件之间进行数据通信有哪些方式？

我一般会按**“通信距离 + 状态生命周期”**来回答。

第一层，**父子组件**：
- props 向下传递
- 回调函数向上传值  
    这是最基本、也是最推荐的方式。

第二层，**兄弟组件 / 跨层级组件**：
- 状态提升到最近的公共父组件
- 再通过 props 分发

第三层，**Context**：
- 解决 props drilling
- 适合低频变化、全局性数据（主题、权限、配置）
- 缺点是：Context 更新会导致所有消费组件重新 render，粒度比较粗。

第四层，**全局状态管理**：
- Redux、Zustand、MobX 等
- 用于生命周期长、影响范围广的状态

核心原则是： **优先用最近、最局部的通信方式，复杂度不够时再升级方案。**


##### 说说 react 的事件代理机制原理和优缺点

React 的事件系统是**合成事件（Synthetic Event）机制**，核心是**事件代理**。

**原理**上：
- React 并不会在每个 DOM 节点上绑定事件
- 而是把事件统一绑定在**根节点（React 17 之后是 root container）**
- 事件触发后，通过事件冒泡捕获到根节点
- React 再根据 Fiber 树，模拟捕获和冒泡阶段，分发给对应组件的事件处理函数

**优点**：
- 性能稳定，避免大量事件监听
- 事件系统一致，跨浏览器行为统一，框架统一处理浏览器兼容性
- React 可以完全控制事件触发时机和优先级，为批量更新、优先级调度提供基础

**缺点**：
- 事件不完全等同于原生事件
- 在极端场景（如 document 级别监听）下可能产生困惑
- 需要理解合成事件与原生事件的差异（如事件对象复用、时机差异）

##### 说说 react 事件和浏览器原生事件执行先后顺序，为什么？

这个问题的关键在于：  
**React 事件本质上是绑定在 react 根元素上（在 React 17 之后）的原生事件监听器。**

在同一个元素上挂载的事件，顺序是：
- → **React 捕获阶段事件**
- → **原生捕获阶段事件**
- → **React 冒泡阶段事件**
- → **原生冒泡阶段事件**

原因在于：
- React 在 react oot container 上注册了原生事件监听
- React 可以选择在捕获阶段或冒泡阶段拦截事件
- 然后在内部模拟完整的捕获/冒泡流程

##### react 的事件为什么要委托，有什么好处？

React 之所以做事件委托，本质原因是：**React 需要一个“可控、统一、可调度”的事件入口**，而不是简单的性能优化。

从实现上看，React 并不会在每个 DOM 节点上绑定事件，而是：
- 在根节点（React 17 之后是 root container）
- 统一注册一组原生事件监听
- 事件触发后，再由 React 自己根据 Fiber 树分发给对应组件

这样做有几个关键好处：

第一，**统一事件模型，屏蔽浏览器差异**  
React 的合成事件层可以抹平不同浏览器在事件对象、冒泡行为上的差异，保证行为一致。

第二，**为批量更新和调度提供控制点**  
事件回调是 React 非常重要的“更新边界”。  
通过委托，React 可以在事件回调结束后，统一做 batching、优先级调度，而不是被分散在各个 DOM listener 里。

第三，**避免大量事件监听带来的管理成本**  
在复杂应用中，组件频繁挂载、卸载，如果每个节点都绑事件，清理和维护成本非常高。  
集中委托让事件生命周期和 React 树保持一致。

所以总结一句话： React 做事件委托，不只是为了少绑事件，而是为了**完全掌控事件 → 更新 → 渲染这一整条链路**。

##### react 事件委托如何解决模态框的事件冒泡？

这个问题其实考的是：**“React 里的事件冒泡，是按 DOM 树，还是按 React 树？”**
答案是：  **React 的事件冒泡是按 React Fiber 树，而不是 DOM 树。**

在模态框（Modal）场景中，经常是：
- Modal 的 DOM 被渲染到 `document.body`（通过 Portal）
- 但在 React 组件结构上，它仍然是某个父组件的子节点

React 的做法是：
- 原生事件先在真实 DOM 上冒泡到 root
- React 拿到事件后
- **根据 Fiber 树关系重新模拟捕获和冒泡**

因此即使 Modal 的 DOM 在 body 下：
- React 仍然能正确判断它“逻辑上属于谁”
- 冒泡顺序仍然符合组件层级预期

总结：React 通过“事件委托 + Fiber 映射”，把**DOM 位置和组件层级解耦**了。

##### react 17 之后的事件机制有什么区别？

React 17 的事件系统变化是一个**非常典型的架构级调整**，**最关键的变化只有一个**：  **事件不再委托到 `document`，而是委托到 root container。**

在 React 16 及之前：
- 所有 React 事件都绑定在 `document` 上
- 多个 React 应用会共享同一套事件系统
在 React 17 之后：
- 事件绑定在 `createRoot` 对应的容器上
- 每个 React 应用拥有独立的事件系统

这样改的核心原因是：
第一，**支持多个 React 版本共存**  
document 级别委托会导致不同版本的 React 互相干扰。

第二，**降低对全局环境的侵入性**  
React 不再“劫持”整个 document，更像一个普通应用。

第三，**为并发特性和渐进升级铺路**  
事件边界更清晰，调度模型更容易控制。

这次改动对业务代码几乎无感，但对架构非常关键。

##### 子组件 portal 能冒泡到父组件吗？

结论先给： **能，React 事件可以，原生事件不行。**

更准确地说：
- **React 合成事件：可以冒泡到逻辑父组件**
- **原生 DOM 事件：只按真实 DOM 结构冒泡**

原因在于：  
React 的事件冒泡是基于 **Fiber 树**，而不是 DOM 树。
Portal 的特点是：
- DOM 节点被插入到别的地方（比如 body）
- 但 Fiber 关系不变

所以：
- React 在事件分发阶段
- 会“无视 DOM 位置”
- 按组件层级模拟冒泡

这也是为什么在 Portal 场景下：
- `e.stopPropagation()` 有时要特别注意
- 原生事件和 React 事件的行为可能不同 

一句话总结就是： Portal 打破的是 DOM 层级，不是 React 的组件层级。

##### Redux 中的 connect 有什么作用?

Redux 中的 `connect` 是一个高阶组件，用来把 Redux 的 store 和 React 组件连接起来。

它的核心作用有三个：  
第一，通过 `mapStateToProps` 精准地选取组件真正依赖的状态，并在这些状态发生变化时才触发组件更新，从而避免不必要的重渲染。  
第二，通过 `mapDispatchToProps` 封装 dispatch，让组件只关心业务行为，而不直接依赖 Redux 的实现细节。  
第三，`connect` 内部自动完成 store 的订阅和取消订阅，简化了组件的生命周期管理。

本质上，`connect` 起到的是**状态管理层和视图层之间的桥梁作用**。  
在 Hooks 出现后，`useSelector / useDispatch` 在使用体验上更直观，但 `connect` 在性能可控性和老项目中依然很常见。

##### 说说你对 immutable 的理解？如何应用在 React 项目中

Immutable 的核心思想是：**数据一旦创建就不被修改，任何变更都会生成一个新的引用**。

在 React 中它的价值主要体现在两点：

1. **状态可预测**：避免隐式修改带来的副作用，数据流更清晰

2. **性能优化基础**：通过引用变化配合 `===`、`memo`、`PureComponent`、`shouldComponentUpdate` 实现高效更新判断

实际应用方式包括：

- 遵守不可变更新原则（展开运算符、slice、map 等）

- 在复杂嵌套结构中使用工具库（如 Immer）降低心智成本

- 配合 Redux / React.memo / useMemo 做更新边界控制

需要注意的是，immutable 是**手段而不是目的**，在性能敏感或结构简单的场景下不必过度追求。

##### RSC react server component

React Server Components 是 React 提出的 **一种让部分组件只在服务器端执行的渲染模式**
它不是传统意义上的 SSR（Server-Side Rendering）那样生成完整 HTML，而是：

**在服务器执行组件逻辑，把渲染结果以特殊协议序列化成数据流发送给客户端，客户端再把这些数据解释成 UI。**

核心特点：

- 组件代码 **永远不发送到客户端**（不会打包到 bundle 里）。
- 只能运行在服务器上，不能使用浏览器 API 和交互 Hooks（如 `useState`, `useEffect`）。主要用于数据密集型、展示型的 UI。
- 主要用于数据密集型、展示型的 UI。

这就能让 React 应用更“轻巧、高效、按需加载”。

| 渲染方式        | JS 发送到客户端       | 数据获取模式         | 互动能力                 |
| ----------- | --------------- | -------------- | -------------------- |
| CSR (客户端渲染) | 全组件 JS          | 客户端请求 API      | 强                    |
| SSR (服务端渲染) | 全组件 JS + HTML   | 服务端预取数据 → HTML | 交互需要 hydrate         |
| **RSC**     | **只发送必要的交互 JS** | 服务器直接数据访问      | 交互需 Client Component |

React Server Components 是一种服务器执行的组件模式，它让 UI 的渲染和数据获取在服务端完成，只把 UI 结构通过序列化协议发送给客户端，从而减少 JS bundle、提高性能并简化数据获取，同时和交互组件协同工作，适配复杂应用。

**RSC 适合：数据驱动、多页面/大列表/复杂查询、多数据源聚合，但客户端交互较轻**的页面。

**不适合：交互复杂、状态频繁变化、强实时响应**的组件。



