#### 五层网络模型

| **层次**                | **主要协议/设备**          | **主要功能**                          |
| --------------------- | -------------------- | --------------------------------- |
| **应用层 (Application)** | HTTP, DNS, SMTP, FTP | 负责处理特定的应用程序细节，为用户提供网络服务。          |
| **传输层 (Transport)**   | TCP, UDP             | 提供进程间的通信（端口），负责数据的可靠传输或快速传输。      |
| **网络层 (Network)**     | IP, ICMP, 路由器        | 负责数据包的路由和转发，确定数据传输的路径（IP 地址）。     |
| **数据链路层 (Data Link)** | Ethernet, PPP, 交换机   | 负责物理地址寻址（MAC 地址），将数据封装成帧，提供点对点传输。 |
| **物理层 (Physical)**    | 网线, 光纤, 集线器          | 负责比特流的传输，规定电压、接口标准等。              |

#### 七层网络模型

**物 数 网 传 会 表 应**

| **应用层 (Application)**  | 提供用户接口，实现特定网络服务。       |
| ---------------------- | ---------------------- |
| **表示层 (Presentation)** | 数据格式转换、加密解密、压缩解压缩。     |
| **会话层 (Session)**      | 建立、管理和终止会话（如同步通信）。     |
| **传输层 (Transport)**    | **(同五层)** 进程间通信，可靠性保障。 |
| **网络层 (Network)**      | **(同五层)** 路由寻址，数据包转发。  |
| **数据链路层 (Data Link)**  | **(同五层)** 帧的传输，MAC 寻址。 |
| **物理层 (Physical)**     | **(同五层)** 比特流传输。       |

#### cookie

**Cookie** 是一种在客户端（浏览器）存储少量数据的机制。它主要用于在无状态的 HTTP 协议中实现**状态管理**。

- **工作机制：**
  
  1. 服务器在 HTTP 响应头中通过 `Set-Cookie` 字段将数据发送给浏览器。
  
  2. 浏览器将这些数据以键值对的形式存储起来。
  
  3. 之后浏览器向同一域名发送请求时，会在请求头中自动带上 `Cookie` 字段发送给服务器。

- **主要用途：**
  
  - **会话管理：** 存储用户登录状态、购物车内容等。
  
  - **个性化：** 存储用户偏好设置、主题等。
  
  - **追踪：** 记录用户行为，用于分析和广告。

- **重要安全属性：**
  
  - `HttpOnly`: 阻止 JavaScript 通过 `document.cookie` 访问 Cookie，防止 XSS 攻击。
  
  - `Secure`: 仅在 HTTPS 连接中发送 Cookie。
  
  - `SameSite`: 用于防止 CSRF 攻击，限制 Cookie 跨站发送。

#### http1.0 1.1 2.0 https

**HTTPS 补充：** HTTPS 是在 HTTP 层和 TCP 层之间插入 **TLS/SSL (安全传输层协议)** 的产物。

- **核心作用：** 提供**数据加密、身份认证和数据完整性**。

- **加密方式：** 采用**混合加密**机制，利用**非对称加密**（证书）进行身份认证和密钥交换，利用**对称加密**对后续数据进行高效加密传输。

1.0：**非持久连接**，每次请求/响应后关闭 TCP 连接；频繁建立/关闭 TCP 连接

1.1：**持久连接**，TCP 连接默认保持打开，可复用。支持 `PUT`, `DELETE` 等更多方法；支持 `Content-Range`、`Cache-Control` 等header，cookie增加了属性；仍有 **队头阻塞**

2.0：**多路复用**，单个 TCP 连接上同时处理多个请求和响应，消除了队头阻塞；**支持头部压缩**，减少头部大小；**支持服务端推送**；但基于TCP的队头阻塞仍存在，HTTP/2 在网络质量差、丢包率高的情况下，性能可能比 HTTP/1.1 更差，因为 HTTP/1.1 至少可以通过多个连接（尽管数量有限）来分散风险

HTTP/3 放弃了 TCP，转而使用 **QUIC 协议**，而 QUIC 是基于 **UDP** 实现的

大多数现代浏览器（Chrome, Firefox, Edge）对**同一个域名 (Host)** 的最大并发 TCP 连接数限制在 **6 到 8 个**之间，针对1.1这个问题很明显

#### <mark>TCP协议</mark>

TCP 是传输层最重要的协议之一，它提供**面向连接的、可靠的、基于字节流**的通信服务。

- **面向连接：** 数据传输前需要经过**三次握手**建立连接，传输结束后需要经过**四次挥手**释放连接。

- **可靠性：**
  
  - **序号 (Sequence Number) 与确认号 (Acknowledgment Number)：** 保证数据包按序到达，并对收到的数据进行确认。
  
  - **重传机制：** 发送方在收到确认前，会重传数据。
  
  - **校验和：** 检查数据在传输过程中是否被损坏。

- **流量控制：** 利用**滑动窗口**机制，控制发送方的发送速率，防止接收方来不及处理数据而丢包。

- **拥塞控制：** 通过慢启动、拥塞避免、快重传、快恢复等机制，防止网络整体性能下降。

#### <mark>websocket：数据传输方式？状态码？怎么实现重连</mark>

WebSocket 协议建立在 HTTP 协议之上（通过 HTTP 握手）

特点

- **双向全双工通信：** 客户端和服务器可以在任何时间独立地向对方发送数据，无需等待对方的响应。

- **基于帧 (Frame) 的数据传输：** 数据以更小、开销更低的**帧**为单位进行传输，而不是像 HTTP 那样需要完整的请求和响应头，大大降低了数据传输的开销和延迟。

- **保持持久连接：** 连接一旦建立，就会一直保持打开状态，直到任意一方关闭或出现异常。

- **独立的应用层协议**（虽然基于HTTP升级），有自己的安全机制，不是依赖浏览器的同源策略。**服务器在握手阶段通过验证 Origin 来控制访问**

状态码：**成功的握手状态码：** `101 Switching Protocols`。

- 客户端发送带有 `Upgrade: websocket` 和 `Connection: Upgrade` 头的 HTTP 请求。

- 服务器如果支持，则返回 `101` 状态码，表示协议切换成功，连接正式升级为 WebSocket。

怎么实现重连：由于网络抖动、服务器重启等原因，WebSocket 连接可能中断。

1. **监听连接关闭事件：** 客户端通过监听 `WebSocket` 对象的 `onclose` 事件来检测连接中断。

2. **设置重连计时器：** 在 `onclose` 事件中，启动一个定时器。

3. **退避算法 (Backoff)：** 为了避免因网络持续中断导致客户端不断发起重连请求（**重连风暴**），应使用**指数退避**策略。
   
   - 第一次等待 1 秒，第二次等待 2 秒，第三次等待 4 秒，依此类推，直到达到最大重连次数或最大等待时间。

4. **重新发起连接：** 定时器触发后，重新创建 `WebSocket` 实例并发起连接。

#### http缓存

#### 状态码

`304 Not Modified` (协商缓存命中)

#### TCP三次握手和四次挥手的过程。为什么挥手是四次?

#### ca证书是从哪里获取的

#### 怎么保证 CA的有效性

CA 证书的有效性由**信任链 (Chain of Trust)** 和**数字签名**机制来保证。

1. 浏览器/操作系统的信任列表：主流的 CA（称为**根 CA, Root CA**）的证书公钥**预装**在所有主流的操作系统和浏览器中，被标记为**受信任**的。这是信任的起点。

2. 网站将自己的**公钥**提供给 CA，CA 用自己的**私钥**对包含网站公钥和信息的证书文件进行**签名**。再将网站公钥、网站信息和这个**数字签名** 封装在一起，形成了网站的 SSL/TLS 证书。

3. 浏览器验证的网站的证书，使用 CA 的**公钥**（已预装或从信任链中获得）来**验证**这个签名
