#### 如果界面需要实时更新用户信息（比如玩家的得分），你会如何设计前端架构来实现这一功能?

如何选轮询 / SSE / WebSocket，我会按 5 个维度选：
	1. 更新频率（秒级 / 100ms / 更高）
	2. 数据量（单值/小 JSON/大 payload）
	3. 是否双向（只接收 vs 需要频繁发送）
	4. 可靠性要求（可丢/不能丢/最终一致即可）
	5. 成本与复杂度（后端/网关/运维）
结合业务问题：
- 每秒更新多少次？
- 同时在线多少用户？
- 允许延迟多少？

2. 轮询（Polling）——“简单、稳，但有浪费”
	**适用场景**
	- 更新频率低：比如 **10s~60s** 更新一次
	- 数据量小：比如积分、状态、小红点
	- 并发不大或服务端压力可控
	**优点**
	- 实现成本最低
	- 容错强（网络抖动也能下一次再拉）
	- 缓存/网关/监控体系成熟
	**缺点**
	- 资源浪费（没变化也请求）
	- 延迟取决于轮询间隔
	**工程实践（加分）**
	- **增量轮询**：带上 `since` / `etag`
	- **退避策略**：失败后指数退避
	- 页面隐藏时暂停：`visibilitychange`
3. SSE（Server-Sent Events）——“单向推送的性价比”
	**适用场景**
	- 只需要**服务端 → 客户端**推送，无需双向实时交互
	- 更新频率中等：**1s~200ms** 级别
	- 消息为文本/JSON，不复杂
	- 典型：公告、通知、进度、状态变化、比分更新
	**优点**
	- 基于 HTTP，穿透代理/负载均衡更友好
	- 浏览器原生支持自动重连（EventSource）
	**缺点**
	- 单向；客户端发消息还是要走 HTTP
	- 需要服务端支持
4. WebSocket ——“高频/交互/多路复用的最终形态”
	**适用场景**
	- 高频更新：**100ms 甚至 16ms**（实时位置、游戏状态）
	- 需要双向：客户端也要实时发送（操作、确认、订阅变更）
	- 需要在一条连接上订阅多种业务 topic（积分、排名、事件）
	**优点**
	- 真正双向、低延迟
	- 支持多路复用（topic/channel）
	- 更适合高频小消息
	**缺点**
	- 复杂度高：鉴权、心跳、重连、订阅恢复、消息顺序
	- 运维要求高：连接数、网关、限流、消息队列
	- “不丢消息”通常要协议层配合（seq/ack/补发）
	**工程实践（加分）**
	- 心跳 + 指数退避重连
	- 订阅协议：subscribe/unsubscribe
	- 消息 `seq` + 去重，必要时 `ack` + 补发
	- 高频 UI 更新：用 rAF/批处理，避免每条消息都 setState

#### 自动化发布怎么实现

1. 版本号规则（SemVer）：团队需要统一 commit 规范
	- 版本号规则：**SemVer（Semantic Versioning）是一套用版本号来表达“变更影响范围”的约定**，标准格式是：  `major.minor.patch`
	- 通过 commit 规范自动推断版本（Conventional Commits）：
	    - `fix:` → patch
	    - `feat:` → minor
	    - `BREAKING CHANGE` → major
2. CI 里自动：简单可以用 npm version patch
    - 更新 `package.json` 版本号，自动生成 changelog
    - 生成一个 commit 并生成 git tag（tag 是给某个 commit 打的“版本标记”，便于后续查找版本号、定位、回滚）
    - push commit + tag，CI 监听 tag → 构建 → 发布
3. 发布提醒（版本号/变更内容）
	- 在 PR / merge 时自动评论：预计 bump 到哪个版本、包含哪些变更
	- release 成功后发通知：
	    - 企业机器人 + @相关人
	    - 包含：版本号、breaking、迁移指引、回滚指令
4. 发布安全阀
	- 灰度：按环境/用户分流（canary）
	- 一键回滚：回到上一个 tag / 上一个 CDN 版本

#### 停留页面提示版本更新

1.方案 1：轮询版本文件（最通用）
- 发布时生成 `/version.json` 或写到 HTML meta：
    - `{ "version": "1.2.3", "buildTime": ... }`
- 客户端每隔 N 分钟拉一次：
    - 发现 version 变化 → toast：**“发现新版本，点击刷新”**
    - 用户确认后 `location.reload()`
- 优点：实现简单、跨技术栈 ；缺点：有轮询
2.Service Worker（更强）
- 有 SW 的项目：更新检测更标准
- 新 SW ready 时提示用户刷新
- 能做到更精细的缓存策略
3.WebSocket/SSE 推送（实时）
- 发布成功后推一条 “newVersion” 消息
- 在线用户秒级感知，无需轮询
- 只做版本更新有点杀鸡用牛刀了

风险与兜底（面试加分）
- 如果是**交易/编辑中**页面，不要强刷：
    - 做“温和提示”，让用户选“稍后”
    - 关键流程完成后再提示
#### 组件库升级怎么让使用这个组件的人都知道

1. 技术层面
	- TS 的 `/** @deprecated */` 标注：`@deprecated` 是 TypeScript/IDE 识别的“废弃标记”。不一定阻止编译，但IDE会给开发者明显提示。
	- **TypeScript 类型变化**：使用方编译就报错（最有效）
	- **严格执行版本号规则**：破坏性更新必须更新 major，能避免自动升级带来的问题
	- 强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要
2. 流程层
	- 发版自动生成 release notes（含 breaking/迁移步骤）
	- 自动推送到群/邮件：
	    - @到组件使用最多的 repo/负责人
3. 文档层
	- 组件站点文档展示：
	    - 最新版本
	    - 变更日志
	    - 迁移指南
	- 给出 **Before/After** 代码片段
#### 如果让你设计一个组件库项目的安全设计，应该考虑哪些方面

核心目标：  
1）让使用方**及时感知**新版本；
2）通过门禁、灰度、监控确保**安全**；
3）可快速回滚

1. 发布侧：版本与变更“可机器理解”（系统成败关键）
	统一规范：SemVer + Conventional Commits
	强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要
2. 依赖侧：版本发布后自动推送到群/邮件等方式通知依赖的业务方，必要时可以通过扫描所有业务仓库的 `package.json` + lockfile 来建立“全局依赖图”
3. 安全设计：从“编译安全”到“线上安全”的多层门禁
	A. 编译期门禁（最有效、最便宜）
	- TS 类型检查：API 不兼容直接失败
	- ESLint/规则：禁用 deprecated API（逐步收敛）
	B. 测试门禁（按成本分层），单测/快照
	C. 灰度与回滚（线上安全核心）
	- **灰度策略**（按 repo 或按用户），先让少量应用升级到新组件库版本，观测一段时间再扩大范围
	- **回滚策略**
	    - 使用方回滚：回退依赖版本（PR 自动生成 revert）
	    - 组件库回滚：回退 tag / CDN 产物（如果是 CDN）
	D. 监控与自动熔断
	- 关键指标按“组件库版本维度”聚合：
	    - JS error rate（含 chunk load error）
	    - 性能指标（LCP/INP）
	    - 业务埋点（转化、下单成功率等）
	- 超阈值触发回滚/告警