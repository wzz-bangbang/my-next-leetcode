#### 业界主流的实现思路和架构

核心：Schema（DSL） → 编辑器（搭建器） → 运行时引擎（渲染 / 执行） → 扩展机制
1. Schema / DSL 是什么？不是 JSX，不是模板，而是**纯配置化的 UI / 逻辑描述**。业界 Schema 通常覆盖 5 类：
	UI 结构：组件树、布局
	组件属性：props、样式、校验
	数据源：API、Mock、静态数据
	事件：点击、变更、提交
	逻辑：条件显隐、联动、流程
2. 编辑器本质是什么？**一个“操作 Schema 的 UI”**
	- 增删改 Schema 节点
	- 改节点属性
	- 维护组件树结构
	常见的实现方式：左中右三栏布局，物料区+画布区+属性区
	注意：画布区，编辑时!=运行时
	- 组件有「选中态 / hover / 边框」
	- 支持拖拽排序（dnd-kit / react-dnd）
	- 支持插槽高亮、占位符
	业界成熟平台画布区一定是 **双渲染器**。
	- 编辑态要**辅助交互**
	- 运行态要**极致稳定和性能**

3. 运行时引擎：低码平台的核心，目的：Schema 渲染成组件
	- 把 Schema 转成真实 UI（一棵真实的组件树）
	- 处理数据流、事件、联动逻辑，要把“页面数据”做成统一的模型
		- 数据初始化与合并（默认值、URL 参数、预加载数据）
		- 订阅与派发（哪些组件依赖哪些数据）
	- 标准化数据读取路径（`$page.xxx` / `$form.xxx` / `$ds.list.data`）
	- 动作系统：动作系统用来描述**用户交互触发的一整套行为流程**，把 schema action 编译/解释成可执行动作：提供动作执行的上下文 ctx（数据、组件引用、路由、权限、埋点）

4. 扩展机制
	自定义组件
	自定义动作
	自定义表单校验

架构：
1. 编辑器(B端)一个项目，预览/运行时一个项目（最常见、最稳）
	- **B 端**：搭建器/编辑器（画布、属性面板、物料管理、权限、发布）
	- **运行时**：预览页 + 线上最终页面（同一套 runtime 包）
	- 集成方式（iframe / 微前端 / 直挂）
	- 优点：编辑器复杂度不会污染运行时；运行时可以做极致性能/体积优化；最利于保证一致性（预览和线上共用 runtime）；**C 端可以换壳**（Next.js / 小程序 / 原生 WebView），但**runtime/渲染引擎/物料协议最好一致**，否则样式/行为一致性很难保证。**
	- 缺点：工程上需要共享物料协议、版本管理更严格
2. 全部一个项目（早期、团队小、迭代快）
	- 编辑器和预览都在一个前端项目里
	- 运行时作为一个模块被引用
	- 优点：开发简单、联调快  
	- 缺点：包会越来越大、边界容易糊、后期难维护

#### 怎么保证“预览样式”和“最终生成页面”一致？

核心原则：预览不要走“模拟渲染”，预览必须走“同一套运行时 + 同一份物料 + 同一份主题样式”。
① 预览和线上共用同一个 Runtime 渲染器（最重要）
② 物料（组件库）版本锁定：预览用哪个版本，线上就用哪个版本
③ 主题与样式体系统一：Design Token / CSS 变量化

预览和线上一致性的关键不是“截图对齐”，而是工程上保证它们**同源**：  
**同一套 runtime、同一套物料版本、同一套主题 token、同一套基础样式和数据请求链路**。  
只要把版本和环境锁住，一致性就可控。

#### 有哪些性能瓶颈和核心难点

瓶颈 1：Schema 解析 + 组件树构建过于频繁。
- 节点很多（几百到上千）； props 多、表达式多；布局复杂（表格/表单/动态容器）
- 如果每次 state 变动都从 root 重新 `render(schema)`，会导致页面频繁的重新渲染

瓶颈2：表达式求值太多：表达式系统主要解决的是**配置里的“动态值”问题**，运行时需要在数据变化时**不断对这些表达式求值**，成熟平台一般会有 **依赖追踪和表达式缓存**
- 每次 React render 都重新跑 N 个表达式
- 表达式里还读深层对象、做过滤/排序
- **解决方向**
	- 把表达式变成“计算属性”：依赖没变就不重算（memo）
	- 依赖追踪：只在依赖字段变化时更新
	- 表达式编译：字符串 → AST → 纯函数（避免重复 parse）

瓶颈 3：数据更新粒度太粗（导致大面积重渲染）
- 如果数据层是一个大 store，任何字段改动都触发全局订阅，那么：一个输入框 change → 整页组件都 rerender
- **常用方案**
	- 分片 store：按作用域拆（page/form/ds）
	- 细粒度订阅：组件只订阅自己依赖的路径
	- 类似 mobx 的 derivation，或 proxy track（读取即收集）

瓶颈 4：异步请求与联动风暴
- 例如：A 字段 change → 触发 3 个请求 → 更新 5 个组件 → 又触发表达式 → 又触发请求…
- **治理手段**
	- request 去重 / 取消（AbortController）
	- 防抖节流（输入联动必须）
	- “联动图”静态分析：避免循环依赖
	- 统一调度队列（batch updates）

#### 为什么同一套 runtime 在 C 端会成为性能瓶颈

线上 C 端确实不会频繁更新 Schema，但低码运行时真正高频变化的是数据层。  
如果数据更新是粗粒度的，就会导致大量与本次变化无关的组件和表达式被重新计算，这个问题在联动多、表达式多的低码页面里会被成倍放大。
前面讨论的那些“数据更新粒度粗导致的性能问题”，主要预设的是：  C 端是「复杂、强数据驱动」的页面。
如果只是典型的活动页（展示为主、交互简单），**大多数情况下确实不会成为核心问题**。

低码 C 端，其实分成两大类
 ① 强数据驱动型（最容易出问题）
典型特征：
- 表单多、字段联动多
- Dashboard / 报表 / BI
- 多数据源、实时/准实时刷新
- 复杂条件显示 / 计算
👉 **前面所有性能讨论，100% 针对这一类。**
② 展示/活动页型（你说的场景）
典型特征：
- 内容以静态展示为主
- 数据来源少（1–2 个接口）
- 几乎无复杂联动
- 交互偏简单（点击跳转、弹窗）
👉 **这一类页面通常不会被“数据更新粒度”卡死。**

#### 预览页面请求实际数据怎么做鉴权？

配置端：
**第一步：预览页本身先鉴权**
- 平台内预览：B端复用公司的 SSO / 登录态（Cookie / OAuth token），预览路由需要登录。
- 对外分享预览：用**一次性或短期有效的 Preview Token**，链接里带 token 或者扫码授权，且可随时撤销。
第二步：**权限模型要到“资源级 / 字段级”**
- 不是“能预览就能查所有数据”，而是按：应用/页面/组件/数据源/字段/行级规则（可选）授权。
- 对外预览通常只给“只读 + 脱敏 + 限制范围（比如只看最近7天、只看聚合结果）”。
**第三步：安全细节**
- Token 短 TTL + 绑定场景（appId/pageId）+ 可撤销
- 防重放：nonce / jti，必要时绑定 IP/UA（看业务）
- CORS、CSRF、SameSite、HTTPS 必须到位
- 全链路日志：谁在什么时候查了什么数据
#### 业界开源平台或常用方案

阿里 LowCode Engine：目前最“教科书级”的实现
运行时具体怎么做？
- Schema → React Element
- 表达式：字符串表达式 + 运行时解析
- 动作：事件 → Action Pipeline
- 强插件化：几乎所有能力都可 Hook
**优点**
- 架构清晰
- 引擎边界非常干净
**缺点**
- 表达式 / 动作偏“工程师友好”
- 对纯业务方不够傻瓜

业界主流低码平台本质都是 **Schema 驱动的运行时引擎**。  
运行时负责三件核心事情：  
**根据 Schema 渲染 UI、通过表达式系统做动态计算、通过动作系统执行用户行为。**

成功的平台一般都选择“配置优先，但允许工程师兜底”。

#### 低代码平台如何实现远程组件的动态加载?

低代码平台实现远程加载组件，一般有三个方向：

1. **按需异步加载**：将组件按功能或场景拆分成独立模块，打包成独立的 chunk，通过动态 import 或类似机制在真正使用组件时才加载。这种方式减少了初始包大小，提高加载性能。
2. **组件独立打包为远程包**：将每个大型组件打包成单独的 npm 包或远程模块，组件之间耦合度低，更新和发布可以独立处理。在运行时，通过动态加载这些包实现按需渲染，保证低代码平台的灵活性和扩展性。
3. **Webpack 模块联邦**：允许模块在运行时动态加载远程模块或微前端应用，实现模块之间的共享和独立打包。

**总结**：核心思想是 **减少初始加载体积 + 动态按需获取组件**，既能保证性能，也便于扩展和维护。

补充亮点
- **缓存策略**：远程组件通常会结合浏览器缓存或 CDN，加快再次加载速度。
- **版本管理**：低代码平台可能需要支持不同版本的组件远程加载，避免依赖冲突。典型做法：
	- 每个组件独立发布版本（npm 或私有 registry）
	- 通过版本号或 hash 动态加载，支持多版本共存
- **安全性**：远程加载的组件需要做沙箱隔离，防止组件内部执行影响全局。


