
##### 函数式编程，在项目中的应用?
强调：**函数是一等公民、尽量纯函数、不可变数据、用组合替代修改状态**。  
目标不是“写得像数学”，而是：**降低副作用，让代码更可测试、可复用、可推理**。

在前端项目中的应用（很常见）
1. **数据转换层**（最稳的 FP 落地点）
	- 接口数据 → 视图模型（mapping/formatting）
	- 用纯函数做 format / normalize
	    - 好测试、好复用、不会跟 UI 耦合
2. **状态更新**（不可变更新）
	- React/Redux/Reducer：本质偏 FP
	- reducer = 纯函数：`(state, action) => newState`
3. **表单校验/规则引擎**
	- 把校验拆成小函数组合：`required -> length -> regex -> asyncCheck`
4. **工具函数与中间件**
	- 比如请求参数处理、错误映射、埋点事件构造，都适合写成纯函数
##### 命令式编程，在项目中的应用?

强调：**一步一步告诉计算机怎么做**，通过变量赋值、循环、条件分支推进过程。  
关键词：**过程、控制流、可操作性**。

在前端项目中的应用（很多场景 FP 不如它）
1. **复杂交互流程/状态机式流程**
	- 例如：上传大文件（分片、并发、重试、暂停恢复）
	- 这类天然是“流程控制”，命令式更清晰
2. **动画/Canvas/游戏循环**
	- 每帧更新位置、速度、碰撞检测：明显是命令式
3. **DOM 操作与性能敏感路径**
	- 极致性能时，直接 for 循环比 map/reduce 更可控
4. **调度器/队列**
	- 并发控制、任务队列：典型命令式

##### 单例模式

保证**全局只有一个实例**，并提供一个全局访问点。

前端项目里典型使用
1. **全局配置/运行时配置中心**
	- `ConfigStore`：保存 apiBase、envKey、feature flags
2. **日志/埋点/监控 SDK**
	- 埋点需要统一队列、统一 sessionId、统一上报
3. **全局事件总线 / WebSocket 连接**
	- 避免每个页面/组件都建一条 ws
4. **缓存管理器**
	- 比如请求缓存、图片缓存、LRU cache

##### 工厂模式

把“创建对象/实例”的逻辑封装起来，通过参数返回不同实现。  
核心价值：**解耦“使用”与“创建细节”，便于扩展与替换**。

前端项目里典型使用
1. **请求客户端工厂**
	- 根据 env/租户/鉴权方式创建不同 client：
	    - `createApiClient({ baseUrl, authType })`
	- 甚至 mock / real 两套实现，切换很方便
2. **组件/渲染器工厂（低码/动态表单）**
	- schema → 组件实例
	- `type: "input"` → Input 组件
	- `type: "date"` → DatePicker