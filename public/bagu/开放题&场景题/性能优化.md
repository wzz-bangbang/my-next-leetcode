##### 针对框架的性能优化

react 核心：减少“不必要的渲染”和“昂贵的计算”

- `useMemo/useCallback`结合React.memo 避免重计算/避免传递函数导致子组件变化
-  useTransition 把非紧急更新降优先级（搜索/筛选）；  useDeferredValue 输入不被卡住
- `useEffect` 依赖正确，避免重复订阅/重复计算
- 慎用 Context 当全局状态：一个字段变动导致全量 consumer 更新
- 列表 key 必须稳定（避免 index）

vue 核心：减少“响应式追踪开销”和“无意义更新”

- `shallowRef/shallowReactive`：大对象只关心顶层变动
- 避免把“不会变化的大数据”做成深度响应式
- 用 `computed` 替代模板里的复杂表达式
- 少用深度 watch；必要时用精确依赖
- watchEffect 注意依赖收集范围，别把无关的也收进去

##### 代码层面的

1) 渲染/布局
	- 避免频繁触发布局：读写 DOM 分离（先读后写）
	- 动画优先用 `transform/opacity`（减少 layout）
	- 减少大阴影/滤镜（GPU/合成开销）
	- 静态资源优化比如压缩、webp等
	- 长列表考虑虚拟列表
2) 计算与数据结构
	- 重计算做缓存（memoization）、增量更新（diff）
	- 大量查找用 Map/Set 建索引
	- 避免复杂的计算（比如 嵌套循环、反复 find/filter）
	- JSON 序列化/反序列化大对象要谨慎（可移到 Worker）
3) 事件与任务调度
	- scroll/resize/input：节流/防抖
	- 大任务切片：`requestIdleCallback` / `setTimeout(0)` / scheduler
	- 非关键任务延后：首屏优先
	- 使用 Web Worker 处理 CPU 重任务（解析、压缩、hash）
4) 资源与缓存
	- 请求合并、并发控制、避免瀑布流
	- 合理缓存（HTTP cache / SWR / local cache）
	- 预加载/懒加载：图片、模块、路由
	- 合理keepalive
5) 内存与泄漏
	- 事件监听/定时器/订阅及时清理
	- DOM 引用、闭包引用大对象注意释放
	- 列表频繁增删注意 key 与复用策略

##### 工程层面

1) 构建产物体积
	- 代码分割（路由级、组件级、依赖级）
	- tree-shaking（ESM、sideEffects 配置）
	- 去掉无用 polyfill、按需引入（lodash-es、babel plugin）
	- 压缩：JS/CSS（terser/cssnano），图片压缩（webp/avif）
 2) 缓存策略（极重要）
	- 静态资源 hash + 长缓存（immutable）
	- HTML 入口短缓存/不缓存（保证版本更新）
	- CDN 加速
	- 服务端配 `Cache-Control` 合理分层