##### 1. 客户端方案（最常用）

这类方案直接在用户的浏览器中运行，优点是响应快、不消耗服务器资源。

- **HTML5 Canvas 绘图 (原生)**
    
    - **原理：** 使用 `canvas.drawImage()` 将图片、文字手动绘制到画布上，再通过 `canvas.toDataURL()` 生成 Base64 图片。
    - **缺点：** 手动计算位置非常痛苦，不适合复杂的 DOM 结构。

```
const generatePoster = async () => {
  // 1. 创建canvas
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  // 2. 设置画布尺寸
  canvas.width = 600;
  canvas.height = 800;

  try {
    // 3. 输出图片
    const dataURL = canvas.toDataURL('image/png');
    console.log('生成的海报Base64:', dataURL);
  } catch (err) {
    console.error('绘制失败', err);
  }
};
```

- **html2canvas (业界主流标准)**
    
    - **原理：** 它并不是真正的“截图”，而是通过 **JS 重新渲染**。它会读取 DOM 结构、解析 CSS 样式，然后在 `<canvas>` 上按像素重新画一遍。
    - **优点：** 使用简单，支持度高。
    - **缺点：** * **样式兼容性：** 对某些高级 CSS（如 `box-shadow`、某些 `flex` 布局、复杂的 `filter`）支持不完美。
        - **跨域：** 图片必须支持跨域，否则会报“画布被污染”错误。
        - **清晰度：** 在高分屏下容易模糊（需要设置 `scale` 参数，配合 `devicePixelRatio` 优化）。

```
import html2canvas from 'html2canvas';

const captureElement = async () => {
  const element = document.getElementById('poster-area'); // 要截图的 DOM 节点
  
  try {
    const canvas = await html2canvas(element, {
      useCORS: true,          // 允许跨域图片
    });

    // 将 canvas 转为图片下载或预览
    const imageData = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = imageData;
    link.download = 'screenshot.png';
    link.click();
  } catch (error) {
    console.error('截图失败:', error);
  }
};
```

- **dom-to-image (SVG 方案)**
    
    - **原理：** 利用 SVG 的 `<foreignObject>` 特性。它将 DOM 序列化为 XML，放入 SVG 中，再利用浏览器原生的 SVG 渲染引擎。
    - **优点：** 性能通常优于 html2canvas，生成的图片更接近真实 DOM 效果。

```
import domtoimage from 'dom-to-image';

const captureBySvg = () => {
  const node = document.getElementById('my-node');

  // 1. 调用插件的方法，把要截图的元素里的内容转成 PNG 格式的字符串 (dataUrl)
  domtoimage.toPng(node)
    .then((dataUrl) => {
      const img = new Image();
      img.src = dataUrl;
      document.body.appendChild(img); // 直接展示生成的图片
    })
    .catch((error) => {
      console.error('生成图片出错!', error);
    });
};
```
### 2. 服务端方案（高还原度）

如果需要 100% 还原页面（包含复杂动画、阴影、外部字体），或者需要批量生成图片，通常采用服务端截图。

- **Puppeteer / Playwright (Headless Browser)**
    
    - **原理：** 在 Node.js 服务端运行一个**无头浏览器**（无界面的 Chrome）。
    - **流程：** 服务端接收请求 -> 浏览器打开指定 URL -> 等待页面加载完成 -> 调用浏览器底层的 `screenshot` API -> 返回图片。
    - **优点：** **最完美还原**。页面长什么样，截出来就长什么样。
    - **缺点：** 实现相对复杂，且消耗服务器 CPU/内存资源巨大，并发量大时会有明显的延迟。

### 3. 常见痛点与解决方案

| **痛点**      | **解决方案**                                              |
| ----------- | ----------------------------------------------------- |
| **图片模糊**    | 将 Canvas 放大 `window.devicePixelRatio` 倍，再通过 CSS 缩小显示。 |
| **图片跨域**    | 后端设置 CORS，或者前端配置 `useCORS: true`。                     |
| **字体丢失**    | 客户端截图通常无法读取系统外的字体，需将字体转为 Base64 嵌入 CSS。               |
| **滚动内容截不全** | 截图前临时设置 `height: auto` 或克隆一份 DOM 放到屏幕外隐藏位置进行渲染。       |
