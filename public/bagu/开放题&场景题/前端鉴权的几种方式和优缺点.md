##### Session-Cookie 鉴权（传统主流）

这是最经典的“有状态”鉴权方式。

- **流程**：用户登录成功，服务器创建一个 **Session** 记录并存储在内存/Redis中，同时向浏览器返回一个包含 `SessionID` 的 **Cookie**。后续请求浏览器会自动带上该 Cookie。
    
- **优点**：
    
    - **安全性高**：敏感数据存在服务端，Cookie 设置 `HttpOnly` 可防 XSS。
        
    - **可控性强**：服务端可以随时销毁 Session 强制用户下线。
        
- **缺点**：
    
    - **扩展性差**：多台服务器时需要做 Session 共享（如同步到 Redis），否则负载均衡会导致登录失效。
        
    - **跨端不友好**：原生 App 或小程序对 Cookie 的支持不如浏览器。
        
    - **CSRF 风险**：因为依赖 Cookie 自动携带，容易受到 CSRF 攻击。

##### OAuth 2.0 (第三方授权)

这通常用于“第三方登录”（如微信、GitHub 登录）或分布式系统间的权限委派。

- **流程**：
    1. 用户向授权服务器申请授权。
    2. 授权服务器返回 **Code (授权码)**。
    3. 后端用 Code 换取 **Access Token**。
- **优点**：
    - **安全性**：用户不需要将密码交给第三方应用。
    - **细粒度**：可以控制只授权读取头像、不授权发动态等权限。
- **缺点**：
    - **逻辑复杂**：需要多次跳转和 Code 换 Token 的过程。

##### SSO (Single Sign-On, 单点登录)

解决“一个公司有多个子系统，登录一次即可访问所有”的需求。

- **实现方式**：
    
    - **同父域**：通过设置 Cookie 的 `Domain` 为父域名（如 `.baidu.com`），让子域共享 Cookie。
        
    - **跨域**：使用 CAS (Central Authentication Service) 模式。用户重定向到独立的 **认证中心**，登录后携带 Ticket 回跳。
        
- **优点**：提升用户体验，统一管理账号。
    
- **缺点**：认证中心一旦宕机，所有关联系统全部瘫痪（单点故障）。

#####  JWT (JSON Web Token)？

**J这是“无状态”鉴权的代表，非常适合前后端分离及分布式架构。

- **结构：** 它由三部分组成：`Header`（算法信息）、`Payload`（用户信息，如 user_id）、`Signature`（签名，防止篡改）。
- **存储：** 前端拿到后，通常不存在 Cookie 里，而是存在 `localStorage` 或 `sessionStorage` 中。
- **传递：** 发请求时，前端手动把它塞进 HTTP Header 的 `Authorization` 字段里（例如：`Authorization: Bearer <token>`）

##### 为什么 JWT 天然免疫 CSRF？

**原因很简单：CSRF 攻击靠的是浏览器的“自动带 Cookie”机制。**

- **Cookie 机制：** 它是浏览器的**原生行为**。不管你愿意不愿意，只要地址匹配，浏览器就自动帮你贴上 Cookie。黑客就是利用这种“自动”来完成攻击。
    
- **JWT 机制：** 它是**手动行为**。存在 `localStorage` 里的 JWT，浏览器绝对不会自动帮你带在 Header 里。必须由你（开发者）写代码 `headers: { 'Authorization': token }` 才能带上去。

当用户点击黑客的 `a.com` 诱导链接时，黑客的脚本无法读取你 `b.com` 域名下的 `localStorage`（受同源策略保护），且浏览器不会自动给跨站请求加上 `Authorization` 头。**既然请求里没有 Token，服务器就会直接拒绝，CSRF 攻击就此失效。**

#### JWT vs Cookie (Session) 深度对比

| **维度**      | **Cookie + Session (传统)**      | **JWT (现代)**                 |
| ----------- | ------------------------------ | ---------------------------- |
| **存储位置**    | 服务器存 Session，客户端存 Cookie       | 服务器不存（无状态），客户端存 Token        |
| **CSRF 防护** | **风险高**，需额外配合 Token 或 SameSite | **天然免疫**，因为不依赖浏览器自动行为        |
| **水平扩展**    | 较难（多台服务器需要共享 Session）          | **非常容易**（服务器只要有密钥就能解密 Token） |
| **时效性**     | 可以在服务端随时注销                     | 一旦签发，很难在有效期内提前作废             |
#### JWT 就绝对安全了吗？（新的挑战）

虽然 JWT 解决了 CSRF，但它引入了新的风险：**XSS 风险。**

- **风险点：** 如果你的页面有 XSS 漏洞，黑客可以运行 JS 代码 `localStorage.getItem('token')`。一旦 Token 被偷走，黑客可以在任何地方冒充你。
    
- **对比：** Cookie 如果设置了 `HttpOnly`，JS 是读不到的，所以 Cookie 在防范 XSS 偷取凭证方面比 JWT 强。

#### JWT进阶：双令牌机制 (Access Token + Refresh Token)

**双令牌机制**（Dual Token Mechanism）是为了解决 JWT（JSON Web Token）的一个核心矛盾：**“安全性”与“用户体验”的博弈。**

**双令牌机制的本质**：把“验证频率”和“登录频率”拆分开。

| **令牌名称**                 | **作用**                                   | **有效期**           | **存储位置建议**                       |
| ------------------------ | ---------------------------------------- | ----------------- | -------------------------------- |
| **Access Token** (访问令牌)  | 真正的“通行证”，每次请求都携带。安全性高，即使被盗也很快失效。         | **短**（如 15-30 分钟） | 内存 (Vuex/Pinia) 或 SessionStorage |
| **Refresh Token** (刷新令牌) | 专门用来换取新的 Access Token。只在刷新时才发送一次，暴露频率极低。 | **长**（如 7-14 天）   | LocalStorage 或 HttpOnly Cookie   |

工作流程（无感续期）
1. **用户登录**：服务端返回两个 Token：`accessToken` 和 `refreshToken`。
2. **正常访问**：前端将 `accessToken` 放在 Header 里请求数据，后端验证通过。
3. **令牌过期**：
    - `accessToken` 过期，后端返回 **401 Unauthorized**（或特定错误码）。
4. **无感刷新**：
    - 前端拦截到 401 错误，**不跳转登录页**。
    - 前端自动发起一个隐藏请求，携带 `refreshToken` 访问“刷新接口”。
    - 服务端验证 `refreshToken` 有效，颁发一个新的 `accessToken` 给前端。
5. **重新请求**：前端用新的 `accessToken` 重新发起刚才失败的那个业务请求。用户完全感觉不到中途发生了令牌置换。
#### 如果 refresh token 也失效了，但你这时挂起了一堆请求，刷新失败了，怎么处理

当 Refresh Token 也失效时，意味着用户必须重新登录。此时核心问题是挂起的一堆请求如何在刷新登录后重试，方案是用一个全局的 **刷新锁** 和一个 **请求队列**。

#### 工程上怎么选登录方案？

- **Session-Cookie**：最成熟，安全性高，但对分布式系统不友好，且存在 CSRF 风险。需要配合 `HttpOnly`、`Secure`、`SameSite=Lax` 以及 `CSRF Token`，全方位防护。

- **JWT**：目前最流行，它是无状态的，易于横向扩展，适合跨端，但要注意 XSS 防护以及 Token 吊销的问题。尤其 **移动端 (App / 小程序)** 首选 **JWT**。因为 App 没有浏览器的 Cookie 限制，JWT 跨域和扩展性极强。

- **OAuth 2.0**：主要用于授权，是实现第三方登录的标准。

- **SSO**：解决多系统间的统一登录问题。