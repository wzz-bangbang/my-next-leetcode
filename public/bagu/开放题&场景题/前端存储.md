#### 对比说说前端存储 localStorage，sessionStorage，IndexDB，Cookie

| 方案             | 容量（大概）            | 生命周期              | 是否随请求发送                 | 访问方式   | 性能/特征             | 典型用途           |
| -------------- | ----------------- | ----------------- | ----------------------- | ------ | ----------------- | -------------- |
| Cookie         | ~4KB/条（总量也有限）     | 可会话/可持久           | ✅ 同域请求自动带（受SameSite等影响） | 同步     | 小、开销大（会走网络）       | 登录会话、偏好（少量）    |
| localStorage   | ~5MB-10MB         | 持久（手动清/配额）        | ❌                       | 同步     | API简单但**同步阻塞主线程** | 用户偏好、简单缓存      |
| sessionStorage | ~5MB-10MB         | **Tab级会话**（关tab清） | ❌                       | 同步     | 同上，且隔离更强          | 表单草稿、一次会话状态    |
| IndexedDB      | 通常几十MB~更大（看浏览器配额） | 持久                | ❌                       | **异步** | 结构化、可索引、适合大数据     | 离线数据、大列表、缓存、队列 |

1) Cookie：它不是“存储”，更多是“协议层会话载体”
- **会随 HTTP 请求自动发送**（同域/同路径/符合 SameSite 等时）
- 容量小（4KB量级），且每次请求都带 → **增加网络开销**
- 可以设置：
    - `HttpOnly`：JS 读不到（防 XSS 窃取 cookie）
    - `Secure`：只走 HTTPS
    - `SameSite`：控制跨站携带，影响 CSRF 风险
    - `Domain/Path/Expires/Max-Age`
- 典型场景：**登录态 / session**（强烈推荐：HttpOnly + Secure + SameSite）

2) localStorage：简单、粗暴、但同步阻塞
- `key -> string`（只能存字符串）
- **同步 API**：读写大数据会卡 UI（尤其移动端）
- 同源共享：同一个 origin 下的所有 tab 共享
- 会触发 `storage` 事件（别的 tab 修改时）
- 典型场景：
	- 用户偏好（主题、语言）；
	- 小体积缓存（如最近搜索词）
	- 跨 tab 简单同步（利用 storage event）
- 不适合
	- 大对象、大数组（序列化/反序列化慢） 
	- 高频写入（每次输入都写会卡）
	- 存敏感 token（XSS 一偷一个准）

3) sessionStorage：更“短命”的 localStorage（Tab 级）
- 和 localStorage API 一样，同步阻塞 
- **每个 tab 独立**（同源但不同 tab 不共享）
- 关闭 tab 即清空（更适合临时态）
- 典型场景
	- 多步骤表单的中间状态
	- 一次会话的临时数据（比如从 A 页带到 B 页但不想持久化）
	- 防止同站不同 tab 相互污染（隔离）

4) IndexedDB：浏览器内置“本地数据库”，离线与大数据首选
- **异步**（不阻塞主线程）
- 存结构化数据：对象、数组、Blob、File
- 支持索引、范围查询、游标（cursor）
- 事务（transaction）保证一致性
- 适合大数据量、离线、复杂查询
- 典型场景
	- 离线 PWA（文章列表、消息、草稿）
	- 大量缓存（接口数据、搜索索引）
	- 上传队列（断网重试）、日志队列
	- “数百/数千项列表”的本地检索、分页

其他：
**Service Worker 内存 / 全局变量**：短期缓存（会重启，不可靠）
Cache Storage：更像“浏览器里的 HTTP 缓存可编程版”

总结：
需要随请求携带、服务端会话相关用 Cookie（HttpOnly/Secure/SameSite）；  
简单小量配置用 localStorage/sessionStorage（注意同步阻塞）；  
大量结构化数据和离线查询用 IndexedDB；  
资源和接口响应的离线缓存用 Cache Storage + Service Worker。

#### Token 到底放哪？

面试官经常想听你的“安全取舍”。
- **最稳（常见 Web 应用）**：
    - **HttpOnly Cookie**
    - 配合 `SameSite` + CSRF 防护
    - XSS 也读不到 cookie（但仍要防 XSS，因为可以发起请求）

- 不能用 cookie的架构，建议用双token：**Refresh Token+Access Token**
	- refresh token 放在 HttpOnly Cookie 里，JS 读不到，配合Secure SameSite
	- access token 只存在内存中，页面刷新即失效（攻击窗口最小），避免 XSS 直接窃取长期凭证
#### PWA (Progressive Web Apps)是什么?它的核心技术有哪些

PWA 是一种通过 Web 技术提供“接近原生 App 体验”的应用形态，核心目标是：可安装、可离线、可快速加载。

PWA想解决什么问题？
- Web：依赖网络; 首屏慢; 不能离线        
- Native：开发成本高; 发布审核慢
**PWA 试图在中间找平衡**

核心技术：通过 Service Worker 结合Manifest，把 Web 应用增强为可离线、可安装的形态，适合内容型和轻交互应用，但在系统能力上仍弱于原生。

① Service Worker（核心中的核心）
- 运行在浏览器后台线程
- 拦截网络请求
- 控制缓存策略
- 支持离线
- Service Worker **必须 HTTPS **，防中间人攻击，保证缓存可信
②Web App Manifest
- 一个 `manifest.json`
- 定义：
    - 应用名
    - 图标
    - 启动页
    - 显示模式（standalone）