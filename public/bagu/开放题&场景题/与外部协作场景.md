##### 如果要集成一个船上的摄像监控系统（第三方页面，但它不能改代码，只能iframe嵌进去，而且还要求根据用户权限控制展示内容，你会怎么处理

方案1：通过代理服务器实现内容过滤，iframe嵌套后端路径，有权限时跳转，无权限时返回一个兜底

方案2：利用 **第三方系统自身的 URL 参数** 进行控制，前提是第三方已有支持

方案3：用前端遮罩进行视觉控制，只控制是否展示，内容有泄漏风险

##### 提供给其他协作方的H5要注意什么？

把它当成“可被集成的 SDK 页面”，核心目标：**可嵌、可控、可观测、可降级**。
通用能力：参数、路由、权限、风控

- **接入参数规范**：URL 参数建议只放“非敏感、可短期失效”的东西（例如 `scene, channel, traceId`），敏感数据走一次性 code 换 token。
- **鉴权与防篡改**：可用 `签名 + 时间戳 + nonce`，避免参数被改导致越权。
- **埋点与日志**：至少要有：
    - 宿主信息（app/mini/iframe + 版本）
    - traceId（贯穿宿主→H5→后端）
    - 关键错误上报（JS error、资源加载失败、接口失败）
- **资源与缓存**：公共 H5 一般需要更稳：
    - 静态资源 hash + 长缓存
    - HTML 短缓存或不缓存，避免发布后白屏
    - Service Worker 谨慎：一旦宿主 WebView 缓存怪异，排查成本很高
- **首屏与体积**：嵌套场景用户耐心更低，尽量：
    - 关键路径代码拆分
    - skeleton/占位
    - 兜底页（加载失败可重试/反馈）
- **样式隔离**：如果是 iframe 还好；如果是同页嵌入（微前端非 iframe），要做 CSS 隔离（BEM/前缀、Shadow DOM、css-modules）。

##### 如果要写一个公共库需要考量哪些？比如模块化，打包，版本，暴露的参数方法，文档等等

把公共库当“产品”来做，核心就是：**API 稳定、兼容可靠、发布可控、可维护**。

 A. 定位与边界
- **这是工具库、组件库、还是 SDK（bridge/埋点/鉴权）？**
- 明确：
    - 负责什么、不负责什么
    - 运行环境（浏览器/Node/小程序/React/Vue）
    - 兼容范围（最低浏览器、WebView、React/Vue 版本）

 B. API 设计（最关键）
- **稳定、少而精**：先设计“最小可用 API”，避免一次性暴露一堆未来要背兼容包袱的方法。
- **输入输出要可预测**：参数默认值、错误场景、返回值结构固定。
- **异步统一 Promise**：不要一会回调一会 Promise。
- **错误处理**：明确错误类型（如 `ErrorCode`）、可观测（日志钩子、debug 开关）。
- **可扩展性**：插件机制/中间件机制（比如拦截请求、注入自定义实现）。

 C. 模块化与产物形态（面向消费者）
通常考虑这几种输出：
- **ESM**：给现代构建（tree-shaking）
- **CJS**：Node 或老构建
- **UMD/IIFE**：直接 script 引入（可选）
- **Types**：`.d.ts`（TS 项目必需）
要考虑：
- **Tree-shaking 友好**：尽量用具名导出、避免副作用（配置 `sideEffects: false` 或精确标注）。
- **跨环境依赖**：避免在顶层直接引用 `window/document`（SSR 会炸），用惰性访问。

D. 打包与依赖管理
- 打包工具：Rollup / tsup / Vite library mode（都行，关键是产物正确）。
- **external / peerDependencies**：
    - React/Vue 这类大依赖通常放 `peerDependencies`，避免打进包导致重复实例。
- **多入口**：按模块拆入口（`lib/core`, `lib/react`, `lib/vue`）降低体积。
- **Polyfill 策略**：不要默认全量 polyfill；给出兼容说明或提供“compat 构建”。

 E. 版本与发布（SemVer）
- **遵循 SemVer**：
- **发布流程自动化**：
    - changeset / conventional commits 自动生成 changelog
    - CI 跑 lint/test/build，tag 后发布
- **废弃策略**：API 要下线必须先 `deprecate`，给迁移期和替代方案。

G. 文档与可用性
- **README 不够**：至少要有：
    - 快速开始（3 分钟跑通）
    - API 文档（参数、返回、错误码）
    - 示例（常见场景）
    - 迁移指南（版本升级）
- **示例项目 / playground**：真实接入更能暴露问题。
- **变更日志**：每次发布要能让使用方快速判断“要不要升级”。

H. 兼容与运行时保护
- **feature detect** + fallback
- 防御式编程：参数校验、空值处理、重复调用幂等
- **避免全局污染**：尤其 UMD/IIFE，命名空间固定、可配置。


##### 如何平衡暴露出的参数或者api的数量和复杂度？

平衡“暴露多少 API/参数”和“复杂度”本质上是：**把变化隔离在库内部，把稳定点暴露给外部**。

 1）先定“用户路径”，只为路径设计 API
不要从“能力清单”出发（会越做越多），而是从**Top 3 接入场景**出发：
- 80% 使用方只需要 1～2 步就能跑通（默认配置足够好）    
- 只有少数高级场景才需要扩展点
落地：先做主干 API，其余能力走扩展。

 2）用“分层 API”控制复杂度：基础层稳定，高级层可选
推荐三层：
	**L1：默认开箱即用（最少参数）**
	**L2：可配置但有限（参数有边界）**（参数数量控制在“人能读懂”的范围，比如 5～10 个以内）
	**L3：扩展点（不把所有开关都做成参数）**，而是通过插件/中间件/回调钩子，复杂能力通过“注入实现”而不是“堆参数”。

 3）优先“聚合参数”而不是“散装开关”，当参数开始变多（>10）通常就该收敛：
- 对一组相关参数打包
- 用 `preset` 提供预设方案
好处：**外部认知负担低**，内部还能不断演进。

4）避免“布尔参数爆炸”，改成枚举/配置对象
布尔开关特别容易无限增长，更好的方式是使用枚举或配置对象

5）保持 API “可组合”，避免“万能函数”
不要做一个 `request(url, {…几十个参数})` 试图覆盖全部场景。
更好的思路：
- 主函数只做核心能力
- 辅助能力通过组合实现：

6）用“数据驱动”决定是否暴露参数
每增加一个参数，都要回答：
- 这个需求出现频率高吗（>=20% 用户）？
- 没这个参数能不能通过扩展点解决？
- 这个参数未来会不会变（变就别暴露，做策略/插件）
- 文档能不能用一句话说明白？说不清就说明太复杂
**规则**：能内部推导的不要暴露；能通过注入实现的不要暴露成参数。

我会用 **“默认好用 + 分层暴露 + 扩展点替代堆参数”** 来控制 API 数量：  
**高频需求做成主干 API + 少量配置，低频和变化大的需求走插件/注入，不轻易增加布尔开关**。并通过 preset、策略对象、escape hatch 保证既简单又不失去扩展性。
