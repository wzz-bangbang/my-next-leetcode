#### 大文件上传

大文件上传核心是 4 件事：**分片、断点续传、并发控制、秒传/校验**，再加上**服务端合并与校验**。
1. 分片上传（Chunk Upload）
	- 前端把文件切片：`Blob.slice(start,end)`
	- 每片带上：`fileId/hash + chunkIndex + chunkSize + totalChunks`
	- 服务端每片落盘（或对象存储 multipart upload），记录已上传分片。
	- **好处：**
		- 网络抖动只重传少量片
		- 可并发提升吞吐
2. 断点续传
	- 上传前先请求服务端：`GET /upload/status?fileId=xxx`
	- 服务端返回已存在的 chunkIndex 列表
	- 前端跳过已传分片，只补缺口
 3. 秒传（去重）
	- 计算文件 hash（通常用 spark-md5 / wasm）：
	    - 大文件不要一次性读入内存，**分片增量算 hash**
	- 先问服务端：`POST /upload/exists {hash}`
	- 服务端如果已存在，直接返回文件 URL / fileKey，前端秒完成
4. 并发与重试（非常容易被问）
	- 并发通常 3~6（看带宽与服务端限制）
	- 失败分片指数退避重试
	- 支持暂停/继续（中断 fetch / XHR，保存状态）
5. 服务端合并与校验（很多人只讲前端）
	- 合并顺序：按 chunkIndex 串行写入
	- 合并完必须校验：
	    - 合并后的 hash 与客户端 hash 一致
	- 合并后清理临时分片
6. 进度条怎么做（加分）
	- 分片上传进度 = 已完成分片数 / total
	- 更精细：每片用 XHR `upload.onprogress` 汇总（fetch 不好拿上传进度）
#### 长列表渲染

长列表性能瓶颈是：**DOM 数量、布局/重排、重绘、JS 计算与事件处理**。解决就是：**虚拟列表 + 稳定高度 + 渐进渲染**。
1. 虚拟列表（Virtualization）只渲染可视区 + buffer：
	- React：react-window / react-virtualized
	- Vue：vue-virtual-scroller
	- 原理：容器撑起总高度；只渲染 start~end 的 items；用 translateY 定位
2. 高度不固定怎么办？两种策略：
	- **估算高度 + 动态修正**（测量后更新偏移）
	- **分组/锚点**（按块维护前缀和，降低重算成本）
3. 交互与更新优化
	- item 组件 `memo` / `PureComponent`
	- key 必须稳定（不要用 index）
	- 滚动事件节流，避免每帧 setState
	- 减少复杂样式（阴影、滤镜）和图片布局抖动
4. 进一步优化（加分）
	- **窗口化 + 分页/增量加载**（infinite scroll）
	- 首屏优先：先渲染前 N 个，后面 idle time 再补
	- 大量图片：懒加载 + 低清占位（LQIP）
#### 如果你有一个含有数百个项目的数组，你将如何有效地搜索特定项目?

1. 一次性查找 / 查得不频繁
- 直接 `Array.find` / `for` 即可：O(n)
- “数百”其实很小，过度优化反而复杂
**面试口径：** 如果只是偶尔查找，线性扫描就够了，代码简单且可维护。

2. 频繁查询（比如输入框实时搜索）

做索引：
 ① 按 id 精确查：Map
 ② 按字段检索：倒排索引（关键词→id 列表）
- 适用于 tags / 多关键字匹配
 ③ 前缀搜索：Trie（前缀树）：适用于“搜用户昵称/商品名”这种前缀匹配
 ④ 模糊搜索：第三方库比如 fuse.js（加分）：小数据量直接 fuse.js，非常工程化
#### 如果现在一个页面要同时展示 300 辆车的实时位置+轨迹，你怎么来优化

数据层面+渲染层面

数据：后续更新只传输增量变化的字段

渲染：分区绘制/懒加载；WebGL/Canvas 渲染；前端聚合（在地图缩放级别较低时，将前端可见的密集点聚合成一个集群图标）；动画优化GPU加速和requestAnimationFrame

**最佳实践组合：** 在后端实现 **视窗过滤** 和 **轨迹简化**，并使用 **WebSocket** 推送增量位置数据。在前端，使用 **WebGL 地图库** (如 Mapbox GL JS) 进行高性能渲染。


#### js写倒计时组件代码，长时间怎么解决误差，如果页面需要大量倒计时组件，怎么优化？

1. 误差：
- 不要用自减计数，因为 `setInterval` 会漂移（后台 tab、主线程忙、定时器 clamp）。正确思路：基于“目标时间戳”计算差值，这样即使定时器延迟 5 秒，下一次也会立刻校正。
	- 记录 `endAt = Date.now() + duration`
	- 每次 tick 用 `endAt - Date.now()` 计算剩余
	- UI 显示取 `Math.max(0, diff)`，再格式化
- 不复杂的情况，可以减小 setInterval 的时间间隔，通过高频检查降低误差
- 用 `performance.now()` 做相对计时更稳定（但跨刷新要落到 Date.now）
- 服务端时间：如果要求对齐服务器（如抢购），做一次 `serverTimeOffset = serverNow - clientNow`
- 用requestAnimationFrame实现setTimeout，参数timestamp用来计算时间

2. 大量倒计时
	核心原则：**不要 N 个组件各自 setInterval**。  
	要做**单一时钟源 + 批量订阅 + 按需渲染**。
	
	1：全局单例 ticker（推荐）
	- 页面只有一个 timer（比如 250ms 或 1000ms）
	- 所有倒计时订阅它
	- 每次 tick 统一计算并分发
	好处：
	- 定时器数量从 N → 1
	- 主线程压力大幅下降
	
	2：按可见区域更新
	- 列表里的倒计时：配合虚拟列表，只更新可见项
	- 或 IntersectionObserver：不可见的倒计时暂停更新
	
	3：降低刷新频率
	- UI 只显示“秒”，就没必要 250ms 更新，1s 足够
	- Tab 不可见时（`visibilitychange`）降频到 5s 或暂停
	
	4：减少 React/Vue 重渲染（框架场景）
	- 倒计时变化频繁，避免触发整行 item 重渲染：
	    - 把倒计时显示拆成最小组件
	    - memo / computed 缓存
	    - 只更新 text node（极端优化）
