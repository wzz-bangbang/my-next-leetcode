#### 说说常用的chrome调试工具，具体怎么用 

常用的 DevTools 主要有：Elements / Console / Sources / Network / Performance / Application /Memory

**Elements（查样式、定位布局问题）**
- **选元素**
- **查样式覆盖链路**：Styles 里看哪条规则生效/被划线，点规则跳到来源文件。
- **强制状态**：`:hov` 强制 hover/active/focus，复现交互样式问题。
- **改 DOM/样式做验证**：临时改 class/style 验证方案可行，再回代码修复。

**Console（看日志、现场验证表达式）**
- **过滤日志**：按 level/关键字过滤，快速找到报错链路。
- **抓 DOM**：`$0` 代表当前选中元素，`$()`/`$$()` 快速 query。
- **监控事件**：`monitorEvents(node, 'click')` 临时监控事件触发（排查重复绑定/冒泡问题）。

**Sources（断点、单步、定位是谁改了数据）**
- **Source map**：确保线上/本地 sourcemap 正常，能从 bundle 映射回源码。
- **断点**：行断点、条件断点（例如 `id === xxx` 才停）、`logpoint`（不改代码直接打印）。
- **异步栈**：开启 async stack traces，排查 Promise/async 调用链。 
- **XHR/Fetch 断点**：对某个接口 URL 设置断点，接口一发就停，查是谁触发的请求。
- **Event Listener Breakpoints**：勾选 `click`/`keydown` 等，事件一触发就停，查是谁绑的、为什么触发多次。

**Network（接口、缓存、跨域、性能）**
- **保留日志 & 禁用缓存**：勾 `Preserve log`（避免跳转丢请求），开发排查勾 `Disable cache`。
- **看请求构成**：Headers/Query/Payload/Response，重点：请求头、cookie、CORS、返回码。
- **看耗时**：Timing 里 DNS/TCP/TTFB/Content download，判断是后端慢还是前端阻塞。
- **模拟弱网和低端机**
- **缓存策略**：看 `from memory cache / from disk cache`、`cache-control/etag`，排查“明明改了但没生效”。

**Performance（卡顿、长任务、掉帧）**
- **录制一次操作**：录制→做一次交互→停止，找 Main 线程长任务（Long Task）和 layout/recalc style。
- **看火焰图**：确认时间花在哪：脚本执行、布局、绘制、合成。
- **定位 React/Vue 渲染问题**：配合框架 DevTools（React Profiler / Vue devtools）一起看 commit、重复渲染、组件耗时。

**Application（存储、SW、PWA、缓存）**
- **Storage**：LocalStorage/SessionStorage/IndexedDB/Cookies，排查登录态、缓存数据是否污染。
- **Clear site data**：一键清站点数据，快速验证“是不是缓存导致的问题”。

**Memory（内存泄漏/频繁 GC）**
- **Heap snapshot**：对比快照，找 detached DOM、事件监听未解绑。

 面试里可以补一句“排查路径”：**Network 定位请求→Console 看报错→Sources 断点定位逻辑→Elements 验证 DOM/CSS→Performance 看卡顿→Application/Memory 查缓存/泄漏**。

#### 平时开发中怎么进行自测？写不写单测

开发中自测一般分三层：**功能正确性、边界与异常、线上一致性**，尽量用“可复现步骤 + 可观测指标”把问题提前暴露。

**功能正确性**
- 按需求 checklist 逐条走：主流程、关键交互、表单校验、空态/加载态/错误态。
- 控制台无报错、埋点/日志关键字段符合预期（比如上报参数、跳转参数）。

**边界与异常**
- 弱网/超时/500/重试：Network 里模拟慢网，或用 mock 返回不同 code，确保 UI 有兜底。
- 极端数据：空数组、超长文本、超大列表、特殊字符、时间/时区问题。
- 权限与登录态：cookie 失效、无权限、token 刷新等。

**线上一致性**
- 对齐环境配置：域名、灰度开关、feature flag、缓存策略（disable cache 复现）。
- 多端验证：至少 Chrome + Safari（Mac），移动端用真机/模拟器看触控和字体渲染。

**关于单测：写，但看模块类型**
- **会写单测**，但不追求“为写而写”。我通常把单测优先放在：
    1. **纯函数/工具函数**（格式化、计算、解析）
    2. **复杂业务规则**（价格/权限/状态机）
    3. **容易回归的公共组件**（表单组件、表格组件）
- UI 强依赖样式、频繁变动的页面，可能更多用 **集成测试/E2E** 或 Storybook 回归，而不是堆大量脆弱的快照。

#### 怎么看待前端单测？了解哪些库

**怎么看待**
- 单测的价值主要是：**防回归、提升重构信心、降低联调成本**。特别是多人协作和组件库/平台型项目，收益很明显。
- 但单测也有成本：**写/维护时间、测试脆弱性（尤其是实现细节驱动的测试）**。所以我倾向于：
    - **测行为，不测实现**（不强依赖内部 state/私有方法）
    - 优先覆盖 **稳定的业务规则** 和 **高风险模块**
    - 控制投入产出：关键路径 + 易错边界 > 追求 100% 覆盖率

**了解/使用的库（按场景）**
- **测试框架/运行器**：Jest、Vitest（Vite 项目更顺手，速度快）
- **断言库**：Jest expect、Chai（不一定单独用）
- **组件测试**：
    - React：React Testing Library（RTL）+ user-event（更贴近用户行为）
    - Vue：Vue Test Utils + Testing Library/Vitest
    - Enzyme（了解，偏旧，更多测实现细节）
- **E2E**：Cypress、Playwright（Playwright 多浏览器更强，适合关键链路回归）
- **Mock**：
    - MSW（拦截 fetch/xhr，做“更接近真实网络”的 mock）
    - nock（Node 环境接口 mock，了解即可）
- **覆盖率**：istanbul（Jest/Vitest 集成）
- **补充**：Storybook + interaction test / visual regression（了解，有条件时用于组件回归）