#### CI/CD流程

持续集成 (CI)：快速、自动化地验证代码质量。包括
代码质量检查lint：代码 提交前的lint校验，保证代码质量、风格一致
git hook触发流程：开发者提交代码到远程仓库；git Webhook 监听到代码变动触发流水线。
build构建：执行 `npm install` 和 `npm run build`，产出 `dist` 文件。

持续交付 (CD)：确保代码随时可以自动化地部署到生产环境。包括
发布：将 `dist` 内容推送到服务器或 OSS
流量切换：多服务器时部署后的合理切换策略，比如蓝绿等
回滚：必要时能快速回滚到指定版本

**核心意义**：减少人为操作失误（比如忘了跑 build 就上线），确保上线过程可追溯、可回滚。

#### 前端工程化的理解，如何自动化，成熟的体系应该具备哪些要素

前端工程化的本质是——让前端开发从“手工活”变成“可规模化、可度量、可迭代的生产体系”，核心目标是：提效、稳定、可控。

自动化质量控制 lint prettier git规范等

自动化构建，自动化发布，保证性能、产物可控、灰度发布、流量分配、自动回滚

监控报警

前端工程化的核心是标准化 + 自动化 + 流程化 + 度量化。  
成熟体系应该覆盖整个研发生命周期：从代码规范、项目结构、组件库沉淀、构建优化，到测试、CI/CD、灰度发布、监控报警。  
最终目标是：让开发提效、质量可控、上线可回滚、运行可监控。

#### nginx配置

Nginx 主要用于作为**反向代理**、**静态资源服务器**和**负载均衡器**。

前端常用：配置SPA 、静态资源路径、反向代理解决跨域、缓存配置、Gzip 压缩等

核心配置项：

```
server {
    listen 80;
    server_name example.com;

    # 1. 静态资源托管
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html; # 关键：解决 Vue/React Router 刷新 404 问题
    }

    # 2. 反向代理（解决跨域）
    location /api/ {
        proxy_pass http://api.backend.com/; # 转发到真实后端
    }

    # 3. 开启 Gzip 压缩
    gzip on;
    gzip_types text/plain application/javascript text/css;
}
```
#### cdn配置

将静态资源分发到全球边缘节点，使用户可以从最近的节点获取资源，加速访问

- **前端配合:** 构建工具（Webpack/Vite）需要配置 **`publicPath`** 为 CDN 域名地址。

- **CDN 关键配置:**
  
  - **回源策略:** 配置 CDN 节点在缓存未命中时，回源到 Nginx 或 OSS。
  
  - **缓存规则:** 区分可缓存（如带 Content Hash 的 JS/CSS）和不可缓存（如 `index.html`）。通常对带 Hash 的资源设置长缓存（如 1 年），对 `index.html` 设置短缓存（如 5 分钟）或不缓存。
  
  - **预热/刷新:** 部署后对新的资源文件进行预热，对旧的资源路径进行缓存刷新。

#### oss 是什么？有什么作用和优势

- 高可靠、高并发、低成本的静态文件存储服务（如 AWS S3, 阿里云 OSS）。

- **前端应用:** 通常将前端构建产物直接上传到 OSS 存储桶中，然后通过 CDN 绑定该存储桶的域名进行加速访问。

- **优势:** 免维护服务器、高可用性。

和cdn对比：
OSS (Object Storage Service - 对象存储)
- **作用**：像一个海量的硬盘，专门存静态文件（图片、JS、CSS、视频）。
- **优势**：高可靠（文件不丢）、按量付费（省钱）、不占用服务器磁盘。

CDN (Content Delivery Network - 内容分发网络)
- **作用**：像连锁店。在全国各地放服务器，缓存 OSS 里的内容。
- **优势**：**就近访问**。你在北京访问，CDN 就从北京节点给你发货，速度极快。

| **维度** | **OSS**            | **CDN**                 |
| ------ | ------------------ | ----------------------- |
| **本质** | **仓库**（存东西的地方）     | **快递**（送东西的地方）          |
| **位置** | 固定的中心机房            | 分布在全国各地的边缘节点            |
| **配合** | 前端产物 `dist` 传给 OSS | 域名指向 CDN，CDN 回源 OSS 拿数据 |
#### OSS 怎么配合 CDN 做缓存刷新的主流方案

文件哈希 + 强缓存：这是目前不需要手动频繁刷新 CDN 的最稳妥方案：

- **静态资源 (JS/CSS/Image)**：文件名带上 Hash（如 `main.a1b2c3.js`）。设置 CDN 为**强缓存**（Cache-Control: max-age=31536000）。
    - _原理_：文件名变了，CDN 没见过这个文件，会自动回源 OSS 拿新的。

- **入口文件 (index.html)**：文件名不变。设置 CDN 为**协商缓存**（Cache-Control: no-cache）。
    - _原理_：每次访问 index.html，CDN 都会回源头对比一下。如果 index.html 更新了，它就下发新的，从而引导浏览器去加载新的 Hash 资源。



#### npm install后发生了什么

- **检查本地缓存:** 检查 `node_modules` 是否存在，以及 `lock` 文件是否与 `package.json` 匹配。

- **下载依赖:**
  
  - **npm/Yarn:** 访问 npm Registry，根据 `lock` 文件中记录的 URL/Hash/Version 下载依赖包，并存入全局缓存。
  
  - **pnpm:** 检查本地内容寻址存储中是否已存在该版本的包。如果存在，跳过下载。

- **构建依赖树:**
  
  - **npm/Yarn:** 根据下载的包创建**扁平化**的依赖树结构，解决依赖冲突（如果能解决）。
  
  - **pnpm:** 根据 `lock` 文件创建**严格的非扁平化**依赖树，使用**硬链接和符号链接**连接到全局存储的包。

- **执行生命周期脚本:** 运行依赖包中定义的 `install`、`postinstall` 等脚本（例如 `node-sass` 或 `Puppeteer` 的编译步骤）。

- **生成/更新 Lock 文件:** 如果 `package.json` 有变化，更新 `package-lock.json` 或 `pnpm-lock.yaml`，确保团队构建环境的一致性。

#### npm 为什么要做依赖提升？会带来什么问题？

- **减少重复依赖**：多个包共用同一版本 → 顶层放一份
- **缩短 node_modules 路径**：避免嵌套过深（历史上还会触发 Windows 路径长度问题）
- **更快的 Node 解析/更少磁盘占用**（间接收益）

带来的问题：
问题 1：幽灵依赖（phantom dependency）
某个包 **没有声明**依赖 A，但因为 A 被 hoist 到顶层，它居然也能 `require('A')` 成功。  
一旦安装结构变化（或换包管理器），就炸。
问题 2：依赖解析不一致 / 隐式耦合
不同安装顺序、不同 lock、不同平台，hoist 结果可能不完全一致（现代工具好很多，但仍是风险点）。  
导致“本地没问题，CI/线上有问题”。

#### npm vs yarn vs pnpm

- **npm / Yarn classic（v1）**：传统 node_modules 布局，**会 hoist**，容易出现幽灵依赖。
    
- **Yarn Berry（v2+）**：默认 **PnP**（不一定生成 node_modules），依赖解析更严格（但生态兼容要配）。
    
- **pnpm**：使用 **全局内容寻址 store**，项目里通过链接组织依赖，默认更严格、磁盘更省，，且安装快速，也能显著减少幽灵依赖。

#### 模块化发展历程(AMD/CMD/UMD/ES6)

**CommonJS (CJS)** 同步加载，`require()` 和 `module.exports`。用在node环境

**AMD 异步**加载，适合浏览器，如 RequireJS。**依赖前置**，模块定义时所有依赖就绪并加载（预先加载）。

**CMD**异步加载，推崇就近依赖。模块代码执行到 `require` 时才加载（按需加载）。

**UMD**通用模式，兼容 CJS、AMD 和全局变量，用于库的发布。是**打包规范**，用于让一个模块或库同时兼容多种加载环境。

**ES Module (ESM)** 静态加载、`import` / `export`，支持 Tree Shaking 和 `import()` 动态加载。

AMD CMD UMD 它们都需要引入各自的模块加载器库，因为浏览器不原生支持这些规范。

Webpack（以及其他现代构建工具，如 Rollup, Parcel, Vite）在编译时处理了 CJS 的引用和依赖关系，并消除了对原生 CJS 运行时环境的需求

本题核心：
模块化最早是 CommonJS，用于 Node.js，采用同步加载，不适合浏览器。
随着浏览器端需求出现，AMD 和 CMD 提供了异步加载方案，分别采用依赖前置和依赖就近的方式。  
UMD 本质上是一种兼容写法，用于同时适配多种模块规范。  
ES Module 是语言层面的标准，支持静态依赖分析和 Tree Shaking，是现代前端构建工具和浏览器的基础模块方案。

补充：JavaScript 模块化机制中最核心、最稳定的特性：**模块单例（Module Singleton）**。对于所有现代 JavaScript 模块规范（CJS, AMD, **ESM**），无论是同步导入还是动态导入，一旦一个模块被加载并执行，它的结果就会被**缓存**起来。


#### 浏览器对模块脚本的加载和执行，具体什么过程和规则？

模块方式加载是浏览器先解析 import 构建依赖图，再按依赖顺序加载和执行，每个模块有独立作用域且只执行一次，这让代码更安全、可维护，也更适合大型工程。

核心：`<script type="module" src="...">`
过程：
- 浏览器在执行前
- **先构建模块依赖图**
- 再按依赖顺序加载所有模块
- 和 `require` 的“运行时加载”不同。

模块脚本的加载特性
- 默认 **defer 行为**（不阻塞 HTML，DOM 解析完成后执行，多个 module 按依赖顺序执行）
- 模块作用域（不挂到 `window`，每个模块有独立作用域，避免全局污染）
- 自动开启严格模式
- 支持依赖的 **按需加载**

缓存：
- 每个模块只导入一次，后续 import 直接复用结果

#### 前端模块化方案有哪些？在工程中你是如何选择的？

现在业务应用开发基本统一用 ES Module，因为它支持静态分析、tree-shaking 和动态 import，配合构建工具体验最好。

真正需要做选择的通常是做“库”的时候：为了兼容不同消费方，我会在构建产物上同时输出 ESM 和 CJS；如果要支持直接 script 引入，则额外输出 UMD/IIFE。服务端项目则根据 Node 版本和生态选择 CJS 或 ESM。

#### 动态 `import()`

这是前端性能优化重要方式，也就是所谓的**路由懒加载**。
用法：返回一个 Promise 对象。可以用.then或者async await

- **作用：** 只有当代码真正运行到这一行时，才去服务器下载对应的 JS 模块。

- **原理（Webpack 实现）：**
    1. **代码分割 (Code Splitting)**：构建工具识别到 `import()`，会将该模块打包成一个独立的子包（Chunk）。
    2. **JSONP 加载**：运行到该行时，浏览器动态插入一个 `<script>` 标签指向子包地址。
    3. **异步执行**：脚本加载完成后，Promise 状态变为 `resolved`，执行后续逻辑。

- **优势：**
    1. **减小首屏体积**：不用一次性下载几 MB 的代码。 
    2. **按需加载**：用户不点击的功能永远不下载，省流量。

#### 前端微服务架构实践

**核心目标:** 将一个庞大的前端应用拆分为多个独立开发、独立部署、独立运行的小应用。

- **Module Federation (推荐):** Webpack 5 联邦模块功能，实现运行时模块共享和依赖去重。

- **Single-SPA/Qiankun (基于框架):** 通过路由劫持和沙箱机制，实现应用级的集成。

- **Web Components/Iframe (隔离):** 通过浏览器原生技术实现 UI 隔离。 

#### Monorepo 项目管理

**定义:** 将多个项目（Package）的代码存储在一个 Git 仓库中。最终的构建（Build）和部署（Deploy）仍然是**按需、独立**进行的。

**常用工具:** Lerna, Nx, Turborepo, Yarn/pnpm Workspace。

**优势:**
  - **代码共享:** 易于在不同项目间共享代码和配置。
  - **原子提交:** 一个 Commit 可以涉及多个项目，尤其对于公共代码修改，提交历史清晰。
  - **统一依赖:** 容易实现跨项目依赖一致性。
  - 本地开发体验更好：不用反复 `npm link` / 发测试包

 **挑战:** 
 仓库体积大，工具配置复杂，权限控制难度增加。
 项目间依赖关系复杂，需要工具辅助管理
 如果缺乏变更感知机制，构建和 CI 成本会急剧上升

实现：
- CI：**Monorepo 工具的集成 (Nx/Turborepo):** 这些工具可以智能地判断**哪些项目**受到了代码变动的影响。例如，在 CI 中运行 `npx nx affected:build`，只构建那些代码或其依赖发生变化的子项目。
- 通常会有一个位于 Monorepo 根目录下的**主 CI 配置文件**，它负责调用 Monorepo 工具，并确定哪个子项目的部署流程需要被触发。
- **部署脚本：** 具体的部署逻辑（例如如何将文件上传到 S3 或如何调用 K8s 部署 API）通常会封装成每个项目内部的独立脚本，或由主 CI 配置文件通过参数动态调用。

#### 包管理和版本控制策略

- **版本锁定:** 强制使用 `package-lock.json` 或 `pnpm-lock.yaml` 锁定依赖版本，确保不同环境下的依赖一致性。

- **包管理:** 使用 **pnpm Workspace**（基于 Monorepo 的包管理）来实现依赖共享和节省空间。

模块的单例行为与 React Hooks 或 Vue Composition API 中的 `composable`（组合式函数）的行为，构成了前端状态管理和逻辑复用的两种截然不同的模式。

模块：共享的应用级状态

Hooks / Composable：隔离的组件级状态

#### 说说前端代码规范 lint prettier，你怎么看？工作中怎么用？

前端代码规范主要通过 **Lint（如 ESLint）** 和 **格式化工具（如 Prettier）** 来统一代码质量和风格。

- **Lint**：偏向**代码质量和潜在错误检查**，结合框架规范进行逻辑校验，预防潜在性能或 Bug 风险
- **Prettier**：偏向**代码格式统一**，统一缩进、换行、分号、引号等

作用：
- 避免低级错误（未使用变量、错误依赖、危险写法）
- 保证多人协作时代码风格一致
- 减少 Code Review 在“格式问题”上的时间浪费
- **让规范“自动化”，而不是靠人记**

实际工程中的使用：
- **项目初始化**
    - ESLint + Prettier + 对应框架插件
    - ESLint 关闭和 Prettier 冲突的规则
- **开发阶段**
    - 编辑器保存自动格式化
    - Lint 实时提示问题
- **提交阶段**
    - husky + lint-staged
    - 提交前只检查本次变更
- **CI 阶段**
    - Lint 作为质量门禁，避免不合规代码进主分支

总结：Lint 保证代码质量，Prettier 保证风格统一，规范的核心目标是降低协作成本，而不是限制个人习惯。规范不是越严越好，而是**在可读性、效率和团队接受度之间取平衡**。
#### 工作中git 怎么用？pull和pull --rebase的区别

Git 是分布式版本控制工具，用来做 **版本管理、协作和回溯问题**。
日常高频命令：
- `clone / add / commit`
- `branch / checkout / merge`
- `pull / push`
- `rebase / reset / cherry-pick`

pull和pull --rebase的区别：
`git pull` 本质是：`git pull = git fetch + git merge`
- 会生成一次 **merge commit**
- 历史是**非线性的**
 `git pull --rebase` 是：`git pull --rebase = git fetch + git rebase`
- 把**本地提交挪到最新远程提交之后**
- 不产生 merge commit
- 历史更线性、干净
实际使用：
- **个人功能分支**：`pull --rebase`
- **公共分支（main / develop）**：`merge`
- **已经 push 的公共提交**：不随意 rebase

#### 说说SemVer规则，^ 和 ~ 有什么区别？还有什么其他常用方案？

1. `^`**兼容升级**，**允许升级到“同一 major 版本”的最新 minor/patch** （特殊的`^0.x.y` **很保守**，等同于~）
2. `~`更保守，只允许 PATCH 升级
3. 固定版本 `1.2.3`，不会自动升级
4. `*`（完全放开，**强烈不推荐**）
5. `>=` / `<=` / `>` / `<`（范围约束）
6. 预发布版本（alpha / beta / rc），比如`1.2.0-beta.3`
	1. npm 在解析依赖时，默认不会自动升级到 `alpha / beta / rc` 版本
	2. **显式指定**预发布版本时，即使用^，比如`^1.2.0-beta.3`，npm **允许升级**， 但**只在同一条预发布线内**，也就是会升级到`1.2.0-beta.4` 不会到`1.3.0`