#### CI/CD流程

持续集成 (CI)：快速、自动化地验证代码质量。包括代码质量检查lint，git hook触发流程 , build构建

持续交付 (CD)：确保代码随时可以自动化地部署到生产环境。包括发布，流量切换，回滚等

#### nginx配置

Nginx 主要用于作为**反向代理**、**静态资源服务器**和**负载均衡器**。

前端常用：配置SPA 、静态资源路径、反向代理解决跨域、缓存配置、Gzip 压缩等

#### cdn配置

将静态资源分发到全球边缘节点，使用户可以从最近的节点获取资源，加速访问

- **前端配合:** 构建工具（Webpack/Vite）需要配置 **`publicPath`** 为 CDN 域名地址。

- **CDN 关键配置:**
  
  - **回源策略:** 配置 CDN 节点在缓存未命中时，回源到 Nginx 或 OSS。
  
  - **缓存规则:** 区分可缓存（如带 Content Hash 的 JS/CSS）和不可缓存（如 `index.html`）。通常对带 Hash 的资源设置长缓存（如 1 年），对 `index.html` 设置短缓存（如 5 分钟）或不缓存。
  
  - **预热/刷新:** 部署后对新的资源文件进行预热，对旧的资源路径进行缓存刷新。

#### oss

- **作用:** 高可靠、高并发、低成本的静态文件存储服务（如 AWS S3, 阿里云 OSS）。

- **前端应用:** 通常将前端构建产物直接上传到 OSS 存储桶中，然后通过 CDN 绑定该存储桶的域名进行加速访问。

- **优势:** 免维护服务器、高可用性。

#### npm pnpm

pnpm：下载包全局存储，然后硬链接到项目目录。所以避免一台机器上重复下载和拷贝，节约磁盘空间，且安装快速

严格的非扁平化依赖树，**避免幽灵依赖**。只允许访问声明的依赖，提高稳定性。

#### npm install后发生了什么

- **检查本地缓存:** 检查 `node_modules` 是否存在，以及 `lock` 文件是否与 `package.json` 匹配。

- **下载依赖:**
  
  - **npm/Yarn:** 访问 npm Registry，根据 `lock` 文件中记录的 URL/Hash/Version 下载依赖包，并存入全局缓存。
  
  - **pnpm:** 检查本地内容寻址存储中是否已存在该版本的包。如果存在，跳过下载。

- **构建依赖树:**
  
  - **npm/Yarn:** 根据下载的包创建**扁平化**的依赖树结构，解决依赖冲突（如果能解决）。
  
  - **pnpm:** 根据 `lock` 文件创建**严格的非扁平化**依赖树，使用**硬链接和符号链接**连接到全局存储的包。

- **执行生命周期脚本:** 运行依赖包中定义的 `install`、`postinstall` 等脚本（例如 `node-sass` 或 `Puppeteer` 的编译步骤）。

- **生成/更新 Lock 文件:** 如果 `package.json` 有变化，更新 `package-lock.json` 或 `pnpm-lock.yaml`，确保团队构建环境的一致性。

#### 模块化发展历程(AMD/CMD/UMD/ES6)

**CommonJS (CJS)** 同步加载，`require()` 和 `module.exports`。用在node环境

**AMD 异步**加载，适合浏览器，如 RequireJS。**依赖前置**，模块定义时所有依赖就绪并加载（预先加载）。

**CMD**异步加载，推崇就近依赖。模块代码执行到 `require` 时才加载（按需加载）。

**UMD**通用模式，兼容 CJS、AMD 和全局变量，用于库的发布。是**打包规范**，用于让一个模块或库同时兼容多种加载环境。

**ES Module (ESM)** 静态加载、`import` / `export`，支持 Tree Shaking 和 `import()` 动态加载。

AMD CMD UMD 它们都需要引入各自的模块加载器库，因为浏览器不原生支持这些规范。

Webpack（以及其他现代构建工具，如 Rollup, Parcel, Vite）在编译时处理了 CJS 的引用和依赖关系，并消除了对原生 CJS 运行时环境的需求

**Webpack 打包后的 Bundle 中，用于加载同步依赖的 `require()` 是同步执行的。打包后require和静态import相当于效果一样？想要拆分chunk并异步加载需要动态import？**

- Webpack 识别源代码中的 `require('')` 语句，并将其视为一个**静态依赖**。

- 会在最终 Bundle 中保留原生的 `require` 函数。

- 它会将每个 CJS 模块包装在一个函数中，并注入一个小的 **Webpack Runtime** 代码（一个自定义的模块加载器，例如一个 `__webpack_require__` 函数）。

- 这个运行时函数负责在 Bundle 内部查找、执行和缓存模块，从而实现了**同步的模块加载效果**，而无需进行网络请求。

#### 动态 `import()`

返回一个 Promise 对象。可以用.then或者async await

JavaScript 模块化机制中最核心、最稳定的特性：**模块单例（Module Singleton）**。对于所有现代 JavaScript 模块规范（CJS, AMD, **ESM**），无论是同步导入还是动态导入，一旦一个模块被加载并执行，它的结果就会被**缓存**起来。

#### 前端微服务架构实践

**核心目标:** 将一个庞大的前端应用拆分为多个独立开发、独立部署、独立运行的小应用。

- **Module Federation (推荐):** Webpack 5 联邦模块功能，实现运行时模块共享和依赖去重。

- **Single-SPA/Qiankun (基于框架):** 通过路由劫持和沙箱机制，实现应用级的集成。

- **Web Components/Iframe (隔离):** 通过浏览器原生技术实现 UI 隔离。 

#### Monorepo 项目管理

- **定义:** 将多个项目（Package）的代码存储在一个 Git 仓库中。最终的构建（Build）和部署（Deploy）仍然是**按需、独立**进行的。

- **常用工具:** Lerna, Nx, Turborepo, Yarn/pnpm Workspace。

- **优势:**
  
  - **代码共享:** 易于在不同项目间共享代码和配置。
  
  - **原子提交:** 一个 Commit 可以涉及多个项目，提交历史清晰。
  
  - **统一依赖:** 容易实现依赖版本统一。

- **挑战:** 仓库体积大，工具配置复杂，权限控制难度增加。

- CI：**Monorepo 工具的集成 (Nx/Turborepo):** 这些工具可以智能地判断**哪些项目**受到了代码变动的影响。例如，在 CI 中运行 `npx nx affected:build`，只构建那些代码或其依赖发生变化的子项目。

- 通常会有一个位于 Monorepo 根目录下的**主 CI 配置文件**，它负责调用 Monorepo 工具，并确定哪个子项目的部署流程需要被触发。

- **部署脚本：** 具体的部署逻辑（例如如何将文件上传到 S3 或如何调用 K8s 部署 API）通常会封装成每个项目内部的独立脚本，或由主 CI 配置文件通过参数动态调用。

**总结：** 在 Monorepo 中，CI 流程是**集中的且智能的**；而 CD 流程是**分散的且独立的**。

#### 包管理和版本控制策略

- **版本锁定:** 强制使用 `package-lock.json` 或 `pnpm-lock.yaml` 锁定依赖版本，确保不同环境下的依赖一致性。

- **包管理:** 使用 **pnpm Workspace**（基于 Monorepo 的包管理）来实现依赖共享和节省空间。

模块的单例行为与 React Hooks 或 Vue Composition API 中的 `composable`（组合式函数）的行为，构成了前端状态管理和逻辑复用的两种截然不同的模式。

模块：共享的应用级状态

Hooks / Composable：隔离的组件级状态
