#### 浮点数精度问题

计算机底层是用二进制存储数据的。虽然 $0.1$ 和 $0.2$ 在十进制看起来很整，但在转换成二进制时，它们是**无限循环小数**，JavaScript 中的 `Number` 类型使用的是 64 位双精度浮点数，这导致存进去的数本身就不是精确的 0.1。

办法：

转成整数运算 (常规解法)**；

使用专业库比如`decimal.js`、`bignumber.js` 或 `big.js`

追问：绝大多数编程语言都有，只要它们使用的浮点数类型是基于 **IEEE 754 国际标准**实现的，核心问题是：无限循环的二进制+尾数位数的限制 导致的强制截断和精度丢失

#### js的字符长度

js字符串的 `length` 属性返回的是字符串中代码单元的数量,而不是传统意义上的字符数量或字节数量，由ECMAScript 标准规定

JS 字符串使用 **UTF-16** 编码格式，一个**代码单元**就是 **16 位（即 2 字节）**

**普通字符**：大多数字符都位于 Unicode 的基本多语言平面 (BMP) 内。它们只需要 **1 个代码单元**来表示，特殊字符/表情符号：位于 BMP 之外的字符（如某些不常见的汉字、最新的 Emoji 🌧️）需要 2 个代码单元。

#### this上下文

this指的是函数执行时所关联的对象，取决于函数在运行时**调用**的方式。

1 直接调用

2 对象. 调用（隐式绑定

3 bind call apply (显式调用)

4 new `this` 绑定到**新创建的实例对象

特殊情况 箭头函数没有this

原生 `setTimeout` 的 this 指向规则：

1. **默认情况下**，回调函数中的 `this` 指向全局对象（浏览器中的 `window`）

2. **严格模式下**，指向 `undefined`

3. this 指向与调用 `setTimeout` 的上下文无关

#### 作用域

#### 原型与原型链

1.函数的`prototype`：Constructor.prototype,  仅存在于函数（构造函数/类）上**它指向一个对象，这个对象就是未来**所有实例对象**将继承的公共属性和方法的集合。

2.`__proto__` :存在于所有实例对象上这是一个内部属性 (`[[Prototype]]` )，它指向创建该实例的构造函数的 `prototype` 对象。`Object.getPrototypeOf()`来访问

原型链是由于对象通过 `__proto__` (内部的 `[[Prototype]]`) 链接到其构造函数的原型对象，而构造函数的原型对象本身也是一个对象，它也有自己的 `__proto__`，如此层层递进，直到链的末端。

原型链是 JavaScript 实现**继承和属性共享**的机制。属性和方法都存储在原型上，所有实例共享同一份，这大大节省了内存空间。

当访问实例对象上的一个属性，JS 引擎会首先检查该实例对象自身是否有这个属性，如果实例自身没有找到，引擎会沿着 `__proto__` 链接向上，到它的原型对象上查找。 如果仍未找到，查找会沿着原型链一直向上，直到到达 `Object.prototype`。`Object.prototype` 的 `__proto__` 是 `null`。如果查找到 `null` 仍未找到，则返回 `undefined`。

**`class` 语法：** ES6 的 `class` 语法是原型和原型链的**语法糖**。它没有改变底层机制，只是提供了一种更清晰的方式来定义构造函数和方法。

#### <mark>继承</mark>

原型链继承**原型链** 是 JS 继承的**唯一底层机制**

1.原型继承，核心：让子类原型对象指向父类实例。当父类的原型上包含**引用类型**的属性时，所有子类实例都会**共享**这个属性。一个实例修改，所有实例都受影响

2.组合继承：【核心优化】：创建父类原型对象的副本，并赋值给子类原型+【构造器指针修正】：将子类构造器指向自身。特点：独立属性+原型共享

es6的class extend super

`class` 关键字**并没有改变底层原型继承的机制**，它只是提供了一套更清晰的 API 来定义构造函数、原型方法和静态方法。

`extends` 的底层操作：

1. **设置子类的原型链：** 自动将 `Child.prototype` 的原型（即 `Child.prototype.__proto__`）设置为 `Parent.prototype`，实现了**方法继承**。

2. **构造函数关联：** 自动将 `Child.__proto__` 设置为 `Parent`，实现了**静态属性和方法的继承**。

`super` 关键字

`super` 是在 `class` 继承中最核心、最关键的机制，它在两个场景下工作：

1. **在 `constructor` 中：** 必须调用 `super()`。它负责调用父类的构造函数，并**将子类实例的 `this` 绑定到父类**。在子类构造函数中，必须在引用 `this` 之前调用 `super()`。

2. **在方法中：** 用于调用父类原型上的同名方法（如 `super.methodName()`）。

#### new操作符

1创建新对象

2新对象原型指向构造函数原型对象

3绑定this并执行构造函数

4如果构造函数有返回就直接返回，否则返回新对象

#### 事件循环

宏任务和微任务的区分是为了做什么?优先级?

答：是为了保证异步代码执行的**确定性、优先级和性能**。微任务享有绝对的**插队权**。

核心目的在于创建**两级异步优先级系统**，确保高优先级、对性能敏感的任务能够快速执行，同时避免长时间阻塞浏览器渲染。

微任务 (Microtasks) 的目的：高优先级，保证状态一致性。微任务在**当前同步代码执行完毕后，浏览器进行下一次渲染之前**立即执行。例如，Promise 链需要保证在一个 DOM 或 UI 渲染周期内全部解析完成，以避免 UI 闪烁或数据不一致。

宏任务 (Macrotasks) 的目的：低优先级，调度 I/O 和 UI 渲染。不阻塞渲染

#### 全局对象

#### 普函通数和箭函头数有么什区别

#### js类型转换

显式转换 (Explicit Coercion)**：通过 `Number()`、`String()`、`Boolean()` 等内置函数或 `parseInt` 等方法进行的**主动**转换。

隐式转换 (Implicit Coercion)**：在运行时，由 JS 引擎根据操作符（如 `==`、`+`、`-`）的需要**自动**进行的转换。

1.转换为 Boolean (转布尔)。这是最简单的转换，发生在逻辑判断、`if` 语句和 `!` 操作符中。

2.转换为 String (转字符串)。发生在字符串拼接（`'a' + b`）、`alert()` 或 `String(value)` 中。规则：原始值直接转换。对象通过调用内部的 **`ToString` 抽象操作**实现

3.转换为 Number (转数字)。发生在数学运算（`-`, `*`, `/`）或一元加操作符（`+a`）中。

规则： 原始值有明确的转换规则（如 `null` 转 $0$，`"123"` 转 $123$）。对象通过调用内部的 `ToNumber` 抽象操作实现。

#### 闭包

注意：闭包 = 函数 + 它能访问的、已脱离当前执行上下文的外部变量

作用：创建私有变量；外部访问私有变量；延长变量生命周期；模块化基础

注意：使用不当容易内存泄漏；性能开销比普通函数大

如何避免内存泄漏? 

解除引用：当你确定一个闭包不再需要使用时，应该手动解除对它的引用。通过将持有闭包的变量设置为 `null` 或 `undefined`，使其失去引用。

```js
let closureFunc = outerFunc(); // 创建闭包
// ... 使用 closureFunc ...
closureFunc = null; // 手动解除引用，帮助 GC 回收内存
```

#### call  apply bind

#### 严格模式

严格模式是 ES5 引入的一种特殊模式，旨在选择性地限制 JavaScript 的某些不安全、低效或有缺陷的行为

- **全局模式：** 在脚本文件顶部添加 `"use strict";`。

- **函数模式：** 在函数体内部顶部添加 `"use strict";`

严格模式是保证代码质量和项目维护性的要求

重要规则：

禁止隐式全局变量：尝试给未声明的变量赋值时，将不再自动在全局对象 (`window` 或 `global`) 上创建该变量，而是**直接抛出 `ReferenceError`**。

规范 `this` 默认绑定（上下文可预测性）：独立函数调用 `this` 为 `undefined`

静默失败转为抛出错误 (代码健壮性)

禁用堆栈调用属性，禁止函数动态获取调用栈信息，（严重阻碍了js 引擎进行即时编译优化

#### 导致js里this指向混乱的原因是什么?

根本原因在于：**普通函数采用动态绑定（Dynamic Binding），其 `this` 的值不是在函数定义时确定的，而是在函数被调用时，根据函数调用的方式（Call Site）临时决定的。**

`this` 的值高度依赖于**调用函数时的上下文**，这种运行时（Runtime）绑定机制与 JS 的词法作用域规则形成了鲜明对比，造成了巨大的认知负担。

ES6 的解决方案：箭头函数，没有自己的动态 `this`，`this` 变得可预测、不可变，不再受调用方式的影响

#### 运算符

ES2020 新增：空值合并运算符 `??` (Nullish Coalescing)

用途：** 专门用于处理 `null` 或 `undefined` 的默认值设置。解决了 `||` 在处理 `0` 和 `""` 时的缺陷。

规则：** 只有当左侧操作数是 `null` 或 `undefined` 时，才返回右侧操作数。

ES2021 新增：逻辑赋值运算符

- **`||=` (OR 赋值)：** 只有当左侧为 Falsy 时才赋值。

- **`??=` (空值赋值)：** 只有当左侧为 `null` 或 `undefined` 时才赋值。

其他：typeof  instanceof  delete

#### <mark>执行上下文</mark>

JavaScript 引擎在运行代码时，会维护一个 **执行上下文栈 (Execution Context Stack)**，也称为调用栈 (Call Stack)。

- **入栈：** 当代码开始执行或调用函数时，新的执行上下文会被创建并推入栈顶。

- **出栈：** 当函数执行完毕，其上下文会从栈中弹出，控制权返回给栈中的上一个上下文。

- **流程：** 栈底永远是 **全局执行上下文**。

全局执行上下文：它创建全局对象（ `window`、Node.js 中的 `global`）和 `this` 绑定。

函数执行上下文 ：每当一个函数被调用时，都会创建一个新的~~。每次调用都是独立的

阶段一：创建阶段 (Creation Phase / 编译阶段)

在代码执行之前，引擎会扫描函数代码，完成以下三项任务：

1. 确定 `this` 绑定 (ThisBinding)：全局 EC绑定到全局对象；函数EC按调用方式绑定

2. 创建词法环境 (LexicalEnvironment)：存储 `let`、`const`  `class` 声明

3. 创建变量环境 (VariableEnvironment)：用于存储 `var` 变量声明和函数声明

阶段二：执行阶段 (Execution Phase)

引擎开始逐行执行代码，完成以下任务：

1. **变量赋值：** 将值赋给变量（之前在创建阶段被初始化为 `undefined` 或保持未初始化状态）。

2. **代码执行：** 执行所有函数调用和其它语句。

#### <mark>词法环境</mark>

**词法环境 (Lexical Environment)** 是 **ECMAScript 标准中定义的具体数据结构**，它是执行上下文（EC）的核心组成部分。它是一个**运行时 (runtime) 对象**，在每个执行上下文创建时生成。它有两个关键部分：

1. **环境记录 (Environment Record)：**
   
   - 实际存储变量和函数声明的地方。
   
   - **声明式环境记录：** 存储 `let`、`const`、`class`。它们被创建时不会初始化，从而产生**暂时性死区 (TDZ)**。
   
   - **对象环境记录：** 在全局 EC 中，存储 `var` 变量和函数。

2. **外部环境引用 (Outer Environment Reference)：**
   
   - 指向**创建该执行上下文时的父级执行上下文的词法环境**。
   
   - 这个引用链条就是 **作用域链 (Scope Chain)** 的基础，用于变量查找。

总结： 当我们在函数内部访问变量时，JS 引擎会首先在当前 执行上下文 的中查找，如果找不到，就会沿着 **作用域链** 向上查找，直到全局 EC，所以函数能访问外部的变量，这也是闭包的前提。

`let` 在 `for` 循环中会为每次迭代创建独立的词法环境，因此闭包捕获的是不同的 i，而不是同一个变量。

#### 作用域

js讨论词法作用域，**词法作用域 (Lexical Scope)** 是一个**抽象的、静态的编程原则或规则**。

- **性质：** 它只取决于代码在 **哪里被编写 (定义)**，与代码在运行时 **哪里被调用** 无关。

- **作用：** 它决定了变量的可访问性范围。

词法环境是 JavaScript 引擎用来**记录和追踪**变量，严格遵守**词法作用域**规则

#### Set、Map、WeakSet、weakMap 的区别

Weak 系列与普通系列的本质区别，就在于**垃圾回收 (GC)** 机制。

1. 强引用 (Strong Reference)：Map & Set
- 如果一个对象被 `Map` 或 `Set` 引用，那么这个对象就不会被垃圾回收机制回收。

- **副作用：** 如果你将 DOM 元素或大型对象作为键或值存储在 `Map` 或 `Set` 中，即使该对象在代码中已无其他引用，它也会被 Map/Set **钉死在内存中**，直到你手动调用 `.delete()` 移除，否则会导致**内存泄漏**。
2. 弱引用 (Weak Reference)：WeakMap & WeakSet
- 如果一个对象**只**被 `WeakMap` 或 `WeakSet` 引用，那么这个对象**可以**被垃圾回收机制回收。

- **自动清理：** 一旦对象被 GC 回收，它在 `Weak` 集合中的对应条目也会被 **自动移除**。

- **副作用消除：** 它们专为**不干扰 GC** 的非核心数据存储而设计，是避免内存泄漏的强大工具。
3. Weak 集合的特殊限制（不可迭代的原因）

`WeakMap` 和 `WeakSet` 具有不可迭代性，也不支持 `.clear()` 或 `.size` 属性。

- **原因：** 由于它们是弱引用，集合中的对象随时可能被 GC 回收而消失。

- **后果：** 如果允许迭代，你将无法保证在迭代开始和结束时集合内容的一致性，这会导致代码逻辑不可预测。

高级应用场景（Use Cases）

A. WeakMap：关联私有数据或缓存

- **场景：** 在不修改原对象的情况下，为其关联额外的数据或缓存。

- **示例：** 创建一个 `WeakMap` 来存储 DOM 元素的事件监听器。当 DOM 元素被移除时（被 GC 回收），WeakMap 中对应的事件监听器也会自动清理，**防止内存泄漏**。

B. WeakSet：跟踪对象状态或成员资格

- **场景：** 简单地跟踪一个大型对象集合中，哪些对象处于“活动”或“已处理”状态，但又不想阻止这些对象被 GC 回收。

- **示例：** 跟踪一个大型应用中哪些对象实例已经被初始化或激活，用于防止重复处理。

总结来说，`Set` 和 `Map` 是通用的数据结构，用于**核心数据存储**；而 `WeakSet` 和 `WeakMap` 是用于**关联辅助数据、解决内存泄漏问题**的**工具**。

#### <mark>es6新特性</mark>

1. 作用域与变量管理 (Scope & Mutability)
- **`let` 和 `const`：** 引入**块级作用域 (Block Scoping)**，彻底解决了 `var` 导致的变量提升和作用域污染问题，增强了代码的稳定性和可预测性。
2. 异步编程基石 (Async Foundation)
- **Promises：** 提供了结构化、可链式调用的异步处理方案，解决了传统回调函数的**回调地狱 (Callback Hell)**，是 `async/await` 的底层基础。
3. 函数与上下文 (Functions & Context)
- **箭头函数 (`=>`)：** 语法简洁。核心价值在于使用**词法 `this`**，消除了普通函数中 `this` 绑定不明确的痛点，使上下文指向更加可靠。
4. 数据结构与模块化 (Data & Structure)
- **`class` 语法：** 基于原型继承的**语法糖**，使面向对象编程（OOP）更接近传统语言模式，提高了可读性。

- **解构赋值/扩展运算符 (`...`)：** 极大地简化了数据操作，如数组合并、对象浅拷贝、函数参数收集等，提高了代码简洁性。

- **`Map` 和 `Set`：** 提供了更高效的数据结构，解决了传统 JS 对象作为键的限制 (`Map`) 和快速去重 (`Set`) 的需求。

#### <mark>ES6模块和Common]S模块的区别</mark>

核心区别在于 **CommonJS 是为服务器端同步加载设计的**，而 **ES Modules 是为浏览器端异步加载和静态分析设计的**。

- CJS 是在 Node.js 环境中诞生的，文件模块通常存储在本地硬盘上。因此，CJS 可以使用 `require()` **同步阻塞**地加载文件。它在**运行时**执行代码后，才能知道导入了什么。

- **ES Modules (异步)：** ESM 是为浏览器设计的，模块通常需要通过网络请求加载。因此，ESM 采用**异步加载**，以避免阻塞主线程。ESM 在**代码静态解析阶段**（编译时）就能确定所有依赖关系。

- **CommonJS (动态值拷贝)：**
  
  - CJS 导出的是一个值的**拷贝**。一旦模块导出，原始模块内部对变量的修改不会影响到导入方。
  
  - `require()` 得到的是一份导出的**值的快照**。

- **ES Modules (静态实时绑定/引用)：**
  
  - ESM 导出的是对原始变量的**引用**（Live Binding）。
  
  - 这意味着导入方和导出方共享同一个变量。如果导出方在后续代码中修改了该变量，导入方可以观察到这种变化。

**ESM 的优势：** 由于 ESM 采用 `import` / `export` 这种**静态语法**，JS 引擎或构建工具（如 Webpack/Rollup）可以在不执行代码的情况下，分析出模块之间的依赖关系。这使得 **Tree-Shaking（摇树优化）**成为可能，即只打包实际用到的代码，极大地减小了最终产物大小。

#### <mark>Object.create(proto) 方法</mark>

其中 *proto* 是新对象的原型对象

`Object.create()` 的主要目的**不是复制 (Clone)** 一个现有对象，而是创建一个**新对象**，并精确控制新对象的**原型 (Prototype)**。

`Object.create()` 的第一个参数是 **强制要求** 传入的，它就是新创建对象的 **`[[Prototype]]` (即 `__proto__`)**。

核心能力是作为 **ECMAScript 官方提供的、创建指定原型对象**的方法，它是实现纯净原型继承的最佳实践。

#### <mark>Object.assign()</mark>

`Object.assign(target, ...sources)` 方法用于将所有**可枚举 (enumerable) 的自有属性 (own properties)** 的值，从一个或多个**源对象 (source)** 复制到**目标对象 (target)**。

返回值： 返回修改后的目标对象 `target`。

仅执行浅拷贝 (Shallow Copy Only)

只复制可枚举的自有属性

一般用于**合并配置对象 (Merging)：** 将默认配置与用户提供的配置合并。

#### 箭头函数与普通函数的差异

没有this, 继承外层作用域的 `this`。

不能new

不能call bind apply

没有 `arguments` 对象

不支持 `yield` 关键字

#### arguments 的定义与作用

`arguments` 是一个特殊的**类数组对象 (Array-like Object)**，它在函数被调用时自动创建，并包含函数被调用时实际传入的所有参数。

**作用域：** 仅存在于**非箭头函数**的函数体内部。

可迭代对象，但不是数组 可以通过传统的 `for` 循环进行遍历或者Array.from(arguments)

```js
function sum(a, b) {
  // 访问第一个参数
  console.log(arguments[0]); // 对应传入的 a
  // 访问所有参数数量
  console.log(arguments.length); 

  // 即使函数没有定义第三个参数，也可以通过 arguments 访问
  if (arguments.length > 2) {
    console.log('还有额外的参数：', arguments[2]);
  }
}

sum(10, 20, 30); 
// 输出: 10
// 输出: 3
// 输出: 还有额外的参数： 30
```

更推荐用es6的剩余参数

```js
function sumAll(...args) {
  // args 是一个真正的数组，可以直接使用数组方法
  return args.reduce((acc, current) => acc + current, 0);
}

// 优势：
// 1. args 是一个真正的数组，可以直接调用 map, reduce 等方法。
// 2. 没有参数绑定的困扰。
// 3. 语法更清晰。
```

#### for..in for..of区别：

KEY in OBJECT, VALUE of ITERABLE

#### <mark> async/await 的实现原理是什么?它和Promise、Generator之间有什么关系?</mark>

`async/await` 是对 **Promise** 和 **Generator** 的一种**语法糖 (Syntactic Sugar)**。

- **Promise** 是 `async/await` 的**外部接口**（输入和输出）。

- **Generator** 是 `async/await` 实现**暂停和恢复**的**内部引擎**。

#### let/const/var 的底层区别

1.作用域 

var 函数作用域。在函数外部声明时是全局作用域。

`let` / `const`块级作用域 。变量的作用域限制在最近的一对花括号 `{}` 内

2.变量提升

var 完整提升。声明和初始化同时提升到作用域顶部，但初始化为 `undefined`

`let` / `const` 只提升声明。声明会被提升，但不会被初始化。存在暂时性死区，在变量声明语句执行之前，访问该变量都会抛出 `ReferenceError`

3.绑定与赋值

var 可以重复声明，在全局作用域声明时，会挂载到 `window` 或 `global` 对象。

let、const **不允许重复声明**。在同一作用域内重复声明会抛出 `SyntaxError`。也不会挂载到全局对象上。

#### <mark>Proxy 和 Reflect 的应用场景</mark>

1.Proxy ： 对象操作拦截

`Proxy` 的核心价值在于**对对象的操作进行非侵入式（Non-invasive）的拦截和定制**。它提供了一个代理层，允许我们在对象操作的 13 个内部方法（如 `get`, `set`, `apply`, `construct`）被调用时介入。

应用：

响应式系统和状态管理（最重要，比如vue）；`Proxy` 可以直接监听对象属性的增删改查，而不需要像 `Object.defineProperty` 那样预先遍历所有属性，解决了数组和新增属性的监听难题。

数据校验与属性保护：在 `set` 拦截器中，加入自定义的校验逻辑（如类型检查、范围检查），如果不通过则抛出错误或拒绝赋值，防止不合规的数据流入

实现私有属性：在 `get` 或 `has` 拦截器中，对特定前缀（如 `_` 开头的属性）返回 undefined` 或 `false`，模拟私有属性效果。

<mark>2.`Reflect` </mark>

不是一个函数，而是一个静态对象，它提供了 13 个静态方法，这些方法与 `Proxy` 的 13 个拦截器方法一一对应。

#### 事件循环

初始同步脚本执行完毕，**执行上下文栈（ECS）清空时**，事件循环机制才真正开始接管，并进入检查队列的循环。

所有的异步事件一定是当前浏览器执行完同步任务空闲了才做的

#### promise

优点：

解决回调地狱，改为链式回调，提高了代码的可读性和维护性

统一的错误处理机制，集中捕获，简化流程

规范异步状态管理，明确的三种状态：Pending/Fulfilled/Rejected, 使异步操作的结果可预测和可追踪。

易于组合和并行处理，.all .race 等

缺点：

仍然是链式结构（未完全同步化）需要显式的 `.then()` 链来组织代码流程

立即执行的特性，缺乏中断和取消机制

一次性结果，一旦状态确定，就无法再次改变

错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获

错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获

#### 异步

计时器 settimeout setInterval，宏任务

网络请求与文件操作：

- **`fetch(url)` (现代标准):** 微任务
  
  - 返回一个 Promise 对象，用于发起网络请求。
  
  - 是最常用的网络请求 API，取代了大部分 XHR 用法。

- **`XMLHttpRequest` (XHR) (传统方法):** 特指基于事件监听而不是promise的，是宏任务
  
  - 传统的回调式 API，现在主要用于文件上传等特定场景，或需要浏览器底层控制的场合。

- **`FileReader` / 各种 I/O 操作:** 也是通过回调或 Promise返回，宏任务

异步流程控制与状态管理：Promise async/await，微任务

#### <mark>Generator是什么怎么用</mark>

Generator 函数（生成器）是一种特殊的函数，它能够**暂停执行**并在稍后**从暂停点恢复执行**。这是通过 Generator 函数内部维护的一个 **状态机 (State Machine)** 来实现的。

`function*`定义 Generator 函数

`yield`暂停函数执行，并返回 `yield` 后的值

`.next()`恢复函数执行，并返回一个包含 `{value, done}` 的对象。

意义：简化异步编程；提供函数**暂停和恢复执行**的底层能力 (`yield` 机制)，这是实现“等待”的唯一方式；返回一个同时满足可迭代和迭代器协议的对象

Generator 解决了 **代码流的连续性** 问题，这是 Promise （依赖于 回调函数）无法做到的。

`async/await` 的底层基础是 Promise，但它的核心机制是 Generator

#### Generator和 Async/Await 原理

核心机制：状态机

普通函数从头到尾执行一次，没有状态。而 Generator 函数被编译后，其函数体内的每一行代码（特别是 `yield` 语句）都成为了状态机中的一个节点。

`yield` 关键字：暂停的指令（将 Generator 函数的执行上下文完整地保存，并挂起，引擎立即将控制权返回给调用者所在的执行上下文，即调用 `gen.next()` 的那个上下文）

`.next()` 方法：恢复的指令（执行优先级非常高，因为它是一个**同步操作**，讲挂起的上下文放入当前执行栈，会影响后续其他的宏任务微任务，就像一个同步函数调用）

Generator 对象的生命周期内，其内部状态（包括局部变量）被持续存储在内存中，这就是它能够从上次离开的地方继续执行的原因。

```js
function* numberGenerator() {
  console.log('--- 启动 ---');
  let result1 = yield 1;

  console.log('--- 恢复，接收到:', result1, '---');
  let result2 = yield 2; 

  console.log('--- 恢复，接收到:', result2, '---');
  return 3;
}

// 1. 调用 Generator 函数，返回迭代器对象（Generator Object）
const gen = numberGenerator(); 

console.log(gen.next()); 
// 输出: --- 启动 ---
// 输出: { value: 1, done: false } (遇到第一个 yield 暂停)

console.log(gen.next('A')); // 将 'A' 作为上一个 yield 的返回值注入
// 输出: --- 恢复，接收到: A ---
// 输出: { value: 2, done: false } (遇到第二个 yield 暂停)

console.log(gen.next('B')); // 将 'B' 作为上一个 yield 的返回值注入
// 输出: --- 恢复，接收到: B ---
// 输出: { value: 3, done: true } (遇到 return 结束)

console.log(gen.next());
// 输出: { value: undefined, done: true } (已完成)
```

`async/await` 是 ES7 (ES2016) 引入的，它的底层是基于 **Promise** 和 **Generator** 实现的**语法糖 (Syntactic Sugar)**。它的核心原理是**自动化**了 Generator 的驱动过程，相当于异步完成后自动调用了.next

开放题：

#### 你觉得js里this的设计怎么样?有没有什么缺点啥的

`this` 的设计初衷是为了实现高度的**灵活性**和**代码复用**。通过显式绑定隐式绑定可以更加灵活

`this` 的所有缺点都源于一个核心问题：**它的值是动态绑定（Runtime Dynamic Binding）的，依赖于函数的调用点 (Call Site)，而不是定义点。**

有严重的上下文丢失陷阱：回调函数问题： 当一个对象的方法被作为参数传递给异步函数（如 `setTimeout`、`Promise.then()`）或事件处理器时，它通常会失去其隐式绑定，退化为**默认绑定（指向全局对象或 `undefined`）**。

违反词法作用域原则 ：JavaScript 的变量（使用 `let/const`）是词法作用域（静态确定）的，但 `this` 却是动态作用域的。这种不一致性打破了语言的统一性，使得在阅读嵌套代码时很难预测 `this` 的值。

es6通过箭头函数和class弥补了这个问题，开发者应当尽可能利用箭头函数和 `class` 语法来避免直接依赖普通函数的动态 `this` 机制

##### proxy写法

```javascript
const handler = {
    // 陷阱 (Trap)：拦截属性的读取操作
    get(target, prop, receiver) {
        if (prop === 'message3') {
            return `[${target.message1} ${target.message2}]`;
        }
        // 默认行为：返回目标对象的属性值
        return Reflect.get(target, prop, receiver); 
    },
    // ... 比如 set(target, prop, value, receiver) { ... }
}
const target = {
    message1: "Hello",
    message2: "World"
};
const proxy = new Proxy(target, handler);
```

##### Reflect 是什么？怎么用

`Reflect` 是一个内置对象，它提供了一系列静态方法，这些方法与 `Proxy` 陷阱的方法**同名且参数一致**。

例如：

- 以前获取对象属性：`obj.prop` 或 `Object.getOwnPropertyDescriptor(obj, prop)`

- 现在通过 `Reflect`：`Reflect.get(obj, prop)`

- `'prop' in obj` $\rightarrow$ `Reflect.has(obj, 'prop')`

- `delete obj.prop` $\rightarrow$ `Reflect.deleteProperty(obj, 'prop')`

在 `Proxy` 的 `handler` 中，我们经常需要执行目标对象上的默认操作。使用 `Reflect` 可以干净、安全地实现这一点。

`Reflect` 将一些命令式的操作符（如 `delete`）或命令式的方法调用（如 `new`）转换成了函数式的调用，使得代码更易于维护和理解。

Reflect 能提供操作失败的明确反馈，返回一个**布尔值**表示成功或失败，代码更简洁。一般的 `Object` 上的方法（例如 `Object.defineProperty`），在执行失败时会抛出异常，这需要用 `try...catch` 捕获。

##### Object.defineProperties 的作用

把参数2的属性赋值给参数1，特点是不仅复制属性，还复制属性的属性，比如是否可枚举、可修改这些属性

- 不仅仅是赋值，而是**使用属性描述符定义属性**

- 可以控制属性的可写性、可枚举性、可配置性

- 可以定义访问器属性（getter/setter）

- 默认属性特性与普通赋值不同
