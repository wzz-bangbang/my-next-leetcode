#### 框架 vue/react/nextjs

**选型考量维度**：团队主要技术栈、偏中后台还是前台、业务数据和交互复杂性、是否性能要求高、是否交付速度优先、是否有SEO或SSR需求、是否有用到典型库的需求、是否有跨端或多端需求、未来模块会不会持续膨胀、多人并行开发多不多、主要瓶颈是**首屏**还是 **交互响应**还是**列表渲染/大数据量**等

- **Vue**：
    - 适合：团队 Vue 经验多、交付速度优先
    - 优点：上手快、约束更强（模板+响应式）、代码风格一致性更好
    - 风险：大型复杂项目仍需工程规范（状态/依赖/性能边界）

- **React**：
    - 适合：复杂交互、组件抽象强、团队工程化能力强、、多团队开发跨端生态需要（RN/小程序生态间接）
    - 优点：组合能力强，生态丰富；复杂场景更“可编程”
    - 风险：自由度高 => 需要更强规范（状态、目录、Hooks 约束、性能）

- **Next.js**：
    - 适合：**需要 SEO / 首屏性能 / 内容与交易混合 / 需要 SSR/SSG/ISR** 的 Web
    - 优点：开箱 SSR/SSG/路由/数据获取/分包优化，工程体系更完整
    - 风险：服务端成本与复杂度上升；缓存、数据一致性、部署方式要设计

总结：
做框架选型会先看约束：团队熟悉度和交付周期是底线，然后看业务形态——中后台还是前台内容型，**数据和交互复杂度决定我们更需要‘强约束的规范’还是‘高自由度的组合能力’**。 
如果是登录后中后台、SEO 不重要、交付优先，通常结合需要面向的端，优先选团队更熟的方案（比如 Vue 或 React），并把工程规范、状态管理、性能治理配套做好。 
如果是 ToC 内容/交易，对 SEO 和首屏体验有硬要求，会优先考虑 Next.js 这种一体化 SSR/SSG 方案。  
最后必要时可以提前验证关键风险点，对可能的性能瓶颈提前预估。
#### 模块化方案

- **现代前端默认优先 ESM**
    - 原因：天然支持静态分析、tree-shaking、按需加载；与 Vite/Rollup/现代浏览器契合
        
- **Node 侧 / 老生态**可能仍有 CJS
    - 场景：历史包、Node 运行环境、某些工具链
    - 策略：库开发可用 **双产物**（`exports` 同时提供 ESM/CJS）
        
- **UMD**：
    - 场景：要被 script 直接引入、或兼容非常老的环境（现在越来越少）
        
- **落地规则**：
    - 应用项目：ESM + Vite / Webpack5（优先 ESM）
    - 公共库：ESM 为主，必要时提供 CJS fallback
    - 关键点：关注 `sideEffects`、`exports`、依赖是否可 tree-shake

**一句结论**：
- 应用侧统一 ESM；
- 库侧 ESM 主产物 + 必要的 CJS 兼容，保证 tree-shaking 和生态兼容。

#### SSR vs CSR vs SSG

**选型考量维度**：是否要 SEO、首屏性能诉求、内容更新频率、个性化程度、后端/缓存能力、部署成本。

- **CSR（纯前端渲染）**
    - 适合：登录后系统、中后台、强交互应用、SEO 不重要
    - 优点：架构简单、服务器压力小
    - 缺点：首屏依赖 JS；SEO 弱
        
- **SSR（服务端渲染）**
    - 适合：SEO 重要、首屏强诉求（电商/内容/营销）
    - 优点：首屏更快、SEO 更好
    - 成本：服务端渲染与缓存、数据请求、部署与稳定性更复杂
        
- **SSG（静态生成）**
    - 适合：内容型、更新不频繁（文档、博客、活动页）
    - 优点：性能最好、成本低（CDN）
    - 缺点：更新需要重新构建
        
- **ISR（增量静态再生）**（以 Next 为代表）
    - 适合：既要静态性能又要一定实时性（内容更新频繁但可接受延迟）

**一句结论**：
- 后台/登录态强交互 => CSR；
- 要 SEO/首屏 => SSR 或 SSG；
- 内容多且更新可延迟 => SSG/ISR 是性价比最高的。

#### SPA VS MPA

**选型维度**：页面形态是否强关联、是否需要极致首屏、多入口/多团队协作、SEO、复杂度。

- **SPA**
    - 适合：强交互、页面间共享状态多（IM、工作台、复杂表单）
    - 优点：路由切换快、状态共享方便
    - 缺点：首屏可能更重；路由/状态/性能治理要求更高；需要结合NGINX等配置

- **MPA**
    - 适合：多入口、页面相对独立（营销站、活动页、老系统渐进改造）
    - 优点：首屏天然更轻、隔离性好、稳定性强
    - 缺点：状态共享困难、体验一致性要额外做

**一句结论**：
- 强交互 + 状态共享多 => SPA；
- 多入口且相互独立、追求隔离与首屏 => MPA 或多应用架构更合适。

#### Redux VS Zustand

**选型维度**：状态规模与复杂度、调试与规范性、团队协作、性能、样板代码接受度。

- **Redux（尤其 React Toolkit）**
    - 适合：大型应用、复杂业务流、强规范团队、需要完整的中间件体系（日志/埋点/异步/回放）
    - 优点：可预测、生态成熟、调试工具强、团队协作一致性高
    - 缺点：心智和样板更多（RTK 已明显改善）

- **Zustand**    
    - 适合：中小型项目、需要更轻量、更少样板、组件局部状态较多
    - 优点：API 简单、性能好、开发快
    - 风险：大型项目需要自建规范（store 划分、依赖管理、异步/错误处理约束）

**一句结论**：
- 状态复杂、多人协作、需要强治理 => Redux/RTK；
- 追求轻量高效、业务中等 => Zustand，但会配套 store 分层和规范。

#### Vuex VS Pinia

- **Pinia（Vue3 时代主推）**
    - 优点：更贴合 Composition API （state/getters/actions 就是一个自然的对象/函数组合）、类型推导更友好、模块化更自然、心智更轻
    - 适合：新项目、Vue3 项目默认选

- **Vuex**
	- 强调**单向数据流**和**严格的状态修改规范（mutation/action/commit/dispatch + module）、相对适合大型项目、但模板代码较多、TS 支持需要额外配置
    - 策略：渐进迁移：新模块用 Pinia，旧模块逐步替换

**一句结论**：
Vuex 和 Pinia 更像官方状态管理的代际更替：Vue3 之后组合式 API 和 TS 成为主流，Pinia 在类型推导、样板代码、store 组织方式上都更契合官方心智，而且是官方推荐路线；Vuex 主要保留在存量项目或迁移成本高的场景，新项目默认 Pinia 风险最低。
#### 移动端适配方案(rem/vw/响应式)

**选型维度**：设计稿体系、是否需要等比缩放、是否要支持复杂断点、组件库/业务形态。

- **vw/vh**
    - 适合：H5 活动页/业务页等比布局
    - 优点：天然跟随视口，不需要 JS 动态计算 root font-size
    - 注意：处理极小/极大屏可配合 clamp() 或断点兜底

- **rem（配合动态 root font-size）**
    - 适合：历史方案、已沉淀一套 rem 工具链（postcss-pxtorem + lib-flexible 等）
    - 风险：依赖 JS 设置；多端/嵌套容器场景要注意

- **响应式（媒体查询 + flex/grid）**
    - 适合：需要多断点、Pad/桌面也要兼容的页面
    - 通常：实际工程中一般会结合上面两种一起用

**一句结论**：
- 纯移动 H5 我优先 vw + clamp；
- rem 多用于历史项目或已有体系
- 结合多端断点 走响应式

#### 小程序选框架 Uniapp VS Taroapp

**选型维度**：团队技术栈（Vue/React）、目标平台（微信/支付宝/抖音/快应用/H5/App）、生态成熟度、性能与原生能力、长期维护。

- **uni-app**
    - 适合：团队 Vue 为主、目标平台多（小程序 + H5 + App）且追求一套代码多端
    - 优点：多端覆盖广、上手快、社区方案多
    - 风险：遇到深度定制/复杂性能场景时，需要评估桥接和兼容成本
- **Taro**
    - 适合：团队 React 为主、希望用 React 心智做小程序多端
    - 优点：React 生态更好融入；工程化能力强
    - 风险：复杂场景要关注运行时开销与一些平台差异；仍需规范组件与渲染性能

**一句结论**：
- 看团队栈：Vue 团队优先 uni-app，React 团队优先 Taro；
- 结合面向的平台，uniapp支持平台略多；
- 结合可能需要的第三方能力
- 必要时提前做关键页面性能验证（长列表、图表、地图等）