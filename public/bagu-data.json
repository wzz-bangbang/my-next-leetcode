{
  "categories": [
    {
      "id": "js-basic",
      "name": "JS基础",
      "questions": [
        {
          "id": "js-basic-1",
          "title": "浮点数精度问题",
          "content": "计算机底层是用二进制存储数据的。虽然 $0.1$ 和 $0.2$ 在十进制看起来很整，但在转换成二进制时，它们是**无限循环小数**，JavaScript 中的 `Number` 类型使用的是 64 位双精度浮点数，这导致存进去的数本身就不是精确的 0.1。\n\n办法：\n\n转成整数运算 (常规解法)**；\n\n使用专业库比如`decimal.js`、`bignumber.js` 或 `big.js`\n\n追问：绝大多数编程语言都有，只要它们使用的浮点数类型是基于 **IEEE 754 国际标准**实现的，核心问题是：无限循环的二进制+尾数位数的限制 导致的强制截断和精度丢失",
          "hasAnswer": true
        },
        {
          "id": "js-basic-2",
          "title": "js的字符长度",
          "content": "js字符串的 `length` 属性返回的是字符串中代码单元的数量,而不是传统意义上的字符数量或字节数量，由ECMAScript 标准规定\n\nJS 字符串使用 **UTF-16** 编码格式，一个**代码单元**就是 **16 位（即 2 字节）**\n\n**普通字符**：大多数字符都位于 Unicode 的基本多语言平面 (BMP) 内。它们只需要 **1 个代码单元**来表示，特殊字符/表情符号：位于 BMP 之外的字符（如某些不常见的汉字、最新的 Emoji 🌧️）需要 2 个代码单元。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-3",
          "title": "this上下文",
          "content": "this指的是函数执行时所关联的对象，取决于函数在运行时**调用**的方式。\n\n1 直接调用\n\n2 对象. 调用（隐式绑定\n\n3 bind call apply (显式调用)\n\n4 new `this` 绑定到**新创建的实例对象\n\n特殊情况 箭头函数没有this\n\n原生 `setTimeout` 的 this 指向规则：\n\n1. **默认情况下**，回调函数中的 `this` 指向全局对象（浏览器中的 `window`）\n\n2. **严格模式下**，指向 `undefined`\n\n3. this 指向与调用 `setTimeout` 的上下文无关",
          "hasAnswer": true
        },
        {
          "id": "js-basic-4",
          "title": "作用域",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "js-basic-5",
          "title": "原型与原型链",
          "content": "1.函数的`prototype`：Constructor.prototype,  仅存在于函数（构造函数/类）上**它指向一个对象，这个对象就是未来**所有实例对象**将继承的公共属性和方法的集合。\n\n2.`__proto__` :存在于所有实例对象上这是一个内部属性 (`[[Prototype]]` )，它指向创建该实例的构造函数的 `prototype` 对象。`Object.getPrototypeOf()`来访问\n\n原型链是由于对象通过 `__proto__` (内部的 `[[Prototype]]`) 链接到其构造函数的原型对象，而构造函数的原型对象本身也是一个对象，它也有自己的 `__proto__`，如此层层递进，直到链的末端。\n\n原型链是 JavaScript 实现**继承和属性共享**的机制。属性和方法都存储在原型上，所有实例共享同一份，这大大节省了内存空间。\n\n当访问实例对象上的一个属性，JS 引擎会首先检查该实例对象自身是否有这个属性，如果实例自身没有找到，引擎会沿着 `__proto__` 链接向上，到它的原型对象上查找。 如果仍未找到，查找会沿着原型链一直向上，直到到达 `Object.prototype`。`Object.prototype` 的 `__proto__` 是 `null`。如果查找到 `null` 仍未找到，则返回 `undefined`。\n\n**`class` 语法：** ES6 的 `class` 语法是原型和原型链的**语法糖**。它没有改变底层机制，只是提供了一种更清晰的方式来定义构造函数和方法。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-6",
          "title": "继承",
          "content": "原型链继承**原型链** 是 JS 继承的**唯一底层机制**\n\n1.原型继承，核心：让子类原型对象指向父类实例。当父类的原型上包含**引用类型**的属性时，所有子类实例都会**共享**这个属性。一个实例修改，所有实例都受影响\n\n2.组合继承：【核心优化】：创建父类原型对象的副本，并赋值给子类原型+【构造器指针修正】：将子类构造器指向自身。特点：独立属性+原型共享\n\nes6的class extend super\n\n`class` 关键字**并没有改变底层原型继承的机制**，它只是提供了一套更清晰的 API 来定义构造函数、原型方法和静态方法。\n\n`extends` 的底层操作：\n\n1. **设置子类的原型链：** 自动将 `Child.prototype` 的原型（即 `Child.prototype.__proto__`）设置为 `Parent.prototype`，实现了**方法继承**。\n\n2. **构造函数关联：** 自动将 `Child.__proto__` 设置为 `Parent`，实现了**静态属性和方法的继承**。\n\n`super` 关键字\n\n`super` 是在 `class` 继承中最核心、最关键的机制，它在两个场景下工作：\n\n1. **在 `constructor` 中：** 必须调用 `super()`。它负责调用父类的构造函数，并**将子类实例的 `this` 绑定到父类**。在子类构造函数中，必须在引用 `this` 之前调用 `super()`。\n\n2. **在方法中：** 用于调用父类原型上的同名方法（如 `super.methodName()`）。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-7",
          "title": "new操作符",
          "content": "1创建新对象\n\n2新对象原型指向构造函数原型对象\n\n3绑定this并执行构造函数\n\n4如果构造函数有返回就直接返回，否则返回新对象",
          "hasAnswer": true
        },
        {
          "id": "js-basic-8",
          "title": "事件循环",
          "content": "宏任务和微任务的区分是为了做什么?优先级?\n\n答：是为了保证异步代码执行的**确定性、优先级和性能**。微任务享有绝对的**插队权**。\n\n核心目的在于创建**两级异步优先级系统**，确保高优先级、对性能敏感的任务能够快速执行，同时避免长时间阻塞浏览器渲染。\n\n微任务 (Microtasks) 的目的：高优先级，保证状态一致性。微任务在**当前同步代码执行完毕后，浏览器进行下一次渲染之前**立即执行。例如，Promise 链需要保证在一个 DOM 或 UI 渲染周期内全部解析完成，以避免 UI 闪烁或数据不一致。\n\n宏任务 (Macrotasks) 的目的：低优先级，调度 I/O 和 UI 渲染。不阻塞渲染",
          "hasAnswer": true
        },
        {
          "id": "js-basic-9",
          "title": "全局对象",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "js-basic-10",
          "title": "普函通数和箭函头数有么什区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "js-basic-11",
          "title": "js类型转换",
          "content": "显式转换 (Explicit Coercion)**：通过 `Number()`、`String()`、`Boolean()` 等内置函数或 `parseInt` 等方法进行的**主动**转换。\n\n隐式转换 (Implicit Coercion)**：在运行时，由 JS 引擎根据操作符（如 `==`、`+`、`-`）的需要**自动**进行的转换。\n\n1.转换为 Boolean (转布尔)。这是最简单的转换，发生在逻辑判断、`if` 语句和 `!` 操作符中。\n\n2.转换为 String (转字符串)。发生在字符串拼接（`'a' + b`）、`alert()` 或 `String(value)` 中。规则：原始值直接转换。对象通过调用内部的 **`ToString` 抽象操作**实现\n\n3.转换为 Number (转数字)。发生在数学运算（`-`, `*`, `/`）或一元加操作符（`+a`）中。\n\n规则： 原始值有明确的转换规则（如 `null` 转 $0$，`\"123\"` 转 $123$）。对象通过调用内部的 `ToNumber` 抽象操作实现。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-12",
          "title": "闭包",
          "content": "注意：闭包 = 函数 + 它能访问的、已脱离当前执行上下文的外部变量\n\n作用：创建私有变量；外部访问私有变量；延长变量生命周期；模块化基础\n\n注意：使用不当容易内存泄漏；性能开销比普通函数大\n\n如何避免内存泄漏? \n\n解除引用：当你确定一个闭包不再需要使用时，应该手动解除对它的引用。通过将持有闭包的变量设置为 `null` 或 `undefined`，使其失去引用。\n\n```js\nlet closureFunc = outerFunc(); // 创建闭包\n// ... 使用 closureFunc ...\nclosureFunc = null; // 手动解除引用，帮助 GC 回收内存\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-13",
          "title": "call  apply bind",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "js-basic-14",
          "title": "严格模式",
          "content": "严格模式是 ES5 引入的一种特殊模式，旨在选择性地限制 JavaScript 的某些不安全、低效或有缺陷的行为\n\n- **全局模式：** 在脚本文件顶部添加 `\"use strict\";`。\n\n- **函数模式：** 在函数体内部顶部添加 `\"use strict\";`\n\n严格模式是保证代码质量和项目维护性的要求\n\n重要规则：\n\n禁止隐式全局变量：尝试给未声明的变量赋值时，将不再自动在全局对象 (`window` 或 `global`) 上创建该变量，而是**直接抛出 `ReferenceError`**。\n\n规范 `this` 默认绑定（上下文可预测性）：独立函数调用 `this` 为 `undefined`\n\n静默失败转为抛出错误 (代码健壮性)\n\n禁用堆栈调用属性，禁止函数动态获取调用栈信息，（严重阻碍了js 引擎进行即时编译优化",
          "hasAnswer": true
        },
        {
          "id": "js-basic-15",
          "title": "导致js里this指向混乱的原因是什么?",
          "content": "根本原因在于：**普通函数采用动态绑定（Dynamic Binding），其 `this` 的值不是在函数定义时确定的，而是在函数被调用时，根据函数调用的方式（Call Site）临时决定的。**\n\n`this` 的值高度依赖于**调用函数时的上下文**，这种运行时（Runtime）绑定机制与 JS 的词法作用域规则形成了鲜明对比，造成了巨大的认知负担。\n\nES6 的解决方案：箭头函数，没有自己的动态 `this`，`this` 变得可预测、不可变，不再受调用方式的影响",
          "hasAnswer": true
        },
        {
          "id": "js-basic-16",
          "title": "运算符",
          "content": "ES2020 新增：空值合并运算符 `??` (Nullish Coalescing)\n\n用途：** 专门用于处理 `null` 或 `undefined` 的默认值设置。解决了 `||` 在处理 `0` 和 `\"\"` 时的缺陷。\n\n规则：** 只有当左侧操作数是 `null` 或 `undefined` 时，才返回右侧操作数。\n\nES2021 新增：逻辑赋值运算符\n\n- **`||=` (OR 赋值)：** 只有当左侧为 Falsy 时才赋值。\n\n- **`??=` (空值赋值)：** 只有当左侧为 `null` 或 `undefined` 时才赋值。\n\n其他：typeof  instanceof  delete",
          "hasAnswer": true
        },
        {
          "id": "js-basic-17",
          "title": "执行上下文",
          "content": "JavaScript 引擎在运行代码时，会维护一个 **执行上下文栈 (Execution Context Stack)**，也称为调用栈 (Call Stack)。\n\n- **入栈：** 当代码开始执行或调用函数时，新的执行上下文会被创建并推入栈顶。\n\n- **出栈：** 当函数执行完毕，其上下文会从栈中弹出，控制权返回给栈中的上一个上下文。\n\n- **流程：** 栈底永远是 **全局执行上下文**。\n\n全局执行上下文：它创建全局对象（ `window`、Node.js 中的 `global`）和 `this` 绑定。\n\n函数执行上下文 ：每当一个函数被调用时，都会创建一个新的~~。每次调用都是独立的\n\n阶段一：创建阶段 (Creation Phase / 编译阶段)\n\n在代码执行之前，引擎会扫描函数代码，完成以下三项任务：\n\n1. 确定 `this` 绑定 (ThisBinding)：全局 EC绑定到全局对象；函数EC按调用方式绑定\n\n2. 创建词法环境 (LexicalEnvironment)：存储 `let`、`const`  `class` 声明\n\n3. 创建变量环境 (VariableEnvironment)：用于存储 `var` 变量声明和函数声明\n\n阶段二：执行阶段 (Execution Phase)\n\n引擎开始逐行执行代码，完成以下任务：\n\n1. **变量赋值：** 将值赋给变量（之前在创建阶段被初始化为 `undefined` 或保持未初始化状态）。\n\n2. **代码执行：** 执行所有函数调用和其它语句。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-18",
          "title": "词法环境",
          "content": "**词法环境 (Lexical Environment)** 是 **ECMAScript 标准中定义的具体数据结构**，它是执行上下文（EC）的核心组成部分。它是一个**运行时 (runtime) 对象**，在每个执行上下文创建时生成。它有两个关键部分：\n\n1. **环境记录 (Environment Record)：**\n   \n   - 实际存储变量和函数声明的地方。\n   \n   - **声明式环境记录：** 存储 `let`、`const`、`class`。它们被创建时不会初始化，从而产生**暂时性死区 (TDZ)**。\n   \n   - **对象环境记录：** 在全局 EC 中，存储 `var` 变量和函数。\n\n2. **外部环境引用 (Outer Environment Reference)：**\n   \n   - 指向**创建该执行上下文时的父级执行上下文的词法环境**。\n   \n   - 这个引用链条就是 **作用域链 (Scope Chain)** 的基础，用于变量查找。\n\n总结： 当我们在函数内部访问变量时，JS 引擎会首先在当前 执行上下文 的中查找，如果找不到，就会沿着 **作用域链** 向上查找，直到全局 EC，所以函数能访问外部的变量，这也是闭包的前提。\n\n`let` 在 `for` 循环中会为每次迭代创建独立的词法环境，因此闭包捕获的是不同的 i，而不是同一个变量。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-19",
          "title": "作用域",
          "content": "js讨论词法作用域，**词法作用域 (Lexical Scope)** 是一个**抽象的、静态的编程原则或规则**。\n\n- **性质：** 它只取决于代码在 **哪里被编写 (定义)**，与代码在运行时 **哪里被调用** 无关。\n\n- **作用：** 它决定了变量的可访问性范围。\n\n词法环境是 JavaScript 引擎用来**记录和追踪**变量，严格遵守**词法作用域**规则",
          "hasAnswer": true
        },
        {
          "id": "js-basic-20",
          "title": "Set、Map、WeakSet、weakMap 的区别",
          "content": "Weak 系列与普通系列的本质区别，就在于**垃圾回收 (GC)** 机制。\n\n1. 强引用 (Strong Reference)：Map & Set\n- 如果一个对象被 `Map` 或 `Set` 引用，那么这个对象就不会被垃圾回收机制回收。\n\n- **副作用：** 如果你将 DOM 元素或大型对象作为键或值存储在 `Map` 或 `Set` 中，即使该对象在代码中已无其他引用，它也会被 Map/Set **钉死在内存中**，直到你手动调用 `.delete()` 移除，否则会导致**内存泄漏**。\n2. 弱引用 (Weak Reference)：WeakMap & WeakSet\n- 如果一个对象**只**被 `WeakMap` 或 `WeakSet` 引用，那么这个对象**可以**被垃圾回收机制回收。\n\n- **自动清理：** 一旦对象被 GC 回收，它在 `Weak` 集合中的对应条目也会被 **自动移除**。\n\n- **副作用消除：** 它们专为**不干扰 GC** 的非核心数据存储而设计，是避免内存泄漏的强大工具。\n3. Weak 集合的特殊限制（不可迭代的原因）\n\n`WeakMap` 和 `WeakSet` 具有不可迭代性，也不支持 `.clear()` 或 `.size` 属性。\n\n- **原因：** 由于它们是弱引用，集合中的对象随时可能被 GC 回收而消失。\n\n- **后果：** 如果允许迭代，你将无法保证在迭代开始和结束时集合内容的一致性，这会导致代码逻辑不可预测。\n\n高级应用场景（Use Cases）\n\nA. WeakMap：关联私有数据或缓存\n\n- **场景：** 在不修改原对象的情况下，为其关联额外的数据或缓存。\n\n- **示例：** 创建一个 `WeakMap` 来存储 DOM 元素的事件监听器。当 DOM 元素被移除时（被 GC 回收），WeakMap 中对应的事件监听器也会自动清理，**防止内存泄漏**。\n\nB. WeakSet：跟踪对象状态或成员资格\n\n- **场景：** 简单地跟踪一个大型对象集合中，哪些对象处于“活动”或“已处理”状态，但又不想阻止这些对象被 GC 回收。\n\n- **示例：** 跟踪一个大型应用中哪些对象实例已经被初始化或激活，用于防止重复处理。\n\n总结来说，`Set` 和 `Map` 是通用的数据结构，用于**核心数据存储**；而 `WeakSet` 和 `WeakMap` 是用于**关联辅助数据、解决内存泄漏问题**的**工具**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-21",
          "title": "es6新特性",
          "content": "1. 作用域与变量管理 (Scope & Mutability)\n- **`let` 和 `const`：** 引入**块级作用域 (Block Scoping)**，彻底解决了 `var` 导致的变量提升和作用域污染问题，增强了代码的稳定性和可预测性。\n2. 异步编程基石 (Async Foundation)\n- **Promises：** 提供了结构化、可链式调用的异步处理方案，解决了传统回调函数的**回调地狱 (Callback Hell)**，是 `async/await` 的底层基础。\n3. 函数与上下文 (Functions & Context)\n- **箭头函数 (`=>`)：** 语法简洁。核心价值在于使用**词法 `this`**，消除了普通函数中 `this` 绑定不明确的痛点，使上下文指向更加可靠。\n4. 数据结构与模块化 (Data & Structure)\n- **`class` 语法：** 基于原型继承的**语法糖**，使面向对象编程（OOP）更接近传统语言模式，提高了可读性。\n\n- **解构赋值/扩展运算符 (`...`)：** 极大地简化了数据操作，如数组合并、对象浅拷贝、函数参数收集等，提高了代码简洁性。\n\n- **`Map` 和 `Set`：** 提供了更高效的数据结构，解决了传统 JS 对象作为键的限制 (`Map`) 和快速去重 (`Set`) 的需求。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-22",
          "title": "ES6模块和Common]S模块的区别",
          "content": "核心区别在于 **CommonJS 是为服务器端同步加载设计的**，而 **ES Modules 是为浏览器端异步加载和静态分析设计的**。\n\n- CJS 是在 Node.js 环境中诞生的，文件模块通常存储在本地硬盘上。因此，CJS 可以使用 `require()` **同步阻塞**地加载文件。它在**运行时**执行代码后，才能知道导入了什么。\n\n- **ES Modules (异步)：** ESM 是为浏览器设计的，模块通常需要通过网络请求加载。因此，ESM 采用**异步加载**，以避免阻塞主线程。ESM 在**代码静态解析阶段**（编译时）就能确定所有依赖关系。\n\n- **CommonJS (动态值拷贝)：**\n  \n  - CJS 导出的是一个值的**拷贝**。一旦模块导出，原始模块内部对变量的修改不会影响到导入方。\n  \n  - `require()` 得到的是一份导出的**值的快照**。\n\n- **ES Modules (静态实时绑定/引用)：**\n  \n  - ESM 导出的是对原始变量的**引用**（Live Binding）。\n  \n  - 这意味着导入方和导出方共享同一个变量。如果导出方在后续代码中修改了该变量，导入方可以观察到这种变化。\n\n**ESM 的优势：** 由于 ESM 采用 `import` / `export` 这种**静态语法**，JS 引擎或构建工具（如 Webpack/Rollup）可以在不执行代码的情况下，分析出模块之间的依赖关系。这使得 **Tree-Shaking（摇树优化）**成为可能，即只打包实际用到的代码，极大地减小了最终产物大小。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-23",
          "title": "Object.create(proto) 方法",
          "content": "其中 *proto* 是新对象的原型对象\n\n`Object.create()` 的主要目的**不是复制 (Clone)** 一个现有对象，而是创建一个**新对象**，并精确控制新对象的**原型 (Prototype)**。\n\n`Object.create()` 的第一个参数是 **强制要求** 传入的，它就是新创建对象的 **`[[Prototype]]` (即 `__proto__`)**。\n\n核心能力是作为 **ECMAScript 官方提供的、创建指定原型对象**的方法，它是实现纯净原型继承的最佳实践。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-24",
          "title": "Object.assign()",
          "content": "`Object.assign(target, ...sources)` 方法用于将所有**可枚举 (enumerable) 的自有属性 (own properties)** 的值，从一个或多个**源对象 (source)** 复制到**目标对象 (target)**。\n\n返回值： 返回修改后的目标对象 `target`。\n\n仅执行浅拷贝 (Shallow Copy Only)\n\n只复制可枚举的自有属性\n\n一般用于**合并配置对象 (Merging)：** 将默认配置与用户提供的配置合并。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-25",
          "title": "箭头函数与普通函数的差异",
          "content": "没有this, 继承外层作用域的 `this`。\n\n不能new\n\n不能call bind apply\n\n没有 `arguments` 对象\n\n不支持 `yield` 关键字",
          "hasAnswer": true
        },
        {
          "id": "js-basic-26",
          "title": "arguments 的定义与作用",
          "content": "`arguments` 是一个特殊的**类数组对象 (Array-like Object)**，它在函数被调用时自动创建，并包含函数被调用时实际传入的所有参数。\n\n**作用域：** 仅存在于**非箭头函数**的函数体内部。\n\n可迭代对象，但不是数组 可以通过传统的 `for` 循环进行遍历或者Array.from(arguments)\n\n```js\nfunction sum(a, b) {\n  // 访问第一个参数\n  console.log(arguments[0]); // 对应传入的 a\n  // 访问所有参数数量\n  console.log(arguments.length); \n\n  // 即使函数没有定义第三个参数，也可以通过 arguments 访问\n  if (arguments.length > 2) {\n    console.log('还有额外的参数：', arguments[2]);\n  }\n}\n\nsum(10, 20, 30); \n// 输出: 10\n// 输出: 3\n// 输出: 还有额外的参数： 30\n```\n\n更推荐用es6的剩余参数\n\n```js\nfunction sumAll(...args) {\n  // args 是一个真正的数组，可以直接使用数组方法\n  return args.reduce((acc, current) => acc + current, 0);\n}\n\n// 优势：\n// 1. args 是一个真正的数组，可以直接调用 map, reduce 等方法。\n// 2. 没有参数绑定的困扰。\n// 3. 语法更清晰。\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-27",
          "title": "for..in for..of区别：",
          "content": "KEY in OBJECT, VALUE of ITERABLE",
          "hasAnswer": true
        },
        {
          "id": "js-basic-28",
          "title": "async/await 的实现原理是什么?它和Promise、Generator之间有什么关系?",
          "content": "`async/await` 是对 **Promise** 和 **Generator** 的一种**语法糖 (Syntactic Sugar)**。\n\n- **Promise** 是 `async/await` 的**外部接口**（输入和输出）。\n\n- **Generator** 是 `async/await` 实现**暂停和恢复**的**内部引擎**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-29",
          "title": "let/const/var 的底层区别",
          "content": "1.作用域 \n\nvar 函数作用域。在函数外部声明时是全局作用域。\n\n`let` / `const`块级作用域 。变量的作用域限制在最近的一对花括号 `{}` 内\n\n2.变量提升\n\nvar 完整提升。声明和初始化同时提升到作用域顶部，但初始化为 `undefined`\n\n`let` / `const` 只提升声明。声明会被提升，但不会被初始化。存在暂时性死区，在变量声明语句执行之前，访问该变量都会抛出 `ReferenceError`\n\n3.绑定与赋值\n\nvar 可以重复声明，在全局作用域声明时，会挂载到 `window` 或 `global` 对象。\n\nlet、const **不允许重复声明**。在同一作用域内重复声明会抛出 `SyntaxError`。也不会挂载到全局对象上。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-30",
          "title": "Proxy 和 Reflect 的应用场景",
          "content": "1.Proxy ： 对象操作拦截\n\n`Proxy` 的核心价值在于**对对象的操作进行非侵入式（Non-invasive）的拦截和定制**。它提供了一个代理层，允许我们在对象操作的 13 个内部方法（如 `get`, `set`, `apply`, `construct`）被调用时介入。\n\n应用：\n\n响应式系统和状态管理（最重要，比如vue）；`Proxy` 可以直接监听对象属性的增删改查，而不需要像 `Object.defineProperty` 那样预先遍历所有属性，解决了数组和新增属性的监听难题。\n\n数据校验与属性保护：在 `set` 拦截器中，加入自定义的校验逻辑（如类型检查、范围检查），如果不通过则抛出错误或拒绝赋值，防止不合规的数据流入\n\n实现私有属性：在 `get` 或 `has` 拦截器中，对特定前缀（如 `_` 开头的属性）返回 undefined` 或 `false`，模拟私有属性效果。\n\n<mark>2.`Reflect` </mark>\n\n不是一个函数，而是一个静态对象，它提供了 13 个静态方法，这些方法与 `Proxy` 的 13 个拦截器方法一一对应。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-31",
          "title": "事件循环",
          "content": "初始同步脚本执行完毕，**执行上下文栈（ECS）清空时**，事件循环机制才真正开始接管，并进入检查队列的循环。\n\n所有的异步事件一定是当前浏览器执行完同步任务空闲了才做的",
          "hasAnswer": true
        },
        {
          "id": "js-basic-32",
          "title": "promise",
          "content": "优点：\n\n解决回调地狱，改为链式回调，提高了代码的可读性和维护性\n\n统一的错误处理机制，集中捕获，简化流程\n\n规范异步状态管理，明确的三种状态：Pending/Fulfilled/Rejected, 使异步操作的结果可预测和可追踪。\n\n易于组合和并行处理，.all .race 等\n\n缺点：\n\n仍然是链式结构（未完全同步化）需要显式的 `.then()` 链来组织代码流程\n\n立即执行的特性，缺乏中断和取消机制\n\n一次性结果，一旦状态确定，就无法再次改变\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获",
          "hasAnswer": true
        },
        {
          "id": "js-basic-33",
          "title": "异步",
          "content": "计时器 settimeout setInterval，宏任务\n\n网络请求与文件操作：\n\n- **`fetch(url)` (现代标准):** 微任务\n  \n  - 返回一个 Promise 对象，用于发起网络请求。\n  \n  - 是最常用的网络请求 API，取代了大部分 XHR 用法。\n\n- **`XMLHttpRequest` (XHR) (传统方法):** 特指基于事件监听而不是promise的，是宏任务\n  \n  - 传统的回调式 API，现在主要用于文件上传等特定场景，或需要浏览器底层控制的场合。\n\n- **`FileReader` / 各种 I/O 操作:** 也是通过回调或 Promise返回，宏任务\n\n异步流程控制与状态管理：Promise async/await，微任务",
          "hasAnswer": true
        },
        {
          "id": "js-basic-34",
          "title": "Generator是什么怎么用",
          "content": "Generator 函数（生成器）是一种特殊的函数，它能够**暂停执行**并在稍后**从暂停点恢复执行**。这是通过 Generator 函数内部维护的一个 **状态机 (State Machine)** 来实现的。\n\n`function*`定义 Generator 函数\n\n`yield`暂停函数执行，并返回 `yield` 后的值\n\n`.next()`恢复函数执行，并返回一个包含 `{value, done}` 的对象。\n\n意义：简化异步编程；提供函数**暂停和恢复执行**的底层能力 (`yield` 机制)，这是实现“等待”的唯一方式；返回一个同时满足可迭代和迭代器协议的对象\n\nGenerator 解决了 **代码流的连续性** 问题，这是 Promise （依赖于 回调函数）无法做到的。\n\n`async/await` 的底层基础是 Promise，但它的核心机制是 Generator",
          "hasAnswer": true
        },
        {
          "id": "js-basic-35",
          "title": "Generator和 Async/Await 原理",
          "content": "核心机制：状态机\n\n普通函数从头到尾执行一次，没有状态。而 Generator 函数被编译后，其函数体内的每一行代码（特别是 `yield` 语句）都成为了状态机中的一个节点。\n\n`yield` 关键字：暂停的指令（将 Generator 函数的执行上下文完整地保存，并挂起，引擎立即将控制权返回给调用者所在的执行上下文，即调用 `gen.next()` 的那个上下文）\n\n`.next()` 方法：恢复的指令（执行优先级非常高，因为它是一个**同步操作**，讲挂起的上下文放入当前执行栈，会影响后续其他的宏任务微任务，就像一个同步函数调用）\n\nGenerator 对象的生命周期内，其内部状态（包括局部变量）被持续存储在内存中，这就是它能够从上次离开的地方继续执行的原因。\n\n```js\nfunction* numberGenerator() {\n  console.log('--- 启动 ---');\n  let result1 = yield 1;\n\n  console.log('--- 恢复，接收到:', result1, '---');\n  let result2 = yield 2; \n\n  console.log('--- 恢复，接收到:', result2, '---');\n  return 3;\n}\n\n// 1. 调用 Generator 函数，返回迭代器对象（Generator Object）\nconst gen = numberGenerator(); \n\nconsole.log(gen.next()); \n// 输出: --- 启动 ---\n// 输出: { value: 1, done: false } (遇到第一个 yield 暂停)\n\nconsole.log(gen.next('A')); // 将 'A' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: A ---\n// 输出: { value: 2, done: false } (遇到第二个 yield 暂停)\n\nconsole.log(gen.next('B')); // 将 'B' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: B ---\n// 输出: { value: 3, done: true } (遇到 return 结束)\n\nconsole.log(gen.next());\n// 输出: { value: undefined, done: true } (已完成)\n```\n\n`async/await` 是 ES7 (ES2016) 引入的，它的底层是基于 **Promise** 和 **Generator** 实现的**语法糖 (Syntactic Sugar)**。它的核心原理是**自动化**了 Generator 的驱动过程，相当于异步完成后自动调用了.next\n\n开放题：",
          "hasAnswer": true
        },
        {
          "id": "js-basic-36",
          "title": "你觉得js里this的设计怎么样?有没有什么缺点啥的",
          "content": "`this` 的设计初衷是为了实现高度的**灵活性**和**代码复用**。通过显式绑定隐式绑定可以更加灵活\n\n`this` 的所有缺点都源于一个核心问题：**它的值是动态绑定（Runtime Dynamic Binding）的，依赖于函数的调用点 (Call Site)，而不是定义点。**\n\n有严重的上下文丢失陷阱：回调函数问题： 当一个对象的方法被作为参数传递给异步函数（如 `setTimeout`、`Promise.then()`）或事件处理器时，它通常会失去其隐式绑定，退化为**默认绑定（指向全局对象或 `undefined`）**。\n\n违反词法作用域原则 ：JavaScript 的变量（使用 `let/const`）是词法作用域（静态确定）的，但 `this` 却是动态作用域的。这种不一致性打破了语言的统一性，使得在阅读嵌套代码时很难预测 `this` 的值。\n\nes6通过箭头函数和class弥补了这个问题，开发者应当尽可能利用箭头函数和 `class` 语法来避免直接依赖普通函数的动态 `this` 机制",
          "hasAnswer": true
        },
        {
          "id": "js-basic-37",
          "title": "proxy写法",
          "content": "```javascript\nconst handler = {\n    // 陷阱 (Trap)：拦截属性的读取操作\n    get(target, prop, receiver) {\n        if (prop === 'message3') {\n            return `[${target.message1} ${target.message2}]`;\n        }\n        // 默认行为：返回目标对象的属性值\n        return Reflect.get(target, prop, receiver); \n    },\n    // ... 比如 set(target, prop, value, receiver) { ... }\n}\nconst target = {\n    message1: \"Hello\",\n    message2: \"World\"\n};\nconst proxy = new Proxy(target, handler);\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-38",
          "title": "Reflect 是什么？怎么用",
          "content": "`Reflect` 是一个内置对象，它提供了一系列静态方法，这些方法与 `Proxy` 陷阱的方法**同名且参数一致**。\n\n例如：\n\n- 以前获取对象属性：`obj.prop` 或 `Object.getOwnPropertyDescriptor(obj, prop)`\n\n- 现在通过 `Reflect`：`Reflect.get(obj, prop)`\n\n- `'prop' in obj` $\\rightarrow$ `Reflect.has(obj, 'prop')`\n\n- `delete obj.prop` $\\rightarrow$ `Reflect.deleteProperty(obj, 'prop')`\n\n在 `Proxy` 的 `handler` 中，我们经常需要执行目标对象上的默认操作。使用 `Reflect` 可以干净、安全地实现这一点。\n\n`Reflect` 将一些命令式的操作符（如 `delete`）或命令式的方法调用（如 `new`）转换成了函数式的调用，使得代码更易于维护和理解。\n\nReflect 能提供操作失败的明确反馈，返回一个**布尔值**表示成功或失败，代码更简洁。一般的 `Object` 上的方法（例如 `Object.defineProperty`），在执行失败时会抛出异常，这需要用 `try...catch` 捕获。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-39",
          "title": "Object.defineProperties 的作用",
          "content": "把参数2的属性赋值给参数1，特点是不仅复制属性，还复制属性的属性，比如是否可枚举、可修改这些属性\n\n- 不仅仅是赋值，而是**使用属性描述符定义属性**\n\n- 可以控制属性的可写性、可枚举性、可配置性\n\n- 可以定义访问器属性（getter/setter）\n\n- 默认属性特性与普通赋值不同",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "typescript",
      "name": "TypeScript",
      "questions": [
        {
          "id": "typescript-1",
          "title": "type 和 interface 的区别",
          "content": "interface 接口 可合并可多次定义，更适合定义对象或者 api 的标准和形状\n\ntype 不可多次声明，可以定义任何类型，包括对象、联合类型、交叉类型、原始类型、元组",
          "hasAnswer": true
        },
        {
          "id": "typescript-2",
          "title": "TypeScript 与 JavaScript 的主要区别",
          "content": "ts: **静态类型**：类型在代码编写时确定。必须通过 **TS 编译器**（或 Babel/SWC 等）编译成 JS 后才能执行；编译时检查，**类型安全**高；JS 的**超集**，包含了 JS 的所有特性\n\njs：动态类型，类型在执行时确定；运行时检查，**类型安全**低（运行时错误多）",
          "hasAnswer": true
        },
        {
          "id": "typescript-3",
          "title": "什么是联合类型 (|) 和交叉类型 (&)",
          "content": "联合类型 | （或） 表示一个值可以是所列类型中的任意一种。\n\n交叉类型 & (且) **表示一个值必须同时满足所列的**所有类型。常用于合并接口或类型，实现 Mixin 效果。一个交叉类型对象必须拥有所有类型的属性。",
          "hasAnswer": true
        },
        {
          "id": "typescript-4",
          "title": "any 和 unknown 的区别",
          "content": "any **完全禁用**类型检查。可以赋值给任何类型，**破坏**类型安全。可以随意访问属性或调用方法，可能导致运行时错误。\n\nunknow **严格类型检查**，除非明确类型收窄，否则无法使用。只能赋值给 `any` 或 `unknown` 本身，**保持**类型安全。**必须先进行类型收窄**（如 `if (typeof x === 'string')`），才能操作。\n\n更推荐 unknow 提供了一个类型安全的占位符",
          "hasAnswer": true
        },
        {
          "id": "typescript-5",
          "title": "类型断言及其使用场景",
          "content": "类型断言是告诉 TypeScript 编译器“我比你更清楚这个变量的实际类型”的一种方式。它不会改变变量的运行时类型，只在编译时起作用\n\n**应避免使用的场景：**\n\n- **不确定的情况下：** 任何你不 100% 确定类型的时候。错误的断言会**绕过 TS 的保护**，导致在运行时出现错误（这是 TS 极力避免的）。\n\n- **可以进行类型收窄的情况下：** 应优先使用类型保护（`if`, `instanceof` 等）进行收窄，而不是使用断言",
          "hasAnswer": true
        },
        {
          "id": "typescript-6",
          "title": "解释 keyof 和 typeof 的用法",
          "content": "| **`typeof`** | **值到类型**。获取一个 JavaScript **变量**或**表达式**的类型。                 | 常用于获取函数的返回值类型，或从常量对象中提取类型。   |\n| ------------ | ------------------------------------------------------------------------------ | ------------------------------------------------------ |\n| **`keyof`**  | **键名提取**。获取一个**对象类型**中所有属性名组成的**联合字符串字面量类型**。 | 常用于泛型约束，确保传入的属性名是对象中真实存在的键。 |\n\n```js\nconst User = {\n    name: 'Alice',\n    age: 30\n};\n\n// 1. typeof：获取 User 变量的类型\ntype UserType = typeof User; // 结果: { name: string; age: number; }\n\n// 2. keyof typeof：获取 User 类型的所有键名\ntype UserKeys = keyof typeof User; // 结果: \"name\" | \"age\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-7",
          "title": "tsconfig.json 中的 strict 模式",
          "content": "**`\"strict\": true`** 是 `tsconfig.json` 中的一个总开关，它同时开启了一系列严格的类型检查规则。它的作用是**最大化地提升代码的类型安全性**。\n\n我认为 **`strictNullChecks`**（严格空值检查）是最重要的子选项。\n\n- **作用：** 默认情况下，`null` 和 `undefined` 可以赋值给任何类型。开启后，`null` 和 `undefined` 只能赋值给它们自己的类型或 `any`，除非类型定义中明确包含它们（如 `string | null`）。",
          "hasAnswer": true
        },
        {
          "id": "typescript-8",
          "title": "装饰器及其应用场景",
          "content": "饰器是一种特殊的声明，它能够附加到类、方法、属性或参数上，用于**修改或扩展**这些目标的功能或行为。它们是 **ES 阶段性提案**，TS 率先实现。\n\n装饰器本质上就是一个**函数**。这个函数在运行时会被调用，它接收关于被装饰目标的元数据（如目标类、方法名、属性描述符等），并可以通过返回新的值来**修改或替换**被装饰目标的定义。\n\n装饰器允许我们在不修改原有类结构和代码的情况下，通过注入元数据或实现额外逻辑，对现有功能进行扩展。\n\n1. 语法\n\n装饰器使用 `@expression` 的形式，紧挨着要装饰的声明之前。\n\n```ts\n@sealed // 这是一个装饰器\nclass Example {\n  @logMethod // 这是另一个装饰器\n  myMethod() {}\n}\n```\n\n2. 启用\n\n装饰器目前是 ECMAScript 的**阶段性提案**（Stage 3），不是标准的 JS 语法。要在 TypeScript 中使用它，必须在 `tsconfig.json` 中启用：\n\nJSON\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true, // 必须开启\n    \"emitDecoratorMetadata\": true // 如果需要依赖注入等元数据，也需要开启\n  }\n}\n```\n\n3.类型：类 属性 方法 Getter/Setter 方法参数\n\n作用\n\n1 依赖注入 (DI) 和框架配置，装饰器（或等效的语法）来标记类和处理依赖注入。比如 vue-property-decorator\n\n2 混入 (Mixins) 或功能增强（类装饰器）：可以利用类装饰器返回一个新的构造函数，为类添加新方法或属性：\n\n3.运行时 添加通用逻辑（方法装饰器）：方法装饰器常用于不修改原函数体的情况下，在其执行前后添加通用逻辑\n\n当一个声明上有多个装饰器时，它们的执行顺序如下：\n\n1. **参数装饰器 $\\to$ 属性装饰器 $\\to$ 方法/访问器装饰器 $\\to$ 类装饰器**（从内向外，从上到下）。\n\n2. **同一类型装饰器：** 如果同一目标上有多个装饰器，它们会像函数组合一样，**从下到上**（从右到左）执行。",
          "hasAnswer": true
        },
        {
          "id": "typescript-9",
          "title": "处理第三方库没有类型定义的问题",
          "content": "当引入一个没有内置类型定义的第三方 JS 库时，需要手动为其添加类型声明，以让 TS 编译器识别其结构。\n\n**处理步骤：**\n\n1. **检查 `@types/` 库：** 首先尝试 npm 生态系统中有没有针对这个第三方 JavaScript 库的**对应的类型定义库**。比如@types/jquery @types/lodash，有的话安装库就行了\n\n2. **创建自定义声明文件 (`.d.ts`)：** 如果 `@types` 包不存在，需要手动创建声明文件，通常命名为 `custom.d.ts` 或 `library-name.d.ts`。\n\n   a.**模块声明：** 使用 `declare module` 声明整个模块的类型。\n\n```typescript\n// my-library.d.ts\ndeclare module 'my-library' {\n  // 声明库导出的函数\n  export function initialize(config: object): void;\n  // 声明库导出的类\n  export class AwesomeClient {\n    connect(): Promise<string>;\n  }\n  // 声明默认导出\n  export default AwesomeClient;\n}\n```\n\nb.全局变量声明：如果库是注入全局变量的（如 jQuery），则使用 `declare var` 或 `declare function`。\n\n这样，TypeScript 编译器就会信任您提供的类型信息，并在您的项目代码中提供类型检查和智能提示。\n\n注意：全局/局部声明：\n如果是 declare module xx{...}，就只针对引用这个 module 的模块，如果是有顶层 export 就只针对导入这个文件的模块，如果直接 declare xx 且文件里没有任何顶层 export 就是全局的\n\n这里的**全局**和**局部（模块）**指的完全是 **TypeScript 编译器**对您的代码和声明文件（`.d.ts`）中**类型和标识符作用域**的认识",
          "hasAnswer": true
        },
        {
          "id": "typescript-10",
          "title": "Extract、Exclude、Pick、Omit 的区别与用法",
          "content": "Extract 提取\n\n- 是一个内置的工具类型，它的作用是**从一个联合类型中，提取出符合特定条件的成员**，并组成一个新的联合类型。\n\n- 可以把它理解为联合类型的“过滤器”。支持**子类型**的匹配\n\n- 原理：遍历 `T` 中的每一个成员。如果该成员能够赋值给 `U`，就保留它（返回 `T`）；否则就丢弃它（返回 `never`）。 `type MyExtract<T, U> = T extends U ? T : never;`\n\n```ts\ntype Result = Extract<Type, Union>;\n\ntype Status = 'success' | 'error' | 'loading' | 'waiting';\n// 我只想从中提取出 'error' 和 'success'\ntype FinalStatus = Extract<Status, 'success' | 'error'>;\n// 结果：'success' | 'error'\n\ntype MyData = string | number | boolean | (() => void);\n// 提取出所有可以赋值给 Function 的类型\ntype OnlyFunction = Extract<MyData, Function>; // 结果：() => void\n```\n\nExclude 排除\n\n**Exclude** 就是 **Extract** 的反义词\n\n`Exclude<T, U>`：排除 `T` 中属于 `U` 的\n\n```ts\ntype Status = 'success' | 'error' | 'loading';\ntype NoError = Exclude<Status, 'error'>; // 结果：'success' | 'loading'\n```\n\nPick（挑选）\n\n`Pick<Type, Keys>` 允许你从一个类型中，选择一组特定的属性来构造新类型。\n\n- **语法**：`Pick<T, K>`，其中 `T` 是源类型，`K` 是由 `T` 的键组成的联合类型。\n\n- **适用场景**：当你只需要一个大型对象中的某几个字段时\n\n- **实现**：它遍历 `K` 中的每一个键，并在 `T` 中找到对应的类型。\n\nOmit（剔除）\n\n`Omit<Type, Keys>` 与 `Pick` 相反，它会从一个类型中剔除指定的属性，剩下的属性组成新类型。\n\n- **语法**：`Omit<T, K>`。\n\n- **适用场景**：当你想复用一个类型，但其中某个字段不需要，或者需要被重新定义时\n\n- **实现**：它结合了 `Exclude` 和 `Pick`。先从 `T` 的所有键中排除掉 `K`，再把剩下的键 `Pick` 出来。\n\n```ts\ntype Hello = { a: string; b: string; c: number };\n\n// 使用 Pick 挑选属性\ntype OnlyAB = Pick<Hello, 'a' | 'b'>;\n// 结果为：\n// type OnlyAB = { a: string; b: string;}\n```\n\n对比：\n\n- **`Extract Exclude`**：操作的是**联合类型**，第二个参数是类型集合。是从一堆类型选项里选出几个\n\n- **`Pick Omit`** 处理的是对象类型, 第二个参数是属性集合，根据属性键进行选择或忽略\n\n- **`Pick`**：可以理解为白名单操作的是**对象接口（Interface/Object Type）**。它是从一个对象的属性里选出几个。 `Pick` 会严格检查选择的键是否存在于原类型中，如果你 Pick 一个不存在的键，编译器会报错\n\n- **Omit**：可以理解为黑名单。在使用 `Omit` 时，TS **不会**检查你剔除的键是否存在于原类型中（因为 `K extends keyof any`）。\n\n```ts\ninterface User {\n  id: string;\n  name: string;\n  age: number;\n}\n// 剔除 id 属性\ntype CreateUserDto = Omit<User, 'id'>;\n/*\n等同于：\ntype CreateUserDto = {\n  name: string;\n  age: number;\n};\n*/\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-11",
          "title": "TypeScript 基本数据类型",
          "content": "- boolean（布尔类型）\n- number（数字类型）\n- string（字符串类型）\n- array（数组类型）\n- null 和 undefined 类型\n- object 对象类型\n- tuple（元组类型） 允许表示一个已知元素数量和类型的数组，各元素的类型不必相同\n- enum（枚举类型）\n- void 类型 用于标识方法返回值的类型，表示该方法没有返回值\n- any（任意类型）可以指定任何类型的值，不进行类型检查而是通过编译阶段的检查\n- unknow 不确定的类型 ：**严格类型检查**，除非明确类型收窄，否则无法使用。\n- never 类型 代表从不会出现的值，是其他所有类型的子类型，可以赋值给任何类型\n\n```\nlet tupleArr:[number, string, boolean];\ntupleArr = [12, '34', true]; //ok\ntypleArr = [12, '34'] // no ok\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-12",
          "title": "TypeScript 类与修饰符",
          "content": "形式跟`ES6`十分的相似，`typescript`在此基础上添加了修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问（ ES6 私有字段用#表示（ES2022））\n- 受保护 protected：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n- 只读属性`readonly`：只读属性必须在声明时或构造函数里被初始化\n- static (ES6 也有) ：静态属性/方法：是类的属性而不是实例的属性，直接通过类调用\n\n```ts\nclass Square {\n    static width: number // 类的属性\n    public static height: number\n    public name: string;     // 公开（默认）\n    private secret: string;  // 仅类内访问\n    protected age: number;   // 类和子类访问\n    readonly id: number;     // 只读属性\n    public readonly publicReadonly: string  // 只读\n    static readonly PI: number = 3.14159; // static + readonly\n    public static readonly staticPublicReadonly: string = \"\";\n    // 方法类似\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-13",
          "title": "抽象类",
          "content": "抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n\n```ts\nabstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earch...');\n  }\n}\n\nclass Cat extends Animal {\n  makeSound() {\n    console.log('miao miao');\n  }\n}\nconst cat = new Cat();\ncat.makeSound(); // miao miao\ncat.move(); // roaming the earch...\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-14",
          "title": "和 ES6 对比",
          "content": "TypeScript 类在 ES6 类的基础上增加了**静态类型系统**和**面向对象增强特性**。主要区别有：\n\n1. **类型注解**：属性、方法、参数都有明确类型\n\n2. **访问修饰符**：`public/private/protected/readonly`\n\n3. **抽象类和抽象方法**：不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n4. **额外语法**：装饰器、泛型等\n\n**关键理解**：TypeScript 类是带类型的 ES6 类，大部分特性在编译后会被移除，最终生成标准的 JavaScript 类。",
          "hasAnswer": true
        },
        {
          "id": "typescript-15",
          "title": "TypeScript 函数特性",
          "content": "默认参数：es6 写法\n\n剩余参数：es6 写法\n\n可选参数：ts\n\n和 ES6 对比：TypeScript 函数在 ES6 函数的基础上增加了**静态类型系统**。主要区别有：\n\n1. **类型注解+更严格的编译时检查**：参数、返回值都有明确类型\n\n2. **函数重载**：支持多个函数签名，提高类型安全\n\n3. **泛型函数**：支持类型参数化，创建可复用的函数模板\n\n4. **可选参数语法**：使用  `?`  明确表示可选参数",
          "hasAnswer": true
        },
        {
          "id": "typescript-16",
          "title": "泛型的定义与使用",
          "content": "泛型允许编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型\n\n在`typescript`中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性\n\n泛型通过`<>`的形式进行表述，可以声明：函数 接口 类\n\n```\nfunction returnItem<T>(para: T): T {\n    return para\n}\ninterface ReturnItemFn<T> {\n    (para: T): T\n}\nclass Stack<T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-17",
          "title": "高级类型",
          "content": "- 交叉类型 `T & U`\n\n- 联合类型 `T | U`\n\n- 条件类型 `T extends U ? X : Y`\n\n- 类型别名 ,可以是泛型 ,也可以使用类型别名来在属性里引用自己：\n\n  ```ts\n  type some = boolean | string;\n  type Container<T> = { value: T };\n  type Tree<T> = {\n    value: T;\n    left: Tree<T>;\n  };\n  ```\n\n- 类型索引：keyof，类似于  `Object.keys` ，用于获取一个接口中 Key 的联合类型。\n\n- 类型约束：通过关键字  `extend`  进行约束，泛型内使用的主要作用是对泛型加以约束\n\n  ```ts\n  type BaseType = string | number | boolean;\n  // 这里表示 copy 的参数\n  // 只能是字符串、数字、布尔这几种基础类型\n  function copy<T extends BaseType>(arg: T): T {\n    return arg;\n  }\n  ```\n\n- 映射类型：通过  `in`  关键字做类型的映射，遍历已有接口的  `key`  或者是遍历联合类型\n\n  ```ts\n  type Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n  };\n  interface Obj {\n    a: string;\n    b: string;\n  }\n  type ReadOnlyObj = Readonly<Obj>;\n  // 等同于\n  interface ReadOnlyObj {\n    readonly a: string;\n    readonly b: string;\n  }\n  ```",
          "hasAnswer": true
        },
        {
          "id": "typescript-18",
          "title": "命名空间 namespace",
          "content": "解决命名污染，使用  `namespace`  来定义，类似模块化\n\n```ts\nnamespace SomeNameSpaceName {\n  export interface ISomeInterfaceName {}\n  export class SomeClassName {}\n}\n// 使用\nSomeNameSpaceName.SomeClassName;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-19",
          "title": "条件类型中的 extends 判断",
          "content": "T extends U ：是 TypeScript 的条件类型语法，用于判断类型  `T`  是否可以赋值给类型  `U`，类似于判断  `T`  是否为  `U`  的子类型（或相同类型）。在分布式条件下，如果  `T`  是联合类型，那么会拆开每个成员分别判断。\n\n```ts\ntype A = 'a' | 'b' | 'c';\ntype B = 'a' | 'b';\n\n// 判断 'a' 是否可以赋值给 B？可以，因为 'a' 在 B 中。\n// 判断 'b' 是否可以赋值给 B？可以。\n// 判断 'c' 是否可以赋值给 B？不可以。\n\n// 所以 Exclude<A, B> 会计算：\n// 'a' extends B ? never : 'a' → never\n// 'b' extends B ? never : 'b' → never\n// 'c' extends B ? never : 'c' → 'c'\n// 合并：never | never | 'c' → 'c'\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-20",
          "title": "为什么  string | null extends null  是  false？",
          "content": "**理解  `extends`  的含义**：在 TypeScript 中，`T extends U`  表示：\n\n- **类型 T 的值可以安全地赋值给类型 U 的变量**\n\n- 或者说：**类型 T 是类型 U 的子类型**",
          "hasAnswer": true
        },
        {
          "id": "typescript-21",
          "title": "infer 关键字的用法",
          "content": "只能在 **条件类型 (Conditional Types)** 的 `extends` 子句中使用。在类型的条件判断中，“声明”一个变量来捕获（提取）某个特定的类型。\n\n可以理解为：infer 告诉编译器：不要让我手动指定这个类型，请你根据当前的上下文，帮我**推断**出这里的具体类型并挂载到变量名下。\n\n我不需要知道 R 是什么，我让 TS 自己去“挖”，不是开发者指定的，是编译器“猜”出来的。\n\n对比泛型：本质上是**参数**，调用时具体什么类型是明确的\n\n可以像正则表达式一样拆分字符串。\n\n```ts\n// 不需要知道 R 是什么，我让 TS 自己去“挖”\ntype MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n// 使用时：\ntype Result = MyReturnType<() => string>;\n// TS 就像做“填空题”一样，把 () => string 和 (...args: any[]) => R 对齐，\n// 发现 R 的位置刚好是 string，于是 R 就被赋值为 string。\n\n// 拆分字符串\ntype GetColor<T> = T extends `color:${infer C}` ? C : 'unknown';\ntype MyColor = GetColor<'color:red'>; // \"red\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-22",
          "title": "映射类型中的 - + 修饰符",
          "content": "- `-`  只能用于  `readonly`  和  `?`，**不能用于  `private`/`protected`!**\n\n- 这些操作只能在映射类型（`[P in keyof T]`）中使用\n\n- 可以组合使用：`-readonly -?`\n\n- 可以递归应用以处理嵌套对象\n\n添加修饰符（默认或显式使用  `+`）\n\n```ts\n// 显式添加（可选写法）\ntype ExplicitReadonly<T> = {\n  +readonly [P in keyof T]: T[P];  // 显式添加 readonly\n};\n\ntype ExplicitPartial<T> = {\n  +? [P in keyof T]: T[P];  // 显式添加 ?\n};\n```\n\n移除修饰符（使用  `-`）\n\n```ts\n// 移除 readonly\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n// 移除可选（?）\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// 同时移除 readonly 和 ?\ntype MutableRequired<T> = {\n  -readonly [P in keyof T]-?: T[P];\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-23",
          "title": "映射类型",
          "content": "遍历一个类型的属性，并对每个属性应用某种转换，生成新的类型。注意不能遍历私有属性\n\n核心语法：`{ [K in Keys]: Type }`\n\n常用场景：批量修改修饰符；批量转换属性；批量改变键名\n\n语法支持：条件过滤，as 断言\n\n注意：\n\n- **一个类型内部只能有一个映射类型**\n- **映射不处理私有和受保护属性**\n- **映射类型会保留索引签名**\n- `keyof any = string | number | symbol`",
          "hasAnswer": true
        },
        {
          "id": "typescript-24",
          "title": "类型收窄（Type Narrowing）",
          "content": "类型收窄是指 TypeScript 通过代码流分析，在特定代码块中将变量的类型从较宽泛的类型缩小到更具体的类型。\n\n**常见的类型收窄方式：**\n\n1. **typeof 类型守卫**：\n\n```ts\nfunction print(x: string | number) {\n  if (typeof x === 'string') {\n    console.log(x.toUpperCase()); // x 被收窄为 string\n  } else {\n    console.log(x.toFixed(2)); // x 被收窄为 number\n  }\n}\n```\n\n2. **instanceof 类型守卫**：\n\n```ts\nfunction logDate(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toISOString()); // x 是 Date\n  }\n}\n```\n\n3. **in 操作符**：\n\n```ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    animal.swim(); // animal 是 Fish\n  }\n}\n```\n\n4. **自定义类型守卫（is 关键字）**：\n\n```ts\nfunction isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n```\n\n5. **真值收窄**：`if (x)` 排除 `null`、`undefined`、`0`、`''` 等\n\n6. **相等性收窄**：`if (x === y)` 或 `if (x !== null)`",
          "hasAnswer": true
        },
        {
          "id": "typescript-25",
          "title": "tsconfig.json 重要配置",
          "content": "| 配置项              | 作用                              |\n| ------------------- | --------------------------------- |\n| `strict`            | 总开关，开启所有严格类型检查      |\n| `strictNullChecks`  | null/undefined 不能赋值给其他类型 |\n| `noImplicitAny`     | 禁止隐式 any 类型                 |\n| `target`            | 编译目标版本（ES5/ES6/ESNext）    |\n| `module`            | 模块系统（CommonJS/ESNext/AMD）   |\n| `moduleResolution`  | 模块解析策略（node/bundler）      |\n| `baseUrl` + `paths` | 路径别名配置                      |\n| `outDir`            | 输出目录                          |\n| `rootDir`           | 源码根目录                        |\n| `declaration`       | 生成 `.d.ts` 声明文件             |\n| `esModuleInterop`   | 兼容 CommonJS 和 ES Module        |\n| `skipLibCheck`      | 跳过声明文件类型检查，加快编译    |\n| `resolveJsonModule` | 允许导入 JSON 文件                |\n| `jsx`               | JSX 编译方式（react/preserve）    |",
          "hasAnswer": true
        },
        {
          "id": "typescript-26",
          "title": "TypeScript 模块化",
          "content": "TypeScript 完全支持 ES Module 语法，同时兼容 CommonJS。\n\n**ES Module 语法**：\n\n```ts\n// 导出\nexport const name = 'hello';\nexport default function () {}\nexport type { MyType };\nexport { value as alias };\n\n// 导入\nimport defaultExport from './module';\nimport { name } from './module';\nimport type { MyType } from './module';\nimport * as all from './module';\n```\n\n**模块解析**：\n\n- `moduleResolution: \"node\"` - Node.js 风格解析\n- `moduleResolution: \"bundler\"` - 现代打包器风格（推荐）\n\n**路径别名**：\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n**命名空间 vs 模块**：现代 TS 项目推荐使用 ES Module，命名空间主要用于全局脚本环境。",
          "hasAnswer": true
        },
        {
          "id": "typescript-27",
          "title": "TypeScript 中的异步处理",
          "content": "TypeScript 为异步操作提供了完整的类型支持：\n\n**1. Promise 类型**：\n\n```ts\nfunction fetchData(): Promise<string> {\n  return fetch('/api').then((res) => res.text());\n}\n\n// 泛型指定返回值类型\nconst promise: Promise<number> = Promise.resolve(42);\n```\n\n**2. async/await**：\n\n```ts\nasync function getData(): Promise<User[]> {\n  const response = await fetch('/api/users');\n  return response.json(); // 自动推断返回 Promise<User[]>\n}\n```\n\n**3. 错误处理类型**：\n\n```ts\nasync function safeFetch<T>(url: string): Promise<T | null> {\n  try {\n    const res = await fetch(url);\n    return res.json();\n  } catch {\n    return null;\n  }\n}\n```\n\n**4. 并发处理**：\n\n```ts\n// Promise.all 自动推断元组类型\nconst [user, posts] = await Promise.all([\n  fetchUser(), // Promise<User>\n  fetchPosts(), // Promise<Post[]>\n]); // user: User, posts: Post[]\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-28",
          "title": "接口继承",
          "content": "**单继承**：\n\n```ts\ninterface Animal {\n  name: string;\n}\ninterface Dog extends Animal {\n  breed: string;\n}\n// Dog 拥有 name 和 breed 两个属性\n```\n\n**多继承**：\n\n```ts\ninterface Flyable {\n  fly(): void;\n}\ninterface Swimmable {\n  swim(): void;\n}\ninterface Duck extends Flyable, Swimmable {\n  quack(): void;\n}\n```\n\n**接口继承类**：\n\n```ts\nclass Point {\n  x: number = 0;\n  y: number = 0;\n}\ninterface Point3D extends Point {\n  z: number;\n}\n```\n\n**interface vs type 继承对比**：\n\n- interface 用 `extends` 继承\n- type 用 `&` 交叉类型实现类似效果\n- interface 可以被多次声明并自动合并，type 不行",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "css-html",
      "name": "CSS & HTML",
      "questions": [
        {
          "id": "css-html-1",
          "title": "tailwind",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "css-html-2",
          "title": "less sass scss 作用",
          "content": "Less、Sass、SCSS*都是 CSS 预处理器。它们的作用是：\n\n- **扩展 CSS 语言：** 引入了变量、嵌套、混合 (Mixins)、函数、继承、条件语句等编程特性，让 CSS 的编写更具逻辑性和可维护性。\n\n- **提高开发效率：** 通过嵌套可以减少重复选择器；通过变量可以实现主题和统一管理颜色值。\n\n- **编译到原生 CSS：** 浏览器无法直接识别预处理器的语法，因此它们都需要一个**编译 (Compile)** 过程，将其特有的语法转换为浏览器能理解的 **标准 CSS 文件**。",
          "hasAnswer": true
        },
        {
          "id": "css-html-3",
          "title": "em rem",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "css-html-4",
          "title": "小程序rpx和px在不同手机上有误差",
          "content": "误差的可能原因：当 `rpx` 换算成的 `px` 不是一个整数时，浏览器或小程序框架会进行取舍 。误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。\n\n避免使用极小的 `rpx` 值。使用偶数的 rpx 值",
          "hasAnswer": true
        },
        {
          "id": "css-html-5",
          "title": "苹果手机1px",
          "content": "- **设备像素比 (DPR > 1)：** 在 iPhone 等高分屏设备上，`1px` (CSS 像素) 可能等于 $2$ 个或 $3$ 个物理像素。但开发者希望绘制的是**最细的 1 物理像素线**。\n\n- **浏览器最小绘制限制：** 当你使用 `border: 1px solid #000;` 时，浏览器会将这个 CSS 像素值放大。如果你在 JavaScript 或 CSS 中尝试计算出 $0.5px$ 并应用，浏览器（尤其是 iOS 上的 Safari/WebView）可能会认为 $0.5px$ **低于其最小渲染阈值**，从而将该边框**优化（忽略）**掉，导致边框看起来被“隐藏”了。\n\n解决方案：利用 CSS transform 缩放 (主流且有效)\n\n该方案利用伪元素，将元素放大到 2 倍，然后使用 `transform: scale(0.5)` 缩放回 1 倍，达到 1 物理像素的边框效果。",
          "hasAnswer": true
        },
        {
          "id": "css-html-6",
          "title": "meta标签",
          "content": "`<meta>` 标签用于定义 HTML 文档中的**元数据 (Metadata)**，即描述 HTML 文档本身的信息。它通常放在 `<head>` 标签内。\n\n常见应用场景：\n\n1. **字符集声明:** `<meta charset=\"UTF-8\">`（**最重要**，定义文档的编码方式）。\n\n2. **视口设置 (Viewport):** 移动端适配核心\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   ```html\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   ```",
          "hasAnswer": true
        },
        {
          "id": "css-html-7",
          "title": "语义化标签的应用场景和优势",
          "content": "用恰当的 HTML 元素来描述内容的**结构和含义**，而不是仅仅关注其默认的样式\n\nheader nav main article section footer h1-h6  form等\n\n可访问性 搜索引擎优化 可读性和可维护性  跨设备兼容性",
          "hasAnswer": true
        },
        {
          "id": "css-html-8",
          "title": "Canvas vs SVG 的区别和选择",
          "content": "canvas 位图：图像复杂、像素操作多、需要频繁重绘\n\nSVG 矢量图：图像简单、需要清晰缩放、需要与图形进行交互、需要良好的可访问性",
          "hasAnswer": true
        },
        {
          "id": "css-html-9",
          "title": "HTML5 表单验证和自定义验证",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "css-html-10",
          "title": "CSS3 动画性能优化方案",
          "content": "性能优化核心是**减少重排 (Reflow/Layout)** 和**重绘 (Repaint)**，并尽可能利用 GPU 加速。\n\n1.使用 `transform` 和 `opacity` 进行动画： 只会触发**合成 (Compositing)**，不会触发重排和重绘，性能最高，可以直接利用 GPU 加速。\n\n2.开启 GPU 硬件加速：`transform: translateZ(0);` 或 `will-change: transform, opacity;`，将元素提升到合成层，利用 GPU 渲染\n\n3.使用 `will-change` 属性：\n\n4.避免使用 `all` 进行transition：\n\n5.**减少 DOM 元素和层次：",
          "hasAnswer": true
        },
        {
          "id": "css-html-11",
          "title": "移动端 1px 边框问题解决方案",
          "content": "CSS `transform: scale()` 缩放 (主流推荐): 将元素的伪元素 (`::before` 或 `::after`) 设置为 `1px` 宽或高，然后通过 `transform: scale(0.5)` 将其在 Y 轴或 X 轴上缩放 50%",
          "hasAnswer": true
        },
        {
          "id": "css-html-12",
          "title": "CSS 模块化和作用域方案",
          "content": "**CSS 模块化**的目的是解决 CSS 全局污染、命名冲突和样式依赖管理的问题。",
          "hasAnswer": true
        },
        {
          "id": "css-html-13",
          "title": "前端性能优化之 CSS 优化策略",
          "content": "1. **合并与压缩 CSS 文件：**\n\n2. **利用媒体查询 (Media Queries) 按需加载：**\n   \n   使用 `<link rel=\"stylesheet\" media=\"(max-width: 600px)\" href=\"mobile.css\">`，只有在符合条件时才加载相应样式。\n\n3. **减少 CSS 嵌套和选择器复杂度：**\n   \n   复杂的选择器（如 `div > ul > li:last-child`）会增加浏览器计算匹配的成本。\n\n4. 避免在 HTML 中使用内联样式 (`style=\"...\"`)：内联样式会增加 HTML 文件体积，且不利于样式复用和缓存。\n\n5. 将 `<link>` 标签放在 `<head>` 顶部：让浏览器尽快下载和解析 CSS，避免**白屏时间**过长。",
          "hasAnswer": true
        },
        {
          "id": "css-html-14",
          "title": ".\"请描述一个你如何使用SVG来增强网站视觉体验的情况。\"",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "css-html-15",
          "title": "\"解释CSS中的BEM命名方法，并展示如何使用它来组织你的样式表。",
          "content": "**BEM** 是 **Block (块)、Element (元素)、Modifier (修饰符)** 的缩写，是一种用于组织 CSS 类名的命名规范。它旨在解决 CSS 全局作用域带来的命名冲突和样式依赖问题，使样式代码更具可读性和可维护性。示例：.card__title--large   .card__image--dark\n\n```css\n.user-card {\n    display: flex;\n    padding: 20px;\n    border: 1px solid #ccc;\n\n    /* 2. Modifier: .user-card--vip (变体) */\n    &--vip {\n        border-color: gold;\n        box-shadow: 0 0 5px gold;\n    }\n...\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "css-html-16",
          "title": "\"你将如何处理跨浏览器的兼容性问题，尤其是在不同设备和操作系统上?\"",
          "content": "- **制定统一的兼容性基线：**\n  \n  - 首先确定项目需要支持的**最低浏览器版本和设备范围**（如 IE11+、最近 2 个版本的 Chrome/Firefox/Safari/Edge、iOS 14+、Android 10+）。\n  \n  - **渐进增强 (Progressive Enhancement):** 优先保证核心功能在所有浏览器中可用，然后为现代浏览器添加高级功能和更优的体验。\n  \n  - **优雅降级 (Graceful Degradation):** 先为现代浏览器构建，然后确保在老旧浏览器中也能以合理的方式工作。\n\n- **编码规范与工具：**\n  \n  - **CSS 前缀：** 使用 **Autoprefixer** 等工具，自动为 CSS3 属性（如 `transform`、`flex`、`grid`）添加必要的浏览器厂商前缀（如 `-webkit-`, `-moz-`）。\n  \n  - **CSS Reset/Normalize：** 使用 **Normalize.css** 或 **Reset.css** 来统一不同浏览器对标签默认样式的差异。\n  \n  - **Polyfills 和 Transpilers：**\n    \n    - 使用 **Babel** 将 ES6+ 的 JavaScript 语法编译为 ES5，以兼容老旧浏览器。\n    \n    - 使用 **Polyfills**（如 `core-js`）为老旧浏览器提供缺失的现代 API（如 `Promise`、`fetch`）。\n\n- **兼容性处理技巧：**\n  \n  - **Flexbox/Grid 兼容性：** 明确知道哪些属性在旧版本浏览器上不支持，并提供备用方案（例如对不支持 Flexbox 的浏览器使用 `float` 布局）。\n  \n  - **特性检测：** 相比于用户代理 (UA) 检测，优先使用 **特性检测 (Feature Detection)**，如 Modernizr，来判断浏览器是否支持某一 CSS 或 JS 特性，并据此执行不同的代码分支。\n\n- **测试与验证：**\n  \n  - 在真实的设备、操作系统和浏览器组合上进行测试。\n  \n  - 使用 **BrowserStack**、**Sauce Labs** 等云测试平台进行自动化和手动兼容性测试。\n  \n  - 利用 Chrome DevTools 的**设备模拟器**和**网络限速**功能进行快速调试",
          "hasAnswer": true
        },
        {
          "id": "css-html-17",
          "title": "在一个复杂的页面上，用户操作导致多次不必要的DOM操作，你将如何优化它?",
          "content": "不必要的 DOM 操作是前端性能的常见瓶颈，因为它会频繁触发浏览器的 **重排 (Reflow/Layout)** 和 **重绘 (Repaint)**。优化策略核心是**减少操作次数**和**批量处理操作**。\n\n1. **使用文档片段 (DocumentFragment) 批量操作：**\n   \n   - **原理：** `DocumentFragment` 是一个轻量级的容器，它**不是真实的 DOM 树的一部分**。将所有需要添加或修改的元素先插入到 `DocumentFragment` 中，然后只需进行**一次**操作，将 `DocumentFragment` 整体插入到 DOM 中。\n   \n   - **优化效果：** 只触发**一次**重排和重绘。\n\n2. **避免频繁读写 DOM 属性：**\n   \n   - **问题：** 连续读取（如 `element.offsetWidth`）和写入（如 `element.style.width = '100px'`）操作会导致“强制同步布局”——浏览器为了保证读取到的值是最新的，会立即执行挂起的重排。\n   \n   - **优化：** 应该**先读取**所有需要的 DOM 属性，然后**集中进行写入**操作。\n\n3. **使用防抖 (Debounce) 和节流 (Throttle)：**\n   \n   - **场景：** 针对用户输入、`resize`、`scroll`、`mousemove` 等高频触发的事件。\n   \n   - **防抖：** 将多次触发合并成一次，只在事件停止触发后执行一次（如搜索框输入）。\n   \n   - **节流：** 在一个时间周期内，事件只执行一次（如页面滚动）。\n\n4. **使用 Virtual DOM (适用于组件化框架)：**\n   \n   - React、Vue 等框架通过 **Virtual DOM** 将所有的 DOM 操作放入内存中进行对比，计算出最小的更新路径，然后一次性批量应用到真实 DOM 上，从框架层面解决了不必要的 DOM 操作问题。\n\n5. **用 CSS 类代替内联样式：**\n   \n   - 避免直接操作 `element.style`，因为它会导致样式计算和布局的开销。\n   \n   - **优化：** 预先定义好 CSS 类，通过增删改元素的 `className` 或 `classList` 来改变样式。\n\n6. **将元素脱离文档流：**\n   \n   - 如果必须对一个元素进行多次复杂的 DOM 操作，可以先通过设置 `display: none` 或将其从 DOM 中移除，进行操作，然后重新插入/显示。脱离文档流的操作不会触发整个页面的重排。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "react",
      "name": "React",
      "questions": [
        {
          "id": "react-1",
          "title": "fiber：",
          "content": "1、具体做了什么事情\n2、具体场景的执行优先级\n3、怎么进行任务的终止的",
          "hasAnswer": true
        },
        {
          "id": "react-2",
          "title": "commit阶段过程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-3",
          "title": "render阶段过程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-4",
          "title": "如何实现时间切片",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-5",
          "title": "fiber为什么是性能飞跃",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-6",
          "title": "为什么react更适合B端大型项目",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-7",
          "title": "为什么说react的组件和逻辑抽象和复用比vue强",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-8",
          "title": "那 react自定义hooks 和 Vue3 composable 本质区别？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-9",
          "title": "React 组件高度抽象和复用的自由有没有代价？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-10",
          "title": "React 组合能力强会带来哪些坑？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-11",
          "title": "hooks 原理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-12",
          "title": "为什么只能在顶层",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-13",
          "title": "看过 hooks 相关的草案吗",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-14",
          "title": "hook的闭包陷阱 如何解决",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-15",
          "title": "为什么usestate返回数组而不是对象",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-16",
          "title": "useeffect如何实现",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-17",
          "title": "usestate如何实现",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-18",
          "title": "useEffect怎么支持async await",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-19",
          "title": "react.memo的第二个参数是什么 作用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-20",
          "title": "memo为什么一定要和useMemo结合使用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-21",
          "title": "ref useref forwardRef 区别和作用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-22",
          "title": "useReducer的理解",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-23",
          "title": "能否之间把prop赋值给state",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-24",
          "title": "react组件间通信的方式",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-25",
          "title": "除了 redux mbox dva 还用过其他的 状态管理没",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-26",
          "title": "对比redux zustand",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-27",
          "title": "redux中间件的原理 举个例子",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-28",
          "title": "redux的使用原则",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-29",
          "title": "react 做了哪些事件优化",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-30",
          "title": "说说react的事件代理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-31",
          "title": "子组件portal能冒泡到父组件吗",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-32",
          "title": "组件状态保存keep-alive",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-33",
          "title": "路由懒加载原理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-34",
          "title": "link标签和a标签的区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-35",
          "title": "实现useUpdate useAsyncEffect useDebounce useTimeout",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-36",
          "title": "对比class组件和hook模拟生命周期的实现方式",
          "content": "17 18 19新特性",
          "hasAnswer": true
        },
        {
          "id": "react-37",
          "title": "函数组件和类组件的本质区别？代码层面如何判断",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-38",
          "title": "jsx转DOM过程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-39",
          "title": "diff算法核心",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-40",
          "title": "react性能优化",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-41",
          "title": "说说useReducer",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-42",
          "title": "对比useReducer和useState",
          "content": "18以前为什么useState不能批量更新，18以后为什么可以： 18以前在浏览器原生事件（如 setTimeout、Promise 回调、addEventListener 内部）中，React 认为已经脱离了控制流，也就是他们的回调是在一个全新的、异步的、与 React 渲染无关的执行上下文中运行的，所以setstate无法批量更新",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "vue",
      "name": "Vue",
      "questions": [
        {
          "id": "vue-1",
          "title": "Vuex 的核心概念和工作流程",
          "content": "**State** 单一状态树，存储应用的全部状态，作为\"唯一数据源\"。\n\n**Getter** 类似于计算属性，用于从 State 派生出新状态，具有缓存特性。\n\n**Mutation** 唯一允许修改 State 的方法。必须是**同步**函数，便于 DevTools 追踪状态变化。\n\n**Action** 负责提交 (`commit`) Mutation，可以包含**异步**操作或复杂的业务逻辑。\n\n**Module** 将 Store 分割成模块，每个模块拥有自己的 State、Getter、Mutation、Action，支持命名空间 (`namespaced: true`)。\n\nVuex 的数据流是**单向**的，遵循以下流程：\n\n1. **View (视图)**：用户在组件中触发一个操作。\n\n2. **Dispatch (分发)**：组件通过 `store.dispatch('actionName', payload)` 提交一个 **Action**。\n\n3. **Action (动作)**：Action 执行异步逻辑（如 API 调用）。一旦数据准备好，Action 会通过 `store.commit('mutationName', payload)` 提交一个 **Mutation**。\n\n4. **Commit (提交)**：**Mutation** 是唯一能修改 **State** 的地方。它同步地修改状态。\n\n5. **State (状态)**：状态被更新。\n\n6. **Render (渲染)**：由于 State 是响应式的，所有依赖此 State 的 **View** 组件会自动更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-2",
          "title": "对比 Vuex 和 Pinia",
          "content": "**Vuex** 是 Vue 2 时代的官方状态管理库，采用 Flux 架构，强调**单向数据流**和**严格的状态修改规范**（必须通过 Mutation）。适合大型项目，但模板代码较多，TS 支持需要额外配置。\n\n**Pinia** 是 Vue 3 官方推荐的状态管理库，可视为 Vuex 5。设计更简洁，去掉了 Mutation，原生支持 TypeScript，每个 Store 独立无需命名空间。\n\n| 特性         | Vuex                            | Pinia                               |\n| ---------- | ------------------------------- | ----------------------------------- |\n| 核心概念       | State, Getter, Mutation, Action | State, Getter, Action (去掉 Mutation) |\n| 修改状态       | 必须通过 Mutation（同步）               | Action 中直接修改 State                  |\n| TypeScript | 需要额外类型声明，配置繁琐                   | **原生支持**，类型自动推导                     |\n| 模块化        | 嵌套 Module，需要 `namespaced: true` | **独立 Store 实例**，按需导入，无需命名空间         |\n| 体积         | ~10KB                           | **~1KB**，更轻量                        |\n| DevTools   | 支持                              | 支持，体验更好                             |\n| SSR        | 需要额外配置                          | 开箱即用                                |\n| API 风格     | Options API 风格                  | 同时支持 Options 和 Composition API      |\n\n**选型建议**：新项目直接用 Pinia；Vue 2 老项目可继续用 Vuex，按需迁移。",
          "hasAnswer": true
        },
        {
          "id": "vue-3",
          "title": "响应式开发比命令式开发有什么优势？",
          "content": "1. **声明式编程**：只需描述**状态与视图的映射关系**，无需手动操作 DOM，代码更易读易维护。\n\n2. **自动更新**：状态变化时，框架自动处理 DOM 更新，开发者无需关心\"何时更新、更新哪里\"。\n\n3. **高效渲染**：Virtual DOM + Diff 算法，**精确计算最小 DOM 变化集**，避免不必要的 DOM 操作。\n\n4. **减少 Bug**：手动 DOM 操作容易遗漏或出错，响应式系统保证状态与视图一致性。\n\n5. **组件化开发**：状态封装在组件内部，提高代码复用性和可测试性。",
          "hasAnswer": true
        },
        {
          "id": "vue-4",
          "title": "什么是装饰器？在 Vue 中怎么用？",
          "content": "装饰器 (Decorator) 是一种特殊的声明，用于**修改类或类成员的行为**，本质是一个函数。\n\n**在 Vue 中的应用**（主要是 Vue 2 + TypeScript）：\n\n```typescript\nimport { Component, Prop, Watch } from 'vue-property-decorator';\n\n@Component\nexport default class MyComponent extends Vue {\n  @Prop({ default: '' }) readonly title!: string; // 声明 props\n\n  @Watch('title') // 监听属性变化\n  onTitleChange(val: string) {}\n}\n```\n\n**Vue 3 现状**：Composition API 已取代装饰器方案，官方不再推荐使用装饰器。原因：\n\n- Composition API 提供更好的类型推导\n- 装饰器提案尚未稳定\n- 函数式组合比类继承更灵活",
          "hasAnswer": true
        },
        {
          "id": "vue-5",
          "title": "如何保持组件状态、避免重复渲染？（keep-alive）",
          "content": "主要通过 Vue 的内置抽象组件 **`<keep-alive>`** 来实现。\n\n作用： ` <keep-alive>` 包裹动态组件或路由组件时，会**缓存不活动的组件实例**，而不是销毁它们。这可以避免组件在切换时被重复创建和渲染，从而**保持组件的状态**（如表单输入内容、滚动位置等），并提升性能。\n\n实现原理与钩子函数\n\n1. **缓存机制**：内部使用 `Map` 缓存 VNode，key 为组件名或自定义 key。\n\n2. **生命周期变化**：缓存后 `unmounted`/`destroyed` 不会触发，新增两个钩子：\n   \n   - **`activated()`**：组件被激活时（切换进来）触发\n   - **`deactivated()`**：组件被停用时（切换出去）触发\n\n3. **常用属性**：\n   \n   - `include`：只缓存匹配的组件（字符串/正则/数组）\n   - `exclude`：排除匹配的组件\n   - `max`：最大缓存数量，超出时使用 **LRU 算法**淘汰最久未使用的\n\n```html\n<keep-alive :include=\"['Home', 'List']\" :max=\"10\">\n  <router-view />\n</keep-alive>\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-6",
          "title": "Vue 2 和 Vue 3 响应式原理的区别？为什么改用 Proxy？",
          "content": "| 对比项  | Vue 2 (Object.defineProperty) | Vue 3 (Proxy)   |\n| ---- | ----------------------------- | --------------- |\n| 初始化  | 递归遍历所有属性，开销大                  | **惰性处理**，访问时才递归 |\n| 新增属性 | ❌ 无法检测，需用 `$set`              | ✅ 自动响应          |\n| 删除属性 | ❌ 无法检测，需用 `$delete`           | ✅ 自动响应          |\n| 数组索引 | ❌ 无法检测 `arr[0] = x`           | ✅ 自动响应          |\n| 数组长度 | ❌ 无法检测 `arr.length = 0`       | ✅ 自动响应          |\n\n**Vue 3 改用 Proxy 的原因**：\n\n1. **功能更全面**：Proxy 可拦截 13 种操作（get/set/delete/has/ownKeys 等）\n2. **性能更优**：惰性响应式，减少初始化开销\n3. **代码更简洁**：无需为数组方法打补丁",
          "hasAnswer": true
        },
        {
          "id": "vue-7",
          "title": "Vue 的渲染过程（模板 → DOM）",
          "content": "总结：\n\n初次：1 编译模板（解析 AST+标记+生成渲染函数）2 执行渲染函数生成 VDOM 3 渲染\n\n后续数据更新：1 执行渲染函数生成新 VDOM 2 diff 获得 patch 3 更新 DOM\n\n阶段一：模板编译 (Template Compilation)\n\n1. **解析 (Parse)**：将 HTML 模板字符串解析成抽象语法树 (AST - Abstract Syntax Tree)。AST 是一种用 JavaScript 对象来描述模板结构的树形结构。\n\n2. **优化 (Optimize)**：遍历 AST，标记静态节点 (Static nodes)。静态节点是指内容不会变化的节点。Vue 在后续的 Diff 过程中会跳过这些节点，**大幅提高性能**。\n\n3. **代码生成 (Generate)**：将优化后的 AST 转换成 **Render Function (渲染函数)**。渲染函数返回的就是 VNode (Virtual Node) 树。\n\n阶段二：创建虚拟 DOM (Virtual DOM Creation)\n\n1. **首次渲染**：执行第一步生成的 **Render Function**，它返回一棵 **VNode Tree (虚拟 DOM 树)**。\n\n阶段三：渲染和更新 (Patching & DOM Update)\n\n1. **首次渲染**：将 VNode Tree 转换成真实的 DOM 元素，并插入到页面中。同时，Vue 将这棵 VNode Tree 保存为 `oldVNode`。\n\n2. **数据更新**：响应式数据发生变化时，会触发组件的 Watcher，重新执行 Render Function，生成一棵 **`newVNode` Tree**。\n\n3. **比对 (Patch)**：Vue 运行 **Diff 算法**（Patch 过程），将 `newVNode` 与 `oldVNode` 进行递归比对。\n\n4. **最小化 DOM 操作**：Diff 算法找出两棵树之间**最小的差异集**。\n\n5. **更新 DOM**：Vue 只对这些有差异的真实 DOM 节点进行必要的创建、更新、移动或删除操作，从而完成视图更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-8",
          "title": "Vue Router 原理？Hash 和 History 模式的区别？",
          "content": "Vue Router 的核心是监听 URL 的变化，并根据配置的路由映射表，动态地渲染对应的组件。\n\n1. **路由映射 (Route Mapping)**：定义 URL 路径 (`path`) 与组件 (`component`) 的映射关系。\n\n2. **监听 URL 变化**：根据配置的模式（Hash 或 History），监听浏览器地址栏 URL 的变化事件。\n\n3. **匹配路由**：当 URL 变化时，Router 捕获新 URL，并在路由映射表中查找匹配的配置。\n\n4. **渲染组件**：将匹配到的组件渲染到 `<router-view>` 占位符的位置上。\n\n| 对比项    | Hash 模式               | History 模式                       |\n| ------ | --------------------- | -------------------------------- |\n| URL 形式 | `example.com/#/user`  | `example.com/user`               |\n| 原理     | `window.onhashchange` | `history.pushState/replaceState` |\n| 服务器配置  | 无需配置                  | **需要配置回退**（所有路由返回 index.html）    |\n| SEO    | 不友好（爬虫忽略 # 后内容）       | 友好                               |\n| 兼容性    | 所有浏览器                 | IE10+                            |\n\n**导航守卫**（补充高频考点）：\n\n- `beforeEach`：全局前置守卫，常用于登录验证\n- `beforeResolve`：全局解析守卫\n- `afterEach`：全局后置钩子\n- `beforeEnter`：路由独享守卫\n- `beforeRouteEnter/Update/Leave`：组件内守卫",
          "hasAnswer": true
        },
        {
          "id": "vue-9",
          "title": "如何自定义 Vue 指令？有哪些钩子函数？",
          "content": "自定义指令用于对 DOM 元素进行**底层操作**，实现可复用的 DOM 行为。例如：自动获取焦点、权限控制、拖拽功能等。\n\n```js\n// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nconst app = createApp(App);\n\n// 注册一个全局自定义指令 v-focus\napp.directive('focus', {\n  // 元素挂载到 DOM 时调用\n  mounted(el) {\n    el.focus(); // 使元素自动获取焦点\n  },\n});\n\napp.mount('#app');\n\n//组件内用directives注册\n```\n\n**Vue 3 指令钩子函数**：\n\n- `created`：元素属性/事件监听器应用前\n- `beforeMount`：挂载前\n- `mounted`：挂载后（常用）\n- `beforeUpdate`：更新前\n- `updated`：更新后\n- `beforeUnmount`：卸载前\n- `unmounted`：卸载后\n\n**常见应用场景**：自动聚焦、权限控制（v-permission）、防抖点击、图片懒加载、拖拽",
          "hasAnswer": true
        },
        {
          "id": "vue-10",
          "title": "Vue 应用性能优化有哪些方向？",
          "content": "- **运行时性能优化 (Runtime Performance)**\n  \n  - **合理使用 `v-if` 和 `v-show`**：\n    \n    - **`v-if`**：真正销毁/重建组件，适用于不频繁切换的场景。\n    \n    - **`v-show`**：仅切换 CSS `display` 属性，适用于频繁切换的场景。\n  \n  - **`v-for` 必须使用 `key`**：帮助 Vue Diff 算法更高效地进行元素追踪和复用。\n  \n  - **使用 `v-once`**：对于内容不依赖数据的静态子树，使用 `v-once` 只渲染一次，避免了后续的更新开销。\n  \n  - **组件拆分和懒加载 (Async Components)**：将大组件拆分为小组件，并使用动态 `import()` 实现组件的按需加载。\n  \n  - 精准依赖，对 store 或外部属性，精准引入，依靠 vue 对响应式数据的优化\n  \n  - **大列表优化 (虚拟滚动/Virtual Scrolling)**：对于包含数千个项目的长列表，只渲染可见区域的 DOM，大幅减少 DOM 节点数量。\n  \n  - **合理使用 `computed` vs `watch`**：`computed` 具有缓存机制，只有依赖项变化时才会重新计算，比 `watch` 更高效。\n  \n  - **使用 Vue 3 的 `shallowRef` (如果可以)**：对于嵌套层级很深但我们只关心顶层引用的数据，使用 `shallowRef` 来减少不必要的深度响应式处理。\n\n- **加载性能优化 (Loading Performance)**\n  \n  - **图片优化**：WebP 格式、懒加载、响应式图片\n  \n  - **路由懒加载**：使用 `const route = () => import('./components/Path')`，将不同路由组件的代码分割成不同的 chunk，实现按需加载。\n  \n  - **第三方库按需引入**：如使用 Babel 插件或 Vite 插件，对 Element-UI/Plus、Ant Design Vue 等库进行按需导入，而不是全量导入。\n\n- **工程化优化**\n  \n  - **Tree Shaking**：确保使用 ES Module，移除未使用代码\n  \n  - **代码分割**：Webpack/Vite 的 splitChunks，合理拆分 vendor 和业务代码\n  \n  - **Gzip 压缩**：服务端开启压缩，减少传输体积\n  \n  - **CDN 加速**：静态资源上 CDN，利用边缘节点加速\n  \n  - **预加载/预获取**：`<link rel=\"prefetch/preload\">` 提前加载关键资源\n  \n  - **缓存策略**：合理配置 HTTP 缓存头，利用浏览器缓存",
          "hasAnswer": true
        },
        {
          "id": "vue-11",
          "title": "项目中遇到过哪些 Vue 相关的难题？如何解决？",
          "content": "**示例回答框架**（根据实际经验调整）：\n\n**场景 1：大列表性能问题**\n\n- 问题：渲染上万条数据导致页面卡顿\n- 方案：引入虚拟滚动（vue-virtual-scroller），只渲染可视区域 DOM\n- 效果：DOM 节点从 10000+ 降到 ~50，滚动流畅\n\n**场景 2：组件通信复杂**\n\n- 问题：多层嵌套组件间状态共享困难，props 层层传递\n- 方案：引入 Pinia 管理全局状态 + provide/inject 处理局部共享\n- 效果：代码解耦，维护性提升\n\n**场景 3：内存泄漏**\n\n- 问题：组件卸载后定时器/事件监听未清理\n- 方案：在 `onUnmounted` 中统一清理，封装 `useInterval` 等 hooks\n- 效果：内存占用稳定\n\n**回答技巧**：描述具体场景 → 分析原因 → 解决方案 → 量化效果",
          "hasAnswer": true
        },
        {
          "id": "vue-12",
          "title": "nextTick 的作用和原理？",
          "content": "**作用**：在下次 DOM 更新循环结束之后执行回调，确保操作的是最新 DOM。\n\n**原理**：\n\n1. Vue 的数据变化触发 DOM 更新是**异步批量**的（同一事件循环内的多次修改合并为一次更新）\n2. DOM 更新任务被推入**微任务队列**（优先使用 `Promise.then`，降级用 `MutationObserver`、`setImmediate`、`setTimeout`）\n3. `nextTick(callback)` 将回调推入同一个微任务队列，排在 DOM 更新之后执行\n\n**执行顺序**：数据变化 → Setter → 派发更新 → 收集 Watcher → **微任务队列**（DOM 更新 → nextTick 回调）\n\n**常见使用场景**：\n\n```javascript\nthis.show = true;\nthis.$nextTick(() => {\n  this.$refs.input.focus(); // 确保 DOM 已渲染\n});\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-13",
          "title": "Vue 3 响应式丢失的原因和解决方案？",
          "content": "常发生在解构（Destructuring）**或**展开（Spreading）响应式对象时。\n\n```javascript\nconst state = reactive({\n  count: 0, // 这是一个被 Proxy 追踪的属性\n  name: 'Alice',\n});\n\n// --- ❌ 错误做法：响应式丢失 ---\n// 解构：将 state.count 的原始值赋给了新的局部变量 count。\n// 这两个变量已经没有任何关联。\nconst { count, name } = state;\n```\n\n**解决方案**：\n\n```javascript\n// 方案1：使用 toRefs 保持响应式\nconst { count, name } = toRefs(state); // count.value 是响应式的\n\n// 方案2：直接引用，不解构\nstate.count;\n\n// 方案3：使用 toRef 获取单个属性\nconst count = toRef(state, 'count');\n```\n\n**延伸：ref vs reactive**\n\n- `ref`：用于基本类型，通过 `.value` 访问，解构不丢失响应式\n- `reactive`：用于对象/数组，直接访问属性，解构会丢失响应式\n\n**最佳实践**：统一使用 `ref`，或始终用 `toRefs` 解构 `reactive` 对象。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "browser",
      "name": "浏览器",
      "questions": [
        {
          "id": "browser-1",
          "title": "浏览器点击url发生什么",
          "content": "DNS解析\n\n建立TCP连接，TLS连接\n\n请求HTML文件\n\n解析HTML并请求css js及其他\n\n构建 DOM 树\n\n**构建 CSSOM 树：** 解析 CSS 样式，生成 CSSOM (CSS Object Model) 树。\n\n**构建 Render Tree (渲染树)：** 将 DOM 树和 CSSOM 树合并，排除不可见的节点\n\n计算布局并绘制",
          "hasAnswer": true
        },
        {
          "id": "browser-2",
          "title": "window document",
          "content": "在浏览器环境中，所有全局变量和函数都是 `window` 的属性。它同时是全局作用域的代表。也是**DOM 和 BOM 的入口：** `document` (DOM) 和 `navigator`, `screen` 等 (BOM)。\n\n`document` 对象代表**浏览器窗口中加载的整个 HTML 文档**。是**DOM (Document Object Model) 的入口**。通过它，我们可以操作网页中的所有元素、内容和样式。\n\nDOM ：文档对象模型，提供了与页面内容和结构交互的能力（如查找元素、修改文本）\n\nBOM： 浏览器对象模型，提供了与浏览器窗口和环境交互的能力（如导航、历史记录、计时器），核心对象是window\n\nBOM包含DOM",
          "hasAnswer": true
        },
        {
          "id": "browser-3",
          "title": "V8垃圾回收",
          "content": "总结 V8 GC 流程\n\n1. **新生代：** 高频、快速的 **Scavenge 算法**，负责快速清理短期对象。\n\n2. **老生代：** 低频、复杂的  标记-清除（Mark-Sweep） 和 标记-整理（Mark-Compact）。算法，通过 增量标记 和 并发/并行技术来减少 减少停顿时间。",
          "hasAnswer": true
        },
        {
          "id": "browser-4",
          "title": "内存泄漏",
          "content": "常见原因：\n\n意外的全局变量\n\n未清除的定时器\n\n未移除的事件监听器\n\n闭包引用外部大对象\n\n未清除的DOM 引用\n\n排查：Chrome DevTools 的 **Memory** 面板\n\n1.录制堆快照-复现操作-录制快照\n\n2.对比分析：重点关注 “Delta”：特别是那些**数量持续增加且没有被回收**的构造函数。找到泄露的对象\n\n3.分析原因：**保留树**显示了**为什么这个对象没有被垃圾回收**。它列出了从全局根 (Root) 到该对象的引用链。顺着保留树向上查找，直到找到阻止 GC 回收的**不必要的全局引用、闭包、或 DOM 引用**。",
          "hasAnswer": true
        },
        {
          "id": "browser-5",
          "title": "跨域以及怎么解决",
          "content": "CORS (跨域资源共享)：Access-Control-Allow-Origin\n\nJSONP：利用 `<script>` 标签没有跨域限制的特性，通过动态创建 `<script>` 标签，以回调函数的形式传递数据。\n\n代理 (Proxy) **：前端代理 (Dev)**：在开发环境，通过 Webpack Dev Server 或 Vite 配置代理服务器，将请求转发到目标服务器。\n\n反向代理 (Nginx/Server)：配置 Nginx 或其他服务器，让请求先发给同源服务器，再由同源服务器转发给目标服务器。",
          "hasAnswer": true
        },
        {
          "id": "browser-6",
          "title": "浏览器内核",
          "content": "浏览器内核（或称渲染引擎，Rendering Engine）是浏览器的核心组件，主要负责：\n\n1. **渲染**：解析 HTML/XML/CSS，构建渲染树，并负责页面的布局和绘制。\n\n2. **脚本执行**：虽然 JavaScript 引擎（如 V8）是独立的部分，但渲染引擎需要协同 JavaScript 引擎。\n\n主流：\n\nblink: chrome edge \n\nWebKit: Safari\n\nGecko: Firefox\n\nTrident: IE",
          "hasAnswer": true
        },
        {
          "id": "browser-7",
          "title": "V8 引擎优化机制",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "browser-8",
          "title": "JavaScript 执行性能优化",
          "content": "减少重排 (Reflow) 和重绘 (Repaint)\n\n优化 JavaScript 执行效率：避免全局查找，减少复杂运算，减少作用域链查找\n\n内存管理： 避免内存泄漏，及时释放大对象\n\n节流 (Throttle) 和防抖 (Debounce)\n\n使用 Web Workers： 对于复杂的、耗时的计算任务（如大量数据处理），将其放在 **Web Worker** 中，避免阻塞主线程，确保 UI 响应流畅。",
          "hasAnswer": true
        },
        {
          "id": "browser-9",
          "title": "跨域解决方案：",
          "content": "1. **CORS（跨域资源共享）**：服务器设置响应头（如`Access-Control-Allow-Origin`）允许跨域。\n\n2. **JSONP**：利用`<script>`标签不受同源策略限制，通过回调函数获取数据。\n\n3. **WebSocket**：不受同源策略限制，可跨域通信。\n\n4. **postMessage**：iframe允许不同源窗口间通信。l\n\n5. **nginx反向代理**：配置nginx将请求代理到目标服务器。",
          "hasAnswer": true
        },
        {
          "id": "browser-10",
          "title": "浏器览的缓存",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "browser-11",
          "title": "怎么衡量一个页面的渲染速度，性能",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "browser-12",
          "title": "你对首屏时间，可交互时间等概念的理解和看法",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "browser-13",
          "title": "xss、csrf攻击原理和防范",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "browser-14",
          "title": "了解浏览器渲染引擎有哪些，渲染机制是怎样的吗，举例说明一下",
          "content": "",
          "hasAnswer": false
        }
      ]
    },
    {
      "id": "network",
      "name": "网络",
      "questions": [
        {
          "id": "network-1",
          "title": "五层网络模型",
          "content": "| **层次**                | **主要协议/设备**          | **主要功能**                          |\n| --------------------- | -------------------- | --------------------------------- |\n| **应用层 (Application)** | HTTP, DNS, SMTP, FTP | 负责处理特定的应用程序细节，为用户提供网络服务。          |\n| **传输层 (Transport)**   | TCP, UDP             | 提供进程间的通信（端口），负责数据的可靠传输或快速传输。      |\n| **网络层 (Network)**     | IP, ICMP, 路由器        | 负责数据包的路由和转发，确定数据传输的路径（IP 地址）。     |\n| **数据链路层 (Data Link)** | Ethernet, PPP, 交换机   | 负责物理地址寻址（MAC 地址），将数据封装成帧，提供点对点传输。 |\n| **物理层 (Physical)**    | 网线, 光纤, 集线器          | 负责比特流的传输，规定电压、接口标准等。              |",
          "hasAnswer": true
        },
        {
          "id": "network-2",
          "title": "七层网络模型",
          "content": "**物 数 网 传 会 表 应**\n\n| **应用层 (Application)**  | 提供用户接口，实现特定网络服务。       |\n| ---------------------- | ---------------------- |\n| **表示层 (Presentation)** | 数据格式转换、加密解密、压缩解压缩。     |\n| **会话层 (Session)**      | 建立、管理和终止会话（如同步通信）。     |\n| **传输层 (Transport)**    | **(同五层)** 进程间通信，可靠性保障。 |\n| **网络层 (Network)**      | **(同五层)** 路由寻址，数据包转发。  |\n| **数据链路层 (Data Link)**  | **(同五层)** 帧的传输，MAC 寻址。 |\n| **物理层 (Physical)**     | **(同五层)** 比特流传输。       |",
          "hasAnswer": true
        },
        {
          "id": "network-3",
          "title": "cookie",
          "content": "**Cookie** 是一种在客户端（浏览器）存储少量数据的机制。它主要用于在无状态的 HTTP 协议中实现**状态管理**。\n\n- **工作机制：**\n  \n  1. 服务器在 HTTP 响应头中通过 `Set-Cookie` 字段将数据发送给浏览器。\n  \n  2. 浏览器将这些数据以键值对的形式存储起来。\n  \n  3. 之后浏览器向同一域名发送请求时，会在请求头中自动带上 `Cookie` 字段发送给服务器。\n\n- **主要用途：**\n  \n  - **会话管理：** 存储用户登录状态、购物车内容等。\n  \n  - **个性化：** 存储用户偏好设置、主题等。\n  \n  - **追踪：** 记录用户行为，用于分析和广告。\n\n- **重要安全属性：**\n  \n  - `HttpOnly`: 阻止 JavaScript 通过 `document.cookie` 访问 Cookie，防止 XSS 攻击。\n  \n  - `Secure`: 仅在 HTTPS 连接中发送 Cookie。\n  \n  - `SameSite`: 用于防止 CSRF 攻击，限制 Cookie 跨站发送。",
          "hasAnswer": true
        },
        {
          "id": "network-4",
          "title": "http1.0 1.1 2.0 https",
          "content": "**HTTPS 补充：** HTTPS 是在 HTTP 层和 TCP 层之间插入 **TLS/SSL (安全传输层协议)** 的产物。\n\n- **核心作用：** 提供**数据加密、身份认证和数据完整性**。\n\n- **加密方式：** 采用**混合加密**机制，利用**非对称加密**（证书）进行身份认证和密钥交换，利用**对称加密**对后续数据进行高效加密传输。\n\n1.0：**非持久连接**，每次请求/响应后关闭 TCP 连接；频繁建立/关闭 TCP 连接\n\n1.1：**持久连接**，TCP 连接默认保持打开，可复用。支持 `PUT`, `DELETE` 等更多方法；支持 `Content-Range`、`Cache-Control` 等header，cookie增加了属性；仍有 **队头阻塞**\n\n2.0：**多路复用**，单个 TCP 连接上同时处理多个请求和响应，消除了队头阻塞；**支持头部压缩**，减少头部大小；**支持服务端推送**；但基于TCP的队头阻塞仍存在，HTTP/2 在网络质量差、丢包率高的情况下，性能可能比 HTTP/1.1 更差，因为 HTTP/1.1 至少可以通过多个连接（尽管数量有限）来分散风险\n\nHTTP/3 放弃了 TCP，转而使用 **QUIC 协议**，而 QUIC 是基于 **UDP** 实现的\n\n大多数现代浏览器（Chrome, Firefox, Edge）对**同一个域名 (Host)** 的最大并发 TCP 连接数限制在 **6 到 8 个**之间，针对1.1这个问题很明显",
          "hasAnswer": true
        },
        {
          "id": "network-5",
          "title": "TCP协议",
          "content": "TCP 是传输层最重要的协议之一，它提供**面向连接的、可靠的、基于字节流**的通信服务。\n\n- **面向连接：** 数据传输前需要经过**三次握手**建立连接，传输结束后需要经过**四次挥手**释放连接。\n\n- **可靠性：**\n  \n  - **序号 (Sequence Number) 与确认号 (Acknowledgment Number)：** 保证数据包按序到达，并对收到的数据进行确认。\n  \n  - **重传机制：** 发送方在收到确认前，会重传数据。\n  \n  - **校验和：** 检查数据在传输过程中是否被损坏。\n\n- **流量控制：** 利用**滑动窗口**机制，控制发送方的发送速率，防止接收方来不及处理数据而丢包。\n\n- **拥塞控制：** 通过慢启动、拥塞避免、快重传、快恢复等机制，防止网络整体性能下降。",
          "hasAnswer": true
        },
        {
          "id": "network-6",
          "title": "websocket：数据传输方式？状态码？怎么实现重连",
          "content": "WebSocket 协议建立在 HTTP 协议之上（通过 HTTP 握手）\n\n特点\n\n- **双向全双工通信：** 客户端和服务器可以在任何时间独立地向对方发送数据，无需等待对方的响应。\n\n- **基于帧 (Frame) 的数据传输：** 数据以更小、开销更低的**帧**为单位进行传输，而不是像 HTTP 那样需要完整的请求和响应头，大大降低了数据传输的开销和延迟。\n\n- **保持持久连接：** 连接一旦建立，就会一直保持打开状态，直到任意一方关闭或出现异常。\n\n- **独立的应用层协议**（虽然基于HTTP升级），有自己的安全机制，不是依赖浏览器的同源策略。**服务器在握手阶段通过验证 Origin 来控制访问**\n\n状态码：**成功的握手状态码：** `101 Switching Protocols`。\n\n- 客户端发送带有 `Upgrade: websocket` 和 `Connection: Upgrade` 头的 HTTP 请求。\n\n- 服务器如果支持，则返回 `101` 状态码，表示协议切换成功，连接正式升级为 WebSocket。\n\n怎么实现重连：由于网络抖动、服务器重启等原因，WebSocket 连接可能中断。\n\n1. **监听连接关闭事件：** 客户端通过监听 `WebSocket` 对象的 `onclose` 事件来检测连接中断。\n\n2. **设置重连计时器：** 在 `onclose` 事件中，启动一个定时器。\n\n3. **退避算法 (Backoff)：** 为了避免因网络持续中断导致客户端不断发起重连请求（**重连风暴**），应使用**指数退避**策略。\n   \n   - 第一次等待 1 秒，第二次等待 2 秒，第三次等待 4 秒，依此类推，直到达到最大重连次数或最大等待时间。\n\n4. **重新发起连接：** 定时器触发后，重新创建 `WebSocket` 实例并发起连接。",
          "hasAnswer": true
        },
        {
          "id": "network-7",
          "title": "http缓存",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "network-8",
          "title": "状态码",
          "content": "`304 Not Modified` (协商缓存命中)",
          "hasAnswer": true
        },
        {
          "id": "network-9",
          "title": "TCP三次握手和四次挥手的过程。为什么挥手是四次?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "network-10",
          "title": "ca证书是从哪里获取的",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "network-11",
          "title": "怎么保证 CA的有效性",
          "content": "CA 证书的有效性由**信任链 (Chain of Trust)** 和**数字签名**机制来保证。\n\n1. 浏览器/操作系统的信任列表：主流的 CA（称为**根 CA, Root CA**）的证书公钥**预装**在所有主流的操作系统和浏览器中，被标记为**受信任**的。这是信任的起点。\n\n2. 网站将自己的**公钥**提供给 CA，CA 用自己的**私钥**对包含网站公钥和信息的证书文件进行**签名**。再将网站公钥、网站信息和这个**数字签名** 封装在一起，形成了网站的 SSL/TLS 证书。\n\n3. 浏览器验证的网站的证书，使用 CA 的**公钥**（已预装或从信任链中获得）来**验证**这个签名",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "node",
      "name": "Node.js",
      "questions": [
        {
          "id": "node-1",
          "title": "node 做BFF代理前端请求，可以处理文件、注入信息、做中间层鉴权等",
          "content": "1. 统一进行数据聚合与裁剪：从多个后端服务获取数据，聚合后返回给前端\n\n2. 统一鉴权并注入加密信息，可以隔离敏感信息。把获取重要的加密信息放在服务端做，然后对前端的请求增加一层转发携带accessToken，可以完成更安全的身份校验不必担心数据暴露的风险\n\n3. 处理文件或查询数据库或进行协议转换：前端不必关心中间层，BFF可以注入必要的信息或进行文件处理，然后进行转发\n   优点\n   解耦前后端：前端只需对接 BFF，无需关心后端服务细节 \n   提升前端性能：减少请求次数，减小数据传输量 \n   灵活适配多端：可以为不同端提供定制化接口 \n   安全性增强：统一鉴权，隐藏内部服务 \n   便于前端开发：前端团队可以主导 BFF 开发，接口更贴合需求\n   缺点：\n   增加一层调用：网络延迟可能略微增加\n   维护成本：需要额外维护 BFF 层代码\n   可能成为瓶颈：如果设计不当，BFF 可能成为性能瓶颈\n   职责边界模糊：需要明确 BFF 和后端服务的职责划分\n\n4. 数据聚合与裁剪\n   BFF 的核心职责之一是从多个后端服务获取数据，聚合后返回给前端。\n\n5. 代理前端请求，并注入加密信息，目的是隔离敏感信息。把获取重要的加密信息放在服务端做，然后对前端的请求增加一层转发携带accessToken，可以完成更安全的身份校验不必担心数据暴露的风险",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "nextjs",
      "name": "Next.js",
      "questions": [
        {
          "id": "nextjs-1",
          "title": "nextjs 适用场景",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "nextjs-2",
          "title": "SSR",
          "content": "在传统的 SSR 架构（如早期的 React SSR）中，您确实需要维护两套入口（client-entry.js 和 server-entry.js），配置两套 Webpack，处理注水 (Hydration) 的各种样板代码。\nNext.js 把这一切都封装了。您只需要写一个 page.tsx，Next.js 会自动在服务器上把它渲染成 HTML，然后在客户端把它“激活”。对于开发者来说，只有一套代码，一套逻辑\nNext.js 的伟大之处在于，它让您在同一个项目、同一个文件结构、同一种语言中，流畅地穿梭于“服务端”和“客户端”之间。您不需要配置复杂的环境，但您需要清晰地知道“我现在是在服务器上（获取数据）”还是“我现在是在浏览器里（处理交互）”。这种无缝融合，正是它作为全栈框架的体验确实是目前业界领先于业界的关键。\n\n客户端组件在服务端执行时，只会生成静态 HTML。它的 useEffect、onClick 等逻辑不会运行。这些逻辑只有代码被下载到浏览器并“注水 (Hydrate)”后，才会真正在客户端执行。\n服务端组件 (RSC) 的代码，只在服务器上运行。零 JS 发送：这些组件的 JavaScript 代码永远不会被打包发送给浏览器。浏览器收到了什么？：浏览器接收到的是 RSC 执行后的结果（一种特殊的 JSON 数据格式，描述了 UI 的结构）。![](/Users/wzz/Library/Application%20Support/marktext/images/2025-12-01-00-06-38-image.png)\n\n服务端内容变成了纯数据：<h1>Hello Server</h1> 没有变成 HTML 标签，而是变成了一个描述：“这有一个 h1，内容是 Hello Server”。\n客户端组件变成了“占位符”：注意那个 \"$L2\"。它告诉浏览器：“这里应该放一个 ClientButton 组件。它的代码在 ClientButton.js 里，请去下载它，并把 initialCount: 10 传给它。”\n浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n在首次加载页面时，RSC Payload 是内嵌在 HTML 源码中的。浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n服务端组件只在服务端执行，所以不能调客户端的方法包括window等（Node.js 里根本就没有浏览器窗口的概念），也不能useeffect usestate，这些 Hooks 的作用是“在浏览器里管理状态和副作用”。既然 RSC 的代码都不发送给浏览器，这些 Hooks 自然也就毫无用武之地。\n\n客户端组件则是提前再服务端执行得到初始样式和HTML，浏览器加载完HTML后再下载并执行js文件进行水合（React 在浏览器里再次运行这个组件，这次它会执行 useEffect，并且把 onClick 事件监听器挂载到那个已经存在的按钮上。）\n\n当 Next.js 在服务器（Node.js）上渲染一个客户端组件时，它其实是在执行一个“阉割版”的 React 渲染流程：\n执行组件函数：Node.js 会像浏览器一样，去调用组件函数\n处理 Hooks (有特殊规则)：useState只取初始值；useEffect / useLayoutEffect: 直接跳过；useContext: 正常执行读取组件树上层的 Provider 里的值；\n生成 Virtual DOM：函数执行完，React 得到了一棵组件树。\n序列化为 HTML：React 的服务端渲染器 (ReactDOMServer) 遍历这棵树，把它转换成纯文本的 HTML 字符串（例如.  \\<div>\\<button>Click</button></div> ）。 \n\nApp Router 是 Next.js 13.4 之后推出的全新路由和渲染架构\n基于 app/ 目录：以前的页面写在 pages/ 里，现在的页面写在 app/ 里。\n默认 RSC：这是最大的区别。在 app/ 里写的组件，默认全是服务端组件。这彻底改变了开发模式。\n嵌套布局 (Nested Layouts)：支持 layout.tsx 嵌套，这是 Pages Router 做不到的。\n流式传输 (Streaming)：利用 React Suspense，可以把页面拆成碎片，一部分一部分地发给浏览器（比如先发个 loading 骨架屏，再发数据），极大地优化了 TTFB。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-3",
          "title": "RSC react server component",
          "content": "React Server Components 是 React 提出的 **一种让部分组件只在服务器端执行的渲染模式** \n它不是传统意义上的 SSR（Server-Side Rendering）那样生成完整 HTML，而是：\n\n> **在服务器执行组件逻辑，把渲染结果以特殊协议序列化成数据流发送给客户端，客户端再把这些数据解释成 UI。**\n\n核心特点：\n\n- 组件代码 **永远不发送到客户端**（不会打包到 bundle 里）。\n\n- 只能运行在服务器上，不能使用浏览器 API 和交互 Hooks（如 `useState`, `useEffect`）。主要用于数据密集型、展示型的 UI。\n\n- 主要用于数据密集型、展示型的 UI。\n\n这就能让 React 应用更“轻巧、高效、按需加载”。\n\n| 渲染方式        | JS 发送到客户端       | 数据获取模式         | 互动能力                 |\n| ----------- | --------------- | -------------- | -------------------- |\n| CSR (客户端渲染) | 全组件 JS          | 客户端请求 API      | 强                    |\n| SSR (服务端渲染) | 全组件 JS + HTML   | 服务端预取数据 → HTML | 交互需要 hydrate         |\n| **RSC**     | **只发送必要的交互 JS** | 服务器直接数据访问      | 交互需 Client Component |\n\nReact Server Components 是一种服务器执行的组件模式，它让 UI 的渲染和数据获取在服务端完成，只把 UI 结构通过序列化协议发送给客户端，从而减少 JS bundle、提高性能并简化数据获取，同时和交互组件协同工作，适配复杂应用。\n\n**RSC 适合：数据驱动、多页面/大列表/复杂查询、多数据源聚合，但客户端交互较轻**的页面。\n\n**不适合：交互复杂、状态频繁变化、强实时响应**的组件。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-4",
          "title": "Next.js RSC 漏洞",
          "content": "这个漏洞（2024–2025 问题）本质是 **反序列化不可信数据 → 服务端执行恶意构造的代码（RCE）**\n\n漏洞点：服务端反序列化 RSC payload 时，默认信任客户端的数据，服务端代码，没有校验actionId 和 payload 结构是否可信，而是直接可以执行\n\n导致只要攻击者伪造结构正确的 payload，就能执行任意的 Server Action 函数\n\n正确的校验应该：\n\n**校验 1：payload 引用的 actionId 必须属于当前构建生成的 action map**\n\n**校验 2：反序列化过程中禁止还原任意类型对象，只允许白名单类型**",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "engineering",
      "name": "工程化",
      "questions": [
        {
          "id": "engineering-1",
          "title": "webpack vite区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "engineering-2",
          "title": "loader plugin区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "engineering-3",
          "title": "webpack场景配置项",
          "content": "首先是入口和输出配置，比如 `entry` 和 `output`，用于定义构建的入口文件以及最终打包产物的输出路径和文件名。\n\n其次是模块解析和处理相关的配置，包括 `resolve`，用于配置文件后缀名解析和路径别名，以及 `module.rules` 中的 loader，用来处理不同类型的资源文件。\n\n然后是插件相关配置，通过 `plugins` 在 webpack 构建的各个生命周期阶段执行特定逻辑。\n\n另外还有一些环境和开发相关的配置，比如 `mode` 区分开发和生产环境，`devServer` 用于本地开发配置，`devtool` 用于 source map 设置。\n\n最后是 `optimization`，用于构建优化，比如代码压缩、`splitChunks` 做代码分包，以及 `runtimeChunk` 抽离运行时代码以支持长期缓存。",
          "hasAnswer": true
        },
        {
          "id": "engineering-4",
          "title": "Rollup 的适用场景",
          "content": "ESM的项目或者打包库",
          "hasAnswer": true
        },
        {
          "id": "engineering-5",
          "title": "Parcel",
          "content": "提供一个**极速、开箱即用**的现代前端开发体验，让开发者可以专注于代码本身，而不是复杂的构建配置\n\n**零配置**这是 Parcel 最大的卖点。对于大多数常见的项目类型（如 JavaScript、CSS、HTML、图片等），它不需要任何配置文件 (`parcel.config.js` 或 `webpack.config.js`) 就能直接工作。\n\n极速打包**Parcel 利用 **多核处理 (Worker 进程)** 来并行编译资源，并使用文件系统缓存。这使得它的初始构建和二次构建速度都非常快。*\n\n自动转换**它能自动检测和转换代码，例如：如果发现使用了 **Babel**、**PostCSS** 或 **TypeScript**，它会自动使用相应的工具进行转换，无需手动配置 Loader 或 Plugin。\n\n资源支持**Parcel 天生支持各种文件类型，包括 JS、CSS、HTML、图片、字体等，并且能自动处理它们之间的依赖关系，不需要额外的插件。\n\n代码分割****零配置**支持基于 ES 模块的**动态导入 (`import()`)**，并自动将应用分割成更小的块，实现按需加载。\n\nHMR (热模块替换)**在开发模式下，Parcel 默认启用快速的热模块替换，可以保留应用状态并即时更新模块，提高开发效率。\n\nParcel 与传统的打包工具（如 Webpack）的主要区别在于**配置哲学**：\n\n- **Webpack：** 是一种高度可配置的工具，通过复杂的配置文件（Entry、Loader、Plugin）来实现强大的功能和定制性。\n\n- **Parcel：** 追求**极简主义**，通过内置的智能模块解析和转换机制，在大多数情况下实现零配置，牺牲部分定制性来换取极高的开发效率和易用性。\n\n**总结：** Parcel 是一个适合快速启动、中小型项目，以及追求简单配置和极致开发速度的开发者的优秀选择。",
          "hasAnswer": true
        },
        {
          "id": "engineering-6",
          "title": "Tree shaking原理和条件",
          "content": "Tree Shaking 的原理可以概括为两步：**标记（Marking）和清除（Sweeping）**。\n\n1. 标记：基于 ES Module 的静态分析\n\nTree Shaking 依赖于 **ES Module (ESM)** 的**静态特性**。\n\n- **静态结构：** ESM 的 `import` 和 `export` 语句在代码执行前就已经确定了模块之间的依赖关系和导出的名称。这意味着，构建工具可以在**编译阶段（编译时）**，而不是运行阶段，确定哪些代码被使用了，哪些没有。\n\n- **依赖图构建：** 构建工具会从入口文件开始，构建一个完整的模块依赖图（Module Dependency Graph）。\n\n- **使用标记：** 在遍历依赖图的过程中，构建工具会标记出**实际被导入和使用的**模块、函数或变量。没有被任何地方导入或引用的代码则会被标记为“未使用”。\n2. 清除：移除未标记的代码\n- 在标记阶段完成后，优化器（通常是 UglifyJS 或 Terser）会执行清除操作。\n\n- 它会遍历所有模块，**物理性地移除**那些被标记为“未使用”（即 Dead Code）的代码块。\n\n✅ Tree Shaking 的生效条件\n\n 1. 必须使用 ES Module 语法\n\n- **导出：** 必须使用 `export` 或 `export default`。\n\n- **导入：** 必须使用 `import` 语句。\n\n- ESM 的 `import()` 动态导入不会阻止 Tree Shaking，反而会成为 Tree Shaking 的起点，实现更精细的按需加载。\n\n- 在这个动态导入的场景中，Tree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n2. 保证代码是“无副作用的” (Side-Effect Free)\n\nTree Shaking 的机制是安全的移除**没有副作用**的代码。\n\n- **定义：** “副作用”是指执行该模块时，除了导出值之外，还会修改全局状态或执行其他操作（例如：修改 DOM、调用 API、修改原型链）。\n\n- **标记：** 如果一个模块被标记为有副作用，即使它的导出没有被使用，构建工具也可能出于安全考虑保留整个模块。\n\n- **实践：`package.json` 的 `\"sideEffects\": false`** 为了告诉构建工具一个库（或文件）是完全无副作用的，可以在项目的 `package.json` 中添加\n\n3.配置生产模式优化，通过设置 `mode: 'production'` 启用，因为它默认包含了像 Terser 这样的代码压缩工具，而压缩工具是执行最终清除（Sweeping）步骤的关键。\n\n4.转换工具的配置。如果使用了 Babel 等工具进行代码转换，必须配置它**不将 ES Module 转换成 CommonJS 模块**。\n\n- 例如，在 Babel 配置中，需要确保 `@babel/preset-env` 中**没有**设置 `modules: 'commonjs'`，或者明确设置为 `modules: false`：",
          "hasAnswer": true
        },
        {
          "id": "engineering-7",
          "title": "Code Splitting 的多种方案",
          "content": "1.入口点分割 (Entry Points)\n\n这是最基础的分割方式。开发者手动在配置文件中定义多个入口文件，Webpack 会为每一个入口点生成一个独立的 Bundle。\n\n- **实现方式：** 在 `webpack.config.js` 的 `entry` 配置中定义多个键值对。\n\n- **适用场景：** 传统多页应用 (MPA)，每个页面对应一个入口；或者当你有两个完全独立的 SPA，想用一个 Webpack 配置打包时。\n\n- 示例 entry: {\n   pageA: './src/page-a.js',\n   pageB: './src/page-b.js',\n   },\n\n- **缺点：** 无法动态加载，且公共依赖代码（如 React 库）会被重复打包到每个入口的 Bundle 中\n\n当构建工具遇到 `import('./moduleA')` 时，它会将 `moduleA` 及其所有依赖单独打包成一个或多个 **Chunk（代码块）**，并在运行时异步加载。\n\nTree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n\n2.动态导入 (Dynamic Imports / 运行时加载)\n\n这是最常用、最灵活的代码分割方案，基于 ES Module 的 `import()` 语法，在运行时根据需要加载代码。\n\n- **实现方式：** 在代码中使用 `import('./path/to/module')`。\n\n- **适用场景：**\n  \n  - **路由懒加载：** 将每个路由页面打包成独立的 Chunk。\n  \n  - **组件懒加载：** 将不常用或在视口外的组件进行懒加载。\n  \n  - **条件加载：** 例如，用户点击某个按钮或满足某个条件时才加载特定的库。\n\n- **优点：** 实现了真正的**按需加载 (On-demand)**，大幅减少初始加载体积。\n\n- **缺点：** 必须处理加载状态（如使用 Suspense 或 Loading 占位符）。\n\n3.提取公共模块 (Vendor/Commons)\n\n目的是将多个模块（入口或动态导入）共享的依赖（如 React, Lodash, jQuery 等第三方库）提取出来，形成一个独立的公共 Chunk，以利用客户端的**缓存机制**。\n\n- **实现方式：** 使用 Webpack 的 `optimization.splitChunks` 配置。\n\n- **适用场景：** 任何包含大量第三方依赖或有多个入口点的应用。\n\n- **配置策略 (`optimization.splitChunks`)：**\n  \n  - **`vendors` (第三方库)：** 将所有来自 `node_modules` 的模块打包在一起。\n  \n  - **`default` (公共模块)：** 将应用内被多个模块（通常是两个以上）引用的代码提取出来。\n\n- **优点：** 充分利用浏览器缓存，核心库代码（如 React）稳定后，用户无需重复下载。\n\n- 示例 \n\n```js\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 对所有类型的 Chunk 生效\n      cacheGroups: {\n        // 自动提取 node_modules 中的库\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          priority: -10,\n        },\n        // 提取被多次使用的公共模块\n        default: {\n          minChunks: 2, \n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  },\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "engineering-8",
          "title": "优化代码分割产物加载速度的机制",
          "content": "- **实现方式：** 使用 Webpack 内联注释（Magic Comments）或 HTML 标签。\n  \n  - **`/* webpackPreload: true */`**\n  \n  - **`/* webpackPrefetch: true */`**\n\n- **适用场景：**\n  \n  - **`Preload` (预加载)：** 用于当前页面**很快就会需要**的资源（如当前路由的字体、关键图片或首个动态加载的 Chunk）。它会和父 Chunk 并行加载，优先级较高。\n  \n  - **`Prefetch` (预取)：** 用于用户**未来可能会需要**的资源（如用户可能会跳转到的下一个路由页面）。它会在浏览器空闲时加载，优先级较低。",
          "hasAnswer": true
        },
        {
          "id": "engineering-9",
          "title": "Babel编译原理和插件开发",
          "content": "Babel 的编译过程严格遵循计算机科学中的编译器原理，可以划分为三个核心阶段：**解析 (Parse)**、**转换 (Transform)** 和 **生成 (Generate)**。\n\n阶段一：解析：此阶段的目标是将原始源代码转换为抽象语法树 (AST)。\n\n1. **词法分析 (Lexical Analysis/Tokenizing):**\n   \n   - 将输入的代码字符串分解成一个个独立的、最小的语法单元，称为 **Token**（标记）。\n   \n   - 例如：`const a = 1;` 会被分解为 `const`, `a`, `=`, `1`, `;` 等 Token。\n\n2. **语法分析 (Syntactic Analysis/Parsing):**\n   \n   - 将 Token 流组合成一个树状的结构，即 **AST (Abstract Syntax Tree)**。\n   \n   - AST 中的每个节点都代表了代码中的一个结构，如变量声明 (`VariableDeclaration`)、标识符 (`Identifier`)、函数调用 (`CallExpression`) 等。\n   \n   - Babel 默认使用 **`@babel/parser`** (以前叫 Babylon) 来进行解析。\n\n获得的AST是个很大超大的JSON，好在Webpack 或 Babel 是**逐个文件**读取和处理的。并且AST不存储时，是临时的数据\n\n阶段二：转换 (Transformation)\n\n这是 Babel 工作的核心，**插件**主要在这个阶段发挥作用。\n\n1. **遍历 (Traversing):**\n   \n   - Babel 会深度优先遍历整个 AST。\n\n2. **插件执行:**\n   \n   - 当遍历器遇到特定的节点类型时，它会调用注册了该节点类型的 **Babel 插件**。\n   \n   - 插件通过操作 AST 节点（增、删、改、替换），将高版本语法转换为目标环境支持的语法。\n   \n   - 例如，将 ES6 的箭头函数 (`ArrowFunctionExpression`) 节点转换成 ES5 的普通函数表达式 (`FunctionExpression`) 节点。\n\n3. **Babel 默认使用 **`@babel/traverse`** 来进行 AST 遍历和节点操作。\n\n阶段三：生成 (Generating)\n\n此阶段的目标是将转换后的 AST 重新渲染为目标代码字符串。\n\n1. **递归生成:** Babel 递归地遍历修改后的 AST，将每个节点打印成对应的代码字符串。\n\n2. **Source Map:** 同时，还会生成 **Source Map**，用于将转译后的代码映射回原始源代码，以便于调试。\n\n3. **Babel 默认使用 **`@babel/generator`** 来进行代码生成。",
          "hasAnswer": true
        },
        {
          "id": "engineering-10",
          "title": "自动化测试策略",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "engineering-11",
          "title": "Webpack 构建流程和原理",
          "content": "阶段一：初始化 (Initialization)：Webpack 从启动到开始处理文件前的准备阶段。\n\n1. **参数合并:** 读取并合并 `webpack.config.js` 中的配置参数、Shell 命令行参数以及默认配置。\n\n2. **创建 Compiler:** 创建一个 `Compiler` 实例。`Compiler` 是 Webpack 的核心对象，它贯穿整个生命周期，负责协调整个构建流程。\n\n3. **加载插件:** 遍历配置中的 `plugins` 数组，依次执行插件的 `apply` 方法，注册各种 Hook（钩子）函数，监听 Compiler 或 Compilation 的事件。\n\n阶段二：构建模块 (Building Modules)：此阶段的核心是根据入口文件递归地构建**模块依赖图 (Module Dependency Graph)**。\n\n1. **确定入口:** 从配置中定义的 `entry` 入口文件开始。\n\n2. **创建 Compilation:** 创建一个 `Compilation` 实例。`Compilation` 对象负责本次构建过程的资源管理，包括模块、依赖图、Chunk、生成的资源文件等信息。\n\n3. **Module 构建循环:** Webpack 进入模块处理的循环：\n   \n   - **加载 (Loading):** 根据模块路径读取文件内容。\n   \n   - **解析 (Resolving):** 使用配置好的 `resolve` 规则，确定模块的绝对路径。\n   \n   - **处理 (Processing):**\n     \n     - 将文件内容传递给匹配的 **`Loader`**。Loader 负责将非 JS 类型的资源（如 TS, Sass, Vue 文件）转换为有效的 JavaScript 模块内容，或进行转换（如 Babel 转译）。\n     \n     - Loader 链式执行，前一个 Loader 的输出是后一个 Loader 的输入。\n   \n   - **依赖分析:** 使用 **`Parser`** (解析器) 遍历经过 Loader 处理后的代码内容。解析器会识别出代码中的 `import`、`require()`、`import()` 等模块导入语句。\n   \n   - **递归:** 每识别到一个依赖，就将其加入到依赖图，并对该依赖文件重复整个构建循环，直到所有依赖都被处理。\n\n阶段三：生成资源 (Sealing & Emitting)\n\n在依赖图构建完成后，Webpack 开始将模块组合成可部署的资源文件。\n\n1. **Chunk 分组:** 将构建好的模块根据它们的关系进行分组，形成 **Chunks** (代码块)。\n   \n   - **Entry Chunk:** 对应入口文件及其同步依赖。\n   \n   - **Lazy Chunk:** 对应通过 `import()` 动态导入形成的异步加载模块。\n   \n   - **Vendor/Common Chunk:** 对应通过 `SplitChunksPlugin` 提取的公共/第三方模块。\n\n2. **Chunk 优化 (Tree Shaking/Code Splitting):** 运行优化步骤，如 Tree Shaking 移除未使用的代码，以及 `splitChunks` 配置提取公共代码。\n\n3. **生成 Bundle:** 将 Chunk 映射到最终的输出文件（Bundle）。Webpack 为每个 Chunk 添加 runtime 代码（用于加载和执行模块）和模块包装器。\n\n4. **写入文件:** 最终，执行 `emitAssets` 钩子，将内存中生成的 Bundle 文件内容写入到输出目录（`output` 配置）。",
          "hasAnswer": true
        },
        {
          "id": "engineering-12",
          "title": "Webpack 的持久化缓存，如何判断文件是否需要重新编译",
          "content": "将上一次构建的结果（包括解析的模块、生成的 AST、转译后的代码等）存储到磁盘上，这样在后续构建中，如果文件或其依赖没有变化，就可以**跳过整个 Loader 链和模块构建过程**，直接复用缓存结果。这使得二次构建（特别是使用 HMR 时的开发构建）的速度大大加快。\n\n持久化缓存通过在 `webpack.config.js` 中设置 `cache` 属性来启用：\n\n```js\nmodule.exports = {\n  // ... 其他配置\n  cache: {\n    type: 'filesystem', // 启用基于文件系统的持久化缓存\n    buildDependencies: {\n      // 告诉 Webpack 哪些文件变动会导致缓存失效\n      config: [__filename], \n    },\n    // 默认缓存目录是 node_modules/.cache/webpack\n    // name: 'my-app-cache', // 可自定义缓存名称\n  },\n  // ...\n};\n```\n\n如何判断和检查是否可以用缓存：\n\n- **检查全局配置：** Webpack 检查自身的版本、Node.js 版本以及配置文件的哈希是否匹配。如果不匹配，清空所有缓存。\n\n- **检查模块哈希：** Webpack 检查当前文件的内容哈希。如果不匹配，缓存失效。\n\n- **检查 Loader/Plugin 配置：** Webpack 检查作用于该文件的 Loader 链和 Plugin 选项是否与缓存中记录的一致。如果不一致，缓存失效。\n\n- **检查依赖哈希：** Webpack 检查该模块所依赖的其他模块的哈希是否匹配。只要一个依赖项发生变化，当前模块的缓存就失效。",
          "hasAnswer": true
        },
        {
          "id": "engineering-13",
          "title": "联邦模块",
          "content": "它允许**多个独立的 Webpack 构建应用**在运行时共享代码和依赖，从而实现了真正的**前端微服务架构**。\n\n它让一个应用（Host）可以在运行时动态加载另一个独立应用（Remote）的代码模块，就像加载本地模块一样。\n\nRemote (远程方)：独立打包的应用。暴露 (Expose) 自己的部分代码模块供其他应用使用。Host (主机方)：独立打包的应用。消费 (Consume) 远程应用暴露出的模块。\n\n两个应用都需要的公共依赖，如 React、Vue。确保所有应用共享同一份依赖实例，避免重复加载和版本冲突\n\nModule Federation 通过在 Webpack 构建输出中添加特殊的 **“容器 (Container)”** 机制来实现：",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "cicd",
      "name": "CI/CD",
      "questions": [
        {
          "id": "cicd-1",
          "title": "CI/CD流程",
          "content": "持续集成 (CI)：快速、自动化地验证代码质量。包括代码质量检查lint，git hook触发流程 , build构建\n\n持续交付 (CD)：确保代码随时可以自动化地部署到生产环境。包括发布，流量切换，回滚等",
          "hasAnswer": true
        },
        {
          "id": "cicd-2",
          "title": "nginx配置",
          "content": "Nginx 主要用于作为**反向代理**、**静态资源服务器**和**负载均衡器**。\n\n前端常用：配置SPA 、静态资源路径、反向代理解决跨域、缓存配置、Gzip 压缩等",
          "hasAnswer": true
        },
        {
          "id": "cicd-3",
          "title": "cdn配置",
          "content": "将静态资源分发到全球边缘节点，使用户可以从最近的节点获取资源，加速访问\n\n- **前端配合:** 构建工具（Webpack/Vite）需要配置 **`publicPath`** 为 CDN 域名地址。\n\n- **CDN 关键配置:**\n  \n  - **回源策略:** 配置 CDN 节点在缓存未命中时，回源到 Nginx 或 OSS。\n  \n  - **缓存规则:** 区分可缓存（如带 Content Hash 的 JS/CSS）和不可缓存（如 `index.html`）。通常对带 Hash 的资源设置长缓存（如 1 年），对 `index.html` 设置短缓存（如 5 分钟）或不缓存。\n  \n  - **预热/刷新:** 部署后对新的资源文件进行预热，对旧的资源路径进行缓存刷新。",
          "hasAnswer": true
        },
        {
          "id": "cicd-4",
          "title": "oss",
          "content": "- **作用:** 高可靠、高并发、低成本的静态文件存储服务（如 AWS S3, 阿里云 OSS）。\n\n- **前端应用:** 通常将前端构建产物直接上传到 OSS 存储桶中，然后通过 CDN 绑定该存储桶的域名进行加速访问。\n\n- **优势:** 免维护服务器、高可用性。",
          "hasAnswer": true
        },
        {
          "id": "cicd-5",
          "title": "npm pnpm",
          "content": "pnpm：下载包全局存储，然后硬链接到项目目录。所以避免一台机器上重复下载和拷贝，节约磁盘空间，且安装快速\n\n严格的非扁平化依赖树，**避免幽灵依赖**。只允许访问声明的依赖，提高稳定性。",
          "hasAnswer": true
        },
        {
          "id": "cicd-6",
          "title": "npm install后发生了什么",
          "content": "- **检查本地缓存:** 检查 `node_modules` 是否存在，以及 `lock` 文件是否与 `package.json` 匹配。\n\n- **下载依赖:**\n  \n  - **npm/Yarn:** 访问 npm Registry，根据 `lock` 文件中记录的 URL/Hash/Version 下载依赖包，并存入全局缓存。\n  \n  - **pnpm:** 检查本地内容寻址存储中是否已存在该版本的包。如果存在，跳过下载。\n\n- **构建依赖树:**\n  \n  - **npm/Yarn:** 根据下载的包创建**扁平化**的依赖树结构，解决依赖冲突（如果能解决）。\n  \n  - **pnpm:** 根据 `lock` 文件创建**严格的非扁平化**依赖树，使用**硬链接和符号链接**连接到全局存储的包。\n\n- **执行生命周期脚本:** 运行依赖包中定义的 `install`、`postinstall` 等脚本（例如 `node-sass` 或 `Puppeteer` 的编译步骤）。\n\n- **生成/更新 Lock 文件:** 如果 `package.json` 有变化，更新 `package-lock.json` 或 `pnpm-lock.yaml`，确保团队构建环境的一致性。",
          "hasAnswer": true
        },
        {
          "id": "cicd-7",
          "title": "模块化发展历程(AMD/CMD/UMD/ES6)",
          "content": "**CommonJS (CJS)** 同步加载，`require()` 和 `module.exports`。用在node环境\n\n**AMD 异步**加载，适合浏览器，如 RequireJS。**依赖前置**，模块定义时所有依赖就绪并加载（预先加载）。\n\n**CMD**异步加载，推崇就近依赖。模块代码执行到 `require` 时才加载（按需加载）。\n\n**UMD**通用模式，兼容 CJS、AMD 和全局变量，用于库的发布。是**打包规范**，用于让一个模块或库同时兼容多种加载环境。\n\n**ES Module (ESM)** 静态加载、`import` / `export`，支持 Tree Shaking 和 `import()` 动态加载。\n\nAMD CMD UMD 它们都需要引入各自的模块加载器库，因为浏览器不原生支持这些规范。\n\nWebpack（以及其他现代构建工具，如 Rollup, Parcel, Vite）在编译时处理了 CJS 的引用和依赖关系，并消除了对原生 CJS 运行时环境的需求\n\n**Webpack 打包后的 Bundle 中，用于加载同步依赖的 `require()` 是同步执行的。打包后require和静态import相当于效果一样？想要拆分chunk并异步加载需要动态import？**\n\n- Webpack 识别源代码中的 `require('')` 语句，并将其视为一个**静态依赖**。\n\n- 会在最终 Bundle 中保留原生的 `require` 函数。\n\n- 它会将每个 CJS 模块包装在一个函数中，并注入一个小的 **Webpack Runtime** 代码（一个自定义的模块加载器，例如一个 `__webpack_require__` 函数）。\n\n- 这个运行时函数负责在 Bundle 内部查找、执行和缓存模块，从而实现了**同步的模块加载效果**，而无需进行网络请求。",
          "hasAnswer": true
        },
        {
          "id": "cicd-8",
          "title": "动态 import()",
          "content": "返回一个 Promise 对象。可以用.then或者async await\n\nJavaScript 模块化机制中最核心、最稳定的特性：**模块单例（Module Singleton）**。对于所有现代 JavaScript 模块规范（CJS, AMD, **ESM**），无论是同步导入还是动态导入，一旦一个模块被加载并执行，它的结果就会被**缓存**起来。",
          "hasAnswer": true
        },
        {
          "id": "cicd-9",
          "title": "前端微服务架构实践",
          "content": "**核心目标:** 将一个庞大的前端应用拆分为多个独立开发、独立部署、独立运行的小应用。\n\n- **Module Federation (推荐):** Webpack 5 联邦模块功能，实现运行时模块共享和依赖去重。\n\n- **Single-SPA/Qiankun (基于框架):** 通过路由劫持和沙箱机制，实现应用级的集成。\n\n- **Web Components/Iframe (隔离):** 通过浏览器原生技术实现 UI 隔离。",
          "hasAnswer": true
        },
        {
          "id": "cicd-10",
          "title": "Monorepo 项目管理",
          "content": "- **定义:** 将多个项目（Package）的代码存储在一个 Git 仓库中。最终的构建（Build）和部署（Deploy）仍然是**按需、独立**进行的。\n\n- **常用工具:** Lerna, Nx, Turborepo, Yarn/pnpm Workspace。\n\n- **优势:**\n  \n  - **代码共享:** 易于在不同项目间共享代码和配置。\n  \n  - **原子提交:** 一个 Commit 可以涉及多个项目，提交历史清晰。\n  \n  - **统一依赖:** 容易实现依赖版本统一。\n\n- **挑战:** 仓库体积大，工具配置复杂，权限控制难度增加。\n\n- CI：**Monorepo 工具的集成 (Nx/Turborepo):** 这些工具可以智能地判断**哪些项目**受到了代码变动的影响。例如，在 CI 中运行 `npx nx affected:build`，只构建那些代码或其依赖发生变化的子项目。\n\n- 通常会有一个位于 Monorepo 根目录下的**主 CI 配置文件**，它负责调用 Monorepo 工具，并确定哪个子项目的部署流程需要被触发。\n\n- **部署脚本：** 具体的部署逻辑（例如如何将文件上传到 S3 或如何调用 K8s 部署 API）通常会封装成每个项目内部的独立脚本，或由主 CI 配置文件通过参数动态调用。\n\n**总结：** 在 Monorepo 中，CI 流程是**集中的且智能的**；而 CD 流程是**分散的且独立的**。",
          "hasAnswer": true
        },
        {
          "id": "cicd-11",
          "title": "包管理和版本控制策略",
          "content": "- **版本锁定:** 强制使用 `package-lock.json` 或 `pnpm-lock.yaml` 锁定依赖版本，确保不同环境下的依赖一致性。\n\n- **包管理:** 使用 **pnpm Workspace**（基于 Monorepo 的包管理）来实现依赖共享和节省空间。\n\n模块的单例行为与 React Hooks 或 Vue Composition API 中的 `composable`（组合式函数）的行为，构成了前端状态管理和逻辑复用的两种截然不同的模式。\n\n模块：共享的应用级状态\n\nHooks / Composable：隔离的组件级状态",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "open-questions",
      "name": "开放题&场景题",
      "isFolder": true,
      "questions": [
        {
          "id": "open-questions-1",
          "title": "SSR-SSG-SPA-MPA",
          "content": "![](/Users/wzz/Library/Application%20Support/marktext/images/2025-11-21-22-10-13-image.png)\n\n![](/Users/wzz/Library/Application%20Support/marktext/images/2025-11-21-22-10-50-image.png)\n\n![](/Users/wzz/Library/Application%20Support/marktext/images/2025-11-21-22-11-34-image.png)",
          "hasAnswer": true
        },
        {
          "id": "open-questions-2",
          "title": "开放题&场景题",
          "content": "##### 前端鉴权的几种方式\n\n大文件上传\n\n前端截图，海报绘制\n\n自动化发布，发布版本号，停留页面提示更新\n\n##### SSR-SSG-SPA-MPA\n\n调试console\n\n##### 前端存储 Local storage，session，indexDB，cookie，根据写的倒计时代码，穿插着问的，问的很深\n\nIndexDB存储上限\n\nfile blob\n\n##### npm install后发生了什么\n\n浏览器地址栏url后发生了什么\n\njs写倒计时组件代码，并优化，长时间怎么解决误差，数据量大怎么办\n\n用过的 AI大模型，使用方式，用了他们那些功能，觉得AI大模型他们存在有什么样的缺点\n\n##### 前端性能指标有哪些?(LCP, FID,CLS等)如何优化这些指标\n\n##### 某个复杂模块的设计思路、遇到的性能瓶颈及解决方案\n\n如何设计一个高可用的前端系统\n\n##### 前端监控系统如何设计?如何上报和分析数据?\n\nPWA (Progressive Web Apps)了解吗?它的核心技术有哪些\n\n谈谈你对SSR(Server-Side Rendering)和 CSR (Client-Side Rendering) 的理解。\n\n如何处理前端的兼容性问题?\n\n对于新技术，你是如何学习和评估的\n\n你认为前端未来3-5年的发展方向是什么?\n\n##### 设计一个在线文档协同编辑的方案，需要考虑哪些技术点\n\n你遇到的最大的技术挑战是什么?从中学习到了什么?\n\n除了 redux mbox dva 还用过其他的 状态管理没\n\n职业发展，今年的打算\n\n组件升级怎么让使用这个组件的人都知道\n\n如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计\n\n用setTimeout实现setInterva，用requestAnimationFrame实现setTimeout\n\n##### Web Workers 的工作原理和使用场景\n\nWeb Workers 是浏览器提供的**多线程解决方案**，允许在后台线程中运行 JavaScript 代码，避免阻塞主线程（UI 线程）。主要优势：\n\n- 提高用户体验：耗时计算放在后台，保证主界面流畅。\n\n- 利用多核 CPU：现代浏览器可以将 Worker 调度到不同的 CPU 核心上并行执行。\n\n#### 跨浏览器 跨终端开发的兼容性处理方案\n\n挑战：\n\n 不同设备：屏幕尺寸与分辨率，输入方式差异，性能与网络条件\n\n- **性能考量**：考虑不同设备的性能差异\n\n- **工具自动化**：使用构建工具处理大部分兼容性问题\n\n- **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）\n\n\"描述一种方法，用以实现一个动态加载内容的无限滚动列表。\"\n\n\"如果你有一个含有数百个项目的数组，你将如何有效地搜索特定项目?\"\n\n\"我们的游戏界面需要实时更新玩家的得分，你会如何设计前端架构来实现这一功能?\"\n\n##### \"解释什么是服务工作线程(Service Worker)，以及它可以如何帮助提高一个游戏网站的性能?\"\n\nservice worker是web worker的一种，Service Worker 脚本在后台运行，与网页的生命周期分离。它最强大的能力是拦截和处理流经它的网络请求，以及持久化存储的能力，这使得缓存控制和离线体验成为可能。\n\n- **请求拦截能力（`fetch` 事件）。**\n\n- **持久化存储能力（`Cache Storage API`）。**\n\n\"如何在前端项目中实现国际化和本地化?\n\n模块化的演进历程\n\nJavaScript 内存管理和垃圾回收\n\n防抖和节流的实现与应用\n\n深拷贝的多种实现方案\n\n函数式编程在项目中的应用?\n\n##### 错误监控和异常处理\n\n前端安全(XSS/CSRF)防护\n\nWebpack 构建流程和原理\n\n##### 前端性能指标有哪些?(LCP,FID,CLS等)如何优化这些指标?\n\n你觉得js里this的设计怎么样?有没有什么缺点啥的\n\n##### 如果让你从零开始搭建一个大型电商网站的前端架构，你会如何设计?考虑哪些问题如何解决\n\n架化 与设计共同维护的UI库\n\nCICD 打包工具 nginx 部署流程CDN OSS 通常都是接公司平台 灰度发布\n\n团队与工程化 menorepo 规范 lint prettier 微前端\n\n监控报警 sentry\n\n其他 国际化 与设计共同维护的UI库\n\n##### 项目报错如何定位，sourcemap\n\n**Sourcemap 是源码和编译后代码的映射文件**，让浏览器能将压缩混淆后的代码映射回原始源代码。在复杂的现代前端项目中，代码经过构建工具（如 Webpack、Vite）的打包、压缩、混淆，生产环境在监控工具或浏览器控制台中，错误堆栈显示的是 **压缩后的文件名、行号和列号**（例如 `main.js:123:45`）。当浏览器或监控工具遇到一个指向 `main.js:123:45` 的错误时，根据sourcemap 查找对应的 `main.js.map` 文件。这个 `.map` 文件存储了原始代码和压缩代码之间的**映射关系**（即 `main.js` 的第 123 行第 45 列对应于 `src/components/UserForm.vue` 的第 50 行第 10 列）。map文件建议不部署到生产服务器。而是将 `.map` 文件上传到错z误监控平台（如 Sentry）。\n\nreact 对比 vue，为什么react需要fiber\n\n##### 如果让你从零开始搭建一个大型前端项目\n\n技术栈选型 框架 语言ts/js css 状态管理 组件库\n\n架构总体思路：ssr/csr SPA/MPA\n\nCICD 打包工具 nginx 部署流程CDN OSS 通常都是接公司平台 灰度发布\n\n团队与工程化 menorepo 规范 lint prettier 微前端\n\n监控报警 sentry\n\n其他 国际化 与设计共同维护的UI库\n\n##### 大型电商网站的架构，你会如何设计?考虑哪些问题如何解决\n\n高并发：忙绿兜底 下单锁 防刷\n\nSEO：ssr\n\nSKU复杂：SKU矩阵选择控件 库存变化要实时同步\n\n支付下单：流程复杂、强一致性要求高：必须 表单自动保存  交易失败兜底提示 幂等提交\n\n性能优化；OSS CDN \n\nA/B 测试、埋点\n\n安全\n\n##### 从0搭建一个内部脚手架项目\n\n##### 前端工程化的理解，如何自动化，成熟的体系应该具备哪些要素\n\n前端工程化的本质是——让前端开发从“手工活”变成“可规模化、可度量、可迭代的生产体系”，核心目标是：提效、稳定、可控。\n\n自动化质量控制 lint prettier git规范等\n\n自动化构建，自动化发布，保证性能、产物可控、灰度发布、流量分配、自动回滚\n\n监控报警\n\n前端工程化的核心是标准化 + 自动化 + 流程化 + 度量化。  \n成熟体系应该覆盖整个研发生命周期：从代码规范、项目结构、组件库沉淀、构建优化，到测试、CI/CD、灰度发布、监控报警。  \n最终目标是：让开发提效、质量可控、上线可回滚、运行可监控。\n\n##### 微前端\n\n两个角色，主应用和子应用\n\n技术难点：样式隔离，JavaScript 隔离，路由管理和应用切换，公共依赖的打包和互相引用、应用之间事件和数据传输\n\n解决：\n\n样式隔离：CSS Modules+CSS-in-JS\n\njs隔离：所有微应用共享全局环境（`window` 对象），如果微应用 A 在全局对象上挂载了变量，微应用 B 可能会意外使用或覆盖它。主流方案是：利用 ES6 的 `Proxy` 对象劫持对 `window` 对象的访问。微应用对 `window` 的读写操作都被 `Proxy` 拦截，读操作从全局 `window` 读取，写操作写入到**当前微应用自己的代理对象**中，从而隔离了对真实全局 `window` 的污染\n\n路由管理和应用切换：路由切换时，主应用能正确加载/卸载对应的微应用，并保持 URL 同步。监听 `hashchange` 或 `popstate` 事件，匹配路由，加载/卸载模块\n\n公共依赖：避免每个微应用都打包相同的库。方案两个方向，1是子应用不处理外部模块的打包，主应用负责加载公共包，2是webpack5的联邦模块，允许应用 A **暴露**其内部的模块（如 React 库）给应用 B **消费**，实现真正的运行时共享\n\n事件和数据传输：发布订阅模式/基于全局状态管理\n\n实现方案：\n\nQiankun：上手难度低，做了css  js隔离，有完整的生命周期钩子，支持多种技术栈。核心是沙箱机制和生命周期管理\n\nsingle-spa：核心作用是作为一个应用路由器（Application Router）和生命周期管理器\n\n联邦模块 (Webpack 5)，只用来处理公共依赖包的情况\n\n**最佳实践**通常是：**使用 Qiankun 或 Single-SPA 来管理应用的隔离和生命周期，同时使用 Webpack 联邦模块来优化公共依赖和公共组件的加载性能。\n\n##### 未来前端技术哪些需要特别关注的技术点\n\n\n\n##### 设计一套全站点请求耗时统计工具\n\n##### 双 token 无感刷新怎么做？如果 refresh token 也失效了，但你这时挂起了一堆请求，刷新失败了，怎么处理\n\n双 token 机制通常包括一个 **Access Token** (访问令牌) 和一个 **Refresh Token** (刷新令牌)。\n\n1. **Access Token (短有效期):** 用于访问受保护的资源，过期时间短（例如 10 分钟）。\n\n2. **Refresh Token (长有效期):** 用于在 Access Token 过期后，获取新的 Access Token，过期时间长（例如 7 天）\n\n当 Refresh Token 也失效时，意味着用户必须重新登录。此时核心问题是挂起的一堆请求如何在刷新登录后重试，方案是用一个全局的 **刷新锁** 和一个 **请求队列**。\n\n##### 如果要集成一个船上的摄像监控系统（第三方页面，但它不能改代码，只能iframe嵌进去，而且还要求根据用户权限控制展示内容，你会怎么处理\n\n方案1：通过代理服务器实现内容过滤，iframe嵌套后端路径，有权限时跳转，无权限时返回一个兜底\n\n方案2：利用 **第三方系统自身的 URL 参数** 进行控制，前提是第三方已有支持\n\n方案3：用前端遮罩进行视觉控制，只控制是否展示，内容有泄漏风险\n\n##### 有这样一个场景：如果你从多个系统的 API 拉数据，但这些系统的数据结构不一致，比如 A 系统返回 camelCase、B 系统是 snake_case，还有一些是中文 key，你怎么统一数据结构，来复用\n\n核心思想：在逻辑和外部 API 之间，建立一个专门负责转换的中间层——**适配器 (Adapter)**。每个外部系统都有一个专属的适配器，该适配器只负责：从外部系统获取数据 $\\rightarrow$ 将其转换成规范模型 $\\rightarrow$ 传递给你的应用核心逻辑。\n\n对于 **`camelCase` 和 `snake_case`** 之间的转换，可以使用成熟的库进行自动化处理\n\n对于中文 Key 或需要复杂的**业务值转换**，需要硬编码映射规则，维护一个 JSON 或 YAML **映射文件**\n\n##### 如果让你来你现在负责一个项目，有20+个页面，需求方经常改字段、加字段，你每次都要改组件，这个时候你怎么来设计\n\n思路：数据驱动渲染+配置化\n\n配置层：把字段抽象出一套配置文件\n\n业务组件和渲染逻辑层都不需要关心如何配置，而是根据配置自动化地应用\n\n##### 如果你要做一个拖拽式仪表盘Dashboard用户呢能自己拖拽、组合图表组件展示不同数据源的信息，你会怎么来设计这个系统\n\n##### 如果现在一个页面要同时展示 300 辆车的实时位置+轨迹，你怎么来优化\n\n数据层面+渲染层面\n\n数据：后续更新只传输增量变化的字段\n\n渲染：分区绘制/懒加载；WebGL/Canvas 渲染；前端聚合（在地图缩放级别较低时，将前端可见的密集点聚合成一个集群图标）；动画优化GPU加速和requestAnimationFrame\n\n**最佳实践组合：** 在后端实现 **视窗过滤** 和 **轨迹简化**，并使用 **WebSocket** 推送增量位置数据。在前端，使用 **WebGL 地图库** (如 Mapbox GL JS) 进行高性能渲染。\n\n##### 地图中你是怎么处理车辆轨迹“绕圈走”的情况的？比如一个车在原地掉头、拐弯，但 GPS 连续记录了好几个点，那肯定你的轨迹图就会一堆锯齿，怎么来做呢\n\n##### GeoJSON 有哪些字段？你在做行政区边界展示的时候，做过数据裁剪吗？如果只展示“浦东新区”这一个区的数据，你怎么只加载它？\n\n##### 怎么处理 WebSocket 的多连接问题？比如你一个页面要同时订阅车辆位置、报警事件、设备状态，怎么复用，保证不丢数据\n\n##### 有没有处理过图表/地图上的数据级联问题？比如点击图表某个项目，地图跟着联动展示，这块怎么处理的\n\n##### 你认为一个优秀的前端架构师/高级工程师需要具备哪些特质?在你的团队中，你是如何推动技术规范落地和技术选型的?\n\n##### 低代码平台如何实现远程组件的动态加载?\n\n####",
          "hasAnswer": true
        },
        {
          "id": "open-questions-3",
          "title": "微信登录支付",
          "content": "2025-11-21-22-12-43-image.png\n\n2025-11-21-22-13-18-image.png",
          "hasAnswer": true
        },
        {
          "id": "open-questions-4",
          "title": "海报绘制",
          "content": "海报绘制",
          "hasAnswer": false
        },
        {
          "id": "open-questions-5",
          "title": "自动化发布",
          "content": "自动化发布\n2025-11-21-22-06-49-image.png",
          "hasAnswer": false
        },
        {
          "id": "open-questions-6",
          "title": "跨浏览器 跨终端开发的兼容性处理方案",
          "content": "##### 跨浏览器 跨终端开发的兼容性处理方案\n\n确保同一个网页或Web应用在**不同的浏览器**上和在**不同类型的设备**上都能具有**一致的外观、布局和功能**，提供**良好的用户体验**。\n\n挑战：\n\n不同浏览器：CSS 渲染差异，JavaScript API 支持度不同\n\n不同设备：屏幕尺寸与分辨率，输入方式差异，性能与网络条件\n\n解决：\n\n开发工具链：\n\n```js\n\"@babel/core\": \"^7.20.0\",          // JavaScript 转译\n\"autoprefixer\": \"^10.4.13\",        // CSS 自动前缀\n\"postcss\": \"^8.4.21\",              // CSS 后处理\n\"eslint\": \"^8.30.0\",               // 代码检查\n\"stylelint\": \"^14.16.0\",           // CSS 检查\n```\n\n检测与兼容性查询能力：\n\n```js\nserviceWorker：'serviceWorker' in navigator\nIntersectionObserver：'IntersectionObserver' in window\n响应式图片：<picture> + <source > 等\nwebp：document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0\nCan I Use：caniuse.isSupported(feature, navigator.userAgent)\n```\n\n原则和思路：\n\n- **渐进增强**：从基础功能开始，逐步为现代浏览器增强体验\n\n- **优雅降级**：现代功能不可用时，提供可用的降级方案\n\n- **移动优先**：从小屏幕开始设计，逐步适配大屏幕\n\n- **使用标准 API**：优先选择广泛支持的 Web 标准\n\n- **特性检测**：运行时检测浏览器能力，而非浏览器嗅探\n\n- **响应式设计**：使用弹性布局和媒体查询\n\n- **性能考量**：考虑不同设备的性能差异\n\n- **工具自动化**：使用构建工具处理大部分兼容性问题\n\n- **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "miniprogram",
      "name": "小程序",
      "questions": [
        {
          "id": "miniprogram-1",
          "title": "选框架 uniapp taroapp",
          "content": "团队主栈\n\n需要发布到 App 端 优选**uni-app**\n\n需要覆盖最多平台 uni-app\n\n更注重小程序性能 unia-app（taro由于底层基于 React Virtual DOM，相较于原生小程序的渲染可能会有轻微性能损耗，但在绝大多数场景下足够使用。）\n\n更注重H5性能的大型项目 优选taro  由于基于 React 体系，更适合大型项目中的组件化、状态管理和架构规范。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-2",
          "title": "小程序和H5的性能差异，结合小程序分包和SPA",
          "content": "| 特性    | 小程序       | H5 SPA           | 建议场景                     |\n| ----- | --------- | ---------------- | ------------------------ |\n| 首屏性能  | 可控，分包优点明显 | 首屏大包阻塞可能慢        | 小程序更适合首次访问频繁的轻量应用        |\n| 页面切换  | 分包可能轻微延迟  | 路由切换快            | SPA 优势在页面多切换且包已加载        |\n| 渲染性能  | 跨桥更新瓶颈    | DOM 操作瓶颈         | 大列表：SPA diff+虚拟 DOM 优势更大 |\n| JS 执行 | 沙箱受限，低端机慢 | 浏览器内存大，可用 Worker | 计算密集型 SPA 更适合浏览器         |\n| 数据请求  | 并发有限      | 并发可控             | 高并发数据接口 SPA 更灵活**        |\n\n小程序：依托微信生态丰富，登录、支付等微信能力更流畅，容易接入官方API，用户触达 分享等方面更有微信的优势，结合分包机制能按需加载，减少首屏 JS。但性能略差，大量组件或频繁 UI 更新时可能卡顿，无法自由访问浏览器原生 API。\n\nH5：交互灵活，渲染性能可优化，浏览器 API功能无限制，技术栈成熟、生态丰富，SPA首屏性能压力大，拉新/留存不如小程序便利",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-3",
          "title": "小程序和h5的渲染性能对比",
          "content": "首次加载：小程序需下载框架和代码包，H5 可按需加载。\n\n热启动：小程序更快，H5取决于缓存策略\n\n渲染性能：小程序有双线程，能 避免 JS 阻塞渲染，交互更流畅。\n\n操作DOM：小程序框架底层对DOM 操作有更严格控制，但是频繁地setData也可能会导致性能瓶颈；H5类似的操作DOM可能会导致性能瓶颈，一般要依赖框架的响应式数据更新或者渲染优化",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-4",
          "title": "小程序底层架构详解",
          "content": "小程序采用的是双线程（Dual-Thread）的运行模型，这是其架构的基石。这个模型将页面的逻辑处理和界面渲染分别放在两个独立的运行环境中，通过异步消息通道通信。开发者编写的**逻辑代码**运行在一个根本，是一个没有 DOM 逻辑层和 BOM 的独立环境中。\n\n逻辑层 (JS Thread) 由独立的 JavaScript 引擎 实现 。\n\n渲染层 (View Thread) 基于浏览器的 WebView，负责渲染页面的容器。\n\n（**WebView 是一种宿主环境提供的、内嵌式的浏览器内核功能。它允许应用程序（App）或小程序框架在原生界面中加载和渲染 Web 内容，它包含了浏览器的大部分核心功能，它运行在原生 App 内部，本质上就是一个浏览器内核组件**）\n\n这种分离架构的好处是解决传统 Web 应用的**性能瓶颈**（双线程）和**安全问题**（无法直接操作DOM），同时保证**跨平台能力**（渲染层可以对不同平台做不同的渲染）。\n\n缺点是：增加了一层数据传输，可能带来通信延迟，增加了调试复杂性，增加一定的内存占用；开发者无法使用完整的浏览器 API和一些成熟的web库；频繁调用setData可能会引起性能问题，因为涉及了两个线程之间的**跨线程通信**和**数据处理**：",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-5",
          "title": "小程序没有dom是如何渲染的",
          "content": "编译阶段：将开发者定义的 WXML/WXSS 转换为渲染指令（类似虚拟DOM的结构对象）和和css\n\n运行阶段：根据渲染指令（类似VDOM）构建真实DOM，数据发生更新时，先diff然后把增量数据发给渲染层，渲染层精确更新 DOM",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "ai",
      "name": "AI",
      "questions": [
        {
          "id": "ai-1",
          "title": "用过的 AI 大模型，使用方式，用了他们那些功能，觉得 AI 大模型他们存在有什么样的缺点",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "ai-2",
          "title": "你对 AI Coding 的理解？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "ai-3",
          "title": "有没有 最佳实践？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "ai-4",
          "title": "平时的 AI 工作流 是怎样的？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "ai-5",
          "title": "用过哪些 AI IDE？差异在哪？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "ai-6",
          "title": "对 Agent / MCP / Tab 补全模型 的理解？",
          "content": "",
          "hasAnswer": false
        }
      ]
    },
    {
      "id": "tech-selection",
      "name": "技术选型",
      "questions": [
        {
          "id": "tech-selection-1",
          "title": "技术选型",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-2",
          "title": "框架 vue/react/nextjs",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-3",
          "title": "模块化方案",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-4",
          "title": "SSR/CSR等",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-5",
          "title": "redux zustand  vuex pinia",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-6",
          "title": "移动端适配方案(rem/vw/响应式)",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "tech-selection-7",
          "title": "小程序选框架 uniapp taroapp",
          "content": "",
          "hasAnswer": false
        }
      ]
    },
    {
      "id": "teamwork",
      "name": "工作协作",
      "questions": [
        {
          "id": "teamwork-1",
          "title": "如何平衡重构和需求时间冲突",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-2",
          "title": "谈谈你对“大前端”的理解",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-3",
          "title": "如何带领一个前端团队?如何提升团队的技术能力",
          "content": "",
          "hasAnswer": false
        }
      ]
    }
  ],
  "generatedAt": "2025-12-29T16:52:40.728Z"
}