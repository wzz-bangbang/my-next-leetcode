{
  "categories": [
    {
      "id": "js-basic",
      "name": "JS基础",
      "questions": [
        {
          "id": "js-basic-1",
          "title": "浮点数精度问题",
          "content": "计算机底层是用二进制存储数据的。虽然 $0.1$ 和 $0.2$ 在十进制看起来很整，但在转换成二进制时，它们是**无限循环小数**，JavaScript 中的 `Number` 类型使用的是 64 位双精度浮点数，这导致存进去的数本身就不是精确的 0.1。\n\n办法：\n\n转成整数运算 (常规解法)**；\n\n使用专业库比如`decimal.js`、`bignumber.js` 或 `big.js`\n\n追问：绝大多数编程语言都有，只要它们使用的浮点数类型是基于 **IEEE 754 国际标准**实现的，核心问题是：无限循环的二进制+尾数位数的限制 导致的强制截断和精度丢失",
          "hasAnswer": true
        },
        {
          "id": "js-basic-2",
          "title": "js的字符长度",
          "content": "js字符串的 `length` 属性返回的是字符串中代码单元的数量,而不是传统意义上的字符数量或字节数量，由ECMAScript 标准规定\n\nJS 字符串使用 **UTF-16** 编码格式，一个**代码单元**就是 **16 位（即 2 字节）**\n\n**普通字符**：大多数字符都位于 Unicode 的基本多语言平面 (BMP) 内。它们只需要 **1 个代码单元**来表示，特殊字符/表情符号：位于 BMP 之外的字符（如某些不常见的汉字、最新的 Emoji 🌧️）需要 2 个代码单元。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-3",
          "title": "this上下文",
          "content": "this指的是函数执行时所关联的对象，取决于函数在运行时**调用**的方式。\n\n1 直接调用\n\n2 对象. 调用（隐式绑定\n\n3 bind call apply (显式调用)\n\n4 new `this` 绑定到**新创建的实例对象\n\n特殊情况 箭头函数没有this\n\n原生 `setTimeout` 的 this 指向规则：\n\n1. **默认情况下**，回调函数中的 `this` 指向全局对象（浏览器中的 `window`）\n\n2. **严格模式下**，指向 `undefined`\n\n3. this 指向与调用 `setTimeout` 的上下文无关",
          "hasAnswer": true
        },
        {
          "id": "js-basic-4",
          "title": "原型与原型链",
          "content": "1.函数的`prototype`：Constructor.prototype,  仅存在于函数（构造函数/类）上**它指向一个对象，这个对象就是未来**所有实例对象**将继承的公共属性和方法的集合。\n\n2.`__proto__` :存在于所有实例对象上这是一个内部属性 (`[[Prototype]]` )，它指向创建该实例的构造函数的 `prototype` 对象。`Object.getPrototypeOf()`来访问\n\n原型链是由于对象通过 `__proto__` (内部的 `[[Prototype]]`) 链接到其构造函数的原型对象，而构造函数的原型对象本身也是一个对象，它也有自己的 `__proto__`，如此层层递进，直到链的末端。\n\n原型链是 JavaScript 实现**继承和属性共享**的机制。属性和方法都存储在原型上，所有实例共享同一份，这大大节省了内存空间。\n\n当访问实例对象上的一个属性，JS 引擎会首先检查该实例对象自身是否有这个属性，如果实例自身没有找到，引擎会沿着 `__proto__` 链接向上，到它的原型对象上查找。 如果仍未找到，查找会沿着原型链一直向上，直到到达 `Object.prototype`。`Object.prototype` 的 `__proto__` 是 `null`。如果查找到 `null` 仍未找到，则返回 `undefined`。\n\n**`class` 语法：** ES6 的 `class` 语法是原型和原型链的**语法糖**。它没有改变底层机制，只是提供了一种更清晰的方式来定义构造函数和方法。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-5",
          "title": "继承",
          "content": "核心：原型链继承**原型链** 是 JS 继承的**唯一底层机制**\n\n1.原型继承，核心：让子类原型对象指向父类实例。\n\n- **做法**：`Child.prototype = new Parent()`\n- **缺点**：**引用类型属性共享**。当父类的原型上包含**引用类型**的属性时（比如一个数组），其中一个子类改了数组，所有子类都会跟着变。\n\n2.组合继承：【核心优化】：创建父类原型对象的副本，并赋值给子类原型+【构造器指针修正】：将子类构造器指向自身。特点：独立属性+原型共享。缺点是`Parent` 构造函数被调用了两次\n\n```\nfunction Child(name, age) { \n\t// 【核心步骤 A】：继承属性 \n\t// 通过 call 调用父类构造函数，将 Parent 的属性绑定到 Child 的实例上 \n\tParent.call(this, name); \n\tthis.age = age; \n}\n\n// 【核心步骤 B】：继承方法: 将 Child 的原型指向 Parent 的一个实例，从而接入原型链 Child.prototype = new Parent(); \n// 4. 修复 constructor 指向 \n// 因为重写了原型，Child.prototype.constructor 现在指向的是 Parent，需要手动改回来 Child.prototype.constructor = Child; \n```\n\n3.终极方案：寄生组合式继承（必杀技）\n\n**这是面试官最想听到的答案，也是 ES6 `class` 背后的核心原理。**\n\n- **核心思想**：不 `new Parent()` 了，直接造一个父类原型的副本。    \n- **优势**：只调用一次父类构造函数，原型链保持完整，效率最高。\n\n```\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n```\n\n3.es6的class extend super,  **本质**是寄生组合继承的**语法糖**。\n\n`class` 关键字**并没有改变底层原型继承的机制**，它只是提供了一套更清晰的 API 来定义构造函数、原型方法和静态方法。\n\n`extends` 的底层操作：\n\n1. **设置子类的原型链：** 自动将 `Child.prototype` 的原型（即 `Child.prototype.__proto__`）设置为 `Parent.prototype`，实现了**方法继承**。\n\n2. **构造函数关联：** 自动将 `Child.__proto__` 设置为 `Parent`，实现了**静态属性和方法的继承**。\n\n`super` 关键字： `super` 是在 `class` 继承中最核心、最关键的机制，它在两个场景下工作：\n\n1. **在 `constructor` 中：** 必须调用 `super()`。它负责调用父类的构造函数，并**将子类实例的 `this` 绑定到父类**。在子类构造函数中，必须在引用 `this` 之前调用 `super()`。\n\n2. **在方法中：** 用于调用父类原型上的同名方法（如 `super.methodName()`）。\n\n```\nclass Child extends Parent {\n    constructor(name, age) {\n        // 【核心】：必须先调用 super()，它负责执行父类的构造函数并创建 this\n        super(name); \n        this.age = age;\n    }\n\n    // 子类自己的方法\n    sayAge() {\n        console.log(`我今年 ${this.age} 岁了`);\n    }\n\n    // 【重写/多态】：子类可以覆盖父类的方法\n    sayName() {\n        // 也可以通过 super 调用父类被覆盖的方法\n        super.sayName(); \n        console.log('这是子类重写后的逻辑');\n    }\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-6",
          "title": "new操作符做了什么",
          "content": "1创建新对象\n\n2新对象原型指向构造函数原型对象\n\n3绑定this并执行构造函数\n\n4如果构造函数有返回就直接返回，否则返回新对象",
          "hasAnswer": true
        },
        {
          "id": "js-basic-7",
          "title": "讲讲js的事件循环",
          "content": "宏任务和微任务的区分是为了做什么? 优先级有什么区别?\n\n答：是为了保证异步代码执行的**确定性、优先级和性能**。微任务享有绝对的**插队权**。\n\n核心目的在于创建**两级异步优先级系统**，确保高优先级、对性能敏感的任务能够快速执行，同时避免长时间阻塞浏览器渲染。\n\n微任务 (Microtasks) 的目的：高优先级，保证状态一致性。微任务在**当前同步代码执行完毕后，浏览器进行下一次渲染之前**立即执行。例如，Promise 链需要保证在一个 DOM 或 UI 渲染周期内全部解析完成，以避免 UI 闪烁或数据不一致。\n\n宏任务 (Macrotasks) 的目的：低优先级，调度 I/O 和 UI 渲染。不阻塞渲染\n\n注意：初始同步脚本执行完毕，**执行上下文栈（ECS）清空时**，事件循环机制才真正开始接管，并进入检查队列的循环。\n\n所有的异步事件一定是当前浏览器执行完同步任务空闲了才做的",
          "hasAnswer": true
        },
        {
          "id": "js-basic-8",
          "title": "全局对象",
          "content": "在不同的环境下，全局对象的名字和表现有所不同：\n\n- **浏览器环境**：全局对象是 `window`。\n- **Node.js 环境**：全局对象是 `global`。\n- **统一规范**：为了跨环境兼容，ES11 引入了 **`globalThis`**，无论在哪个环境下，它都指向当前环境的全局对象。\n\n> **面试避坑指南：** 在全局作用域下用 `var` 声明的变量会挂载到全局对象上，但用 `let` 或 `const` 声明的变量**不会**。这是因为 ES6 之后，全局作用域内部还存在一个“块级作用域”的顶层环境。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-9",
          "title": "js类型转换",
          "content": "显式转换 (Explicit Coercion)**：通过 `Number()`、`String()`、`Boolean()` 等内置函数或 `parseInt` 等方法进行的**主动**转换。\n\n隐式转换 (Implicit Coercion)**：在运行时，由 JS 引擎根据操作符（如 `==`、`+`、`-`）的需要**自动**进行的转换。\n\n1.转换为 Boolean (转布尔)。这是最简单的转换，发生在逻辑判断、`if` 语句和 `!` 操作符中。\n\n2.转换为 String (转字符串)。发生在字符串拼接（`'a' + b`）、`alert()` 或 `String(value)` 中。规则：原始值直接转换。对象通过调用内部的 **`ToString` 抽象操作**实现\n\n3.转换为 Number (转数字)。发生在数学运算（`-`, `*`, `/`）或一元加操作符（`+a`）中。\n\n规则： 原始值有明确的转换规则（如 `null` 转 $0$，`\"123\"` 转 $123$）。对象通过调用内部的 `ToNumber` 抽象操作实现。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-10",
          "title": "闭包",
          "content": "注意：闭包 = 函数 + 它能访问的、已脱离当前执行上下文的外部变量\n\n作用：创建私有变量；外部访问私有变量；延长变量生命周期；模块化基础\n\n注意：使用不当容易内存泄漏；性能开销比普通函数大\n\n如何避免内存泄漏? \n\n解除引用：当你确定一个闭包不再需要使用时，应该手动解除对它的引用。通过将持有闭包的变量设置为 `null` 或 `undefined`，使其失去引用。\n\n```js\nlet closureFunc = outerFunc(); // 创建闭包\n// ... 使用 closureFunc ...\nclosureFunc = null; // 手动解除引用，帮助 GC 回收内存\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-11",
          "title": "for..in for..of区别",
          "content": "记忆：KEY in OBJECT, VALUE of ITERABLE，`in` 拿 Key（下标），`of` 拿 Value（内容）\n\n| **特性**   | **for..in**          | **for..of (ES6)**                      |\n| -------- | -------------------- | -------------------------------------- |\n| **迭代内容** | 迭代的是 **Key (键名/索引)** | 迭代的是 **Value (键值)**                    |\n| **适用范围** | 主要用于**对象**，也可用于数组    | 只要部署了 **Iterator 接口** (数组、Map、Set、字符串) |\n| **原型链**  | **会**遍历原型链上的可枚举属性    | **不会**遍历原型链                            |\n| **顺序**   | 顺序不确定（对象属性无序）        | 按迭代器的顺序执行（数组是有序的）                      |",
          "hasAnswer": true
        },
        {
          "id": "js-basic-12",
          "title": "call  apply bind 区别",
          "content": "这三个方法都是为了**改变函数执行时的 `this` 指向**。\n\n- **`call(context, arg1, arg2...)`**：立即执行。参数是一个个传进去的。\n\n- **`apply(context, [args])`**：立即执行。参数是以**数组**形式传进去的。\n\n- **`bind(context, arg1...)`**：**不会立即执行**。它会返回一个新的函数，并永久绑定了 `this`，后续调用时再传入剩余参数。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-13",
          "title": "导致js里this指向混乱的原因是什么?",
          "content": "根本原因在于：**普通函数采用动态绑定（Dynamic Binding），其 `this` 的值不是在函数定义时确定的，而是在函数被调用时，根据函数调用的方式（Call Site）临时决定的。**\n\n`this` 的值高度依赖于**调用函数时的上下文**，这种运行时（Runtime）绑定机制与 JS 的词法作用域规则形成了鲜明对比，造成了巨大的认知负担。\n\nES6 的解决方案：箭头函数，没有自己的动态 `this`，`this` 变得可预测、不可变，不再受调用方式的影响",
          "hasAnswer": true
        },
        {
          "id": "js-basic-14",
          "title": "你觉得js里this的设计怎么样?有没有什么缺点",
          "content": "`this` 的设计初衷是为了实现高度的**灵活性**和**代码复用**。通过显式绑定隐式绑定可以更加灵活\n\n`this` 的所有缺点都源于一个核心问题：**它的值是动态绑定（Runtime Dynamic Binding）的，依赖于函数的调用点 (Call Site)，而不是定义点。**\n\n有严重的上下文丢失陷阱：回调函数问题： 当一个对象的方法被作为参数传递给异步函数（如 `setTimeout`、`Promise.then()`）或事件处理器时，它通常会失去其隐式绑定，退化为**默认绑定（指向全局对象或 `undefined`）**。\n\n违反词法作用域原则 ：JavaScript 的变量（使用 `let/const`）是词法作用域（静态确定）的，但 `this` 却是动态作用域的。这种不一致性打破了语言的统一性，使得在阅读嵌套代码时很难预测 `this` 的值。\n\nes6通过箭头函数和class弥补了这个问题，开发者应当尽可能利用箭头函数和 `class` 语法来避免直接依赖普通函数的动态 `this` 机制",
          "hasAnswer": true
        },
        {
          "id": "js-basic-15",
          "title": "运算符",
          "content": "ES2020 新增：空值合并运算符 `??` (Nullish Coalescing)\n\n用途：** 专门用于处理 `null` 或 `undefined` 的默认值设置。解决了 `||` 在处理 `0` 和 `\"\"` 时的缺陷。\n\n规则：** 只有当左侧操作数是 `null` 或 `undefined` 时，才返回右侧操作数。\n\nES2021 新增：逻辑赋值运算符\n\n- **`||=` (OR 赋值)：** 只有当左侧为 Falsy 时才赋值。\n\n- **`??=` (空值赋值)：** 只有当左侧为 `null` 或 `undefined` 时才赋值。\n\n其他：typeof  instanceof  delete",
          "hasAnswer": true
        },
        {
          "id": "js-basic-16",
          "title": "执行上下文",
          "content": "JavaScript 引擎在运行代码时，会维护一个 **执行上下文栈 (Execution Context Stack)**，也称为调用栈 (Call Stack)。\n\n- **入栈：** 当代码开始执行或调用函数时，新的执行上下文会被创建并推入栈顶。\n\n- **出栈：** 当函数执行完毕，其上下文会从栈中弹出，控制权返回给栈中的上一个上下文。\n\n- **流程：** 栈底永远是 **全局执行上下文**。\n\n全局执行上下文：它创建全局对象（ `window`、Node.js 中的 `global`）和 `this` 绑定。\n\n函数执行上下文 ：每当一个函数被调用时，都会创建一个新的~~。每次调用都是独立的\n\n阶段一：创建阶段 (Creation Phase / 编译阶段)\n\n在代码执行之前，引擎会扫描函数代码，完成以下三项任务：\n\n1. 确定 `this` 绑定 (ThisBinding)：全局 EC绑定到全局对象；函数EC按调用方式绑定\n\n2. 创建词法环境 (LexicalEnvironment)：存储 `let`、`const`  `class` 声明\n\n3. 创建变量环境 (VariableEnvironment)：用于存储 `var` 变量声明和函数声明\n\n阶段二：执行阶段 (Execution Phase)\n\n引擎开始逐行执行代码，完成以下任务：\n\n1. **变量赋值：** 将值赋给变量（之前在创建阶段被初始化为 `undefined` 或保持未初始化状态）。\n\n2. **代码执行：** 执行所有函数调用和其它语句。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-17",
          "title": "词法环境",
          "content": "**词法环境 (Lexical Environment)** 是 **ECMAScript 标准中定义的具体数据结构**，它是执行上下文（EC）的核心组成部分。它是一个**运行时 (runtime) 对象**，在每个执行上下文创建时生成。它有两个关键部分：\n\n1. **环境记录 (Environment Record)：**\n   \n   - 实际存储变量和函数声明的地方。\n   \n   - **声明式环境记录：** 存储 `let`、`const`、`class`。它们被创建时不会初始化，从而产生**暂时性死区 (TDZ)**。\n   \n   - **对象环境记录：** 在全局 EC 中，存储 `var` 变量和函数。\n\n2. **外部环境引用 (Outer Environment Reference)：**\n   \n   - 指向**创建该执行上下文时的父级执行上下文的词法环境**。\n   \n   - 这个引用链条就是 **作用域链 (Scope Chain)** 的基础，用于变量查找。\n\n总结： 当我们在函数内部访问变量时，JS 引擎会首先在当前 执行上下文 的中查找，如果找不到，就会沿着 **作用域链** 向上查找，直到全局 EC，所以函数能访问外部的变量，这也是闭包的前提。\n\n`let` 在 `for` 循环中会为每次迭代创建独立的词法环境，因此闭包捕获的是不同的 i，而不是同一个变量。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-18",
          "title": "说说js的作用域",
          "content": "A. 三种作用域：\n\n1. **全局作用域**：代码任何地方都能访问。\n2. **函数作用域**：变量只在函数内部可见。\n3. **块级作用域 (ES6+)**：由 `{}` 包裹的区域（配合 `let` / `const` 使用）。\n\nB. 作用域链 (Scope Chain)：\n\n当 JS 引擎寻找一个变量时，会先在当前作用域找。如果找不到，就去**父级作用域**找，直到找到全局作用域为止。这种链式查找机制就是作用域链。\n\nC. JS 采用的是**静态作用域**（即词法作用域）。\n\n**词法作用域 (Lexical Scope)** 是一个**抽象的、静态的编程原则或规则**。\n\n- **性质：** 它只取决于代码在 **哪里被编写 (定义)**，与代码在运行时 **哪里被调用** 无关。\n- **作用：** 它决定了变量的可访问性范围。\n- 这意味着函数的作用域在**函数定义的时候**就决定了，而不是在函数调用的时候。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-19",
          "title": "Object.create(proto) 方法",
          "content": "其中 *proto* 是新对象的原型对象\n\n`Object.create()` 的主要目的**不是复制 (Clone)** 一个现有对象，而是创建一个**新对象**，并精确控制新对象的**原型 (Prototype)**。\n\n`Object.create()` 的第一个参数是 **强制要求** 传入的，它就是新创建对象的 **`[[Prototype]]` (即 `__proto__`)**。\n\n核心能力是作为 **ECMAScript 官方提供的、创建指定原型对象**的方法，它是实现纯净原型继承的最佳实践。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-20",
          "title": "Object.assign()",
          "content": "`Object.assign(target, ...sources)` 方法用于将所有**可枚举 (enumerable) 的自有属性 (own properties)** 的值，从一个或多个**源对象 (source)** 复制到**目标对象 (target)**。\n\n返回值： 返回修改后的目标对象 `target`。\n\n仅执行浅拷贝 (Shallow Copy Only)\n\n只复制可枚举的自有属性\n\n一般用于**合并配置对象 (Merging)：** 将默认配置与用户提供的配置合并。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-21",
          "title": "Object.defineProperties 的作用",
          "content": "把参数2的属性赋值给参数1，特点是不仅复制属性，还复制属性的属性，比如是否可枚举、可修改这些属性\n\n- 不仅仅是赋值，而是**使用属性描述符定义属性**\n\n- 可以控制属性的可写性、可枚举性、可配置性\n\n- 可以定义访问器属性（getter/setter）\n\n- 默认属性特性与普通赋值不同",
          "hasAnswer": true
        },
        {
          "id": "js-basic-22",
          "title": "es6新特性",
          "content": "1. 作用域与变量管理 (Scope & Mutability)\n- **`let` 和 `const`：** 引入**块级作用域 (Block Scoping)**，彻底解决了 `var` 导致的变量提升和作用域污染问题，增强了代码的稳定性和可预测性。\n2. 异步编程基石 (Async Foundation)\n- **Promises：** 提供了结构化、可链式调用的异步处理方案，解决了传统回调函数的**回调地狱 (Callback Hell)**，是 `async/await` 的底层基础。\n3. 函数与上下文 (Functions & Context)\n- **箭头函数 (`=>`)：** 语法简洁。核心价值在于使用**词法 `this`**，消除了普通函数中 `this` 绑定不明确的痛点，使上下文指向更加可靠。\n4. 数据结构与模块化 (Data & Structure)\n- **`class` 语法：** 基于原型继承的**语法糖**，使面向对象编程（OOP）更接近传统语言模式，提高了可读性。\n- **解构赋值/扩展运算符 (`...`)：** 极大地简化了数据操作，如数组合并、对象浅拷贝、函数参数收集等，提高了代码简洁性。\n- **`Map` 和 `Set`：** 提供了更高效的数据结构，解决了传统 JS 对象作为键的限制 (`Map`) 和快速去重 (`Set`) 的需求。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-23",
          "title": "Set、Map、WeakSet、weakMap 的区别",
          "content": "Weak 系列与普通系列的本质区别，就在于**垃圾回收 (GC)** 机制。\n\n1. 强引用 (Strong Reference)：Map & Set\n- 如果一个对象被 `Map` 或 `Set` 引用，那么这个对象就不会被垃圾回收机制回收。\n\n- **副作用：** 如果你将 DOM 元素或大型对象作为键或值存储在 `Map` 或 `Set` 中，即使该对象在代码中已无其他引用，它也会被 Map/Set **钉死在内存中**，直到你手动调用 `.delete()` 移除，否则会导致**内存泄漏**。\n2. 弱引用 (Weak Reference)：WeakMap & WeakSet\n- 如果一个对象**只**被 `WeakMap` 或 `WeakSet` 引用，那么这个对象**可以**被垃圾回收机制回收。\n\n- **自动清理：** 一旦对象被 GC 回收，它在 `Weak` 集合中的对应条目也会被 **自动移除**。\n\n- **副作用消除：** 它们专为**不干扰 GC** 的非核心数据存储而设计，是避免内存泄漏的强大工具。\n3. Weak 集合的特殊限制（不可迭代的原因）\n\n`WeakMap` 和 `WeakSet` 具有不可迭代性，也不支持 `.clear()` 或 `.size` 属性。\n\n- **原因：** 由于它们是弱引用，集合中的对象随时可能被 GC 回收而消失。\n\n- **后果：** 如果允许迭代，你将无法保证在迭代开始和结束时集合内容的一致性，这会导致代码逻辑不可预测。\n\n高级应用场景（Use Cases）\n\nA. WeakMap：关联私有数据或缓存\n\n- **场景：** 在不修改原对象的情况下，为其关联额外的数据或缓存。\n\n- **示例：** 创建一个 `WeakMap` 来存储 DOM 元素的事件监听器。当 DOM 元素被移除时（被 GC 回收），WeakMap 中对应的事件监听器也会自动清理，**防止内存泄漏**。\n\nB. WeakSet：跟踪对象状态或成员资格\n\n- **场景：** 简单地跟踪一个大型对象集合中，哪些对象处于“活动”或“已处理”状态，但又不想阻止这些对象被 GC 回收。\n\n- **示例：** 跟踪一个大型应用中哪些对象实例已经被初始化或激活，用于防止重复处理。\n\n总结来说，`Set` 和 `Map` 是通用的数据结构，用于**核心数据存储**；而 `WeakSet` 和 `WeakMap` 是用于**关联辅助数据、解决内存泄漏问题**的**工具**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-24",
          "title": "箭头函数与普通函数的差异",
          "content": "没有自己的this, 继承外层作用域的 `this`。\n\n不能new\n\n不能call bind apply\n\n没有 `arguments` 对象\n\n不支持 `yield` 关键字",
          "hasAnswer": true
        },
        {
          "id": "js-basic-25",
          "title": "ES6模块和Common]S模块的区别",
          "content": "核心区别在于 **CommonJS 是为服务器端同步加载设计的**，而 **ES Modules 是为浏览器端异步加载和静态分析设计的**。\n\n- CJS 是在 Node.js 环境中诞生的，文件模块通常存储在本地硬盘上。因此，CJS 可以使用 `require()` **同步阻塞**地加载文件。它在**运行时**执行代码后，才能知道导入了什么。\n\n- **ES Modules (异步)：** ESM 是为浏览器设计的，模块通常需要通过网络请求加载。因此，ESM 采用**异步加载**，以避免阻塞主线程。ESM 在**代码静态解析阶段**（编译时）就能确定所有依赖关系。\n\n- **CommonJS (动态值拷贝)：**\n  \n  - CJS 导出的是一个值的**拷贝**。一旦模块导出，原始模块内部对变量的修改不会影响到导入方。\n  \n  - `require()` 得到的是一份导出的**值的快照**。\n\n- **ES Modules (静态实时绑定/引用)：**\n  \n  - ESM 导出的是对原始变量的**引用**（Live Binding）。\n  \n  - 这意味着导入方和导出方共享同一个变量。如果导出方在后续代码中修改了该变量，导入方可以观察到这种变化。\n\n**ESM 的优势：** 由于 ESM 采用 `import` / `export` 这种**静态语法**，JS 引擎或构建工具（如 Webpack/Rollup）可以在不执行代码的情况下，分析出模块之间的依赖关系。这使得 **Tree-Shaking（摇树优化）**成为可能，即只打包实际用到的代码，极大地减小了最终产物大小。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-26",
          "title": "arguments 的定义与作用",
          "content": "`arguments` 是一个特殊的**类数组对象 (Array-like Object)**，它在函数被调用时自动创建，并包含函数被调用时实际传入的所有参数。\n\n**作用域：** 仅存在于**非箭头函数**的函数体内部。\n\n可迭代对象，但不是数组 可以通过传统的 `for` 循环进行遍历或者Array.from(arguments)\n\n```js\nfunction sum(a, b) {\n  // 访问第一个参数\n  console.log(arguments[0]); // 对应传入的 a\n  // 访问所有参数数量\n  console.log(arguments.length); \n\n  // 即使函数没有定义第三个参数，也可以通过 arguments 访问\n  if (arguments.length > 2) {\n    console.log('还有额外的参数：', arguments[2]);\n  }\n}\n\nsum(10, 20, 30); \n// 输出: 10\n// 输出: 3\n// 输出: 还有额外的参数： 30\n```\n\n更推荐用es6的剩余参数\n\n```js\nfunction sumAll(...args) {\n  // args 是一个真正的数组，可以直接使用数组方法\n  return args.reduce((acc, current) => acc + current, 0);\n}\n\n// 优势：\n// 1. args 是一个真正的数组，可以直接调用 map, reduce 等方法。\n// 2. 没有参数绑定的困扰。\n// 3. 语法更清晰。\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-27",
          "title": "let/const/var 的底层区别",
          "content": "1.作用域 \n\nvar 函数作用域。在函数外部声明时是全局作用域。\n\n`let` / `const`块级作用域 。变量的作用域限制在最近的一对花括号 `{}` 内\n\n2.变量提升\n\nvar 完整提升。声明和初始化同时提升到作用域顶部，但初始化为 `undefined`\n\n`let` / `const` 只提升声明。声明会被提升，但不会被初始化。存在暂时性死区，在变量声明语句执行之前，访问该变量都会抛出 `ReferenceError`\n\n3.绑定与赋值\n\nvar 可以重复声明，在全局作用域声明时，会挂载到 `window` 或 `global` 对象。\n\nlet、const **不允许重复声明**。在同一作用域内重复声明会抛出 `SyntaxError`。也不会挂载到全局对象上。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-28",
          "title": "说说Proxy",
          "content": "`Proxy` 的核心价值在于**对对象的操作进行非侵入式（Non-invasive）的拦截和定制**。它提供了一个代理层，允许我们在对象操作的 13 个内部方法（如 `get`, `set`, `apply`, `construct`）被调用时介入。\n\n应用：\n\n响应式系统和状态管理（最重要，比如vue）；`Proxy` 可以直接监听对象属性的增删改查，而不需要像 `Object.defineProperty` 那样预先遍历所有属性，解决了数组和新增属性的监听难题。\n\n数据校验与属性保护：在 `set` 拦截器中，加入自定义的校验逻辑（如类型检查、范围检查），如果不通过则抛出错误或拒绝赋值，防止不合规的数据流入\n\n实现私有属性：在 `get` 或 `has` 拦截器中，对特定前缀（如 `_` 开头的属性）返回 undefined` 或 `false`，模拟私有属性效果。\n\n写法：\n```javascript\nconst handler = {\n    // 陷阱 (Trap)：拦截属性的读取操作\n    get(target, prop, receiver) {\n        if (prop === 'message3') {\n            return `[${target.message1} ${target.message2}]`;\n        }\n        // 默认行为：返回目标对象的属性值\n        return Reflect.get(target, prop, receiver); \n    },\n    // ... 比如 set(target, prop, value, receiver) { ... }\n}\nconst target = {\n    message1: \"Hello\",\n    message2: \"World\"\n};\nconst proxy = new Proxy(target, handler);\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-29",
          "title": "Reflect 是什么？怎么用",
          "content": "`Reflect` 是一个内置对象，它提供了一系列静态方法，这些方法与 `Proxy` 陷阱的方法**同名且参数一致**。它提供了 13 个静态方法，这些方法与 `Proxy` 的 13 个拦截器方法一一对应。\n\n例如：\n\n- 以前获取对象属性：`obj.prop` 或 `Object.getOwnPropertyDescriptor(obj, prop)`\n\n- 现在通过 `Reflect`：`Reflect.get(obj, prop)`\n\n- `'prop' in obj` $\\rightarrow$ `Reflect.has(obj, 'prop')`\n\n- `delete obj.prop` $\\rightarrow$ `Reflect.deleteProperty(obj, 'prop')`\n\n在 `Proxy` 的 `handler` 中，我们经常需要执行目标对象上的默认操作。使用 `Reflect` 可以干净、安全地实现这一点。\n\n`Reflect` 将一些命令式的操作符（如 `delete`）或命令式的方法调用（如 `new`）转换成了函数式的调用，使得代码更易于维护和理解。\n\nReflect 能提供操作失败的明确反馈，返回一个**布尔值**表示成功或失败，代码更简洁。一般的 `Object` 上的方法（例如 `Object.defineProperty`），在执行失败时会抛出异常，这需要用 `try...catch` 捕获。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-30",
          "title": "说说promise怎么用和优缺点",
          "content": "优点：\n\n解决回调地狱，改为链式回调，提高了代码的可读性和维护性\n\n统一的错误处理机制，集中捕获，简化流程\n\n规范异步状态管理，明确的三种状态：Pending/Fulfilled/Rejected, 使异步操作的结果可预测和可追踪。\n\n易于组合和并行处理，.all .race 等\n\n缺点：\n\n仍然是链式结构（未完全同步化）需要显式的 `.then()` 链来组织代码流程\n\n立即执行的特性，缺乏中断和取消机制\n\n一次性结果，一旦状态确定，就无法再次改变\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获",
          "hasAnswer": true
        },
        {
          "id": "js-basic-31",
          "title": "js有哪些异步方法",
          "content": "1. 计时器 settimeout setInterval，属于宏任务\n2. 异步流程控制与状态管理：Promise async/await，属于微任务\n3. 网络请求与文件操作：\n- **`fetch(url)` (现代标准):** 微任务\n  - 返回一个 Promise 对象，用于发起网络请求。\n  - 是最常用的网络请求 API，取代了大部分 XHR 用法。\n- **`XMLHttpRequest` (XHR) (传统方法):** 特指基于事件监听而不是promise的，是宏任务\n  - 传统的回调式 API，现在主要用于文件上传等特定场景，或需要浏览器底层控制的场合。\n- **`FileReader` / 各种 I/O 操作:** 也是通过回调或 Promise返回，宏任务",
          "hasAnswer": true
        },
        {
          "id": "js-basic-32",
          "title": "Generator是什么怎么用",
          "content": "Generator 函数（生成器）是一种特殊的函数，它能够**暂停执行**并在稍后**从暂停点恢复执行**。这是通过 Generator 函数内部维护的一个 **状态机 (State Machine)** 来实现的。本质是同步的\n\n`function`定义 Generator 函数\n\n`yield`暂停函数执行，并返回 `yield` 后的值\n\n`.next()`恢复函数执行，并返回一个包含 `{value, done}` 的对象。\n\n意义：简化异步编程；提供函数**暂停和恢复执行**的底层能力 (`yield` 机制)，这是实现“等待”的唯一方式；返回一个同时满足可迭代和迭代器协议的对象\n\nGenerator 解决了 **代码流的连续性** 问题，这是 Promise （依赖于 回调函数）无法做到的。\n\n`async/await` 的底层基础是 Promise，但它的核心机制是 Generator",
          "hasAnswer": true
        },
        {
          "id": "js-basic-33",
          "title": "Generator和 Async/Await 原理",
          "content": "核心机制：状态机\n\n普通函数从头到尾执行一次，没有状态。而 Generator 函数被编译后，其函数体内的每一行代码（特别是 `yield` 语句）都成为了状态机中的一个节点。\n\n`yield` 关键字：暂停的指令（将 Generator 函数的执行上下文完整地保存，并挂起，引擎立即将控制权返回给调用者所在的执行上下文，即调用 `gen.next()` 的那个上下文）\n\n`.next()` 方法：恢复的指令（执行优先级非常高，因为它是一个**同步操作**，讲挂起的上下文放入当前执行栈，会影响后续其他的宏任务微任务，就像一个同步函数调用）\n\nGenerator 对象的生命周期内，其内部状态（包括局部变量）被持续存储在内存中，这就是它能够从上次离开的地方继续执行的原因。\n\n```js\nfunction* numberGenerator() {\n  console.log('--- 启动 ---');\n  let result1 = yield 1;\n\n  console.log('--- 恢复，接收到:', result1, '---');\n  let result2 = yield 2; \n\n  console.log('--- 恢复，接收到:', result2, '---');\n  return 3;\n}\n\n// 1. 调用 Generator 函数，返回迭代器对象（Generator Object）\nconst gen = numberGenerator(); \n\nconsole.log(gen.next()); \n// 输出: --- 启动 ---\n// 输出: { value: 1, done: false } (遇到第一个 yield 暂停)\n\nconsole.log(gen.next('A')); // 将 'A' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: A ---\n// 输出: { value: 2, done: false } (遇到第二个 yield 暂停)\n\nconsole.log(gen.next('B')); // 将 'B' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: B ---\n// 输出: { value: 3, done: true } (遇到 return 结束)\n\nconsole.log(gen.next());\n// 输出: { value: undefined, done: true } (已完成)\n```\n\n`async/await` 是 ES7 (ES2016) 引入的，它的底层是基于 **Promise** 和 **Generator** 实现的**语法糖 (Syntactic Sugar)**。它的核心原理是**自动化**了 Generator 的驱动过程，相当于异步完成后自动调用了.next\n\n对比：\n- **Promise** 是 `async/await` 的**外部接口**（输入和输出）。\n- **Generator** 是 `async/await` 实现**暂停和恢复**的**内部引擎**。\n- **async/await**` 是对 **Promise** 和 **Generator** 的一种**语法糖 (Syntactic Sugar)**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-34",
          "title": "严格模式",
          "content": "严格模式是 ES5 引入的一种特殊模式，旨在选择性地限制 JavaScript 的某些不安全、低效或有缺陷的行为\n\n- **全局模式：** 在脚本文件顶部添加 `\"use strict\";`。\n\n- **函数模式：** 在函数体内部顶部添加 `\"use strict\";`\n\n严格模式是保证代码质量和项目维护性的要求\n\n重要规则：\n\n禁止隐式全局变量：尝试给未声明的变量赋值时，将不再自动在全局对象 (`window` 或 `global`) 上创建该变量，而是**直接抛出 `ReferenceError`**。\n\n规范 `this` 默认绑定（上下文可预测性）：独立函数调用 `this` 为 `undefined`\n\n静默失败转为抛出错误 (代码健壮性)\n\n禁用堆栈调用属性，禁止函数动态获取调用栈信息，（严重阻碍了js 引擎进行即时编译优化",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "typescript",
      "name": "TypeScript",
      "questions": [
        {
          "id": "typescript-1",
          "title": "type 和 interface 的区别",
          "content": "interface 接口 可合并可多次定义，更适合定义对象或者 api 的标准和形状\n\ntype 不可多次声明，可以定义任何类型，包括对象、联合类型、交叉类型、原始类型、元组",
          "hasAnswer": true
        },
        {
          "id": "typescript-2",
          "title": "TypeScript 与 JavaScript 的主要区别",
          "content": "ts: **静态类型**：类型在代码编写时确定。必须通过 **TS 编译器**（或 Babel/SWC 等）编译成 JS 后才能执行；编译时检查，**类型安全**高；JS 的**超集**，包含了 JS 的所有特性\n\njs：动态类型，类型在执行时确定；运行时检查，**类型安全**低（运行时错误多）",
          "hasAnswer": true
        },
        {
          "id": "typescript-3",
          "title": "什么是联合类型 (|) 和交叉类型 (&)",
          "content": "联合类型 | （或） 表示一个值可以是所列类型中的任意一种。\n\n交叉类型 & (且) **表示一个值必须同时满足所列的**所有类型。常用于合并接口或类型，实现 Mixin 效果。一个交叉类型对象必须拥有所有类型的属性。",
          "hasAnswer": true
        },
        {
          "id": "typescript-4",
          "title": "any 和 unknown 的区别",
          "content": "any **完全禁用**类型检查。可以赋值给任何类型，**破坏**类型安全。可以随意访问属性或调用方法，可能导致运行时错误。\n\nunknow **严格类型检查**，除非明确类型收窄，否则无法使用。只能赋值给 `any` 或 `unknown` 本身，**保持**类型安全。**必须先进行类型收窄**（如 `if (typeof x === 'string')`），才能操作。\n\n更推荐 unknow 提供了一个类型安全的占位符",
          "hasAnswer": true
        },
        {
          "id": "typescript-5",
          "title": "类型断言及其使用场景",
          "content": "类型断言是告诉 TypeScript 编译器“我比你更清楚这个变量的实际类型”的一种方式。它不会改变变量的运行时类型，只在编译时起作用\n\n**应避免使用的场景：**\n\n- **不确定的情况下：** 任何你不 100% 确定类型的时候。错误的断言会**绕过 TS 的保护**，导致在运行时出现错误（这是 TS 极力避免的）。\n\n- **可以进行类型收窄的情况下：** 应优先使用类型保护（`if`, `instanceof` 等）进行收窄，而不是使用断言",
          "hasAnswer": true
        },
        {
          "id": "typescript-6",
          "title": "解释 keyof 和 typeof 的用法",
          "content": "| **`typeof`** | **值到类型**。获取一个 JavaScript **变量**或**表达式**的类型。   | 常用于获取函数的返回值类型，或从常量对象中提取类型。  |\n| ------------ | --------------------------------------------- | --------------------------- |\n| **`keyof`**  | **键名提取**。获取一个**对象类型**中所有属性名组成的**联合字符串字面量类型**。 | 常用于泛型约束，确保传入的属性名是对象中真实存在的键。 |\n\n```js\nconst User = {\n    name: 'Alice',\n    age: 30\n};\n\n// 1. typeof：获取 User 变量的类型\ntype UserType = typeof User; // 结果: { name: string; age: number; }\n\n// 2. keyof typeof：获取 User 类型的所有键名\ntype UserKeys = keyof typeof User; // 结果: \"name\" | \"age\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-7",
          "title": "tsconfig.json 中的 strict 模式",
          "content": "**`\"strict\": true`** 是 `tsconfig.json` 中的一个总开关，它同时开启了一系列严格的类型检查规则。它的作用是**最大化地提升代码的类型安全性**。\n\n我认为 **`strictNullChecks`**（严格空值检查）是最重要的子选项。\n\n- **作用：** 默认情况下，`null` 和 `undefined` 可以赋值给任何类型。开启后，`null` 和 `undefined` 只能赋值给它们自己的类型或 `any`，除非类型定义中明确包含它们（如 `string | null`）。",
          "hasAnswer": true
        },
        {
          "id": "typescript-8",
          "title": "装饰器及其应用场景",
          "content": "饰器是一种特殊的声明，它能够附加到类、方法、属性或参数上，用于**修改或扩展**这些目标的功能或行为。它们是 **ES 阶段性提案**，TS 率先实现。\n\n装饰器本质上就是一个**函数**。这个函数在运行时会被调用，它接收关于被装饰目标的元数据（如目标类、方法名、属性描述符等），并可以通过返回新的值来**修改或替换**被装饰目标的定义。\n\n装饰器允许我们在不修改原有类结构和代码的情况下，通过注入元数据或实现额外逻辑，对现有功能进行扩展。\n\n1. 语法\n\n装饰器使用 `@expression` 的形式，紧挨着要装饰的声明之前。\n\n```ts\n@sealed // 这是一个装饰器\nclass Example {\n  @logMethod // 这是另一个装饰器\n  myMethod() {}\n}\n```\n\n2. 启用\n\n装饰器目前是 ECMAScript 的**阶段性提案**（Stage 3），不是标准的 JS 语法。要在 TypeScript 中使用它，必须在 `tsconfig.json` 中启用：\n\nJSON\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true, // 必须开启\n    \"emitDecoratorMetadata\": true // 如果需要依赖注入等元数据，也需要开启\n  }\n}\n```\n\n3.类型：类 属性 方法 Getter/Setter 方法参数\n\n作用\n\n1 依赖注入 (DI) 和框架配置，装饰器（或等效的语法）来标记类和处理依赖注入。比如 vue-property-decorator\n\n2 混入 (Mixins) 或功能增强（类装饰器）：可以利用类装饰器返回一个新的构造函数，为类添加新方法或属性：\n\n3.运行时 添加通用逻辑（方法装饰器）：方法装饰器常用于不修改原函数体的情况下，在其执行前后添加通用逻辑\n\n当一个声明上有多个装饰器时，它们的执行顺序如下：\n\n1. **参数装饰器 $\\to$ 属性装饰器 $\\to$ 方法/访问器装饰器 $\\to$ 类装饰器**（从内向外，从上到下）。\n\n2. **同一类型装饰器：** 如果同一目标上有多个装饰器，它们会像函数组合一样，**从下到上**（从右到左）执行。",
          "hasAnswer": true
        },
        {
          "id": "typescript-9",
          "title": "处理第三方库没有类型定义的问题",
          "content": "当引入一个没有内置类型定义的第三方 JS 库时，需要手动为其添加类型声明，以让 TS 编译器识别其结构。\n\n**处理步骤：**\n\n1. **检查 `@types/` 库：** 首先尝试 npm 生态系统中有没有针对这个第三方 JavaScript 库的**对应的类型定义库**。比如@types/jquery @types/lodash，有的话安装库就行了\n\n2. **创建自定义声明文件 (`.d.ts`)：** 如果 `@types` 包不存在，需要手动创建声明文件，通常命名为 `custom.d.ts` 或 `library-name.d.ts`。\n   \n   a.**模块声明：** 使用 `declare module` 声明整个模块的类型。\n\n```typescript\n// my-library.d.ts\ndeclare module 'my-library' {\n  // 声明库导出的函数\n  export function initialize(config: object): void;\n  // 声明库导出的类\n  export class AwesomeClient {\n    connect(): Promise<string>;\n  }\n  // 声明默认导出\n  export default AwesomeClient;\n}\n```\n\nb.全局变量声明：如果库是注入全局变量的（如 jQuery），则使用 `declare var` 或 `declare function`。\n\n这样，TypeScript 编译器就会信任您提供的类型信息，并在您的项目代码中提供类型检查和智能提示。\n\n注意：全局/局部声明：\n如果是 declare module xx{...}，就只针对引用这个 module 的模块，如果是有顶层 export 就只针对导入这个文件的模块，如果直接 declare xx 且文件里没有任何顶层 export 就是全局的\n\n这里的**全局**和**局部（模块）**指的完全是 **TypeScript 编译器**对您的代码和声明文件（`.d.ts`）中**类型和标识符作用域**的认识",
          "hasAnswer": true
        },
        {
          "id": "typescript-10",
          "title": "Extract、Exclude、Pick、Omit 的区别与用法",
          "content": "Extract 提取\n\n- 是一个内置的工具类型，它的作用是**从一个联合类型中，提取出符合特定条件的成员**，并组成一个新的联合类型。\n\n- 可以把它理解为联合类型的“过滤器”。支持**子类型**的匹配\n\n- 原理：遍历 `T` 中的每一个成员。如果该成员能够赋值给 `U`，就保留它（返回 `T`）；否则就丢弃它（返回 `never`）。 `type MyExtract<T, U> = T extends U ? T : never;`\n\n```ts\ntype Result = Extract<Type, Union>;\n\ntype Status = 'success' | 'error' | 'loading' | 'waiting';\n// 我只想从中提取出 'error' 和 'success'\ntype FinalStatus = Extract<Status, 'success' | 'error'>;\n// 结果：'success' | 'error'\n\ntype MyData = string | number | boolean | (() => void);\n// 提取出所有可以赋值给 Function 的类型\ntype OnlyFunction = Extract<MyData, Function>; // 结果：() => void\n```\n\nExclude 排除\n\n**Exclude** 就是 **Extract** 的反义词\n\n`Exclude<T, U>`：排除 `T` 中属于 `U` 的\n\n```ts\ntype Status = 'success' | 'error' | 'loading';\ntype NoError = Exclude<Status, 'error'>; // 结果：'success' | 'loading'\n```\n\nPick（挑选）\n\n`Pick<Type, Keys>` 允许你从一个类型中，选择一组特定的属性来构造新类型。\n\n- **语法**：`Pick<T, K>`，其中 `T` 是源类型，`K` 是由 `T` 的键组成的联合类型。\n\n- **适用场景**：当你只需要一个大型对象中的某几个字段时\n\n- **实现**：它遍历 `K` 中的每一个键，并在 `T` 中找到对应的类型。\n\nOmit（剔除）\n\n`Omit<Type, Keys>` 与 `Pick` 相反，它会从一个类型中剔除指定的属性，剩下的属性组成新类型。\n\n- **语法**：`Omit<T, K>`。\n\n- **适用场景**：当你想复用一个类型，但其中某个字段不需要，或者需要被重新定义时\n\n- **实现**：它结合了 `Exclude` 和 `Pick`。先从 `T` 的所有键中排除掉 `K`，再把剩下的键 `Pick` 出来。\n\n```ts\ntype Hello = { a: string; b: string; c: number };\n\n// 使用 Pick 挑选属性\ntype OnlyAB = Pick<Hello, 'a' | 'b'>;\n// 结果为：\n// type OnlyAB = { a: string; b: string;}\n```\n\n对比：\n\n- **`Extract Exclude`**：操作的是**联合类型**，第二个参数是类型集合。是从一堆类型选项里选出几个\n\n- **`Pick Omit`** 处理的是对象类型, 第二个参数是属性集合，根据属性键进行选择或忽略\n\n- **`Pick`**：可以理解为白名单操作的是**对象接口（Interface/Object Type）**。它是从一个对象的属性里选出几个。 `Pick` 会严格检查选择的键是否存在于原类型中，如果你 Pick 一个不存在的键，编译器会报错\n\n- **Omit**：可以理解为黑名单。在使用 `Omit` 时，TS **不会**检查你剔除的键是否存在于原类型中（因为 `K extends keyof any`）。\n\n```ts\ninterface User {\n  id: string;\n  name: string;\n  age: number;\n}\n// 剔除 id 属性\ntype CreateUserDto = Omit<User, 'id'>;\n/*\n等同于：\ntype CreateUserDto = {\n  name: string;\n  age: number;\n};\n*/\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-11",
          "title": "TypeScript 基本数据类型",
          "content": "- boolean（布尔类型）\n- number（数字类型）\n- string（字符串类型）\n- array（数组类型）\n- null 和 undefined 类型\n- object 对象类型\n- tuple（元组类型） 允许表示一个已知元素数量和类型的数组，各元素的类型不必相同\n- enum（枚举类型）\n- void 类型 用于标识方法返回值的类型，表示该方法没有返回值\n- any（任意类型）可以指定任何类型的值，不进行类型检查而是通过编译阶段的检查\n- unknow 不确定的类型 ：**严格类型检查**，除非明确类型收窄，否则无法使用。\n- never 类型 代表从不会出现的值，是其他所有类型的子类型，可以赋值给任何类型\n\n```\nlet tupleArr:[number, string, boolean];\ntupleArr = [12, '34', true]; //ok\ntypleArr = [12, '34'] // no ok\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-12",
          "title": "TypeScript 类与修饰符",
          "content": "形式跟`ES6`十分的相似，`typescript`在此基础上添加了修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问（ ES6 私有字段用#表示（ES2022））\n- 受保护 protected：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n- 只读属性`readonly`：只读属性必须在声明时或构造函数里被初始化\n- static (ES6 也有) ：静态属性/方法：是类的属性而不是实例的属性，直接通过类调用\n\n```ts\nclass Square {\n    static width: number // 类的属性\n    public static height: number\n    public name: string;     // 公开（默认）\n    private secret: string;  // 仅类内访问\n    protected age: number;   // 类和子类访问\n    readonly id: number;     // 只读属性\n    public readonly publicReadonly: string  // 只读\n    static readonly PI: number = 3.14159; // static + readonly\n    public static readonly staticPublicReadonly: string = \"\";\n    // 方法类似\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-13",
          "title": "抽象类",
          "content": "抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n\n```ts\nabstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earch...');\n  }\n}\n\nclass Cat extends Animal {\n  makeSound() {\n    console.log('miao miao');\n  }\n}\nconst cat = new Cat();\ncat.makeSound(); // miao miao\ncat.move(); // roaming the earch...\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-14",
          "title": "和 ES6 对比",
          "content": "TypeScript 类在 ES6 类的基础上增加了**静态类型系统**和**面向对象增强特性**。主要区别有：\n\n1. **类型注解**：属性、方法、参数都有明确类型\n\n2. **访问修饰符**：`public/private/protected/readonly`\n\n3. **抽象类和抽象方法**：不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n4. **额外语法**：装饰器、泛型等\n\n**关键理解**：TypeScript 类是带类型的 ES6 类，大部分特性在编译后会被移除，最终生成标准的 JavaScript 类。",
          "hasAnswer": true
        },
        {
          "id": "typescript-15",
          "title": "TypeScript 函数特性",
          "content": "默认参数：es6 写法\n\n剩余参数：es6 写法\n\n可选参数：ts\n\n和 ES6 对比：TypeScript 函数在 ES6 函数的基础上增加了**静态类型系统**。主要区别有：\n\n1. **类型注解+更严格的编译时检查**：参数、返回值都有明确类型\n\n2. **函数重载**：支持多个函数签名，提高类型安全\n\n3. **泛型函数**：支持类型参数化，创建可复用的函数模板\n\n4. **可选参数语法**：使用  `?`  明确表示可选参数",
          "hasAnswer": true
        },
        {
          "id": "typescript-16",
          "title": "泛型的定义与使用",
          "content": "泛型允许编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型\n\n在`typescript`中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性\n\n泛型通过`<>`的形式进行表述，可以声明：函数 接口 类\n\n```\nfunction returnItem<T>(para: T): T {\n    return para\n}\ninterface ReturnItemFn<T> {\n    (para: T): T\n}\nclass Stack<T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-17",
          "title": "高级类型",
          "content": "- 交叉类型 `T & U`\n\n- 联合类型 `T | U`\n\n- 条件类型 `T extends U ? X : Y`\n\n- 类型别名 ,可以是泛型 ,也可以使用类型别名来在属性里引用自己：\n  \n  ```ts\n  type some = boolean | string;\n  type Container<T> = { value: T };\n  type Tree<T> = {\n    value: T;\n    left: Tree<T>;\n  };\n  ```\n\n- 类型索引：keyof，类似于  `Object.keys` ，用于获取一个接口中 Key 的联合类型。\n\n- 类型约束：通过关键字  `extend`  进行约束，泛型内使用的主要作用是对泛型加以约束\n  \n  ```ts\n  type BaseType = string | number | boolean;\n  // 这里表示 copy 的参数\n  // 只能是字符串、数字、布尔这几种基础类型\n  function copy<T extends BaseType>(arg: T): T {\n    return arg;\n  }\n  ```\n\n- 映射类型：通过  `in`  关键字做类型的映射，遍历已有接口的  `key`  或者是遍历联合类型\n  \n  ```ts\n  type Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n  };\n  interface Obj {\n    a: string;\n    b: string;\n  }\n  type ReadOnlyObj = Readonly<Obj>;\n  // 等同于\n  interface ReadOnlyObj {\n    readonly a: string;\n    readonly b: string;\n  }\n  ```",
          "hasAnswer": true
        },
        {
          "id": "typescript-18",
          "title": "命名空间 namespace",
          "content": "解决命名污染，使用  `namespace`  来定义，类似模块化\n\n```ts\nnamespace SomeNameSpaceName {\n  export interface ISomeInterfaceName {}\n  export class SomeClassName {}\n}\n// 使用\nSomeNameSpaceName.SomeClassName;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-19",
          "title": "条件类型中的 extends 判断",
          "content": "T extends U ：是 TypeScript 的条件类型语法，用于判断类型  `T`  是否可以赋值给类型  `U`，类似于判断  `T`  是否为  `U`  的子类型（或相同类型）。在分布式条件下，如果  `T`  是联合类型，那么会拆开每个成员分别判断。\n\n```ts\ntype A = 'a' | 'b' | 'c';\ntype B = 'a' | 'b';\n\n// 判断 'a' 是否可以赋值给 B？可以，因为 'a' 在 B 中。\n// 判断 'b' 是否可以赋值给 B？可以。\n// 判断 'c' 是否可以赋值给 B？不可以。\n\n// 所以 Exclude<A, B> 会计算：\n// 'a' extends B ? never : 'a' → never\n// 'b' extends B ? never : 'b' → never\n// 'c' extends B ? never : 'c' → 'c'\n// 合并：never | never | 'c' → 'c'\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-20",
          "title": "为什么  string | null extends null  是  false？",
          "content": "**理解  `extends`  的含义**：在 TypeScript 中，`T extends U`  表示：\n\n- **类型 T 的值可以安全地赋值给类型 U 的变量**\n\n- 或者说：**类型 T 是类型 U 的子类型**",
          "hasAnswer": true
        },
        {
          "id": "typescript-21",
          "title": "infer 关键字的用法",
          "content": "只能在 **条件类型 (Conditional Types)** 的 `extends` 子句中使用。在类型的条件判断中，“声明”一个变量来捕获（提取）某个特定的类型。\n\n可以理解为：infer 告诉编译器：不要让我手动指定这个类型，请你根据当前的上下文，帮我**推断**出这里的具体类型并挂载到变量名下。\n\n我不需要知道 R 是什么，我让 TS 自己去“挖”，不是开发者指定的，是编译器“猜”出来的。\n\n对比泛型：本质上是**参数**，调用时具体什么类型是明确的\n\n可以像正则表达式一样拆分字符串。\n\n```ts\n// 不需要知道 R 是什么，我让 TS 自己去“挖”\ntype MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n// 使用时：\ntype Result = MyReturnType<() => string>;\n// TS 就像做“填空题”一样，把 () => string 和 (...args: any[]) => R 对齐，\n// 发现 R 的位置刚好是 string，于是 R 就被赋值为 string。\n\n// 拆分字符串\ntype GetColor<T> = T extends `color:${infer C}` ? C : 'unknown';\ntype MyColor = GetColor<'color:red'>; // \"red\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-22",
          "title": "映射类型中的 - + 修饰符",
          "content": "- `-`  只能用于  `readonly`  和  `?`，**不能用于  `private`/`protected`!**\n\n- 这些操作只能在映射类型（`[P in keyof T]`）中使用\n\n- 可以组合使用：`-readonly -?`\n\n- 可以递归应用以处理嵌套对象\n\n添加修饰符（默认或显式使用  `+`）\n\n```ts\n// 显式添加（可选写法）\ntype ExplicitReadonly<T> = {\n  +readonly [P in keyof T]: T[P];  // 显式添加 readonly\n};\n\ntype ExplicitPartial<T> = {\n  +? [P in keyof T]: T[P];  // 显式添加 ?\n};\n```\n\n移除修饰符（使用  `-`）\n\n```ts\n// 移除 readonly\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n// 移除可选（?）\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// 同时移除 readonly 和 ?\ntype MutableRequired<T> = {\n  -readonly [P in keyof T]-?: T[P];\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-23",
          "title": "映射类型",
          "content": "遍历一个类型的属性，并对每个属性应用某种转换，生成新的类型。注意不能遍历私有属性\n\n核心语法：`{ [K in Keys]: Type }`\n\n常用场景：批量修改修饰符；批量转换属性；批量改变键名\n\n语法支持：条件过滤，as 断言\n\n注意：\n\n- **一个类型内部只能有一个映射类型**\n- **映射不处理私有和受保护属性**\n- **映射类型会保留索引签名**\n- `keyof any = string | number | symbol`",
          "hasAnswer": true
        },
        {
          "id": "typescript-24",
          "title": "类型收窄（Type Narrowing）",
          "content": "类型收窄是指 TypeScript 通过代码流分析，在特定代码块中将变量的类型从较宽泛的类型缩小到更具体的类型。\n\n**常见的类型收窄方式：**\n\n1. **typeof 类型守卫**：\n\n```ts\nfunction print(x: string | number) {\n  if (typeof x === 'string') {\n    console.log(x.toUpperCase()); // x 被收窄为 string\n  } else {\n    console.log(x.toFixed(2)); // x 被收窄为 number\n  }\n}\n```\n\n2. **instanceof 类型守卫**：\n\n```ts\nfunction logDate(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toISOString()); // x 是 Date\n  }\n}\n```\n\n3. **in 操作符**：\n\n```ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    animal.swim(); // animal 是 Fish\n  }\n}\n```\n\n4. **自定义类型守卫（is 关键字）**：\n\n```ts\nfunction isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n```\n\n5. **真值收窄**：`if (x)` 排除 `null`、`undefined`、`0`、`''` 等\n\n6. **相等性收窄**：`if (x === y)` 或 `if (x !== null)`",
          "hasAnswer": true
        },
        {
          "id": "typescript-25",
          "title": "tsconfig.json 重要配置",
          "content": "| 配置项                 | 作用                        |\n| ------------------- | ------------------------- |\n| `strict`            | 总开关，开启所有严格类型检查            |\n| `strictNullChecks`  | null/undefined 不能赋值给其他类型  |\n| `noImplicitAny`     | 禁止隐式 any 类型               |\n| `target`            | 编译目标版本（ES5/ES6/ESNext）    |\n| `module`            | 模块系统（CommonJS/ESNext/AMD） |\n| `moduleResolution`  | 模块解析策略（node/bundler）      |\n| `baseUrl` + `paths` | 路径别名配置                    |\n| `outDir`            | 输出目录                      |\n| `rootDir`           | 源码根目录                     |\n| `declaration`       | 生成 `.d.ts` 声明文件           |\n| `esModuleInterop`   | 兼容 CommonJS 和 ES Module   |\n| `skipLibCheck`      | 跳过声明文件类型检查，加快编译           |\n| `resolveJsonModule` | 允许导入 JSON 文件              |\n| `jsx`               | JSX 编译方式（react/preserve）  |",
          "hasAnswer": true
        },
        {
          "id": "typescript-26",
          "title": "TypeScript 模块化",
          "content": "TypeScript 完全支持 ES Module 语法，同时兼容 CommonJS。\n\n**ES Module 语法**：\n\n```ts\n// 导出\nexport const name = 'hello';\nexport default function () {}\nexport type { MyType };\nexport { value as alias };\n\n// 导入\nimport defaultExport from './module';\nimport { name } from './module';\nimport type { MyType } from './module';\nimport * as all from './module';\n```\n\n**模块解析**：\n\n- `moduleResolution: \"node\"` - Node.js 风格解析\n- `moduleResolution: \"bundler\"` - 现代打包器风格（推荐）\n\n**路径别名**：\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n**命名空间 vs 模块**：现代 TS 项目推荐使用 ES Module，命名空间主要用于全局脚本环境。",
          "hasAnswer": true
        },
        {
          "id": "typescript-27",
          "title": "TypeScript 中的异步处理",
          "content": "TypeScript 为异步操作提供了完整的类型支持：\n\n**1. Promise 类型**：\n\n```ts\nfunction fetchData(): Promise<string> {\n  return fetch('/api').then((res) => res.text());\n}\n\n// 泛型指定返回值类型\nconst promise: Promise<number> = Promise.resolve(42);\n```\n\n**2. async/await**：\n\n```ts\nasync function getData(): Promise<User[]> {\n  const response = await fetch('/api/users');\n  return response.json(); // 自动推断返回 Promise<User[]>\n}\n```\n\n**3. 错误处理类型**：\n\n```ts\nasync function safeFetch<T>(url: string): Promise<T | null> {\n  try {\n    const res = await fetch(url);\n    return res.json();\n  } catch {\n    return null;\n  }\n}\n```\n\n**4. 并发处理**：\n\n```ts\n// Promise.all 自动推断元组类型\nconst [user, posts] = await Promise.all([\n  fetchUser(), // Promise<User>\n  fetchPosts(), // Promise<Post[]>\n]); // user: User, posts: Post[]\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-28",
          "title": "接口继承",
          "content": "**单继承**：\n\n```ts\ninterface Animal {\n  name: string;\n}\ninterface Dog extends Animal {\n  breed: string;\n}\n// Dog 拥有 name 和 breed 两个属性\n```\n\n**多继承**：\n\n```ts\ninterface Flyable {\n  fly(): void;\n}\ninterface Swimmable {\n  swim(): void;\n}\ninterface Duck extends Flyable, Swimmable {\n  quack(): void;\n}\n```\n\n**接口继承类**：\n\n```ts\nclass Point {\n  x: number = 0;\n  y: number = 0;\n}\ninterface Point3D extends Point {\n  z: number;\n}\n```\n\n**interface vs type 继承对比**：\n\n- interface 用 `extends` 继承\n- type 用 `&` 交叉类型实现类似效果\n- interface 可以被多次声明并自动合并，type 不行",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "css-html",
      "name": "CSS & HTML",
      "questions": [
        {
          "id": "css-html-1",
          "title": "tailwind",
          "content": "Tailwind 是一个原子化 CSS 框架，每个类名对应一个单独的 CSS 属性，通过组合类名来构建组件样式。  \n **优点**：1️⃣ 打包时只包含使用到的类，CSS 文件体积小；2️⃣ 响应式和状态样式有内置支持，熟悉后可快速阅读 HTML/JSX，无需跳转 CSS 文件。  \n **缺点**：1️⃣ HTML/JSX 中类名可能很长，阅读略困难；2️⃣ 对复杂动效和状态管理，需要组合更多类，前期学习成本高。\n\n 简单一句话概括：**Tailwind 用类名组装替代传统 CSS，更轻量、可维护，但初学者上手和复杂交互处理略有挑战。**",
          "hasAnswer": true
        },
        {
          "id": "css-html-2",
          "title": "less sass scss 作用",
          "content": "Less、Sass、SCSS*都是 CSS 预处理器。它们的作用是：\n\n- **扩展 CSS 语言：** 引入了变量、嵌套、混合 (Mixins)、函数、继承、条件语句等编程特性，让 CSS 的编写更具逻辑性和可维护性。\n\n- **提高开发效率：** 通过嵌套可以减少重复选择器；通过变量可以实现主题和统一管理颜色值。\n\n- **编译到原生 CSS：** 浏览器无法直接识别预处理器的语法，因此它们都需要一个**编译 (Compile)** 过程，将其特有的语法转换为浏览器能理解的 **标准 CSS 文件**。",
          "hasAnswer": true
        },
        {
          "id": "css-html-3",
          "title": "em rem",
          "content": "em 是以父元素font-size为基准，常用于局部比例计算\nrem 是以页面根元素font-size为基准，常用于页面的整体适配",
          "hasAnswer": true
        },
        {
          "id": "css-html-4",
          "title": "小程序rpx和px在不同手机上有误差",
          "content": "rpx 是小程序里的相对单位，规定屏幕宽度等于 750rpx，不同设备上会根据屏幕宽度换算成不同的 px。\npx 是绝对单位，在不同设备上不自适应；  rpx 是相对单位，理论上 rpx 可以适配不同设备，但在实际渲染时，由于屏幕宽度和 DPR 不同，rpx 换算成 px 时会出现小数，最终需要取整，不同平台的取整和渲染机制也存在差异，因此在不同手机上可能会有细微误差。  误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。\n\n解决：\n避免使用极小的 `rpx` 值。尽量使用偶数的 rpx 值，必要时利用 CSS transform 缩放结合微元素 伪类解决\n尽量用 flex / 自适应布局，减少“精确像素依赖”",
          "hasAnswer": true
        },
        {
          "id": "css-html-5",
          "title": "苹果手机1px",
          "content": "- **设备像素比 (DPR > 1)：** 在 iPhone 等高分屏设备上，`1px` (CSS 像素) 可能等于 $2$ 个或 $3$ 个物理像素。但开发者希望绘制的是**最细的 1 物理像素线**。\n\n- **浏览器最小绘制限制：** 当你使用 `border: 1px solid #000;` 时，浏览器会将这个 CSS 像素值放大。如果你在 JavaScript 或 CSS 中尝试计算出 $0.5px$ 并应用，浏览器（尤其是 iOS 上的 Safari/WebView）可能会认为 $0.5px$ **低于其最小渲染阈值**，从而将该边框**优化（忽略）**掉，导致边框看起来被“隐藏”了。\n\n解决方案：利用 CSS transform 缩放 (主流且有效)\n\n该方案利用伪元素，将元素放大到 2 倍，然后使用 `transform: scale(0.5)` 缩放回 1 倍，达到 1 物理像素的边框效果。",
          "hasAnswer": true
        },
        {
          "id": "css-html-6",
          "title": "meta标签",
          "content": "`<meta>` 标签用于定义 HTML 文档中的**元数据 (Metadata)**，即描述 HTML 文档本身的信息。它通常放在 `<head>` 标签内。\n\n常见应用场景：\n\n1. **字符集声明:** `<meta charset=\"UTF-8\">`（**最重要**，定义文档的编码方式）。\n\n2. **视口设置 (Viewport):** 移动端适配核心\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   ```html\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   ```",
          "hasAnswer": true
        },
        {
          "id": "css-html-7",
          "title": "script标签有哪些参数？async和defer有什么区别",
          "content": "`<script>` 用于加载和执行 JavaScript，默认行为是**阻塞 HTML 解析**。\n 常见属性\n- `src`：外部脚本\n- `type=\"module\"`：表示该脚本是 **ES Module**，浏览器会按模块方式加载和执行。\n- `async` 异步请求js，不阻塞html解析，下载完立刻执行，不保证执行顺序\n- `defer`：异步请求js，不阻塞html解析，等待DOM 解析完成后执行，按顺序执行\n- `crossorigin`：控制**跨域资源请求的凭证模式**\n- `nomodule`：`nomodule` 用于 **兼容老浏览器**，加载降级脚本\n\nasync和defer使用场景\n- **async**\n    - 不依赖 DOM\n    - 不依赖其他脚本\n    - 如统计、监控脚本\n- **defer**\n    - 依赖 DOM\n    - 脚本之间有顺序\n    - 主业务 JS\n总结：async 重在‘谁先下完谁先跑’，defer 重在‘等 DOM 好了按顺序跑’。\n工作中：业务脚本优先 `defer`，第三方统计用 `async`，避免阻塞首屏。",
          "hasAnswer": true
        },
        {
          "id": "css-html-8",
          "title": "script link img标签的crossorigin属性作用是什么？",
          "content": "**面试回答**：\n`script`、`img`、`link` 等标签即使跨域也可以正常加载资源，但默认情况下浏览器会限制这些资源的可用性。\n\n`crossorigin` 属性用于控制跨域资源请求时是否携带凭证，以及这些资源是否可以被 JavaScript 或 Canvas 等进一步使用。\n\n常见的取值有两个：\n- `anonymous`：表示跨域请求不携带 cookie，需要服务端允许当前源或使用 `Access-Control-Allow-Origin`\n- `use-credentials`：表示跨域请求会携带 cookie，服务端必须显式指定允许的源，并返回 `Access-Control-Allow-Credentials: true`\n\n如果不设置 `crossorigin`，资源本身可以加载成功，但在 `img` 场景下 Canvas 会被污染，JavaScript 无法读取像素数据；在 `script` 场景下，跨域脚本报错时只能看到 `Script error.`，无法获取完整的错误堆栈。\n\n讲解：\n参数：默认 anonymous 表示不携带 cookie，use-credentials 表示携带 cookie\n规则：\n1. 默认情况下`<script src=\"https://cdn.xxx.com/app.js\"></script>` ，浏览器**允许跨域加载并执行**，不需要 CORS 头\n2. `type=\"module\"` 下，跨域规则完全不同。ES Module 脚本默认开启 CORS 检查，没有 `Access-Control-Allow-Origin` → 直接加载失败\n\n`crossorigin` 在 script 里的真正意义：\n- 告诉浏览器：  \n    **“这是一个受 CORS 约束的脚本请求”**\n- 前提：\n    - 服务端返回 `Access-Control-Allow-Origin`\n- 结果：\n    - 可以拿到**完整错误堆栈**\n    - 监控系统才能正常工作\n\n为什么：\n根本原因：**防止信息泄露**\n错误堆栈里可能包含：\n- 代码结构\n- 变量名\n- 文件路径\n- 业务逻辑线索\n如果任意网站都能：\n- 引入你的 JS\n- 再读取完整错误信息\n那就是一个 **跨站信息泄露漏洞**。\n\n所以浏览器规定： **跨域脚本，默认只允许“执行”，不允许“读取细节”**，会的，只要是跨域且未通过 CORS 授权的脚本，语法错误、运行时错误、Promise 未捕获异常都会被折叠成 `Script error.`",
          "hasAnswer": true
        },
        {
          "id": "css-html-9",
          "title": "script标签的type=\"module\" 有什么作用",
          "content": "浏览器规范 **直接规定**：`type=\"module\"` 脚本具有 **类 defer 行为**：不阻塞 HTML 解析；DOM 解析完成后执行；多个 module 按依赖顺序执行\n\n1. 为什么模块脚本必须“类 defer”？\n\t因为模块是「静态依赖系统」\n\t模块脚本在执行前要**先解析 import / export，构建完整的模块依赖图**\n\t这件事要求：\n\t- DOM 可以继续解析（不能阻塞）\n\t- 等依赖关系确定后，再统一调度执行\n\t\n\t如果模块像普通 script 一样“下载完就执行”，会导致：\n\t- DOM 未 ready\n\t- 依赖模块还没准备好\n\t- 执行顺序不稳定\n2. 多个 module 按依赖顺序执行\n\t### defer 的顺序规则\n\t- **按 script 在 HTML 中的顺序执行**\n\t- 和 JS 内部逻辑无关\n\tmodule 的顺序规则\n\t- **按模块依赖图（import 关系）执行**\n\t- 执行顺序由依赖关系决定\n\n初次之外还有自己的特点：自动开启严格模式 / 支持按需加载 / 受 CORS 限制\n1. 自动开启严格模式（use strict）模块脚本默认在 strict mode 下执行，因为：\n\t- 模块是**静态可分析**的\n\t- 容忍 `this === window`、隐式全局、重复参数等行为会破坏分析\n2. 支持依赖的按需加载（动态 import）\n\t- 模块系统是**可控、可缓存、可追踪的**\n\t- 浏览器可以安全地：下载；解析；执行；缓存 模块\n3. 必须走 CORS\n\t- 因为模块脚本：会被解析；会被别的模块 import；会影响执行顺序和依赖\n\t- 如果允许“随便跨域加载模块”：会形成 **跨站代码注入**；会泄露模块结构和依赖关系\n\t- 所以模块脚本：**强制 CORS 校验**；子模块同样受限\n\n总结：\n`type=module` 的类 defer 行为不是因为 defer 本身，而是模块脚本需要先构建依赖图并保证依赖有序执行，这是 ES Module 语义的一部分；\n模块脚本默认严格模式、支持动态 import，并强制 CORS，是因为模块是可分析、可组合的资源，浏览器必须在安全边界内管理它们。",
          "hasAnswer": true
        },
        {
          "id": "css-html-10",
          "title": "什么是css预处理器？",
          "content": "CSS 预处理器（如 Sass / Less）是在 CSS 之上提供**更强表达能力**的工具，最终会被编译成标准 CSS。\n\n常见能力\n- 变量\n- 嵌套：用结构化写法描述 DOM 层级\n- mixin：封装可复用样式片段，避免重复代码。\n- 继承：复用已有选择器的样式，适合语义化类共享样式。\n- 模块拆分：通过 `@import / @use` 拆分样式文件，提升维护性\n\n解决了什么问题\n- 原生 CSS 在早期缺乏变量和逻辑能力\n- 大型项目样式难以维护\n- 重复代码多\n优势\n- 提升可维护性\n- 降低重复\n- 结构更清晰\n- 方便主题化和换肤\n\n使用：在webpack的Loader中配置；vite原生支持 Sass / Less",
          "hasAnswer": true
        },
        {
          "id": "css-html-11",
          "title": "语义化标签的应用场景和优势",
          "content": "用恰当的 HTML 元素来描述内容的**结构和含义**，而不是仅仅关注其默认的样式\n\nheader nav main article section footer h1-h6  form等\n\n可访问性 搜索引擎优化 可读性和可维护性  跨设备兼容性",
          "hasAnswer": true
        },
        {
          "id": "css-html-12",
          "title": "Canvas vs SVG 的区别和选择",
          "content": "1️. Canvas vs SVG 的本质区别\n\n|特性|Canvas|SVG|\n|---|---|---|\n|绘制方式|**基于像素**，一次性绘制，渲染后不保留对象|**基于矢量**，DOM节点形式，每个图形元素可操作|\n|更新|需要重绘整个画布或部分区域|可以单独操作某个元素，自动重渲染|\n|性能|大量动态像素操作（游戏、动画）效率高|大量元素节点多时，性能可能下降|\n|调试|不像 DOM 元素可直接 inspect，调试相对困难|可直接 inspect DOM 节点，样式、位置可见|\n2️. 优缺点\n Canvas\n- **优点**：\n    - 适合大量动态渲染或复杂动画（游戏、可视化图表）\n    - 渲染速度快，像素级控制灵活\n- **缺点**：\n    - 不保留对象，不容易对单个元素操作\n    - 调试困难\n    - 对响应式、交互事件支持有限\n SVG\n- **优点**：\n    - 矢量图形，缩放不失真\n    - DOM 节点可操作，易调试，事件绑定方便\n    - 适合图标、静态或轻量级动画\n- **缺点**：\n    - 大量节点性能开销大，不适合复杂动画或实时渲染\n\n3️. 使用场景参考\n- **Canvas**：游戏渲染、粒子动画、复杂图表、图像处理\n- **SVG**：图标、流程图、矢量图、轻量动画、交互图表\n\n总结：Canvas 是基于像素的绘制方式，渲染后不保留对象，适合大量动态渲染和复杂动画，但调试相对困难；SVG 是基于矢量的，每个元素都是 DOM 节点，可单独操作，适合图标、静态图、轻量动画。选择时一般原则：**动态、像素级操作选 Canvas，静态或矢量图形选 SVG**",
          "hasAnswer": true
        },
        {
          "id": "css-html-13",
          "title": "HTML5 表单验证和自定义验证",
          "content": "1. HTML5 表单验证，原生提供了**内置验证属性**，常见的有：\n\t- **required**：必填字段\n\t- **type**：比如 `email`、`number`、`url`，浏览器会自动检查格式\n\t- **pattern**：自定义正则，匹配特定格式\n\t- **min / max / step**：数值范围限制\n\t- **maxlength / minlength**：字符长度限制\n\t- 特点：\n\t\t- 浏览器自动触发验证\n\t\t- 不需要 JS 代码\n\t\t- 用户体验好，移动端也会弹出原生提示\n2. 自定义验证：有些场景 HTML5 自带的验证无法满足，比如：\n\t- 复杂密码规则\n\t- 异步验证（用户名是否已存在）\n\t- 联动验证（两个字段必须匹配）\n   这时就需要**JavaScript 自定义验证**，常用方法：\n\t1. **oninput / onchange**：输入实时验证\n\t2. **onSubmit 拦截**：`form.addEventListener('submit', function(e) {...}`\n总结：HTML5 表单验证主要分两类：一是浏览器原生验证，通过 `required`、`type`、`pattern`、`min/max` 等属性自动检查输入；二是自定义验证，通过 JavaScript 检查复杂逻辑或异步条件，并通过 Constraint Validation API 或表单 submit 事件阻止非法提交。原生验证简单易用，但灵活性有限，自定义验证可以覆盖更复杂的场景。",
          "hasAnswer": true
        },
        {
          "id": "css-html-14",
          "title": "CSS3 动画性能优化方案",
          "content": "性能优化核心是**减少重排 (Reflow/Layout)** 和**重绘 (Repaint)**，并尽可能利用 GPU 加速。\n\n1.使用 `transform` 和 `opacity` 进行动画： 只会触发**合成 (Compositing)**，不会触发重排和重绘，性能最高，可以直接利用 GPU 加速。\n\n2.开启 GPU 硬件加速：`transform: translateZ(0);` 或 `will-change: transform, opacity;`，将元素提升到合成层，利用 GPU 渲染\n\n3.使用 `will-change` 属性：\n\n4.避免使用 `all` 进行transition：\n\n5.**减少 DOM 元素和层次：",
          "hasAnswer": true
        },
        {
          "id": "css-html-15",
          "title": "CSS 模块化和作用域方案",
          "content": "目的：\n- **解决全局污染：** 默认情况下，CSS 所有的选择器都是全局的。不同组件同名的 `.title` 会相互覆盖。\n- **提高复用性：** 像 JS 模块一样方便地导入、导出样式。\n- **提升维护性：** 明确样式与组件的绑定关系，删除组件时能放心地删除其样式。\n\n核心原理：\n1. **命名约定/空间隔离：** 通过人为约定的规范（如 BEM）来模拟作用域。\n2. **构建转换（哈希化）：** 通过构建工具（Webpack/Vite）自动重命名选择器。\n    - **原理：** 当你导入一个 CSS 模块时，编译器会将你的类名（如 `.button`）转换成一个唯一的哈希字符串（如 `._button_x1y2z`）。\n    - **映射：** 编译器会生成一个 JSON 映射表，让 JS 能够引用这个变色后的类名。\n\n常见方案：\n1. CSS Modules：基于 JS 映射的哈希化。开发者编写正常的 CSS 文件（通常命名为 `.module.css`），打包工具在构建时对类名进行转换增加hash，比如`._title_1a2b3_5`，并把引用处也做相同的修改。\n2. Scoped CSS：基于属性选择器的隔离： 打包工具在编译模板时，会给该组件内所有的 DOM 节点加上一个唯一的属性，例如 `data-v-7ba5bd90`，同时将对应的 CSS 选择器转换增加属性选择。\n3. Tailwind CSS：基于原子类的预扫描方案，不进行类名哈希化。优点是按需编译和极致复用。",
          "hasAnswer": true
        },
        {
          "id": "css-html-16",
          "title": "前端性能优化之 CSS 优化策略",
          "content": "CSS 性能优化我通常从浏览器渲染链路来做：尽量减少 Layout、Paint，并让动画尽可能走 Composite。\n\n1. **减少 重排重绘**：避免频繁读写会触发布局的属性，比如在循环里交替读 `offsetHeight` 和写样式；需要批量修改样式时尽量合并，或者通过切换 class 一次性生效。对于会改变几何信息的属性（width/height/top/left/margin）要谨慎，尤其在动画里尽量不要用。\n\n2. **动画优化**：优先用 `transform` 和 `opacity` 做动画，避免触发布局；必要时对动画元素使用 `will-change: transform` 预创建合成层，但要控制数量避免占用显存。\n\n3. **降低选择器匹配成本**：选择器尽量简单，避免过深的嵌套、`*` 通配、复杂的后代选择器；类选择器比标签/后代链更稳定高效。复杂的选择器（如 `div > ul > li:last-child`）会增加浏览器计算匹配的成本。\n\n4. **减少阻塞和体积**：首屏关键 CSS 可以内联或拆分，非关键 CSS 延后加载；CSS 体积上做压缩、按路由/组件拆分，减少不必要的全量样式。\n\n5. **利用媒体查询 (Media Queries) 按需加载：**\n\t使用 `<link rel=\"stylesheet\" media=\"(max-width: 600px)\" href=\"mobile.css\">`，只有在符合条件时才加载相应样式。\n\n6. 避免在 HTML 中使用内联样式 (`style=\"...\"`)：内联样式会增加 HTML 文件体积，且不利于样式复用和缓存。",
          "hasAnswer": true
        },
        {
          "id": "css-html-17",
          "title": "解释CSS中的BEM命名方法，并展示如何使用它来组织你的样式表。",
          "content": "**BEM** 是 **Block (块)、Element (元素)、Modifier (修饰符)** 的缩写，是一种用于组织 CSS 类名的命名规范。它旨在解决 CSS 全局作用域带来的命名冲突和样式依赖问题，使样式代码更具可读性和可维护性。示例：.card__title--large   .card__image--dark\n\n```css\n.user-card {\n    display: flex;\n    padding: 20px;\n    border: 1px solid #ccc;\n\n    /* 2. Modifier: .user-card--vip (变体) */\n    &--vip {\n        border-color: gold;\n        box-shadow: 0 0 5px gold;\n    }\n...\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "css-html-18",
          "title": "在一个复杂的页面上，用户操作导致多次不必要的DOM操作，你将如何优化它?",
          "content": "不必要的 DOM 操作是前端性能的常见瓶颈，因为它会频繁触发浏览器的 **重排 (Reflow/Layout)** 和 **重绘 (Repaint)**。优化策略核心是**减少操作次数**和**批量处理操作**。\n\n1. **使用文档片段 (DocumentFragment) 批量操作：**\n   \n   - **原理：** `DocumentFragment` 是一个轻量级的容器，它**不是真实的 DOM 树的一部分**。将所有需要添加或修改的元素先插入到 `DocumentFragment` 中，然后只需进行**一次**操作，将 `DocumentFragment` 整体插入到 DOM 中。\n   \n   - **优化效果：** 只触发**一次**重排和重绘。\n\n2. **避免频繁读写 DOM 属性：**\n   \n   - **问题：** 连续读取（如 `element.offsetWidth`）和写入（如 `element.style.width = '100px'`）操作会导致“强制同步布局”——浏览器为了保证读取到的值是最新的，会立即执行挂起的重排。\n   \n   - **优化：** 应该**先读取**所有需要的 DOM 属性，然后**集中进行写入**操作。\n\n3. **使用防抖 (Debounce) 和节流 (Throttle)：**\n   \n   - **场景：** 针对用户输入、`resize`、`scroll`、`mousemove` 等高频触发的事件。\n   \n   - **防抖：** 将多次触发合并成一次，只在事件停止触发后执行一次（如搜索框输入）。\n   \n   - **节流：** 在一个时间周期内，事件只执行一次（如页面滚动）。\n\n4. **使用 Virtual DOM (适用于组件化框架)：**\n   \n   - React、Vue 等框架通过 **Virtual DOM** 将所有的 DOM 操作放入内存中进行对比，计算出最小的更新路径，然后一次性批量应用到真实 DOM 上，从框架层面解决了不必要的 DOM 操作问题。\n\n5. **用 CSS 类代替内联样式：**\n   \n   - 避免直接操作 `element.style`，因为它会导致样式计算和布局的开销。\n   \n   - **优化：** 预先定义好 CSS 类，通过增删改元素的 `className` 或 `classList` 来改变样式。\n\n6. **将元素脱离文档流：**\n   \n   - 如果必须对一个元素进行多次复杂的 DOM 操作，可以先通过设置 `display: none` 或将其从 DOM 中移除，进行操作，然后重新插入/显示。脱离文档流的操作不会触发整个页面的重排。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "react",
      "name": "React",
      "questions": [
        {
          "id": "react-1",
          "title": "谈谈你对 React 的了解",
          "content": "React 是一个用于构建 UI 的库，它的核心是**用组件来描述 UI**，并通过**状态驱动视图**来让 UI 随数据变化而更新。  \n从机制上看，React 有三块比较关键：\n\n1. **声明式渲染 + 单向数据流**：开发者描述“在某个 state 下 UI 应该长什么样”，React 负责把它变成真实 DOM；数据自上而下流动，边界清晰，利于大型项目可维护。\n\n2. **协调与渲染分离（Reconciler + Renderer）**：React 先在 render 阶段计算“需要改什么”（reconcile/diff），再在 commit 阶段把变更提交到宿主环境（DOM/Native）。React DOM 只是其中一个 renderer。\n\n3. **Fiber 架构与并发能力（React 16+，18+ 更明显）**：把更新拆成可调度的小任务，引入优先级与可中断渲染；18 的并发特性让 React 能在交互、动画、数据渲染之间更好地平衡体验（比如自动批处理、Transitions 等）。\n\n工程实践上，我会把 React 当成“**UI 运行时**”：组件设计、状态归属、性能边界（memo、拆分、列表 key、避免无效渲染）和工程化（路由懒加载、SSR/CSR 取舍）是高级前端更看重的点。",
          "hasAnswer": true
        },
        {
          "id": "react-2",
          "title": "React 中 key 的作用是什么",
          "content": "key 的作用是帮助 React 在**同一层级的子节点列表**中建立“身份标识”，从而在 diff 时更准确地判断：哪些节点是新增/删除/移动，哪些可以复用。  \n它带来的核心收益是：\n\n- **稳定复用**：key 稳定时，React 能复用对应的 Fiber/DOM，减少不必要的卸载与重建。\n\n- **保持局部状态**：列表项里如果有 input、组件内部 state，稳定 key 能让它们跟随“同一项数据”而不是“同一位置”。\n\n- **更高效的 diff**：在存在插入、排序、过滤时，key 能显著减少误判与 DOM 操作。\n\n最佳实践是：**使用稳定且唯一的业务 id**，不要用 index（除非列表永不重排/增删，且项内无状态/无输入）。index 作为 key 常见问题是：插入/排序会导致“状态串位”和不必要的重渲染。",
          "hasAnswer": true
        },
        {
          "id": "react-3",
          "title": "说说对受控组件和非受控组件的理解，以及应用场景",
          "content": "- **受控组件（Controlled Component）**  \n  表单的值完全由 React state 控制，input 的 value / checked 来自 state，用户输入通过 onChange 触发 setState。  \n  优点是**数据来源单一、状态可控**，非常适合做校验、联动、回填、表单回显等复杂逻辑。  \n  缺点是更新频繁时可能带来额外渲染成本，需要注意拆分组件或做性能优化。\n\n- **非受控组件（Uncontrolled Component）**  \n  表单值由 DOM 自己维护，React 只在需要时通过 ref 读取，或者用 defaultValue 初始化。  \n  优点是实现简单、性能开销小，适合一次性提交、简单表单、第三方表单组件或富文本场景。  \n  缺点是状态分散在 DOM 中，不利于复杂业务逻辑管理。\n\n实际项目中更多是**以受控为主、非受控为辅**，在性能或实现成本更重要的场景下使用非受控。",
          "hasAnswer": true
        },
        {
          "id": "react-4",
          "title": "什么是无状态组件，与有状态组件的区别？本质区别是什么？现在还推荐这样区分吗？",
          "content": "无状态组件通常指**不维护自身状态、只根据 props 渲染 UI** 的组件，更多承担展示职责。  \n有状态组件则内部维护 state，负责交互和业务逻辑。\n\n在早期 React 中，这种区分基本等同于：\n\n- 无状态组件 → 函数组件\n\n- 有状态组件 → 类组件\n\n但在 Hooks 引入后，函数组件同样可以拥有完整状态和副作用能力，因此**这种区分已经不再是技术层面的限制**。\n\n现在更推荐从**组件职责**出发：\n\n- 状态是否应该属于这个组件\n\n- 是否可以下沉/上提状态\n\n- 是否是纯展示组件\n\n而不是纠结“有没有 state”。\n\n######",
          "hasAnswer": true
        },
        {
          "id": "react-5",
          "title": "说说 react 中引入 CSS 的方式有哪几种？区别？",
          "content": "常见方式包括：\n\n1. **全局 CSS / SCSS**：简单直接，但容易命名冲突\n\n2. **CSS Modules**：通过构建工具生成局部作用域，适合组件化项目\n\n3. **CSS-in-JS（styled-components、emotion）**：样式即组件，动态能力强，但运行时有成本\n\n4. **内联 style**：适合少量动态样式，但不支持伪类、媒体查询\n\n5. **原子化方案（Tailwind）**：通过组合 class 构建 UI，提高一致性，但对团队规范要求高\n\n选择时主要看：**项目规模、团队习惯、动态样式复杂度和运行时性能要求**。",
          "hasAnswer": true
        },
        {
          "id": "react-6",
          "title": "怎么给 children 添加额外的属性？",
          "content": "常见方式有三种：\n\n1. `React.cloneElement`：在不改变 children 结构的前提下追加 props\n\n2. render props：通过函数形式显式传递参数\n\n3. Context：适合跨层级、全局性信息\n\n其中 `cloneElement` 适合对子组件做增强，但要注意它**只能作用于 ReactElement，且会增加耦合度**，不适合滥用。",
          "hasAnswer": true
        },
        {
          "id": "react-7",
          "title": "对比类组件和函数组件，有什么本质区别？代码层面如何判断",
          "content": "本质区别在于：\n\n- 类组件是**基于实例的模型**，状态和生命周期绑定在实例上\n\n- 函数组件是**基于函数执行和闭包的模型**，每次 render 都是一次全新执行\n\n代码层面判断很简单：\n\n- 是否 `extends React.Component`\n\n- 是否存在 `this`、生命周期方法\n\n现代 React 推荐函数组件 + Hooks，它在逻辑复用、组合能力、类型推导上都更有优势。",
          "hasAnswer": true
        },
        {
          "id": "react-8",
          "title": "React 组件高度抽象和复用的自由有没有代价？",
          "content": "有，而且代价不小。\n\n常见问题包括：\n\n- 过度抽象导致组件层级过深、调试困难\n\n- props 设计不合理导致使用成本高\n\n- 复用场景被“假设”，反而限制业务演进\n\n高级前端更关注：**恰到好处的抽象**，优先服务当前真实需求，而不是追求“看起来通用”。",
          "hasAnswer": true
        },
        {
          "id": "react-9",
          "title": "为什么虚拟 DOM 会提高性能？一定能提高性能吗？",
          "content": "虚拟 DOM 是对真实 DOM 的一层 JS 抽象，用来描述 UI 结构。\n\n它提升性能的关键不在于“操作更快”，而在于：\n\n- **最小化真实 DOM 操作**：通过 diff 算法计算最小更新集\n\n- **批量更新**：多次状态变化合并后统一提交\n\n- **跨平台能力**：让渲染逻辑与宿主环境解耦\n\n但虚拟 DOM **并不保证所有场景都更快**：\n\n- UI 结构极其简单、几乎不更新时，diff 本身是额外成本\n\n- 高频动画、Canvas、WebGL 等场景不适合\n\n- 不合理的组件设计仍然会导致性能问题\n\n虚拟 DOM 的本质价值是：**提升整体可维护性与复杂场景下的性能上限，而不是极限性能**。",
          "hasAnswer": true
        },
        {
          "id": "react-10",
          "title": "为什么说 react 更适合 B 端大型项目",
          "content": "我觉得 React 更适合 B 端，核心不是“性能更好”，而是**对复杂度的容忍度更高**。\n\n第一，B 端项目的复杂点往往不在页面样式，而在**状态多、交互复杂、业务规则多**。React 是典型的“状态驱动 UI”，组件就是函数，UI = state 的映射，这种模型在复杂场景下更容易拆解和维护。\n\n第二，React 的**组件和逻辑抽象能力非常强**。比如 Hooks，本质就是普通函数，你可以把一整套业务逻辑抽成一个 Hook，在多个页面复用，这在后台系统、配置台里非常常见。\n\n第三，**生态和工程化成熟**。B 端项目通常生命周期很长，React 从状态管理、路由、表单、表格、权限体系，到 SSR、微前端，都有大量成熟方案可选。\n\n简单说，React 更像一个 **UI 运行时 + 架构工具箱**，而不是“拿来即用的完整框架”，这点在大型 B 端项目里反而是优势。",
          "hasAnswer": true
        },
        {
          "id": "react-11",
          "title": "React 组合能力强会带来哪些坑？",
          "content": "组合能力强，本身就是一把双刃剑。\n\n最常见的坑是：**抽象过度**。  \n比如 Hook 拆得太细，一个页面引七八个 Hook，逻辑分散在不同文件里，新人根本不知道一段行为是从哪来的。\n\n第二是**隐式依赖**。  \n有些自定义 Hook 内部偷偷用 Context、全局状态，表面上看参数很少，但实际上依赖一大堆外部环境，用错地方就出问题。\n\n第三是**性能问题更隐蔽**。  \n组合之后，谁在触发 re-render、哪个 Hook 闭包不对，很难第一时间看出来，排查成本高。\n\n所以在实际项目里，我会刻意控制：\n\n- Hook 不追求“极致通用”\n\n- 抽象只覆盖真实复用场景\n\n- 组合层级不要太深\n\n否则组合能力反而会变成维护负担。",
          "hasAnswer": true
        },
        {
          "id": "react-12",
          "title": "为什么说 react 的组件和逻辑抽象和复用比 vue 强",
          "content": "我觉得本质原因在于：**React 的抽象完全建立在 JavaScript 函数之上**。\n\n在 React 里：\n\n- 组件是函数\n\n- Hook 也是函数\n\n- 逻辑复用就是函数组合\n\n你不需要理解太多框架“特殊规则”，就是 JS 思维，这点在复杂逻辑复用时非常舒服。\n\nVue 虽然现在有了 Composition API，但整体还是**模板 + 指令 + 响应式语法**的模型，抽象能力更多依赖框架约定，而不是纯语言能力。\n\n举个例子：  \n在 React 里，我可以很自然地写一个 `useTable`、`usePermission`，内部怎么拆、怎么组合完全自由；  \n而 Vue 里你要同时考虑响应式、生命周期、模板使用方式，约束会更多。\n\n当然代价也很明显：**React 更考验开发者的架构能力**，自由度越高，犯错空间也越大。",
          "hasAnswer": true
        },
        {
          "id": "react-13",
          "title": "组件状态保存 keep-alive 怎么用？原理是什么？",
          "content": "React 本身没有官方 keep-alive，这点和 Vue 不一样。\n\n但本质上，所谓 keep-alive 就一句话：**不要让组件被 unmount**。\n\n常见做法有几类：  \n第一类，最简单的，用 CSS 控制显示隐藏，而不是条件渲染销毁组件。  \n第二类，路由缓存，比如 react-activation，本质是把组件实例缓存起来，下次直接复用。  \n第三类，把关键 state 提到更高层，比如路由外层，这样即使页面切换，状态也还在。\n\n原理上非常简单：  \nReact 一旦 unmount，state、effect、ref 全都会被清掉。  \nkeep-alive 只是想办法绕开“卸载”这一步。\n\n但一定要注意：  \nkeep-alive 是**用内存换体验**，用不好很容易内存膨胀、逻辑混乱。",
          "hasAnswer": true
        },
        {
          "id": "react-14",
          "title": "路由懒加载原理",
          "content": "路由懒加载的核心其实就一句话：**按路由拆包，按需加载**。\n\n实现上一般是：\n\n- 使用 `import()`\n\n- 构建工具把不同路由打成不同 chunk\n\n- 用户访问某个路由时，才下载对应 JS\n\n在 React 里常见写法是 `React.lazy + Suspense`。\n\n它解决的是一个非常现实的问题：  \n后台系统路由多、页面多，如果全部打进首包，首屏一定很慢。\n\n懒加载的本质是：**把“第一次看不到的代码”延后加载**。",
          "hasAnswer": true
        },
        {
          "id": "react-15",
          "title": "react 的 Link 标签和 a 标签的区别",
          "content": "这个问题我一般会直接从“是否刷新页面”讲。\n\n`a` 标签是浏览器原生跳转：\n\n- 会刷新整个页面\n\n- JS 状态全部丢失\n\n- 重新请求资源\n\n`Link` 是前端路由跳转：\n\n- 通过 history API 改 URL\n\n- 不刷新页面\n\n- 应用状态全部保留\n\n- 只切换组件\n\n所以在 SPA 内部跳转，一定用 `Link`；  \n只有跳外部网站，或者明确需要刷新时，才用 `a`。",
          "hasAnswer": true
        },
        {
          "id": "react-16",
          "title": "分别讲讲 react 16 / 17 / 18 / 19 新特性",
          "content": "React 16 是一个**架构级版本**，大的变化是引入了 Fiber 架构，把原来同步、不可中断的递归渲染，改成了可拆分、可中断的工作单元模型。为后续并发渲染打地基。但是\n\nReact 17 主要做了两件事：\n一是重构事件系统，把事件从 document 下移到 root，减少对全局的侵入；\n二是为并发模式、渐进升级铺路，让多个 React 版本可以共存。\n\nReact 18 是真正对业务产生明显影响的版本。\n核心是并发特性正式可用，包括：\n\n自动批处理（不再区分 React 事件还是原生事件）\n\nstartTransition / useTransition，区分紧急和非紧急更新\n\n新的 root API，为并发调度提供入口\n\n18 的目标很明确：在复杂更新场景下，保证交互优先级和页面响应性。\n\nReact 19 更偏向方向和能力整合，而不是一次 API 爆炸。\n重点包括：\n\nServer Components 更成熟\n\n编译期优化能力增强，减少手写 memo、useCallback 的心智负担\n\n更进一步弱化“开发者手动性能调优”的必要性",
          "hasAnswer": true
        },
        {
          "id": "react-17",
          "title": "什么是 JSX？为什么浏览器无法读取 JSX",
          "content": "JSX 本质就是 **JavaScript 的语法糖**，用来更直观地写 UI 结构。\n\n浏览器不能直接识别 JSX，是因为 JSX 根本不是合法的 JS 语法。\n\n它必须先经过编译，比如 Babel，把 JSX 转成 `createElement` 调用，浏览器才能执行。\n\n所以 JSX 只是开发体验层面的东西，运行时根本不存在 JSX。",
          "hasAnswer": true
        },
        {
          "id": "react-18",
          "title": "说说 jsx 转 DOM 的过程和原理",
          "content": "这个过程我一般会拆成 **三层：编译期、运行时计算、提交阶段**。\n\n第一层是**编译期**。  \nJSX 本身不是合法的 JavaScript，必须通过 Babel 等工具，把 JSX 转成 `React.createElement` 或等价函数调用。  \n这一步做的事情只是：**把语法糖变成普通 JS 表达式**。\n\n第二层是**运行时生成虚拟 DOM**。  \n`createElement` 执行后，会生成一个 React Element，本质是一个普通对象，用来描述节点类型、props、children。  \n注意这里的 React Element 不是 Fiber，也不是 DOM，只是**UI 描述数据**。\n\n第三层是**协调与提交**。  \nReact 在 render 阶段，会根据新旧 React Element 构建 Fiber 树，并通过 diff 算法计算出需要变更的部分；  \n在 commit 阶段，再把这些变更一次性映射成真实 DOM 操作。\n\n所以 JSX 到 DOM 并不是“直接生成 DOM”，而是：  \n**JSX → React Element → Fiber → DOM**  \nJSX 只是最前面的语法入口。",
          "hasAnswer": true
        },
        {
          "id": "react-19",
          "title": "react diff 算法核心，和 vue 的 diff 有什么区别",
          "content": "React diff 的核心设计思路是：**在可接受复杂度内，尽量减少 DOM 操作**。\n\n它有几个非常关键的假设：  \n第一，不同类型的节点，直接销毁重建  \n第二，只在**同一层级**做 diff，不跨层比较  \n第三，列表通过 key 来标识节点身份，而不是位置\n\n基于这些假设，React 可以把 diff 的复杂度控制在 O(n)，代价是：  \n如果 key 设计不合理，或者结构变化剧烈，更新效率会下降。\n\nVue 的 diff 思路和 React 不太一样，更依赖 **响应式系统 + 静态分析**：\n\n- 编译阶段标记静态节点\n\n- 运行时 diff 范围更小\n\n- 更新路径更明确\n\n所以可以这样总结：\n\n- React diff 更偏**运行时策略 + 调度能力**\n\n- Vue diff 更偏**编译期优化 + 精确依赖追踪**",
          "hasAnswer": true
        },
        {
          "id": "react-20",
          "title": "讲讲 react 项目的性能优化",
          "content": "一般会从 **“更新为什么会发生、更新发生在哪、怎么减少无效更新”** 这三个层面来讲\n\n第一层是 **渲染边界控制**。  \nReact 的性能问题，本质上大多数都是“**不该 re-render 的组件 re-render 了**”。所以核心是控制 render 边界：\n\n- 拆分组件，让 state 尽量就近\n\n- 对纯展示组件使用 `React.memo`\n\n- 配合 `useMemo / useCallback` 稳定 props 引用  \n  但我会强调一点：memo 不是越多越好，而是用来**明确哪些组件可以跳过更新**。\n\n第二层是 **状态设计和更新粒度**。  \n很多性能问题不是出在 React，而是 state 设计不合理，比如：\n\n- 一个 state 牵动一大片组件\n\n- 把临时状态、派生状态也放进 state  \n  这类问题通过**拆 state、下沉 state、减少不必要的 state**，往往比任何 memo 都有效。\n\n第三层是 **列表和计算场景**。  \n包括：\n\n- key 是否稳定、是否使用 index\n\n- 大列表是否需要虚拟滚动\n\n- 昂贵计算是否需要缓存  \n  这是 React 项目里非常常见、也非常实际的性能瓶颈。\n\n第四层是 **调度和工程层面**。  \n比如：\n\n- 路由懒加载、代码分割\n\n- React 18 的 `startTransition` 区分更新优先级\n\n- 必要时使用 SSR / Streaming  \n  这些是解决“页面是否卡顿”“首屏是否慢”的关键。",
          "hasAnswer": true
        },
        {
          "id": "react-21",
          "title": "说说 hooks 的思想和原理",
          "content": "Hooks 的思想核心不是“语法糖”，而是**组件模型的转变**。\n\n在 class 组件里，state 和生命周期是挂在实例上的，逻辑复用只能通过继承或 HOC，这会带来很强的结构耦合。  \nHooks 做的是：**把状态和副作用能力，从实例模型，转移到函数执行模型中**。\n\n从原理上讲：\n\n- 每个函数组件在 render 时，React 都会为它维护一份 Hook 状态\n\n- `useState / useEffect` 这些 Hook，本质是在当前组件对应的 Fiber 上，按顺序读写这份状态\n\n- React 并不关心 Hook 的名字，而是**依赖调用顺序来关联状态**\n\n所以 Hooks 能够做到：\n\n- 不依赖 class\n\n- 逻辑可以自由拆分、组合  \n  代价就是：**必须保证调用顺序稳定**。",
          "hasAnswer": true
        },
        {
          "id": "react-22",
          "title": "react hook 如何以链表存储",
          "content": "在实现层面，React 是用**链表**来存 Hook 状态的。\n\n每个函数组件对应一个 Fiber 节点，Fiber 上有一个 `memoizedState`，它指向 Hook 链表的头。  \n在 render 阶段：\n\n- React 会维护一个指针\n\n- 每调用一次 Hook，就顺序访问或创建一个 Hook 节点\n\n- Hook 节点里会存 state、更新队列、effect 信息等\n\n选择链表而不是数组，主要是为了：\n\n- 更好地配合 Fiber 的 workInProgress 机制\n\n- 在更新、复用时成本更低\n\n但这个设计直接导致了一个前提：**Hook 的调用顺序必须一致**。",
          "hasAnswer": true
        },
        {
          "id": "react-23",
          "title": "为什么 hook 只能写在顶层",
          "content": "这是一个**实现层面的硬约束**。\n\nReact 是通过“第 N 次调用 Hook ↔ 第 N 个 Hook 节点”来匹配状态的。  \n如果 Hook 写在条件、循环或提前 return 里，那么某次 render 调用顺序发生变化，后面的 Hook 就会全部错位。\n\n一旦错位：\n\n- state 会读错\n\n- effect 会乱执行\n\n- 行为不可预测\n\n所以 Hook 只能写在顶层，不是语法限制，而是**为了保证 Hook 链表和调用顺序的一致性**。",
          "hasAnswer": true
        },
        {
          "id": "react-24",
          "title": "看过 hooks 相关的草案吗",
          "content": "看过 Hooks 的 RFC。\n\n当时的设计思路其实非常明确：\n\n- 目标是解决 class 组件的复用和复杂度问题\n\n- 明确接受“依赖调用顺序”和“规则约束”这类 trade-off\n\n- 优先选择工程上可落地、可维护的方案，而不是理论最优\n\n总体来说 Hooks 的设计是一次**非常务实、非常工程化的取舍**。",
          "hasAnswer": true
        },
        {
          "id": "react-25",
          "title": "说说 react 里你常用的 hook",
          "content": "在实际项目中，我常用的 Hook 基本分几类：\n\n- **状态类**：`useState`，复杂状态时用 `useReducer`\n\n- **副作用类**：`useEffect`，处理请求、订阅、生命周期逻辑\n\n- **性能与引用控制**：`useMemo`、`useCallback`，明确 render 边界\n\n- **引用类**：`useRef`，保存跨 render 的可变值、解决闭包问题\n\n- **共享状态**：`useContext`，用于低频、全局性数据\n\n但从工程角度看，最有价值的是**自定义 Hook**，它能把状态、副作用和业务规则封装成可复用的逻辑单元，让组件本身保持非常“薄”。",
          "hasAnswer": true
        },
        {
          "id": "react-26",
          "title": "React 中 refs 的作用是什么",
          "content": "refs 的核心作用可以概括为一句话：**在 React 的声明式渲染模型之外，持有一个稳定、可变的引用**。\n\nReact 的 state / props 都是参与渲染的，只要变了就会触发一次 render；但在实际工程中，总会存在一些数据或对象：\n\n- **变化不应该触发重新渲染**\n\n- 但又需要在多次 render 之间被保留下来\n\n这正是 refs 存在的意义。\n\n在实践中，refs 主要有三类典型用途：  \n第一，**直接访问或操作 DOM**，比如 focus、scroll、测量尺寸，这是声明式模型无法完全覆盖的场景。  \n第二，**保存跨 render 的可变数据**，例如定时器 id、上一次的值、外部实例对象，这类数据如果用 state 反而会制造多余更新。  \n第三，**与非 React 管理的第三方库对接**，比如图表、编辑器，它们往往需要一个长期存在的实例引用。\n\n关键点在于：**ref 的变化不会触发组件重新渲染**，它是 React 提供的一条“逃生通道”，但不应该被滥用。",
          "hasAnswer": true
        },
        {
          "id": "react-27",
          "title": "useRef 和 useState 的区别",
          "content": "useRef 和 useState 的本质区别并不在“是不是 Hook”，而在于**是否参与渲染流程**。\n\n`useState` 的语义是：\n\n- 状态变化会影响 UI\n\n- 更新会触发重新 render\n\n- React 会基于新 state 重新计算 UI\n\n`useRef` 的语义是：\n\n- 只是保存一个可变引用\n\n- 更新 `ref.current` 不会触发 render\n\n- 更像是一个“组件级的实例变量”\n\n还有一个在高级场景里非常重要的差异：  \n**闭包捕获行为不同**。  \n函数组件的闭包会捕获某一次 render 的 state 值，但捕获到的 ref 是同一个对象引用，因此通过 `ref.current` 读取到的永远是最新值，这也是 useRef 常被用来解决闭包问题的原因。\n\n所以结论很明确：\n\n- 影响 UI 的，用 state\n\n- 不影响 UI、但要跨 render 保存的，用 ref",
          "hasAnswer": true
        },
        {
          "id": "react-28",
          "title": "为什么 useState 返回数组而不是对象",
          "content": "这是一个典型的 **API 设计取舍问题**。\n\n从使用层面看，数组有两个明显优势：  \n第一，**解构时可以自由命名**，不依赖固定的 key 名，这对 API 使用体验更友好。  \n第二，数组的语义是“有顺序的返回值”，而 Hooks 的实现恰好是**强依赖调用顺序**的。\n\n从实现角度看，React 内部并不关心返回值的结构，它只关心：  \n“这是当前组件第几个 Hook”。  \n数组这种形式，正好和 Hooks 依赖顺序的模型保持一致。\n\n所以 useState 返回数组，并不是随意选择，而是**和 Hooks 整体设计哲学高度一致的结果**。",
          "hasAnswer": true
        },
        {
          "id": "react-29",
          "title": "useState 如何实现？怎么获得下一次更新后的值",
          "content": "useState 在内部并不是“直接改值”，而是基于 **更新队列（update queue）** 的模型。\n\n每一个 useState 对应一个 Hook 节点，这个节点上会维护：\n\n- 当前 state\n\n- 一个 update queue，用来存储多次 setState 产生的更新\n\n当调用 `setState` 时，React 做的事情是：\n\n- 创建一个 update\n\n- 把 update 放进当前 Hook 的更新队列\n\n- 标记当前 Fiber 需要更新\n\n真正的 state 计算发生在**下一次 render 阶段**，React 会按顺序处理 update queue，得到新的 state。\n\n如果需要基于旧值计算新值，正确且唯一可靠的方式是：\n\n`setState(prev => next)`\n\n至于“怎么拿到更新后的值”，答案其实是：  \n**拿不到同步结果**。  \nReact 不提供同步读取“下一次 state”的能力，只能在下一次 render 或通过 `useEffect` 感知 state 变化，这也是 React 保持渲染可控性的一个重要前提。",
          "hasAnswer": true
        },
        {
          "id": "react-30",
          "title": "调用 setState 之后发生了什么",
          "content": "从内部机制上看，调用 setState 之后大致会经历这样一条链路：\n\n第一步，**生成 update 对象**  \nsetState 不会立刻修改 state，而是生成一条“状态更新描述”。\n\n第二步，**update 入队**  \nupdate 被放入当前 Hook 或 class 组件对应的更新队列中。\n\n第三步，**调度更新**  \nReact 会根据当前更新的优先级，把这个 Fiber 标记为需要更新，并交给调度器决定何时执行。\n\n第四步，**render 阶段**  \nReact 从当前 Fiber 开始，重新执行函数组件或调用 render，构建新的 Fiber 树，并计算 UI 差异。\n\n第五步，**commit 阶段**  \n把 render 阶段计算出的结果一次性提交到 DOM，并执行副作用（effect、ref 更新等）。\n\n所以从设计上讲，`setState` 做的事情非常克制：  \n它只是**发起一次更新请求**，而不是“命令 React 立刻更新 UI”，这也是 React 能做调度、并发和批处理的基础。",
          "hasAnswer": true
        },
        {
          "id": "react-31",
          "title": "setState 何时同步何时异步?",
          "content": "严格来说，**setState 从来不是“同步或异步”的问题，而是“是否被批处理”**。\n\n在 React 的模型里，setState 做的事情只是**创建 update 并触发一次更新调度**，并不等价于“立刻改 state”。\n\n- **React 18 之前**\n  \n  - 在 React 事件系统（如 onClick）中，更新会被批处理\n  \n  - 在原生事件、Promise、setTimeout 中，更新不会被批处理，看起来像“同步”\n\n- **React 18 之后**\n  \n  - 默认开启 **自动批处理（automatic batching）**\n  \n  - 不论是 React 事件、Promise、setTimeout，都会合并更新\n  \n  - 统一交给 Scheduler 决定何时 render\n\n如果真的需要强制同步更新，只能使用 `flushSync`，但这会打断调度机制，属于兜底手段，不建议常用。",
          "hasAnswer": true
        },
        {
          "id": "react-32",
          "title": "useEffect 是如何实现的？",
          "content": "useEffect 的实现要分清 **render 阶段** 和 **commit 阶段**。\n\n在 **render 阶段**：\n\n- React 只做一件事：**收集 effect 描述**\n\n- 判断依赖数组是否变化，决定这个 effect 是否需要在本次提交后执行\n\n在 **commit 阶段**：\n\n- DOM 更新完成后\n\n- 先执行上一次 effect 的 cleanup\n\n- 再执行新的 effect 回调\n\n这也是为什么 useEffect：\n\n- 不会阻塞页面渲染\n\n- 执行时机一定晚于 DOM 更新\n\n本质上，useEffect 是一个**延迟到提交之后执行的副作用调度机制**。",
          "hasAnswer": true
        },
        {
          "id": "react-33",
          "title": "useLayoutEffect 和 useEffect 的区别",
          "content": "两者的核心区别只有一个：**执行时机不同**。\n\n- **useLayoutEffect**\n  \n  - DOM 更新完成\n  \n  - 浏览器绘制之前\n  \n  - 同步执行，会阻塞浏览器绘制\n\n- **useEffect**\n  \n  - 浏览器完成绘制之后\n  \n  - 异步执行\n\n因此 useLayoutEffect 适合：\n\n- 读取布局信息（如 getBoundingClientRect）\n\n- 需要在首帧绘制前同步修改 DOM 的场景\n\n其余绝大多数情况，优先使用 useEffect，避免阻塞渲染。",
          "hasAnswer": true
        },
        {
          "id": "react-34",
          "title": "React.memo 的第二个参数是什么？作用是什么",
          "content": "React.memo 的第二个参数是一个 **自定义 props 比较函数**：\n\n`React.memo(Component, (prevProps, nextProps) => boolean)`\n\n默认情况下，React.memo 使用 **浅比较**。  \n提供第二个参数后，你可以**完全接管“是否重新渲染”的判断逻辑**。\n\n适用场景：\n\n- props 结构复杂\n\n- 默认浅比较不够用\n\n- 组件渲染成本很高\n\n但需要注意：\n\n- 比较函数本身有执行成本\n\n- 写错容易导致组件不更新或状态不一致\n\n所以它是一个**高风险、高收益**的优化点，一般只在性能瓶颈明确时使用。",
          "hasAnswer": true
        },
        {
          "id": "react-35",
          "title": "ref / useRef / forwardRef 区别和作用",
          "content": "这三个概念解决的是同一类问题：如何在函数组件体系中持有和传递引用，但分工不同。\n\nref：引用这个概念本身，最终目的是访问或控制某个对象（通常是 DOM 或实例）\n\nuseRef：在函数组件中创建一个稳定的 ref，对应 { current }，在多次 render 之间保持同一个引用\n\nforwardRef：让函数组件能够接收父组件传下来的 ref，并继续向内部传递\n\nuseRef 的关键特性是：\n\n修改 ref.current 不会触发重新渲染\n\n闭包捕获的是 ref 对象本身，而不是某次 render 的值\n\nforwardRef 的核心价值在于：\n在不破坏组件封装的前提下，向外暴露必要的控制能力，\n这在组件库（Input、Select、Modal 等）中几乎是必需的能力。",
          "hasAnswer": true
        },
        {
          "id": "react-36",
          "title": "说说 useReducer 是什么，怎么用",
          "content": "useReducer 是 useState 的一种“结构化升级”。\n\n它引入了 reducer 的概念：\n\n- state 的变化不再分散在各处\n\n- 所有更新逻辑集中在 reducer 中\n\n- 通过 dispatch action 驱动状态变化\n\n适合的场景是：\n\n- state 结构复杂\n\n- 更新规则清晰\n\n- 多种行为影响同一份 state\n\n从模型上看，useReducer 更接近一个**局部状态机**。",
          "hasAnswer": true
        },
        {
          "id": "react-37",
          "title": "对比 useReducer 和 useState",
          "content": "这两个 Hook 的**底层能力是等价的**，差异主要体现在**状态建模方式和复杂度管理**上。\n\n`useState` 更偏向**值级别的状态管理**：\n\n- 一个 state 对应一块独立的值\n\n- 更新逻辑通常写在调用点\n\n- 适合状态简单、更新路径单一的场景\n\n`useReducer` 更偏向**行为驱动的状态管理**：\n\n- state 的变化由 reducer 统一描述\n\n- 通过 dispatch action 驱动更新\n\n- 更新逻辑集中，可读性和可维护性更好\n\n从实现上看，`useState` 本质上就是一个**简化版的 useReducer**（内部同样是 update queue + reducer 逻辑）。  \n所以在实际项目里，一般的选择策略是：\n\n- **状态简单 → useState**\n\n- **状态复杂 / 多种行为影响同一状态 → useReducer**\n\n关键不是“哪个更高级”，而是**状态复杂度是否已经超过 useState 的舒适区**。",
          "hasAnswer": true
        },
        {
          "id": "react-38",
          "title": "18 以前为什么 useState 不能批量更新，18 以后为什么可以？",
          "content": "这个问题的核心不在 useState，而在 **React 的调度模型是否统一**。\n\n**React 18 以前**：\n\n- 只有 React 自己控制的事件系统（如 onClick）里，更新才会被批处理\n\n- 原生事件、Promise、setTimeout 中的 setState，被认为处在“脱离 React 控制流”的执行上下文\n\n- React 无法安全地判断这些更新是否属于同一批次，因此默认不合并\n\n**React 18 之后**：\n\n- 引入了统一的调度入口（Scheduler）\n\n- 不再根据“事件来源”决定是否批处理\n\n- 所有更新都会先进入调度系统，再由调度器决定合并和执行时机\n\n所以 18 之后 useState 能批量更新，不是 API 行为改变，而是：  \n**React 终于具备了跨异步边界统一调度更新的能力**，这是并发架构的直接结果。\n\nReact 18 之所以能跨异步边界批量更新，本质原因是它把所有状态更新统一收编进 Scheduler，通过 concurrent root + lane 模型，让 React 自己掌握更新的合并和调度时机，而不再依赖事件来源是否“可控”。",
          "hasAnswer": true
        },
        {
          "id": "react-39",
          "title": "react 自定义 hooks 和 Vue3 composable 本质区别？",
          "content": "两者在“形式”上很像，但**底层模型完全不同**。\n\nReact 自定义 Hook：\n\n- 本质是**普通函数**\n\n- 状态管理依赖 **Hook 调用顺序 + 内部链表**\n\n- 不具备自动依赖追踪\n\n- 数据流完全由开发者显式控制\n\nVue3 composable：\n\n- 基于 **响应式系统**\n\n- 状态是 reactive / ref\n\n- 依赖关系由系统自动收集\n\n- 更偏“声明数据 → 自动更新”\n\n这带来的差异是：\n\n- React Hook 更自由、更贴近 JavaScript 语义，但规则更严格（调用顺序、依赖数组）\n\n- Vue composable 更自动化、心智负担更低，但抽象层更厚，对框架依赖更强\n\n从工程角度看：  \nReact 的自定义 Hook 更像**逻辑层抽象工具**；  \nVue 的 composable 更像**响应式能力的复用单元**。",
          "hasAnswer": true
        },
        {
          "id": "react-40",
          "title": "useContext 是什么作用？有什么优缺点？",
          "content": "useContext 的作用是**跨层级共享数据，避免 props drilling**。\n\n优点：\n\n- 使用简单\n\n- 数据流清晰\n\n- 适合全局配置、主题、权限等低频变化数据\n\n缺点：\n\n- 更新粒度粗\n\n- Context value 变化会导致所有消费者重新渲染\n\n- 不适合高频、复杂状态\n\n常见优化方式包括：\n\n- 拆分 Context\n\n- 保持 value 引用稳定\n\n- 在复杂场景中配合 selector 或状态管理库使用",
          "hasAnswer": true
        },
        {
          "id": "react-41",
          "title": "React Fiber 是什么? 说说 fiber 架构的工作原理?",
          "content": "React Fiber 本质上是 **React 的新协调（reconciliation）架构**，它解决的核心问题只有一个：  \n**让渲染过程从“同步、不可中断”，变成“可中断、可恢复、可调度”。**\n\n在 Fiber 之前（Stack Reconciler），React 渲染是一次深度递归：\n\n- 一旦开始 render，就必须把整棵组件树算完\n\n- 过程中无法中断\n\n- 主线程被长期占用，容易造成掉帧、输入卡顿\n\nFiber 引入之后，React 把“一次 render”拆成了很多**以 Fiber Node 为单位的小任务**。\n\n从结构上看：\n\n- 每个组件实例对应一个 Fiber Node\n\n- Fiber Node 同时是：\n  \n  - 组件的“数据结构表示”\n  \n  - 一个“工作单元（work unit）”\n\n从执行模型上看：\n\n- render 阶段不再是递归，而是**可暂停的循环**\n\n- React 每处理完一个 Fiber，就判断：\n  \n  - 时间片是否用完\n  \n  - 是否有更高优先级任务\n\n- 如果需要，就中断当前渲染，稍后从中断点继续\n\n一句话总结 Fiber 的工作原理：**把一次大而不可控的渲染任务，拆成很多可调度的小任务，由 React 自己掌控执行节奏。**",
          "hasAnswer": true
        },
        {
          "id": "react-42",
          "title": "为什么 react 需要 fiber 架构，而 Vue 却不需要?",
          "content": "React 需要 Fiber，而 Vue 不需要，本质原因是两者的更新模型不同。\n\nVue 是**以数据为核心的响应式系统**，通过依赖收集和发布订阅机制，精确地知道哪些组件、哪些计算属性依赖了某个数据，因此在数据变化时，可以直接定位到需要更新的最小范围，更新路径是明确且可控的。\n\n而 React 是**以组件为核心的更新模型**，当组件状态发生变化时，默认会从该组件开始，重新执行组件函数，并向下递归子组件来计算新的 UI，这在组件树很大时，可能会形成一次耗时很长的渲染任务。\n\n在 Fiber 架构之前，React 的 reconciler 是同步、不可中断的，一旦开始渲染，就会一直占用主线程，容易造成页面卡顿，影响用户输入和滚动等交互。\n\nFiber 架构的核心作用是把一次大的渲染任务拆分成多个以 Fiber 节点为单位的小任务，引入时间切片和优先级调度机制，在 render 阶段可以随时中断，把执行权交还给浏览器，等空闲时再继续执行，而 commit 阶段则一次性提交所有副作用，保证 UI 一致性。\n\n所以总结来说，**React 由于组件级整体更新的特性，需要 Fiber 来解决可中断调度的问题，而 Vue 基于依赖追踪的更新模型，本身不需要这种级别的调度体系。**",
          "hasAnswer": true
        },
        {
          "id": "react-43",
          "title": "讲讲 React Fiber 是如何实现更新过程可控的",
          "content": "“可控”是 Fiber 的核心价值，具体体现在 **三件事** 上：\n\n1. 第一，渲染任务可拆分（incremental work）\n\nFiber 把渲染拆成一个个 Fiber Node：\n\n- 每个 Fiber 只做很小的一步工作\n\n- React 可以在任意 Fiber 节点处暂停\n\n这让 React 能避免“长时间霸占主线程”。\n\n2. 第二，渲染过程可中断、可恢复\n\n在 render 阶段：\n\n- React 使用 `workInProgress` Fiber 树\n\n- 每完成一个 Fiber，就记录当前进度\n\n- 一旦被打断，下次可以从中断的 Fiber 继续，而不是重来\n\n这是 Fiber 和旧架构**本质上的差异**。\n\n3. 第三，render 和 commit 严格分离\n\nFiber 明确区分两个阶段：\n\n- **render 阶段**：\n  \n  - 纯计算\n  \n  - 可中断\n  \n  - 不产生副作用\n\n- **commit 阶段**：\n  \n  - 一次性提交 DOM\n  \n  - 不可中断\n  \n  - 保证 UI 一致性\n\n这种分离，是 React 能做并发调度的前提。",
          "hasAnswer": true
        },
        {
          "id": "react-44",
          "title": "react 如何确定具体场景的执行优先级",
          "content": "React 的优先级系统在 Fiber 中是通过 **Lane 模型 + Scheduler** 实现的。\n\n1. Lane：优先级的“数据表示”\n\n每一次更新（setState）都会被分配一个 lane：\n\n- lane 是一个 bitmask\n\n- 不同 lane 表示不同紧急程度\n  \n  - 同步输入（点击、输入）\n  \n  - 动画\n  \n  - 普通更新\n  \n  - transition\n  \n  - idle\n\nlane 的本质作用是：**告诉 React：这个更新有多急，能不能等。**\n\n2. Scheduler：优先级的“执行者”\n\nScheduler 会：\n\n- 收集当前所有 pending updates\n\n- 根据 lane 决定：\n  \n  - 先执行哪个\n  \n  - 哪些可以合并\n  \n  - 是否可以打断当前 render\n\nReact 会优先保证输入响应，而不是把时间花在低优先级渲染上。\n\n3. 场景优先级的来源\n\n优先级的来源主要包括：\n\n- 更新发生的上下文（事件、transition）\n\n- 开发者显式标记（如 `startTransition`）\n\n- 内部默认策略（如初次渲染、同步更新）\n\nReact 18 的并发特性，本质上就是**开发者可以参与优先级标注**。",
          "hasAnswer": true
        },
        {
          "id": "react-45",
          "title": "fiber 怎么进行任务的终止和恢复的？为什么不直接使用 requestldleCallback?",
          "content": "React Fiber 通过把一次渲染拆分成多个小的工作单元（Fiber Node），使渲染过程变成**可中断、可恢复的增量执行过程**。\n\n在渲染阶段，React 每次只处理一个 Fiber 节点，处理完成后会判断当前时间片是否用尽，如果有更高优先级任务或者时间不够，就主动让出主线程。\n\n中断时，React 会保存当前的 `workInProgress Fiber`，等下次调度继续从这个 Fiber 节点开始执行，而不是从头重新渲染整棵树。\n\nReact 并不是直接依赖浏览器调度，而是自己实现了一套 Scheduler。 通过 MessageChannel 来创建一个**稳定、可控、优先级更高的异步调度入口**，用来触发一次新的调度循环，而不是用来通信任务完成状态。\n\nrequestIdleCallback 的最大问题是： **调度时机完全由浏览器决定，React 无法精确控制优先级和执行时长。** 回调时机不可预测：浏览器“觉得”空闲才会调用，在动画、输入密集时可能长期不执行\n优先级控制能力弱：只区分是否空闲而没有优先级\n与 React 的调度模型不匹配：React 需要在不同优先级任务之间频繁切换，rIC 不适合高频、精细的任务切分\n\n总结：Fiber 的本质是把同步、不可中断的递归渲染，改造成基于 Fiber Node 的可中断工作流；React 通过自建 Scheduler 控制调度节奏，而不是把渲染节奏完全交给浏览器。",
          "hasAnswer": true
        },
        {
          "id": "react-46",
          "title": "详细说说 fiber 架构的 commit 阶段过程",
          "content": "commit 阶段的核心特征只有一句话：  \n**不可中断，一次性提交所有副作用。**\n\ncommit 阶段通常分为 **三个子阶段**：\n\n1. 第一阶段：before mutation\n\n这一阶段主要做两件事：\n\n- 执行 `getSnapshotBeforeUpdate`\n\n- 读取 DOM 状态（在 DOM 变更之前）\n\n这是给类组件和部分底层逻辑用的。\n\n2. 第二阶段：mutation\n\n这是 commit 的核心阶段：\n\n- 执行 DOM 插入、更新、删除\n\n- 更新 ref\n\n- 执行 layout effect 的 cleanup（旧的）\n\n所有 DOM 变更都发生在这里，而且**顺序是严格保证的**。\n\n3. 第三阶段：layout\n\n在 DOM 已经更新完成后：\n\n- 执行 `useLayoutEffect`\n\n- 执行 class 组件的 `componentDidMount / componentDidUpdate`\n\n这一阶段仍然是同步的，会阻塞浏览器绘制。",
          "hasAnswer": true
        },
        {
          "id": "react-47",
          "title": "详细说说 fiber 架构的 render 阶段过程",
          "content": "render 阶段是 **Fiber 的核心工作阶段**，特点是：  \n**纯计算、可中断、不触碰 DOM。**\n\n整个过程可以理解为一个循环，而不是递归。\n\n1. beginWork（向下）\n- 从 root Fiber 开始\n\n- 对每个 Fiber 执行 `beginWork`\n\n- 根据 props/state 计算子 Fiber\n\n- 标记副作用（flags）\n\n这是“向下构建 Fiber 树”的过程。\n\n2. completeWork（向上）\n- 当一个 Fiber 的子节点处理完成\n\n- 执行 `completeWork`\n\n- 收集子节点的副作用\n\n- 构建 effect list（flags 链）\n\n这是“向上归并结果”的过程。\n\n3. 可中断点\n\n在任意一个 Fiber 处理完成后：\n\n- React 都可以检查时间片\n\n- 如果需要：\n  \n  - 暂停 render\n  \n  - 把控制权还给浏览器\n  \n  - 之后从当前 Fiber 继续\n4. render 阶段的产出\n\nrender 阶段的最终产物是：\n\n- 一棵 **workInProgress Fiber Tree**\n\n- 一份完整的副作用描述（flags）\n\n但 **不会产生任何真实 DOM 变更**。",
          "hasAnswer": true
        },
        {
          "id": "react-48",
          "title": "react 如何实现时间切片",
          "content": "时间切片（Time Slicing）本质上是：  **把一次长时间占用主线程的渲染任务，拆成多个短任务，在合适的时机主动让出主线程。**\n\nReact 能实现时间切片，靠的是 **Fiber + Scheduler + cooperative scheduling（协作式调度）** 这一整套机制。\n\n**第一步：把渲染任务拆成最小工作单元**\n\n在 Fiber 架构下：\n\n- 每一个 Fiber Node 就是一个**最小可执行单元**\n\n- render 阶段不再是递归调用，而是一个循环\n\n- 每处理完一个 Fiber，React 都有机会“停下来看看要不要继续”\n\n这是时间切片的**结构前提**。  \n如果还是递归，一次函数调用栈跑完，根本没有中断点。\n\n**第二步：在 render 阶段引入“可让出点”**\n\nReact 在 render 阶段，每完成一个 Fiber 的 `beginWork / completeWork` 后，都会检查：\n\n- 当前时间是否超过了本次分配的时间片\n\n- 是否有更高优先级的任务（如用户输入）\n\n一旦判断“该让出主线程了”：\n\n- 当前 render 立即暂停\n\n- 保存当前 `workInProgress` 指针\n\n- 把控制权还给浏览器（让输入、动画先执行）\n\n**第三步：通过 Scheduler 决定何时继续**\n\nReact 并不是随便继续渲染的，而是通过 Scheduler：\n\n- 把剩余的 Fiber 工作挂到一个任务队列里\n\n- 等浏览器空闲、或者当前优先级允许时\n\n- 从上一次中断的 Fiber 继续执行，而不是重头开始\n\n这一步的关键在于：  \n**render 阶段是可恢复的**，这是 Fiber 架构才能做到的事情。",
          "hasAnswer": true
        },
        {
          "id": "react-49",
          "title": "fiber 为什么是性能飞跃",
          "content": "Fiber 被称为性能飞跃，不是因为“单次渲染更快”，而是因为**性能模型发生了根本变化**。\n\n可以从三个层面理解。\n\n**第一，Fiber 解决的是“卡顿问题”，不是“跑得快不快”**\n旧架构的问题不是平均性能，而是**最坏情况**：\n- 一次更新渲染几百个组件\n- 主线程被占用几十毫秒\n- 用户输入、滚动直接卡死\nFiber 的价值在于：  \n👉 **把不可控的长任务，变成可控的短任务**\n这直接提升的是**交互稳定性**，而不是 benchmark 分数。\n\n**第二，Fiber 让“优先级”成为调度原则**\n在 Fiber 之前：\n- 更新基本是 FIFO\n- 用户输入和低优先级更新没有本质区别\nFiber 之后：\n- 每个更新都有优先级（lane）\n- 高优先级更新可以打断低优先级渲染\n- 非紧急更新可以被延后甚至丢弃重算\n这让 React 能做到：  \n**页面再复杂，也优先保证用户交互不卡。**\n\n**第三，Fiber 为并发能力打开了天花板**\nFiber 本身不是并发，但它是并发的**必要前提**。\n没有 Fiber：\n- render 不可中断\n- 无法调度\n- 不可能并发\n有了 Fiber：\n- render 可暂停、可恢复\n- Scheduler 可以插队、合并、延迟\n- 才有 React 18 的并发渲染、自动批处理、transition\n\n**一句话总结 Fiber 为什么是性能飞跃**：Fiber 的性能飞跃不在于加快一次渲染，而在于把渲染从同步、不可控的长任务，变成可调度、可中断的工作流，从而在复杂场景下保证交互优先级和系统稳定性，这也是 React 并发能力的基础。",
          "hasAnswer": true
        },
        {
          "id": "react-50",
          "title": "redux 的使用原则",
          "content": "我理解 Redux 的使用原则可以总结为三点：**该不该用、怎么用、用到什么程度**。\n\n第一，**不是所有状态都适合放 Redux**。  \nRedux 主要解决的是**跨组件、跨页面、生命周期长、需要可预测性的状态**，比如用户信息、权限、全局配置、复杂业务流程状态。  \n组件内部 UI 状态、临时状态，用 Redux 反而会增加复杂度。\n\n第二，**Redux store 里的状态必须是“业务状态”**。  \n不要把派生状态、纯 UI 状态、一次性状态塞进 store，否则 reducer 会变得难以维护。\n\n第三，**更新路径必须可追踪、可预测**。  \nRedux 的核心价值在于“状态变更有明确入口”，如果 dispatch 到处乱飞、action 语义混乱，Redux 的优势会被完全抵消。\n\n一句话原则是：\n\n> Redux 用来管理“重要且复杂的共享状态”，而不是“所有状态”。",
          "hasAnswer": true
        },
        {
          "id": "react-51",
          "title": "说说 Redux 的核心方法和工作流程",
          "content": "Redux 的核心其实非常少，主要就是 **store、action、reducer** 这三件事。\n\n从工作流程看是一个**严格的单向数据流**：\n\n1）UI 触发一个 action（一个普通对象，描述发生了什么）  \n2）action 被 dispatch 到 store  \n3）store 调用 reducer，传入旧 state 和 action  \n4）reducer 根据 action 返回一个新的 state  \n5）store 保存新 state，并通知所有订阅者  \n6）UI 读取最新 state，重新渲染\n\n这里有两个非常关键的点：\n- reducer 必须是**纯函数**\n- state 必须是**不可变更新**\n\n正是这两个约束，保证了 Redux 的可预测性和可调试性。",
          "hasAnswer": true
        },
        {
          "id": "react-52",
          "title": "redux 的优缺点",
          "content": "Redux 的优点：\n第一，**状态可预测、可追溯**。  \n所有状态变化都通过 action 发生，时间线非常清晰，调试和回溯成本低。\n第二，**适合复杂业务状态**。  \n当状态更新逻辑变复杂时，Redux 反而更清晰，因为规则都集中在 reducer 里。\n第三，**生态成熟**。  \n中间件、调试工具、最佳实践非常完善。\n\n但缺点也同样明显：\n第一，**样板代码多**。  \naction、reducer、types，一旦规模不控制，很容易膨胀。\n第二，**心智负担偏重**。  \n对简单场景来说，Redux 明显是“重武器”。\n\n所以 Redux 非常适合复杂中大型项目，但并不适合所有项目。",
          "hasAnswer": true
        },
        {
          "id": "react-53",
          "title": "说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？",
          "content": "Redux 中间件的本质是：  \n**在 dispatch action 和 reducer 处理 action 之间，插入一层可扩展的拦截逻辑**。\n\n常见中间件包括：\n- `redux-thunk`：支持 action 返回函数\n- `redux-saga`：用 generator 处理复杂异步流程\n- `redux-logger`：日志和调试\n- `redux-promise`：处理 Promise action\n\n实现原理并不复杂：  \nRedux 在创建 store 时，会把原始的 `dispatch` 包装成一层层函数链，每个中间件都可以：\n- 拦截 action\n- 执行额外逻辑\n- 决定是否、何时、以什么形式继续 dispatch\n\n所以中间件解决的是：  \n**扩展 Redux 能力，但不污染 reducer 纯度**。",
          "hasAnswer": true
        },
        {
          "id": "react-54",
          "title": "Redux 中异步的请求怎么处理",
          "content": "Redux 本身是同步的，不支持直接在 reducer 里做异步。\n\n处理异步主要有三类方案：\n第一类，**Thunk 模式**。  \naction 返回一个函数，在函数里做异步请求，完成后再 dispatch 普通 action，适合简单异步。\n第二类，**Saga 模式**。  \n通过 generator + effect 描述异步流程，更适合复杂的并发、取消、重试场景。\n第三类，**请求层与 Redux 解耦**。  \n比如请求在组件或 service 层完成，只把结果 dispatch 进 Redux，这在工程实践中非常常见。\n\n选择哪种，取决于**异步复杂度**，而不是“哪个更高级”。",
          "hasAnswer": true
        },
        {
          "id": "react-55",
          "title": "React 中组件之间进行数据通信有哪些方式？",
          "content": "从低到高大致可以分几层：\n\n第一，**props 传递**，父子组件最基本方式  \n第二，**回调函数**，子组件向父组件通信  \n第三，**Context**，解决跨层级传参  \n第四，**全局状态管理（Redux、Zustand 等）**  \n第五，**外部事件系统 / pub-sub**，极少数特殊场景\n\n原则是：\n\n> 优先选择最简单的通信方式，复杂度不够时再升级方案。",
          "hasAnswer": true
        },
        {
          "id": "react-56",
          "title": "对比 redux 和 zustand",
          "content": "Redux 和 Zustand 的核心差异，不在 API，而在**设计目标和约束强度**。\n\n**Redux 的定位是“强约束的全局状态管理方案”**：\n- 单一 store、单向数据流\n- 所有状态变化必须通过 action → reducer\n- 强调可预测性、可追溯性、可调试性\n这使得 Redux 非常适合：\n- 复杂业务状态\n- 状态变更规则多、流程长\n- 多人协作、长期维护的项目\n代价也很明显：\n- 样板代码多\n- 心智负担重\n- 简单场景下显得过度设计\n\n**Zustand 的定位是“轻量、贴近 React 的状态容器”**：\n- 基于 hook\n- 没有 reducer、action 的强制约束\n- 按需订阅，更新粒度细\nZustand 更像是： “一个可共享的 useState + useCallback 集合”\n它非常适合：\n- 中小规模项目\n- 对开发效率和简洁性要求高的场景\n\n总结一句话：\n- **Redux 用规则换确定性**\n- **Zustand 用自由换效率**\n\n在实际工程中，我更倾向于：\n- 复杂业务核心状态 → Redux\n- 中小型项目，强调开发效率 → Zustand",
          "hasAnswer": true
        },
        {
          "id": "react-57",
          "title": "React 中组件之间进行数据通信有哪些方式？",
          "content": "我一般会按**“通信距离 + 状态生命周期”**来回答。\n\n第一层，**父子组件**：\n- props 向下传递\n- 回调函数向上传值  \n    这是最基本、也是最推荐的方式。\n\n第二层，**兄弟组件 / 跨层级组件**：\n- 状态提升到最近的公共父组件\n- 再通过 props 分发\n\n第三层，**Context**：\n- 解决 props drilling\n- 适合低频变化、全局性数据（主题、权限、配置）\n- 缺点是：Context 更新会导致所有消费组件重新 render，粒度比较粗。\n\n第四层，**全局状态管理**：\n- Redux、Zustand、MobX 等\n- 用于生命周期长、影响范围广的状态\n\n核心原则是： **优先用最近、最局部的通信方式，复杂度不够时再升级方案。**",
          "hasAnswer": true
        },
        {
          "id": "react-58",
          "title": "说说 react 的事件代理机制原理和优缺点",
          "content": "React 的事件系统是**合成事件（Synthetic Event）机制**，核心是**事件代理**。\n\n**原理**上：\n- React 并不会在每个 DOM 节点上绑定事件\n- 而是把事件统一绑定在**根节点（React 17 之后是 root container）**\n- 事件触发后，通过事件冒泡捕获到根节点\n- React 再根据 Fiber 树，模拟捕获和冒泡阶段，分发给对应组件的事件处理函数\n\n**优点**：\n- 性能稳定，避免大量事件监听\n- 事件系统一致，跨浏览器行为统一，框架统一处理浏览器兼容性\n- React 可以完全控制事件触发时机和优先级，为批量更新、优先级调度提供基础\n\n**缺点**：\n- 事件不完全等同于原生事件\n- 在极端场景（如 document 级别监听）下可能产生困惑\n- 需要理解合成事件与原生事件的差异（如事件对象复用、时机差异）",
          "hasAnswer": true
        },
        {
          "id": "react-59",
          "title": "说说 react 事件和浏览器原生事件执行先后顺序，为什么？",
          "content": "这个问题的关键在于：  \n**React 事件本质上是绑定在 react 根元素上（在 React 17 之后）的原生事件监听器。**\n\n在同一个元素上挂载的事件，顺序是：\n- → **React 捕获阶段事件**\n- → **原生捕获阶段事件**\n- → **React 冒泡阶段事件**\n- → **原生冒泡阶段事件**\n\n原因在于：\n- React 在 react oot container 上注册了原生事件监听\n- React 可以选择在捕获阶段或冒泡阶段拦截事件\n- 然后在内部模拟完整的捕获/冒泡流程",
          "hasAnswer": true
        },
        {
          "id": "react-60",
          "title": "react 的事件为什么要委托，有什么好处？",
          "content": "React 之所以做事件委托，本质原因是：**React 需要一个“可控、统一、可调度”的事件入口**，而不是简单的性能优化。\n\n从实现上看，React 并不会在每个 DOM 节点上绑定事件，而是：\n- 在根节点（React 17 之后是 root container）\n- 统一注册一组原生事件监听\n- 事件触发后，再由 React 自己根据 Fiber 树分发给对应组件\n\n这样做有几个关键好处：\n\n第一，**统一事件模型，屏蔽浏览器差异**  \nReact 的合成事件层可以抹平不同浏览器在事件对象、冒泡行为上的差异，保证行为一致。\n\n第二，**为批量更新和调度提供控制点**  \n事件回调是 React 非常重要的“更新边界”。  \n通过委托，React 可以在事件回调结束后，统一做 batching、优先级调度，而不是被分散在各个 DOM listener 里。\n\n第三，**避免大量事件监听带来的管理成本**  \n在复杂应用中，组件频繁挂载、卸载，如果每个节点都绑事件，清理和维护成本非常高。  \n集中委托让事件生命周期和 React 树保持一致。\n\n所以总结一句话： React 做事件委托，不只是为了少绑事件，而是为了**完全掌控事件 → 更新 → 渲染这一整条链路**。",
          "hasAnswer": true
        },
        {
          "id": "react-61",
          "title": "react 事件委托如何解决模态框的事件冒泡？",
          "content": "这个问题其实考的是：**“React 里的事件冒泡，是按 DOM 树，还是按 React 树？”**\n答案是：  **React 的事件冒泡是按 React Fiber 树，而不是 DOM 树。**\n\n在模态框（Modal）场景中，经常是：\n- Modal 的 DOM 被渲染到 `document.body`（通过 Portal）\n- 但在 React 组件结构上，它仍然是某个父组件的子节点\n\nReact 的做法是：\n- 原生事件先在真实 DOM 上冒泡到 root\n- React 拿到事件后\n- **根据 Fiber 树关系重新模拟捕获和冒泡**\n\n因此即使 Modal 的 DOM 在 body 下：\n- React 仍然能正确判断它“逻辑上属于谁”\n- 冒泡顺序仍然符合组件层级预期\n\n总结：React 通过“事件委托 + Fiber 映射”，把**DOM 位置和组件层级解耦**了。",
          "hasAnswer": true
        },
        {
          "id": "react-62",
          "title": "react 17 之后的事件机制有什么区别？",
          "content": "React 17 的事件系统变化是一个**非常典型的架构级调整**，**最关键的变化只有一个**：  **事件不再委托到 `document`，而是委托到 root container。**\n\n在 React 16 及之前：\n- 所有 React 事件都绑定在 `document` 上\n- 多个 React 应用会共享同一套事件系统\n在 React 17 之后：\n- 事件绑定在 `createRoot` 对应的容器上\n- 每个 React 应用拥有独立的事件系统\n\n这样改的核心原因是：\n第一，**支持多个 React 版本共存**  \ndocument 级别委托会导致不同版本的 React 互相干扰。\n\n第二，**降低对全局环境的侵入性**  \nReact 不再“劫持”整个 document，更像一个普通应用。\n\n第三，**为并发特性和渐进升级铺路**  \n事件边界更清晰，调度模型更容易控制。\n\n这次改动对业务代码几乎无感，但对架构非常关键。",
          "hasAnswer": true
        },
        {
          "id": "react-63",
          "title": "子组件 portal 能冒泡到父组件吗？",
          "content": "结论先给： **能，React 事件可以，原生事件不行。**\n\n更准确地说：\n- **React 合成事件：可以冒泡到逻辑父组件**\n- **原生 DOM 事件：只按真实 DOM 结构冒泡**\n\n原因在于：  \nReact 的事件冒泡是基于 **Fiber 树**，而不是 DOM 树。\nPortal 的特点是：\n- DOM 节点被插入到别的地方（比如 body）\n- 但 Fiber 关系不变\n\n所以：\n- React 在事件分发阶段\n- 会“无视 DOM 位置”\n- 按组件层级模拟冒泡\n\n这也是为什么在 Portal 场景下：\n- `e.stopPropagation()` 有时要特别注意\n- 原生事件和 React 事件的行为可能不同 \n\n一句话总结就是： Portal 打破的是 DOM 层级，不是 React 的组件层级。",
          "hasAnswer": true
        },
        {
          "id": "react-64",
          "title": "Redux 中的 connect 有什么作用?",
          "content": "Redux 中的 `connect` 是一个高阶组件，用来把 Redux 的 store 和 React 组件连接起来。\n\n它的核心作用有三个：  \n第一，通过 `mapStateToProps` 精准地选取组件真正依赖的状态，并在这些状态发生变化时才触发组件更新，从而避免不必要的重渲染。  \n第二，通过 `mapDispatchToProps` 封装 dispatch，让组件只关心业务行为，而不直接依赖 Redux 的实现细节。  \n第三，`connect` 内部自动完成 store 的订阅和取消订阅，简化了组件的生命周期管理。\n\n本质上，`connect` 起到的是**状态管理层和视图层之间的桥梁作用**。  \n在 Hooks 出现后，`useSelector / useDispatch` 在使用体验上更直观，但 `connect` 在性能可控性和老项目中依然很常见。",
          "hasAnswer": true
        },
        {
          "id": "react-65",
          "title": "说说你对 immutable 的理解？如何应用在 React 项目中",
          "content": "Immutable 的核心思想是：**数据一旦创建就不被修改，任何变更都会生成一个新的引用**。\n\n在 React 中它的价值主要体现在两点：\n\n1. **状态可预测**：避免隐式修改带来的副作用，数据流更清晰\n\n2. **性能优化基础**：通过引用变化配合 `===`、`memo`、`PureComponent`、`shouldComponentUpdate` 实现高效更新判断\n\n实际应用方式包括：\n\n- 遵守不可变更新原则（展开运算符、slice、map 等）\n\n- 在复杂嵌套结构中使用工具库（如 Immer）降低心智成本\n\n- 配合 Redux / React.memo / useMemo 做更新边界控制\n\n需要注意的是，immutable 是**手段而不是目的**，在性能敏感或结构简单的场景下不必过度追求。",
          "hasAnswer": true
        },
        {
          "id": "react-66",
          "title": "RSC react server component",
          "content": "React Server Components 是 React 提出的 **一种让部分组件只在服务器端执行的渲染模式**\n它不是传统意义上的 SSR（Server-Side Rendering）那样生成完整 HTML，而是：\n\n**在服务器执行组件逻辑，把渲染结果以特殊协议序列化成数据流发送给客户端，客户端再把这些数据解释成 UI。**\n\n核心特点：\n\n- 组件代码 **永远不发送到客户端**（不会打包到 bundle 里）。\n- 只能运行在服务器上，不能使用浏览器 API 和交互 Hooks（如 `useState`, `useEffect`）。主要用于数据密集型、展示型的 UI。\n- 主要用于数据密集型、展示型的 UI。\n\n这就能让 React 应用更“轻巧、高效、按需加载”。\n\n| 渲染方式        | JS 发送到客户端       | 数据获取模式         | 互动能力                 |\n| ----------- | --------------- | -------------- | -------------------- |\n| CSR (客户端渲染) | 全组件 JS          | 客户端请求 API      | 强                    |\n| SSR (服务端渲染) | 全组件 JS + HTML   | 服务端预取数据 → HTML | 交互需要 hydrate         |\n| **RSC**     | **只发送必要的交互 JS** | 服务器直接数据访问      | 交互需 Client Component |\n\nReact Server Components 是一种服务器执行的组件模式，它让 UI 的渲染和数据获取在服务端完成，只把 UI 结构通过序列化协议发送给客户端，从而减少 JS bundle、提高性能并简化数据获取，同时和交互组件协同工作，适配复杂应用。\n\n**RSC 适合：数据驱动、多页面/大列表/复杂查询、多数据源聚合，但客户端交互较轻**的页面。\n\n**不适合：交互复杂、状态频繁变化、强实时响应**的组件。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "vue",
      "name": "Vue",
      "questions": [
        {
          "id": "vue-1",
          "title": "Vuex 的核心概念和工作流程",
          "content": "**State** 单一状态树，存储应用的全部状态，作为\"唯一数据源\"。\n\n**Getter** 类似于计算属性，用于从 State 派生出新状态，具有缓存特性。\n\n**Mutation** 唯一允许修改 State 的方法。必须是**同步**函数，便于 DevTools 追踪状态变化。\n\n**Action** 负责提交 (`commit`) Mutation，可以包含**异步**操作或复杂的业务逻辑。\n\n**Module** 将 Store 分割成模块，每个模块拥有自己的 State、Getter、Mutation、Action，支持命名空间 (`namespaced: true`)。\n\nVuex 的数据流是**单向**的，遵循以下流程：\n\n1. **View (视图)**：用户在组件中触发一个操作。\n\n2. **Dispatch (分发)**：组件通过 `store.dispatch('actionName', payload)` 提交一个 **Action**。\n\n3. **Action (动作)**：Action 执行异步逻辑（如 API 调用）。一旦数据准备好，Action 会通过 `store.commit('mutationName', payload)` 提交一个 **Mutation**。\n\n4. **Commit (提交)**：**Mutation** 是唯一能修改 **State** 的地方。它同步地修改状态。\n\n5. **State (状态)**：状态被更新。\n\n6. **Render (渲染)**：由于 State 是响应式的，所有依赖此 State 的 **View** 组件会自动更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-2",
          "title": "对比 Vuex 和 Pinia",
          "content": "**Vuex** 是 Vue 2 时代的官方状态管理库，采用 Flux 架构，强调**单向数据流**和**严格的状态修改规范**（必须通过 Mutation）。适合大型项目，但模板代码较多，TS 支持需要额外配置。\n\n**Pinia** 是 Vue 3 官方推荐的状态管理库，可视为 Vuex 5。设计更简洁，去掉了 Mutation，原生支持 TypeScript，每个 Store 独立无需命名空间。\n\n| 特性         | Vuex                            | Pinia                               |\n| ---------- | ------------------------------- | ----------------------------------- |\n| 核心概念       | State, Getter, Mutation, Action | State, Getter, Action (去掉 Mutation) |\n| 修改状态       | 必须通过 Mutation（同步）               | Action 中直接修改 State                  |\n| TypeScript | 需要额外类型声明，配置繁琐                   | **原生支持**，类型自动推导                     |\n| 模块化        | 嵌套 Module，需要 `namespaced: true` | **独立 Store 实例**，按需导入，无需命名空间         |\n| 体积         | ~10KB                           | **~1KB**，更轻量                        |\n| DevTools   | 支持                              | 支持，体验更好                             |\n| SSR        | 需要额外配置                          | 开箱即用                                |\n| API 风格     | Options API 风格                  | 同时支持 Options 和 Composition API      |\n\n**选型建议**：\nVuex 和 Pinia 更像官方状态管理的代际更替：Vue3 之后组合式 API 和 TS 成为主流，Pinia 在类型推导、样板代码、store 组织方式上都更契合官方心智，而且是官方推荐路线；Vuex 主要保留在存量项目或迁移成本高的场景，新项目默认 Pinia 风险最低。",
          "hasAnswer": true
        },
        {
          "id": "vue-3",
          "title": "响应式开发比命令式开发有什么优势？",
          "content": "1. **声明式编程**：只需描述**状态与视图的映射关系**，无需手动操作 DOM，代码更易读易维护。\n\n2. **自动更新**：状态变化时，框架自动处理 DOM 更新，开发者无需关心\"何时更新、更新哪里\"。\n\n3. **高效渲染**：Virtual DOM + Diff 算法，**精确计算最小 DOM 变化集**，避免不必要的 DOM 操作。\n\n4. **减少 Bug**：手动 DOM 操作容易遗漏或出错，响应式系统保证状态与视图一致性。\n\n5. **组件化开发**：状态封装在组件内部，提高代码复用性和可测试性。",
          "hasAnswer": true
        },
        {
          "id": "vue-4",
          "title": "什么是装饰器？在 Vue 中怎么用？",
          "content": "装饰器 (Decorator) 是一种特殊的声明，用于**修改类或类成员的行为**，本质是一个函数。\n\n**在 Vue 中的应用**（主要是 Vue 2 + TypeScript）：\n\n```typescript\nimport { Component, Prop, Watch } from 'vue-property-decorator';\n\n@Component\nexport default class MyComponent extends Vue {\n  @Prop({ default: '' }) readonly title!: string; // 声明 props\n\n  @Watch('title') // 监听属性变化\n  onTitleChange(val: string) {}\n}\n```\n\n**Vue 3 现状**：Composition API 已取代装饰器方案，官方不再推荐使用装饰器。原因：\n\n- Composition API 提供更好的类型推导\n- 装饰器提案尚未稳定\n- 函数式组合比类继承更灵活",
          "hasAnswer": true
        },
        {
          "id": "vue-5",
          "title": "如何保持组件状态、避免重复渲染？（keep-alive）",
          "content": "主要通过 Vue 的内置抽象组件 **`<keep-alive>`** 来实现。\n\n作用： ` <keep-alive>` 包裹动态组件或路由组件时，会**缓存不活动的组件实例**，而不是销毁它们。这可以避免组件在切换时被重复创建和渲染，从而**保持组件的状态**（如表单输入内容、滚动位置等），并提升性能。\n\n实现原理与钩子函数\n\n1. **缓存机制**：内部使用 `Map` 缓存 VNode，key 为组件名或自定义 key。\n\n2. **生命周期变化**：缓存后 `unmounted`/`destroyed` 不会触发，新增两个钩子：\n   \n   - **`activated()`**：组件被激活时（切换进来）触发\n   - **`deactivated()`**：组件被停用时（切换出去）触发\n\n3. **常用属性**：\n   \n   - `include`：只缓存匹配的组件（字符串/正则/数组）\n   - `exclude`：排除匹配的组件\n   - `max`：最大缓存数量，超出时使用 **LRU 算法**淘汰最久未使用的\n\n```html\n<keep-alive :include=\"['Home', 'List']\" :max=\"10\">\n  <router-view />\n</keep-alive>\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-6",
          "title": "Vue 2 和 Vue 3 响应式原理的区别？为什么改用 Proxy？",
          "content": "| 对比项  | Vue 2 (Object.defineProperty) | Vue 3 (Proxy)   |\n| ---- | ----------------------------- | --------------- |\n| 初始化  | 递归遍历所有属性，开销大                  | **惰性处理**，访问时才递归 |\n| 新增属性 | ❌ 无法检测，需用 `$set`              | ✅ 自动响应          |\n| 删除属性 | ❌ 无法检测，需用 `$delete`           | ✅ 自动响应          |\n| 数组索引 | ❌ 无法检测 `arr[0] = x`           | ✅ 自动响应          |\n| 数组长度 | ❌ 无法检测 `arr.length = 0`       | ✅ 自动响应          |\n\n**Vue 3 改用 Proxy 的原因**：\n\n1. **功能更全面**：Proxy 可拦截 13 种操作（get/set/delete/has/ownKeys 等）\n2. **性能更优**：惰性响应式，减少初始化开销\n3. **代码更简洁**：无需为数组方法打补丁",
          "hasAnswer": true
        },
        {
          "id": "vue-7",
          "title": "Vue 的渲染过程（模板 → DOM）",
          "content": "总结：\n\n初次：1 编译模板（解析 AST+标记+生成渲染函数）2 执行渲染函数生成 VDOM 3 渲染\n\n后续数据更新：1 执行渲染函数生成新 VDOM 2 diff 获得 patch 3 更新 DOM\n\n阶段一：模板编译 (Template Compilation)\n\n1. **解析 (Parse)**：将 HTML 模板字符串解析成抽象语法树 (AST - Abstract Syntax Tree)。AST 是一种用 JavaScript 对象来描述模板结构的树形结构。\n\n2. **优化 (Optimize)**：遍历 AST，标记静态节点 (Static nodes)。静态节点是指内容不会变化的节点。Vue 在后续的 Diff 过程中会跳过这些节点，**大幅提高性能**。\n\n3. **代码生成 (Generate)**：将优化后的 AST 转换成 **Render Function (渲染函数)**。渲染函数返回的就是 VNode (Virtual Node) 树。\n\n阶段二：创建虚拟 DOM (Virtual DOM Creation)\n\n1. **首次渲染**：执行第一步生成的 **Render Function**，它返回一棵 **VNode Tree (虚拟 DOM 树)**。\n\n阶段三：渲染和更新 (Patching & DOM Update)\n\n1. **首次渲染**：将 VNode Tree 转换成真实的 DOM 元素，并插入到页面中。同时，Vue 将这棵 VNode Tree 保存为 `oldVNode`。\n\n2. **数据更新**：响应式数据发生变化时，会触发组件的 Watcher，重新执行 Render Function，生成一棵 **`newVNode` Tree**。\n\n3. **比对 (Patch)**：Vue 运行 **Diff 算法**（Patch 过程），将 `newVNode` 与 `oldVNode` 进行递归比对。\n\n4. **最小化 DOM 操作**：Diff 算法找出两棵树之间**最小的差异集**。\n\n5. **更新 DOM**：Vue 只对这些有差异的真实 DOM 节点进行必要的创建、更新、移动或删除操作，从而完成视图更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-8",
          "title": "Vue Router 原理？Hash 和 History 模式的区别？",
          "content": "Vue Router 的核心是监听 URL 的变化，并根据配置的路由映射表，动态地渲染对应的组件。\n\n1. **路由映射 (Route Mapping)**：定义 URL 路径 (`path`) 与组件 (`component`) 的映射关系。\n\n2. **监听 URL 变化**：根据配置的模式（Hash 或 History），监听浏览器地址栏 URL 的变化事件。\n\n3. **匹配路由**：当 URL 变化时，Router 捕获新 URL，并在路由映射表中查找匹配的配置。\n\n4. **渲染组件**：将匹配到的组件渲染到 `<router-view>` 占位符的位置上。\n\n| 对比项    | Hash 模式               | History 模式                       |\n| ------ | --------------------- | -------------------------------- |\n| URL 形式 | `example.com/#/user`  | `example.com/user`               |\n| 原理     | `window.onhashchange` | `history.pushState/replaceState` |\n| 服务器配置  | 无需配置                  | **需要配置回退**（所有路由返回 index.html）    |\n| SEO    | 不友好（爬虫忽略 # 后内容）       | 友好                               |\n| 兼容性    | 所有浏览器                 | IE10+                            |\n\n**导航守卫**（补充高频考点）：\n\n- `beforeEach`：全局前置守卫，常用于登录验证\n- `beforeResolve`：全局解析守卫\n- `afterEach`：全局后置钩子\n- `beforeEnter`：路由独享守卫\n- `beforeRouteEnter/Update/Leave`：组件内守卫",
          "hasAnswer": true
        },
        {
          "id": "vue-9",
          "title": "如何自定义 Vue 指令？有哪些钩子函数？",
          "content": "自定义指令用于对 DOM 元素进行**底层操作**，实现可复用的 DOM 行为。例如：自动获取焦点、权限控制、拖拽功能等。\n\n```js\n// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nconst app = createApp(App);\n\n// 注册一个全局自定义指令 v-focus\napp.directive('focus', {\n  // 元素挂载到 DOM 时调用\n  mounted(el) {\n    el.focus(); // 使元素自动获取焦点\n  },\n});\n\napp.mount('#app');\n\n//组件内用directives注册\n```\n\n**Vue 3 指令钩子函数**：\n\n- `created`：元素属性/事件监听器应用前\n- `beforeMount`：挂载前\n- `mounted`：挂载后（常用）\n- `beforeUpdate`：更新前\n- `updated`：更新后\n- `beforeUnmount`：卸载前\n- `unmounted`：卸载后\n\n**常见应用场景**：自动聚焦、权限控制（v-permission）、防抖点击、图片懒加载、拖拽",
          "hasAnswer": true
        },
        {
          "id": "vue-10",
          "title": "Vue 应用性能优化有哪些方向？",
          "content": "- **运行时性能优化 (Runtime Performance)**\n  \n  - **合理使用 `v-if` 和 `v-show`**：\n    \n    - **`v-if`**：真正销毁/重建组件，适用于不频繁切换的场景。\n    \n    - **`v-show`**：仅切换 CSS `display` 属性，适用于频繁切换的场景。\n  \n  - **`v-for` 必须使用 `key`**：帮助 Vue Diff 算法更高效地进行元素追踪和复用。\n  \n  - **使用 `v-once`**：对于内容不依赖数据的静态子树，使用 `v-once` 只渲染一次，避免了后续的更新开销。\n  \n  - **组件拆分和懒加载 (Async Components)**：将大组件拆分为小组件，并使用动态 `import()` 实现组件的按需加载。\n  \n  - 精准依赖，对 store 或外部属性，精准引入，依靠 vue 对响应式数据的优化\n  \n  - **大列表优化 (虚拟滚动/Virtual Scrolling)**：对于包含数千个项目的长列表，只渲染可见区域的 DOM，大幅减少 DOM 节点数量。\n  \n  - **合理使用 `computed` vs `watch`**：`computed` 具有缓存机制，只有依赖项变化时才会重新计算，比 `watch` 更高效。\n  \n  - **使用 Vue 3 的 `shallowRef` (如果可以)**：对于嵌套层级很深但我们只关心顶层引用的数据，使用 `shallowRef` 来减少不必要的深度响应式处理。\n\n- **加载性能优化 (Loading Performance)**\n  \n  - **图片优化**：WebP 格式、懒加载、响应式图片\n  \n  - **路由懒加载**：使用 `const route = () => import('./components/Path')`，将不同路由组件的代码分割成不同的 chunk，实现按需加载。\n  \n  - **第三方库按需引入**：如使用 Babel 插件或 Vite 插件，对 Element-UI/Plus、Ant Design Vue 等库进行按需导入，而不是全量导入。\n\n- **工程化优化**\n  \n  - **Tree Shaking**：确保使用 ES Module，移除未使用代码\n  \n  - **代码分割**：Webpack/Vite 的 splitChunks，合理拆分 vendor 和业务代码\n  \n  - **Gzip 压缩**：服务端开启压缩，减少传输体积\n  \n  - **CDN 加速**：静态资源上 CDN，利用边缘节点加速\n  \n  - **预加载/预获取**：`<link rel=\"prefetch/preload\">` 提前加载关键资源\n  \n  - **缓存策略**：合理配置 HTTP 缓存头，利用浏览器缓存",
          "hasAnswer": true
        },
        {
          "id": "vue-11",
          "title": "项目中遇到过哪些 Vue 相关的难题？如何解决？",
          "content": "**示例回答框架**（根据实际经验调整）：\n\n**场景 1：大列表性能问题**\n\n- 问题：渲染上万条数据导致页面卡顿\n- 方案：引入虚拟滚动（vue-virtual-scroller），只渲染可视区域 DOM\n- 效果：DOM 节点从 10000+ 降到 ~50，滚动流畅\n\n**场景 2：组件通信复杂**\n\n- 问题：多层嵌套组件间状态共享困难，props 层层传递\n- 方案：引入 Pinia 管理全局状态 + provide/inject 处理局部共享\n- 效果：代码解耦，维护性提升\n\n**场景 3：内存泄漏**\n\n- 问题：组件卸载后定时器/事件监听未清理\n- 方案：在 `onUnmounted` 中统一清理，封装 `useInterval` 等 hooks\n- 效果：内存占用稳定\n\n**回答技巧**：描述具体场景 → 分析原因 → 解决方案 → 量化效果",
          "hasAnswer": true
        },
        {
          "id": "vue-12",
          "title": "nextTick 的作用和原理？",
          "content": "**作用**：在下次 DOM 更新循环结束之后执行回调，确保操作的是最新 DOM。\n\n**原理**：\n\n1. Vue 的数据变化触发 DOM 更新是**异步批量**的（同一事件循环内的多次修改合并为一次更新）\n2. DOM 更新任务被推入**微任务队列**（优先使用 `Promise.then`，降级用 `MutationObserver`、`setImmediate`、`setTimeout`）\n3. `nextTick(callback)` 将回调推入同一个微任务队列，排在 DOM 更新之后执行\n\n**执行顺序**：数据变化 → Setter → 派发更新 → 收集 Watcher → **微任务队列**（DOM 更新 → nextTick 回调）\n\n**常见使用场景**：\n\n```javascript\nthis.show = true;\nthis.$nextTick(() => {\n  this.$refs.input.focus(); // 确保 DOM 已渲染\n});\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-13",
          "title": "Vue 3 响应式丢失的原因和解决方案？",
          "content": "常发生在解构（Destructuring）**或**展开（Spreading）响应式对象时。\n\n```javascript\nconst state = reactive({\n  count: 0, // 这是一个被 Proxy 追踪的属性\n  name: 'Alice',\n});\n\n// --- ❌ 错误做法：响应式丢失 ---\n// 解构：将 state.count 的原始值赋给了新的局部变量 count。\n// 这两个变量已经没有任何关联。\nconst { count, name } = state;\n```\n\n**解决方案**：\n\n```javascript\n// 方案1：使用 toRefs 保持响应式\nconst { count, name } = toRefs(state); // count.value 是响应式的\n\n// 方案2：直接引用，不解构\nstate.count;\n\n// 方案3：使用 toRef 获取单个属性\nconst count = toRef(state, 'count');\n```\n\n**延伸：ref vs reactive**\n\n- `ref`：用于基本类型，通过 `.value` 访问，解构不丢失响应式\n- `reactive`：用于对象/数组，直接访问属性，解构会丢失响应式\n\n**最佳实践**：统一使用 `ref`，或始终用 `toRefs` 解构 `reactive` 对象。",
          "hasAnswer": true
        },
        {
          "id": "vue-14",
          "title": "ref和reactive有什么区别？为什么这样设计",
          "content": "先给一个**本质层面的结论**：**reactive 是“面向对象的响应式”，ref 是“面向值的响应式”。** 两者解决的是**不同层级的问题**。\n1️. reactive：设计目标是 **让一个对象整体变成响应式**。\n特点很明确：\n- 返回的是 **Proxy**\n- 直接通过 `state.xxx` 访问\n- 适合表示**有结构、有多个字段的状态**\n- 深层属性天然响应式（递归代理）\n为什么 reactive **只能用于对象**？  \n因为 Proxy 的拦截目标必须是 object，没法代理：\n\n2️. ref：设计目标完全不同：  **让「单个值 / 基础类型」也能拥有响应式能力**。\n特点是：\n- 内部用对象包了一层：`{ value: 0 }`\n- 响应式发生在 `.value` 上\n- 可以包裹 **基础类型 / 对象 / 函数**\n也就是说，ref 解决的是一个 reactive 无法解决的问题：**“如何让 number / string / boolean 也参与响应式系统？**\n\n3️. 为什么 Vue 需要同时提供 ref 和 reactive？\n这是一个**设计取舍问题**\n如果只有 reactive：基础类型没法响应式；解构会丢失响应式（核心问题）\n如果只有 ref：对象每一层都要 `.value.xxx`\n\n一句话总结设计动机： **reactive 负责“结构”，ref 负责“原子值”，两者互补而不是替代关系。**",
          "hasAnswer": true
        },
        {
          "id": "vue-15",
          "title": "ref为什么要用.value?为什么模板不需要",
          "content": "1️. 为什么 ref 必须用 `.value`？\n核心原因一句话就够： **JavaScript 没有办法拦截“变量本身”的读写。**\n解决：用一个 `{value: }` 对象来包裹，然后用 Proxy / getter / setter 拦截\n\n2️. 那为什么模板里不用 `.value`？\n这是 Vue3 做的一个**非常重要的 DX（开发体验）优化**，叫：**Ref Unwrapping（自动解包）**\n在模板编译阶段，Vue 会做一件事：`{{ count }}` 编译成 `_count.value`\n设计原因：\n- 如果每个 ref 都写 `.value`，模板可读性会非常差\n- 但在 JS 逻辑里，显式 `.value` 反而更清晰",
          "hasAnswer": true
        },
        {
          "id": "vue-16",
          "title": "React 自定义 Hooks 和 Vue 3 的 composable，本质区别是什么？",
          "content": "React 自定义 Hook 本质上是对官方 Hook 的组合，它依赖 Hooks 在 Fiber 中按调用顺序存储状态，因此必须遵守严格的调用顺序规则。\n\nVue 3 的 composable 则是基于响应式系统的逻辑封装，状态由 ref 或 reactive 对象本身标识，而不是由调用顺序决定，因此机制上更加灵活。\n\n两者在写法上相似，但底层原理不同：React Hook 是“顺序绑定状态”，Vue composable 是“引用绑定状态”。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "browser",
      "name": "浏览器",
      "questions": [
        {
          "id": "browser-1",
          "title": "浏览器点击url发生什么",
          "content": "> 当在浏览器输入 URL 并回车后，整体可以分为 **网络阶段** 和 **渲染阶段** 两大部分。\n\n1. **URL 解析 & DNS 查询**  \n    浏览器解析 URL，判断协议、域名和路径，通过 DNS 将域名解析成 IP\n2. **建立连接**\n    - HTTP：TCP 三次握手\n    - HTTPS：在 TCP 之上增加 TLS 握手，完成证书校验和密钥协商\n3. **发送 HTTP 请求并接收响应**  \n    - 请求HTML文件并解析。\n    - 解析HTML的过程中请求css js及其他资源，过程中css的请求和解析不阻塞构建 DOM 树但会阻塞渲染，js的请求和解析会阻塞 HTML 解析和渲染（使用 defer 可以避免阻塞解析，而 async 则不保证执行时机和顺序，适合独立脚本。）\n4. **浏览器解析与渲染**\n    - HTML → DOM：构建 DOM 树\n    - CSS → CSSOM：解析 CSS 样式，生成 CSSOM (CSS Object Model) 树。\n    - 合成 Render Tree ：将 DOM 树和 CSSOM 树合并，排除不可见的节点\n    - 计算布局并绘制\n5. **JS 文件加载后开始执行**  \n    JS 执行过程中可能修改 DOM/CSS，触发重新渲染。\n\n👉 **优化点**：DNS 缓存、HTTP 缓存、资源并行加载、减少阻塞资源、SSR/SSG。",
          "hasAnswer": true
        },
        {
          "id": "browser-2",
          "title": "浏览器渲染流程",
          "content": "浏览器的渲染流程本质是把 HTML 和 CSS 转换成像素。\n\n核心步骤：\n1. **HTML 解析生成 DOM**\n2. **CSS 解析生成 CSSOM**\n3. **DOM + CSSOM → Render Tree**\n4. **Layout（回流）**：计算元素几何信息\n5. **Paint（重绘）**：绘制样式\n6. **Composite（合成）**：GPU 合成图层\n\n👉 追问：\n- 哪些操作会触发 **回流 / 重绘** \n- 为什么 `transform / opacity` 性能好（只走合成层）\n\t- `transform` 和 `opacity` 不会影响元素的布局和绘制，只会影响**合成阶段**。",
          "hasAnswer": true
        },
        {
          "id": "browser-3",
          "title": "window document",
          "content": "在浏览器环境中，所有全局变量和函数都是 `window` 的属性。它同时是全局作用域的代表。也是**DOM 和 BOM 的入口：** `document` (DOM) 和 `navigator`, `screen` 等 (BOM)。\n\n`document` 对象代表**浏览器窗口中加载的整个 HTML 文档**。是**DOM (Document Object Model) 的入口**。通过它，我们可以操作网页中的所有元素、内容和样式。\n\nDOM ：文档对象模型，提供了与页面内容和结构交互的能力（如查找元素、修改文本）\n\nBOM： 浏览器对象模型，提供了与浏览器窗口和环境交互的能力（如导航、历史记录、计时器），核心对象是window\n\n `window.document === document`\n\n👉 常见追问：\n- 全局变量为什么会挂到 window 上\n\t- 在浏览器环境中，`window` 是全局对象，**非模块环境下**，使用 `var` 或直接声明的全局变量会成为 `window` 的属性。\n\t- 常见风险：全局变量容易造成命名冲突和内存泄漏。\n- document 什么时候可用\n\t- `DOMContentLoaded` 事件表示 **DOM 树已经构建完成**，但不保证图片、样式等资源加载完成。\n\t- `window.load` 事件表示整个页面及其所有资源加载完成，包括：HTML、CSS、JS、**图片、字体、iframe**，注意只等资源下载完成，不等 JS 执行结束",
          "hasAnswer": true
        },
        {
          "id": "browser-4",
          "title": "requestAnimationFrame & 帧机制",
          "content": "**`requestAnimationFrame`** 会在浏览器**下一帧渲染前执行回调**。特点是：\n- 与屏幕刷新率同步（≈16.6ms）\n- 页面不可见时自动暂停\n\n**浏览器帧机制：**\n浏览器通常以约 60FPS 的刷新率进行渲染，也就是每帧大约 16.7ms，但 rAF 并不是固定 60FPS，而是跟随设备的实际刷新率。\n在一帧中，浏览器会先执行 JavaScript，包括 rAF 回调，然后进行样式计算、布局、绘制和合成。由于 rAF 的执行时机在渲染之前，因此非常适合用来更新动画相关的样式。\n\nrAF 优势：\n- 跟随刷新率\n- 页面不可见自动暂停\n- 比 setTimeout 更省电、更流畅\n适合：\n- 频繁更新的动画\n- 与渲染强相关的状态更新\n\n用法：\n`requestAnimationFrame` 接收一个 **回调函数**，该回调会被传入一个 **高精度时间戳参数**。timestamp 是从页面加载开始到当前帧的时间（毫秒），是高精度（浮点数）\n\n示例\n```\nlet last = 0\nfunction animate(timestamp) {\n  const delta = timestamp - last // 获取两次回调的时间差\n  ...\n  requestAnimationFrame(animate)\n}\n\nrequestAnimationFrame(animate)\n```",
          "hasAnswer": true
        },
        {
          "id": "browser-5",
          "title": "重排 (Reflow) 重绘 (Repaint) 合成层",
          "content": "- **重排**：布局变，**代价高**\n\t- 修改 width / height / padding / margin\n\t- 修改 display、position\n\t- 添加 / 删除 DOM 节点\n\t- 获取 layout 信息（offsetTop、getBoundingClientRect）并穿插写操作\n- **重绘**：样式变化，不影响布局，代价相对低\n\t-  修改 color / background / box-shadow\n\t- visibility 变化\n- **合成**：transform/opacity\n\t- 浏览器会把元素提升到**独立合成层**\n\t- 动画只在 GPU 中做矩阵变换或透明度计算\n\t- **跳过 布局计算 和 绘制**\n\n回流一定会引起重绘，但重绘不一定回流。\n\n👉 优化原则：\n- 批量 DOM 操作\n- 读写分离\n- 动画优先用 transform",
          "hasAnswer": true
        },
        {
          "id": "browser-6",
          "title": "IntersectionObserver 作用",
          "content": "`IntersectionObserver` 是一个**异步 API**，用于监听目标元素与一个参照区域（root）之间的**位置关系变化**，**不依赖滚动事件**，性能更好。它关注的是：\n- **是否相交**\n- **相交比例**\n- **相交发生的时机**\n本质是：**“元素是否进入 / 离开某个区域”**\n\n使用场景：\n- 图片懒加载\n- 无限滚动\n- 曝光埋点\n优势：\n- 异步执行\n- 不阻塞主线程\n- 浏览器原生优化\n\n示例\n```\nnew IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.isIntersecting       // 是否相交\n    entry.intersectionRatio   // 相交比例\n    entry.boundingClientRect  // 元素自身位置\n    entry.rootBounds          // root 区域\n    entry.intersectionRect    // 实际相交区域\n  }),\n  {\n\t  root: container,  // 要校验的参照区域\n\t  threshold: 1, // 相交阈值，达到阈值会触发回调函数，也可以是数组\n\t  rootMargin: '200px' //要校验的相交关系\n  }\n)\n```\n\n总结：`IntersectionObserver` 本质是浏览器原生的‘位置关系监听器’，可以基于 root、rootMargin 和 threshold 精确描述元素与容器的相交状态，用来做懒加载、曝光埋点和位置校验，比手写滚动监听更高效。",
          "hasAnswer": true
        },
        {
          "id": "browser-7",
          "title": "JS 执行机制 & 事件循环",
          "content": "浏览器是单线程执行 JS，通过事件循环机制来处理异步任务。\n\n核心机制：\n1. 主线程执行同步代码\n2. 遇到异步任务，交给 Web APIs\n3. 回调按类型进入任务队列：\n    - **微任务**：Promise.then、MutationObserver\n    - **宏任务**：setTimeout、setInterval、I/O\n4. 每轮循环顺序：\n    - 执行一个宏任务\n    - 清空所有微任务\n\n👉 关键点：\n- 微任务会阻塞渲染，如果微任务不断追加（比如递归 Promise），浏览器就**无法进入渲染阶段**，页面会卡住。高频陷阱：大量 Promise.then 会导致页面假死。\n- 微任务优先级高于宏任务",
          "hasAnswer": true
        },
        {
          "id": "browser-8",
          "title": "浏览器缓存机制",
          "content": "浏览器缓存的目标是减少网络请求、提升加载性能。\nHTTP 缓存两类：\n\n 缓存层级：\n- 内存缓存\n\t- - 速度最快\n\t- 生命周期短（页面关闭即失效）\n\t- 常用于当前页面重复请求的资源\n- 磁盘缓存\n\t- 速度慢于内存\n\t- 持久化存储\n\t- 跨页面、跨会话复用\n- HTTP 缓存\n\t1. **强缓存**\n\t    - `Cache-Control`、`Expires`\n\t    - 命中后**不发请求**\n\t2. **协商缓存**\n\t    - `ETag / If-None-Match`\n\t    - `Last-Modified / If-Modified-Since`\n\t    - 返回 304，不传资源\n\n具体使用哪种由浏览器根据资源大小、使用频率自动决定。",
          "hasAnswer": true
        },
        {
          "id": "browser-9",
          "title": "什么是跨域？什么是同源策略？为什么需要跨域？常见解决方案",
          "content": "浏览器的同源策略要求：**协议、域名、端口** 三者一致，否则就是跨域。\n\n为什么有同源策略？\n- 防止恶意网站读取用户隐私数据\n- 属于浏览器的安全机制\n为什么需要跨域？\n- 前后端分离\n- 多服务、多子域部署\n\n跨域解决方案：\n1. **CORS（跨域资源共享）**：服务器设置响应头（如`Access-Control-Allow-Origin`）允许跨域。\n2. **JSONP**：利用`<script>`标签不受同源策略限制，通过回调函数获取数据。\n3. **WebSocket**：不受同源策略限制，可跨域通信。\n4. **postMessage**：iframe允许不同源窗口间通信。l\n5. **nginx反向代理**：配置nginx将请求代理到目标服务器。",
          "hasAnswer": true
        },
        {
          "id": "browser-10",
          "title": "浏览器存储体系",
          "content": "| 类型             | 特点            |\n| -------------- | ------------- |\n| Cookie         | 小、随请求发送、受同源限制 |\n| localStorage   | 持久化、同步 API    |\n| sessionStorage | 会话级           |\n| IndexedDB      | 大、异步、结构化      |\n- 为什么 cookie 不适合存 token\n- 为什么 localStorage 不适合高频读写",
          "hasAnswer": true
        },
        {
          "id": "browser-11",
          "title": "V8垃圾回收",
          "content": "总结 V8 GC 流程\n1. **新生代：** 高频、快速的 **Scavenge 算法**，负责快速清理短期对象。\n2. **老生代：** 低频、复杂的  标记-清除（Mark-Sweep） 和 标记-整理（Mark-Compact）。算法，通过 增量标记 和 并发/并行技术来减少 减少停顿时间。\n\n核心思想：\n- 大多数对象“朝生夕死”\n- 减少全量扫描，提升性能\n\n👉 追问：\n- 为什么闭包容易导致内存问题\n\t- 闭包会让内部变量被外部函数持续引用，导致变量**无法被 GC 回收**。\n\t- 解决思路：使用完后断开引用；避免在闭包中持有不必要的大对象\n- GC 会不会阻塞 JS\n\t- 会阻塞，但 V8 通过增量 GC 降低了阻塞时间。GC 本质要暂停 JS 执行；V8 将一次大 GC 拆成多次小步骤，在 JS 执行间隙逐步完成回收",
          "hasAnswer": true
        },
        {
          "id": "browser-12",
          "title": "内存泄漏",
          "content": "内存泄漏指的是对象不再使用，但仍被引用，无法被 GC 回收。\n\n常见原因：\n1. 意外的全局变量\n2. 未清除的定时器\n3. 未移除的事件监听器\n4. 闭包引用外部大对象\n5. 未清除的DOM 引用\n\n排查：Chrome DevTools 的 **Memory** 面板\n1. 录制堆快照-复现操作-录制快照\n2. 对比分析：重点关注 “Delta”：特别是那些**数量持续增加且没有被回收**的构造函数。找到泄露的对象\n3. 分析原因：**保留树**显示了**为什么这个对象没有被垃圾回收**。它列出了从全局根 (Root) 到该对象的引用链。顺着保留树向上查找，直到找到阻止 GC 回收的**不必要的全局引用、闭包、或 DOM 引用**。\n\n解决思路：\n- 组件卸载时清理副作用和事件监听器\n- 避免不必要的全局引用\n- 节点移除时清理事件监听器\n- 慎用闭包",
          "hasAnswer": true
        },
        {
          "id": "browser-13",
          "title": "浏览器内核",
          "content": "浏览器内核（或称渲染引擎，Rendering Engine）是浏览器的核心组件，主要负责：\n1. **渲染**：解析 HTML/XML/CSS，构建渲染树，并负责页面的布局和绘制。\n2. **脚本执行**：虽然 JavaScript 引擎（如 V8）是独立的部分，但渲染引擎需要协同 JavaScript 引擎。\n\n主流：\nblink: chrome edge \nWebKit: Safari\nGecko: Firefox\nTrident: IE\n\n注：JS 引擎（如 V8）是独立模块，但与渲染引擎紧密配合",
          "hasAnswer": true
        },
        {
          "id": "browser-14",
          "title": "了解哪些浏览器渲染引擎？渲染机制举例",
          "content": "主流浏览器渲染引擎包括 Blink、WebKit、Gecko，整体渲染机制一致，都是 DOM + CSSOM → Render Tree → Layout → Paint → Composite。\n\n举例：\n- Chrome 使用 Blink + V8\n- Safari 使用 WebKit + JavaScriptCore",
          "hasAnswer": true
        },
        {
          "id": "browser-15",
          "title": "V8 引擎优化机制",
          "content": "V8 通过 **JIT 编译 + 隐藏类 + 内联缓存** 提升 JS 执行性能。\n\n关键点：\n- **JIT**：热点代码从解释执行转为机器码\n- **Hidden Class**：对象结构稳定 → 访问更快\n- **Inline Cache**：缓存属性访问路径\n\n👉 开发建议：\n- 保持对象结构稳定\n- 避免频繁增删属性\n- 避免混合类型数组",
          "hasAnswer": true
        },
        {
          "id": "browser-16",
          "title": "JavaScript 执行性能优化",
          "content": "JS 性能优化的核心是减少阻塞主线程。\n\n常见手段：\n- 减少长任务（>50ms）\n- 合理拆分任务（结合setTimeout / requestAnimationFrame）\n- 避免频繁操作 DOM，减少重排 (Reflow) 和重绘 (Repaint)\n- 优化 JavaScript 执行效率：避免全局查找，减少复杂运算，减少作用域链查找\n- 内存管理：避免内存泄漏，及时释放大对象和事件监听器\n- 节流 (Throttle) 和防抖 (Debounce)\n- 使用 Web Workers：对于复杂的、耗时的计算任务（如大量数据处理），将其放在 **Web Worker** 中，避免阻塞主线程，确保 UI 响应流畅。",
          "hasAnswer": true
        },
        {
          "id": "browser-17",
          "title": "navigator.sendBeacon 是什么？怎么用",
          "content": "`navigator.sendBeacon` 是浏览器提供的**专门用于上报少量数据的异步接口**，核心特点是：  \n**在页面卸载（unload / pagehide）阶段也能可靠发送请求，且不阻塞页面跳转。**\n\n它最典型的用途就是：**埋点、日志、性能数据上报**。\n\n传统方案的问题\n- 在 `beforeunload / unload` 阶段：\n    - `fetch` / `XHR` **很容易被浏览器直接中断**\n    - 同步请求会 **阻塞页面关闭（被限制甚至禁止）**\n `sendBeacon` 的设计目标\n- 页面即将关闭 / 跳转\n- **保证“尽最大可能把数据送到服务端”**\n- 不影响用户体验\n\n特点：\n- 返回值是 `boolean`\n    - `true`：浏览器已接管发送任务\n    - `false`：参数非法或发送失败\n- **不返回 Promise**\n- **拿不到响应结果**\n缺点：\n- **只适合小数据量**（通常 < 64KB，浏览器实现不同）\n- 只能用 **POST**\n- 不能自定义 header（如 Authorization）\n- 不能读取响应\n- 不适合业务请求\n\n示例：\n```\nnavigator.sendBeacon('/log', JSON.stringify({\n  event: 'page_leave',\n  time: Date.now()\n}))\n```\n\n追问：对比 fetch keepalive\n`fetch keepalive` 确实能在页面卸载时继续请求，但：\n- 有严格的体积限制\n- 不同浏览器支持不一致\n- 仍然不如 `sendBeacon` 稳定\n所以在**埋点上报**这种场景，优先使用 `sendBeacon`。",
          "hasAnswer": true
        },
        {
          "id": "browser-18",
          "title": "如何判断页面要离开/卸载/隐藏",
          "content": "1. `pagehide`（最推荐，离开/进入 bfcache 都覆盖）\n**用途**：页面即将被卸载，或被放入 **bfcache**（前进后退缓存）时触发。  \n**优点**：比 `unload/beforeunload` 更可靠，移动端也相对稳。\n\n2.  `visibilitychange` + `document.visibilityState === 'hidden'`（隐藏/切后台最通用）\n**用途**：页面从可见变为隐藏（切 Tab、切后台、锁屏、打开系统任务切换）时触发。  \n**优点**：覆盖“隐藏”场景很全面；不一定意味着卸载，但对上报很实用。\n\n3. `beforeunload`（老方案：可拦截离开，但限制多）\n**用途**：尝试在离开页面前做确认提示（比如表单未保存）。  \n**现实**：现代浏览器对自定义文案基本禁用，而且触发时机/条件很多限制。\n\n4. 辅助方案：结合 组件卸载，路由变化等",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "nextjs",
      "name": "Next.js",
      "questions": [
        {
          "id": "nextjs-1",
          "title": "nextjs 是什么？适用场景？",
          "content": "Next.js 本质是一个 React 的全栈框架，它通过内置 SSR、SSG、ISR 和 Server Components，解决了传统 React SPA 在首屏性能、SEO 和工程复杂度上的问题。  \n在新版本中，Next.js 以 App Router 和 RSC 为核心，通过默认服务端渲染和精细化缓存，大幅减少客户端 JS 体积，是目前 React 生态中性能和工程化最成熟的方案之一。\n\n1. **SEO 要求高的网站**：官网、博客、电商等需要搜索引擎收录的场景\n2. **内容型网站**：新闻、文档站点，适合 SSG/ISR 预渲染\n3. **全栈应用**：前后端一体化开发，API Routes 可直接写后端逻辑\n4. **性能敏感场景**：首屏加载要求高，需要 SSR + 流式渲染\n5. **团队协作项目**：约定式路由 + 文件结构清晰，降低沟通成本",
          "hasAnswer": true
        },
        {
          "id": "nextjs-2",
          "title": "Next.js 解决了 React 的哪些核心问题",
          "content": "1. **SEO 问题**：React默认CSR，首屏 JS 大、白屏时间长、SEO 差，Next.js 提供 **SSR / RSC** \n2. **服务端能力**：React 只负责 UI，Next.js = **前端 + BFF + API 层**，服务端组件 / Server Actions / Middleware\n3. **工程复杂度**：SSR开箱即用，Next.js 提供文件系统路由，自动按页面代码分割，零配置起步，约定大于配置\n4. **开发体验**：Fast Refresh、内置 TypeScript 支持、API Routes 等",
          "hasAnswer": true
        },
        {
          "id": "nextjs-3",
          "title": "Next.js 和 React 的区别？",
          "content": "| 维度   | React            | Next.js                     |\n| ---- | ---------------- | --------------------------- |\n| 定位   |                  | 全栈框架                        |\n| 路由   | 需要 react-router  | 内置文件系统路由                    |\n| 渲染   | 默认仅 CSR          | RSC/SSR/SSG/ISR/CSR 都支持     |\n| 后端能力 | 19 开始官方支持 RSC 协议 | API Routes + Server Actions |\n| 构建工具 | 需自行配置            | 内置 Turbopack/Webpack        |\n| SEO  | 需额外处理            | 原生支持                        |\n\n**一句话**：React 是造轮子的原料，Next.js 是装好轮子的车。\n\n追问：\nNext.js 的 RSC 和 React 19 是不是“一样”？\nReact 的**RSC 是“框架能力”，不是库能力。** React 19 开始正式支持 RSC 的协议和运行时，但它并不提供完整的服务端渲染和构建体系。RSC 在 React 中更多是作为一种规范存在，主要是给 **框架作者** 用的，不是给普通业务开发者直接用的。而 Next.js 在 App Router 中实现了完整的 RSC 工程化方案，包括 bundle 拆分、缓存、Streaming 和 Server Actions，因此两者在能力完整度上差异很大。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-4",
          "title": "Next.js 支持哪些渲染模式？",
          "content": "1. **CSR（Client-Side Rendering）**：纯客户端渲染，用 `use client` 组件实现\n2. **RSC（React Server Components）**：默认在服务端执行，不进入 JS bundle，减少客户端 JS 体积\n3. **SSR（Server-Side Rendering）**：每次请求时服务端渲染，首屏渲染快，SEO更优秀，页面实时性高，适合动态数据，但成本高\n4. **SSG（Static Site Generation）**：构建时生成 HTML，适合静态内容，不适合频繁变化内容\n5. **ISR（Incremental Static Regeneration）**：SSG + 定时重新生成，兼顾性能和数据新鲜度\n\n**一句话总结**：  \nCSR 是兜底，SSR 是实时，SSG 是极致性能，ISR 是折中方案，RSC 是未来方向",
          "hasAnswer": true
        },
        {
          "id": "nextjs-5",
          "title": "Next.js 的 SSR",
          "content": "在传统的 SSR 架构（如早期的 React SSR）中，您确实需要维护两套入口（client-entry.js 和 server-entry.js），配置两套 Webpack，处理注水 (Hydration) 的各种样板代码。\nNext.js 把这一切都封装了。您只需要写一个 page.tsx，Next.js 会自动在服务器上把它渲染成 HTML，然后在客户端把它\"激活\"。对于开发者来说，只有一套代码，一套逻辑\nNext.js 的伟大之处在于，它让您在同一个项目、同一个文件结构、同一种语言中，流畅地穿梭于\"服务端\"和\"客户端\"之间。您不需要配置复杂的环境，但您需要清晰地知道\"我现在是在服务器上（获取数据）\"还是\"我现在是在浏览器里（处理交互）\"。这种无缝融合，正是它作为全栈框架的体验确实是目前业界领先于业界的关键。\n\n客户端组件在服务端执行时，只会生成静态 HTML。它的 useEffect、onClick 等逻辑不会运行。这些逻辑只有代码被下载到浏览器并\"注水 (Hydrate)\"后，才会真正在客户端执行。\n服务端组件 (RSC) 的代码，只在服务器上运行。零 JS 发送：这些组件的 JavaScript 代码永远不会被打包发送给浏览器。浏览器收到了什么？：浏览器接收到的是 RSC 执行后的结果（一种特殊的 JSON 数据格式，描述了 UI 的结构）。![](/Users/wzz/Library/Application%20Support/marktext/images/2025-12-01-00-06-38-image.png)\n\n服务端内容变成了纯数据：`<h1>Hello Server</h1>`没有变成 HTML 标签，而是变成了一个描述：\"这有一个 h1，内容是 Hello Server\"。\n客户端组件变成了\"占位符\"：注意那个 \"$L2\"。它告诉浏览器：\"这里应该放一个 ClientButton 组件。它的代码在 ClientButton.js 里，请去下载它，并把 initialCount: 10 传给它。\"\n浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n在首次加载页面时，RSC Payload 是内嵌在 HTML 源码中的。浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n服务端组件只在服务端执行，所以不能调客户端的方法包括 window 等（Node.js 里根本就没有浏览器窗口的概念），也不能 useeffect usestate，这些 Hooks 的作用是\"在浏览器里管理状态和副作用\"。既然 RSC 的代码都不发送给浏览器，这些 Hooks 自然也就毫无用武之地。\n\n客户端组件则是提前再服务端执行得到初始样式和 HTML，浏览器加载完 HTML 后再下载并执行 js 文件进行水合（React 在浏览器里再次运行这个组件，这次它会执行 useEffect，并且把 onClick 事件监听器挂载到那个已经存在的按钮上。）\n\n当 Next.js 在服务器（Node.js）上渲染一个客户端组件时，它其实是在执行一个\"阉割版\"的 React 渲染流程：\n执行组件函数：Node.js 会像浏览器一样，去调用组件函数\n处理 Hooks (有特殊规则)：useState 只取初始值；useEffect / useLayoutEffect: 直接跳过；useContext: 正常执行读取组件树上层的 Provider 里的值；\n生成 Virtual DOM：函数执行完，React 得到了一棵组件树。\n序列化为 HTML：React 的服务端渲染器 (ReactDOMServer) 遍历这棵树，把它转换成纯文本的 HTML 字符串（例如. \\<div>\\<button>Click</button></div> ）。\n\nApp Router 是 Next.js 13.4 之后推出的全新路由和渲染架构\n基于 app/ 目录：以前的页面写在 pages/ 里，现在的页面写在 app/ 里。\n默认 RSC：这是最大的区别。在 app/ 里写的组件，默认全是服务端组件。这彻底改变了开发模式。\n嵌套布局 (Nested Layouts)：支持 layout.tsx 嵌套，这是 Pages Router 做不到的。\n流式传输 (Streaming)：利用 React Suspense，可以把页面拆成碎片，一部分一部分地发给浏览器（比如先发个 loading 骨架屏，再发数据），极大地优化了 TTFB。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-6",
          "title": "什么是 React Server Components？",
          "content": "**核心概念**：只在服务端执行的 React 组件，JS 代码不会发送到客户端。\n\n**特点**：\n1. **零客户端 JS**：组件代码不打包到 bundle，减小体积\n2. **直接访问后端资源**：可以直接读数据库、文件系统、调用内部 API\n3. **输出是 RSC Payload**：一种特殊 JSON 格式，描述 UI 结构\n\n**限制**：\n- 不能用 useState、useEffect 等 Hooks\n- 不能绑定事件（onClick 等）\n- 不能访问浏览器 API（window、document）\n\n**使用场景**：数据获取、静态展示、包裹客户端组件\n\n总结：React Server Components 是一种服务器执行的组件模式，本质是**把 React 的一部分计算前移到服务端**，它让 UI 的渲染和数据获取在服务端完成，只把 UI 结构通过序列化协议发送给客户端，从而减少 JS bundle、提高性能并简化数据获取，同时和交互组件协同工作，适配复杂应用。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-7",
          "title": "Next.js RSC 漏洞",
          "content": "这个漏洞（2024–2025 问题）本质是 **反序列化不可信数据 → 服务端执行恶意构造的代码（RCE）**\n\n漏洞点：服务端反序列化 RSC payload 时，默认信任客户端的数据，服务端代码，没有校验 actionId 和 payload 结构是否可信，而是直接可以执行\n\n导致只要攻击者伪造结构正确的 payload，就能执行任意的 Server Action 函数\n\n正确的校验应该：\n\n**校验 1：payload 引用的 actionId 必须属于当前构建生成的 action map**\n\n**校验 2：反序列化过程中禁止还原任意类型对象，只允许白名单类型**",
          "hasAnswer": true
        },
        {
          "id": "nextjs-8",
          "title": "use client 是做什么的？",
          "content": "**作用**：声明一个组件为客户端组件，标记「服务端 → 客户端」的边界。\n\n**使用时机**：\n1. 需要用 useState、useEffect 等 Hooks\n2. 需要绑定事件（onClick、onChange）\n3. 需要访问浏览器 API（window、localStorage）\n4. 使用仅客户端的第三方库\n\n**注意事项**：\n- 放在文件顶部第一行\n- 该文件及其导入的所有模块都会打包到客户端\n- 客户端组件可以渲染服务端组件（通过 children）",
          "hasAnswer": true
        },
        {
          "id": "nextjs-9",
          "title": "Next.js 如何做 SEO？",
          "content": "1. **渲染策略**\n\t- 需要 SEO 的页面用 **SSG/ISR/SSR** 输出完整 HTML。\n\t- 内容稳定：SSG / ISR；强实时：SSR。\n\t- App Router 里默认 Server Component，本身就更利于首屏和可索引内容。\n2. **Meta / OpenGraph / 结构化数据**\n\t- **App Router 用 `generateMetadata()` 或 `metadata` 导出（更结构化）。\n\t- Pages Router 用 `next/head` 写 title、description、canonical、OG、twitter card。\n\t- App Router 用 `generateMetadata()` 或 `metadata` 导出（更结构化）。\n\t- 对文章页加 JSON-LD（结构化数据），提高 rich result 概率。\n3. **站点工程化**\n\t- `sitemap.xml`、`robots.txt`、规范化 URL（canonical）、国际化 hreflang（如果有）。\n\t- 避免重复内容，控制分页/筛选页索引策略。\n\t- \n**加分点：**\n- SEO 不只看“能不能爬”，还看 **Core Web Vitals（LCP/INP/CLS）**，Next.js 通过图片优化、代码分割、RSC 降 JS 等改善性能指标。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-10",
          "title": "Pages Router vs App Router 有什么区别？",
          "content": "两者的本质差异在于：**App Router 是围绕 RSC（Server Components）重新设计的路由与渲染体系**，而 Pages Router 是传统的 SSR/SSG 模型。\n\n| 维度   | Pages Router                         | App Router                         |\n| ---- | ------------------------------------ | ---------------------------------- |\n| 目录   | `pages/`                             | `app/`                             |\n| 组件模型 | 默认客户端组件                              | 服务端组件，标 `use client` 才会进客户端 bundle |\n| 布局   | `_app.tsx` 全局                        | `layout.tsx` 嵌套                    |\n| 数据获取 | getServerSideProps /getStaticProps 等 | 直接 async/await                     |\n| 流式渲染 | 不支持                                  | 支持 Suspense                        |\n| 错误处理 | `_error.tsx`                         | `error.tsx` 嵌套                     |\n\n**迁移建议**：新项目直接用 App Router，老项目可渐进式迁移。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-11",
          "title": "layout.tsx 和 page.tsx 的区别？",
          "content": "**layout.tsx**：定义该路由段及其所有子路由共享的布局（导航栏、侧边栏等）\n- **路由切换时保持状态**不会重新渲染\n- 可以嵌套，子路由继承父布局\n- 必须接收 `children` 并渲染\n- 在 App Router 下 layout 默认是 Server Component（除非 `use client`）\n**page.tsx**：\n- 定义路由的实际内容，对应一个 URL 的最终页面\n- 每次访问都会重新渲染\n- 是路由可访问的必要条件\n- 接收 `params` 和 `searchParams`\n\n**执行顺序**：layout 包裹 page，从外到内渲染。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-12",
          "title": "图片优化 Image 组件的原理？",
          "content": "Next.js 的 `next/image` 做的是“**端到端的图片性能优化**”，核心目标是降低 LCP、节省带宽。\n1. **按需生成与压缩**：Image 不是简单 `<img>`，它会请求 Next 的图片优化服务（loader），在服务端做 resize 压缩 格式转换（优先 WebP/AVIF）\n2. **响应式尺寸**：根据 `sizes` 属性生成多尺寸 srcset，让浏览器按 DPR 与视口选择合适的资源\n3. **懒加载**：默认 `loading=\"lazy\"`，进入视口才加载；首屏关键图用 `priority` 提升加载优先级\n4. **占位符**：`placeholder=\"blur\"` 显示模糊预览图（**必须**有 `blurDataURL` 才生效）\n5. **防止布局偏移**：通过 width/height 或 fill + container 约束，提前占位，减少布局抖动\n\n**核心**：不是构建时处理，而是请求时按需优化 + 缓存。\n\n**常见坑：**\n- 外链域名没配 `images.domains/remotePatterns` 会失败。\n- `fill` 必须给父容器明确尺寸/position，否则布局异常。\n- 首屏大图不加 `priority` 容易拉高 LCP。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-13",
          "title": "loading.tsx 的渲染时机？",
          "content": "**原理**：Next.js 自动将 loading.tsx 包装成 Suspense 的 fallback。\n\n**触发时机**：页面首次加载时/路由切换时，Server Components 在等待数据或组件异步加载导致挂起，Next 会先返回并显示该段的 `loading.tsx`，等数据 ready 后再把真实内容“流式替换”进来。\n\n**特点**：\n- 每个路由段可以有自己的 loading.tsx\n- 支持流式传输，先返回 loading 状态\n- 布局（layout.tsx）不会触发 loading",
          "hasAnswer": true
        },
        {
          "id": "nextjs-14",
          "title": "路由跳转是如何避免整页刷新的？",
          "content": "Next.js 的客户端路由（`next/link` / `router.push`）本质是 **SPA 导航**：\n1. **拦截点击事件**：`<Link>` 阻止浏览器默认跳转（不触发整页 reload）。\n2. **History API**：使用 `pushState/replaceState` 改 URL，不刷新页面。\n3. **预取与增量请求**：Next 会预取目标路由所需的 JS chunk / 数据（空闲时或可见时），导航时只做最小增量加载。\n4. **差异化更新**：只重新渲染变化的路由段，保留共享布局状态\n5. **按需 hydration**：只对需要交互的 Client Components 做 hydration（RSC 场景下客户端 JS 更少）。\n\n**补一句加分：**  \n如果你用 `<a href>` 且没用 Link，或跳到外域，就会整页刷新，这是预期行为。`",
          "hasAnswer": true
        },
        {
          "id": "nextjs-15",
          "title": "Next.js 中如何做代码分割？",
          "content": "Next.js 默认就做了非常多代码分割，核心是 **按路由、按组件、按依赖** 三层：\n\n1. **路由级分割（自动）**：每个页面/路由会生成独立 chunk，只有访问该路由才加载对应 JS。\n2. **动态导入（手动控制）**\n\t- 用 `next/dynamic` 对重组件（富文本、图表、地图）做按需加载：\n\t    - 只在需要时加载\n\t    - 可以 SSR: false（例如只在浏览器可用的库）\n\t\n3. **组件边界与 RSC**\n\t- App Router 默认 Server Components 不进客户端 bundle，本质上把很多 UI 逻辑“分割”到服务端，减少客户端 JS。\n\t- `use client` 会把该组件及其依赖打进客户端 chunk，所以要控制 client 边界尽量小。\n\n4. **第三方依赖优化**\n\t- 把大依赖放到动态 import 或只在 Server Component 使用，避免进主包。\n\n**常见坑：**\n- 一个顶层组件加了 `use client`，会把它依赖的很多东西都拖进客户端包（client 边界扩散）。\n- 动态 import 过多会产生大量小 chunk，可能增加请求开销，需要平衡。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-16",
          "title": "Next.js 中如何做鉴权？",
          "content": "**正确的 Next.js 鉴权思路是“分层”**：登录（Authentication）+ 会话（Session）+ 授权（Authorization）。官方指南就是这么拆的。\n常见落地方案（面试说这套就稳）\n1. **登录/注册**： 用 **Server Actions** 接表单，执行在服务端，适合放敏感逻辑。\n2. **会话管理**：Session 放 **HTTP-only Cookie**（或配合 session store / JWT）\n3. 授权：不能只在 middleware 做粗过滤，真正的数据读取处也要校验\n\n**常用对比**：\n1. **Middleware**：\n   - 在请求到达页面前拦截\n   - 适合路由级别的权限控制\n2. **Server Component**：\n   - 直接读取 cookies/headers 验证\n   - 适合页面级数据权限\n3. **Server Actions**：\n   - 每个 action 内部校验用户身份\n   - 适合操作级别的权限\n4. **第三方库**：NextAuth.js / Clerk / Auth0\n\n**最佳实践**：\n用 middleware 做快速跳转和粗过滤，但真正的数据读取必须在 Server Components / Route Handlers / Server Actions 的数据访问层再做一次授权校验。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-17",
          "title": "middleware 能做什么？不能做什么？",
          "content": "**能做**：核心就是“改请求/改响应/改去向”\n1. 重定向 / 重写 URL\n2. 设置/读取 cookies 和 headers\n3. 直接返回一个响应，比如鉴权拦截\n4. 请求日志\n\n**不能做**：\n1. 访问 Node.js API（fs、path 等）—— 运行在 Edge Runtime\n2. 直接连接数据库（需通过 API 调用）\n3. 执行耗时操作（会把每次请求的“最前置链路”拖慢）\n4. 使用大型 npm 包（bundle 大小限制）\n\n**执行时机**：在缓存之前、路由匹配之后。\n实战建议：middleware/proxy 只做**快速、轻量、可失败**的事：重定向、locale、A/B、粗鉴权、灰度、加 header",
          "hasAnswer": true
        },
        {
          "id": "nextjs-18",
          "title": "Next.js 的数据请求是怎么缓存的？",
          "content": "**四层缓存机制**：\n\n1. **Request Memoization**：同一渲染过程中，相同请求自动去重\n2. **Data Cache**：fetch 结果持久化缓存（跨请求/部署）\n3. **Full Route Cache**：SSG 页面的 HTML + RSC Payload 缓存\n4. **Router Cache**：客户端缓存已访问的路由段（30s/5min）\n\n并且（重要）：Next 默认倾向于“**尽可能缓存**”，除非你显式 opt-out 或触发动态渲染条件。\n\n**控制缓存**示例：\n```tsx\nfetch(url, { cache: 'no-store' }); // 不缓存\nfetch(url, { next: { revalidate: 60 } }); // 60秒后重新验证\n```",
          "hasAnswer": true
        },
        {
          "id": "nextjs-19",
          "title": "fetch 在 Server Component 中和浏览器 fetch 有什么不同？",
          "content": "**相同点：**API 形状一样，都是 Web fetch。  \n**不同点（关键）：`cache` 的含义完全不同**：\n- 在**浏览器**：`cache` 表示怎么和浏览器 HTTP cache 交互。\n- 在 **Next 服务端**：`cache` 表示怎么和 Next 的 **Data Cache** 交互；并且 Next 给 fetch 增加了 `next.revalidate`、`next.tags` 等语义来做持久缓存与失效。\n- 默认是 auto：能静态 → 静态（等价于 force-cache）；发现动态 API → 退化成 no-store\n- Server Component 的 fetch：是 **服务端到服务端请求**，不受浏览器 CORS 限制\n- cookie 不是“隐式自动注入到所有 fetch”，而是由开发者显式控制。\n\n| 维度      | Server Component，注意执行在服务端       | 浏览器                |\n| ------- | ------------------------------- | ------------------ |\n| 执行环境    | Node.js / Edge                  | 浏览器                |\n| 默认缓存    | 默认是 auto，`cache: 'force-cache'` | `cache: 'default'` |\n| 请求去重    | 自动 memoization                  | 无                  |\n| 跨域限制    | 无 CORS 限制                       | 受 CORS 约束          |\n| Cookies | 需手动加参数控制                        | 自动携带               |\n| 扩展选项    | `next: { revalidate, tags }`    | 无                  |\n\n**注意**：Server Component 中的 fetch 运行在真正的服务端环境中，被 Next.js 增强过，不是原生 fetch。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-20",
          "title": "Fast Refresh 是什么？",
          "content": "**Fast Refresh 是 Next.js 的开发态热更新机制**。\n**Fast Refresh 是在不丢失组件 state 的前提下，实时刷新修改过的模块，用来提升开发体验。**\n\n它解决什么问题？\n- 普通 HMR：一改代码 → 整页刷新 → state 全丢\n- Fast Refresh：\n    - 只刷新受影响组件\n    - **尽量保留 React state**\n    - 错误修复后自动恢复页面\n\n面试官想听到的关键词\n- 开发态（development only）\n- 基于 React Refresh\n- 保留 state（如果是函数组件 & hooks 结构没破坏）\n- 修改 hooks 顺序 / export 结构会触发 full reload",
          "hasAnswer": true
        },
        {
          "id": "nextjs-21",
          "title": "API Routes 是什么？",
          "content": "**API Routes 是 Next.js 内置的后端接口能力（BFF）**\n**API Routes 允许在 Next.js 项目中直接编写服务端接口，用来承接前端请求或作为 BFF 层。**\n\n本质是什么？\n- 运行在 **Node.js / Edge Runtime**\n- 不进浏览器 bundle\n- 本质是一个 HTTP handler\n\n面试官想听的点\n- BFF（Backend For Frontend）\n- 鉴权、聚合接口、隐藏后端结构\n- 不适合复杂业务（不是完整后端）",
          "hasAnswer": true
        },
        {
          "id": "nextjs-22",
          "title": "Edge Runtime",
          "content": "Edge Runtime 本质是一个运行在 CDN 边缘的“请求拦截与改写层”，不是完整服务器，也不是浏览器。\n本质\n- 运行在 **CDN 边缘节点**\n- 执行的是 **Web 标准 API**\n- **不是 Node.js**\n- **比浏览器多权限，比 Node.js 少能力**\n\n可以把它理解成： **一个“增强版 Service Worker + 网络代理层”**",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "engineering",
      "name": "工程化",
      "questions": [
        {
          "id": "engineering-1",
          "title": "Webpack 构建流程和原理",
          "content": "阶段一：初始化 (Initialization)：Webpack 从启动到开始处理文件前的准备阶段。\n\n1. **参数合并:** 读取并合并 `webpack.config.js` 中的配置参数、Shell 命令行参数以及默认配置。\n\n2. **创建 Compiler:** 创建一个 `Compiler` 实例。`Compiler` 是 Webpack 的核心对象，它贯穿整个生命周期，负责协调整个构建流程。\n\n3. **加载插件:** 遍历配置中的 `plugins` 数组，依次执行插件的 `apply` 方法，注册各种 Hook（钩子）函数，监听 Compiler 或 Compilation 的事件。\n\n阶段二：构建模块 (Building Modules)：此阶段的核心是根据入口文件递归地构建**模块依赖图 (Module Dependency Graph)**。\n\n1. **确定入口:** 从配置中定义的 `entry` 入口文件开始。\n\n2. **创建 Compilation:** 创建一个 `Compilation` 实例。`Compilation` 对象负责本次构建过程的资源管理，包括模块、依赖图、Chunk、生成的资源文件等信息。\n\n3. **Module 构建循环:** Webpack 进入模块处理的循环：\n   \n   - **加载 (Loading):** 根据模块路径读取文件内容。\n   \n   - **解析 (Resolving):** 使用配置好的 `resolve` 规则，确定模块的绝对路径。\n   \n   - **处理 (Processing):**\n     \n     - 将文件内容传递给匹配的 **`Loader`**。Loader 负责将非 JS 类型的资源（如 TS, Sass, Vue 文件）转换为有效的 JavaScript 模块内容，或进行转换（如 Babel 转译）。\n     \n     - Loader 链式执行，前一个 Loader 的输出是后一个 Loader 的输入。\n   \n   - **依赖分析:** 使用 **`Parser`** (解析器) 遍历经过 Loader 处理后的代码内容。解析器会识别出代码中的 `import`、`require()`、`import()` 等模块导入语句。\n   \n   - **递归:** 每识别到一个依赖，就将其加入到依赖图，并对该依赖文件重复整个构建循环，直到所有依赖都被处理。\n\n阶段三：生成资源 (Sealing & Emitting)\n\n在依赖图构建完成后，Webpack 开始将模块组合成可部署的资源文件。\n\n1. **Chunk 分组:** 将构建好的模块根据它们的关系进行分组，形成 **Chunks** (代码块)。\n   - **Entry Chunk:** 对应入口文件及其同步依赖。\n   - **Lazy Chunk:** 对应通过 `import()` 动态导入形成的异步加载模块。\n   - **Vendor/Common Chunk:** 对应通过 `SplitChunksPlugin` 提取的公共/第三方模块。\n\n2. **Chunk 优化 (Tree Shaking/Code Splitting):** 运行优化步骤，如 Tree Shaking 移除未使用的代码，以及 `splitChunks` 配置提取公共代码。\n\n3. **生成 Bundle:** 将 Chunk 映射到最终的输出文件（Bundle）。Webpack 为每个 Chunk 添加 runtime 代码（用于加载和执行模块）和模块包装器。\n\n4. **写入文件:** 最终，执行 `emitAssets` 钩子，将内存中生成的 Bundle 文件内容写入到输出目录（`output` 配置）。",
          "hasAnswer": true
        },
        {
          "id": "engineering-2",
          "title": "webpack优化代码分割产物加载速度的机制",
          "content": "- **实现方式：** 使用 Webpack 内联注释（Magic Comments）或 HTML 标签。\n  \n  - **`/* webpackPreload: true */`**\n  \n  - **`/* webpackPrefetch: true */`**\n\n- **适用场景：**\n  \n  - **`Preload` (预加载)：** 用于当前页面**很快就会需要**的资源（如当前路由的字体、关键图片或首个动态加载的 Chunk）。它会和父 Chunk 并行加载，优先级较高。\n  \n  - **`Prefetch` (预取)：** 用于用户**未来可能会需要**的资源（如用户可能会跳转到的下一个路由页面）。它会在浏览器空闲时加载，优先级较低。",
          "hasAnswer": true
        },
        {
          "id": "engineering-3",
          "title": "loader plugin区别",
          "content": "这两者是 Webpack 的核心支柱，但作用维度完全不同：\n\n- **Loader (转化器)：** 它是文件级的转换。Webpack 只能理解 JS 和 JSON，Loader 的作用是让 Webpack 具备处理 **非 JS 文件** 的能力（如 `css-loader` 处理 CSS，`babel-loader` 转化 ES6）。它运行在打包之前，遵循‘从右往左’的链式调用。\n- **Plugin (插件)：** 它是系统级的扩展。基于 Webpack 的**事件流（Tapable）**机制。Plugin 会挂载在 Webpack 构建生命周期的各个钩子上，在整个构建流程中执行更复杂的任务。\n- **一句话总结：** Loader 是干活的工人（处理文件），Plugin 是监工（控制构建流程，如压缩代码、清空目录、生成 HTML）。”",
          "hasAnswer": true
        },
        {
          "id": "engineering-4",
          "title": "webpack常用配置项",
          "content": "首先是入口和输出配置，比如 `entry` 和 `output`，用于定义构建的入口文件以及最终打包产物的输出路径和文件名。\n其次是模块解析和处理相关的配置，包括 `resolve`，用于配置文件后缀名解析和路径别名，以及 `module.rules` 中的 loader，用来处理不同类型的资源文件。\n然后是插件相关配置，通过 `plugins` 在 webpack 构建的各个生命周期阶段执行特定逻辑。\n另外还有一些环境和开发相关的配置，比如 `mode` 区分开发和生产环境，`devServer` 用于本地开发配置，`devtool` 用于 source map 设置。\n最后是 `optimization`，用于构建优化，比如代码压缩、`splitChunks` 做代码分包，以及 `runtimeChunk` 抽离运行时代码以支持长期缓存。",
          "hasAnswer": true
        },
        {
          "id": "engineering-5",
          "title": "什么是webpack运行时",
          "content": "1. 什么是 Runtime？\n\nWebpack 运行时是**一段微型的代码块，负责在浏览器运行期间连接模块、加载模块、解析依赖。**\n\n没有它，浏览器根本不认识 `require()`、`import` 或 `module.exports`。\n\n2. Runtime 的核心功能\n\n- **模块映射表 (Module Manifest)**：里面记录了所有模块的 ID 和它们在打包后的文件位置。\n- **模块加载机制**：\n    - 实现同步加载：`__webpack_require__(moduleId)`。\n    - 实现异步加载（动态 import）：通过动态创建 `<script>` 标签并注入 JSONP 回调。\n- **缓存管理**：确保同一个模块在多次引用时只执行一次，后续直接从内存缓存中读取。\n\n实际工程中：我们通常会将它提取为独立的 `runtimeChunk`，防止业务代码变动导致映射表更新，从而破坏第三方库的长期缓存。",
          "hasAnswer": true
        },
        {
          "id": "engineering-6",
          "title": "webpack 如何处理require？",
          "content": "在 Webpack 的世界里，不论你在源码里写的是 `const a = require('./a')` 还是 `import a from './a'`，打包后它们的效果确实是**一样**的。\n\n- **编译阶段**：Webpack 会扫描所有的静态依赖，把它们全部塞进同一个（或指定的几个）Bundle 块中。\n    \n- **运行阶段**：Webpack 会在 Bundle 内部维护一个 `modules` 对象（即**模块定义映射表**）。\n    \n- **执行逻辑**：当你调用 Webpack 模拟的 `__webpack_require__` 时，它会去映射表里找。如果模块已经执行过，直接从缓存拿 `exports`；如果没有，就执行模块代码并存入缓存。\n    \n\n**结论：** 静态 `import` 和 `require` 都会被视为**同步依赖**。它们会被打包在一起，在页面启动时就全部加载完成，不会产生额外的网络请求",
          "hasAnswer": true
        },
        {
          "id": "engineering-7",
          "title": "Webpack 异步加载的底层原理（JSONP）",
          "content": "当你在代码里写下 `import('./A')`，Webpack 在运行时其实做了以下几件事：\n\n1. **发起请求**：通过 `document.createElement('script')` 动态创建一个标签，指向子包的 URL。\n2. **JSONP 回调**：子包的文件内容通常包裹在一个函数里，例如 `self[\"webpackChunk\"].push([[chunkId], { modules... }])`。\n3. **合并模块**：当脚本加载成功，这个全局回调被触发。Webpack 的 Runtime 接收到新模块，把它们合并到主 Bundle 的模块映射表中。\n4. **Resolve Promise**：原来 `import()` 返回的那个 Promise 被标记为成功，你就可以在 `.then()` 或 `await` 之后拿到模块内容了。",
          "hasAnswer": true
        },
        {
          "id": "engineering-8",
          "title": "webpack 如何拆分 Chunk 动态加载？",
          "content": "动态 `import()` 是触发“代码分割（Code Splitting）”的最主要开关\n- **静态加载**：`import A from './A'` $\\rightarrow$ A 模块被打包进 Main Bundle $\\rightarrow$ **网络一次性下载**。\n    \n- **动态加载**：`import('./A')` $\\rightarrow$ Webpack 自动将 A 模块及其依赖单独切出来，生成一个 `src_A_js.bundle.js` $\\rightarrow$ **运行到这一行时才发请求下载**。\n\n除了动态import ，还提供了**配置驱动**的拆分方案：\n\n- **`optimization.splitChunks` (抽离公共库)**： 这是最常用的。你可以配置“如果某个模块（如 `lodash` 或 `react`）被引用了超过 2 次，或者来自 `node_modules`，就把它单独拆成一个 `vendors.js`”。这样即使你没写动态 `import`，它也会被拆出来。\n    \n- **多入口配置 (`entry`)**： 如果你配置了多个入口（比如 `index.js` 和 `admin.js`），Webpack 会自动为每个入口生成独立的 Bundle。",
          "hasAnswer": true
        },
        {
          "id": "engineering-9",
          "title": "Webpack 的持久化缓存，如何判断文件是否需要重新编译",
          "content": "将上一次构建的结果（包括解析的模块、生成的 AST、转译后的代码等）存储到磁盘上，这样在后续构建中，如果文件或其依赖没有变化，就可以**跳过整个 Loader 链和模块构建过程**，直接复用缓存结果。这使得二次构建（特别是使用 HMR 时的开发构建）的速度大大加快。\n\n持久化缓存通过在 `webpack.config.js` 中设置 `cache` 属性来启用：\n\n```js\nmodule.exports = {\n  // ... 其他配置\n  cache: {\n    type: 'filesystem', // 启用基于文件系统的持久化缓存\n    buildDependencies: {\n      // 告诉 Webpack 哪些文件变动会导致缓存失效\n      config: [__filename], \n    },\n    // 默认缓存目录是 node_modules/.cache/webpack\n    // name: 'my-app-cache', // 可自定义缓存名称\n  },\n  // ...\n};\n```\n\n如何判断和检查是否可以用缓存：\n\n- **检查全局配置：** Webpack 检查自身的版本、Node.js 版本以及配置文件的哈希是否匹配。如果不匹配，清空所有缓存。\n\n- **检查模块哈希：** Webpack 检查当前文件的内容哈希。如果不匹配，缓存失效。\n\n- **检查 Loader/Plugin 配置：** Webpack 检查作用于该文件的 Loader 链和 Plugin 选项是否与缓存中记录的一致。如果不一致，缓存失效。\n\n- **检查依赖哈希：** Webpack 检查该模块所依赖的其他模块的哈希是否匹配。只要一个依赖项发生变化，当前模块的缓存就失效。",
          "hasAnswer": true
        },
        {
          "id": "engineering-10",
          "title": "说说webpack 联邦模块",
          "content": "它允许**多个独立的 Webpack 构建应用**在运行时共享代码和依赖，给**前端微服务架构**提供基础。\n\n它让一个应用（Host）可以在运行时动态加载另一个独立应用（Remote）的代码模块，就像加载本地模块一样。\n\nRemote (远程方)：独立打包的应用。暴露 (Expose) 自己的部分代码模块供其他应用使用。Host (主机方)：独立打包的应用。消费 (Consume) 远程应用暴露出的模块。\n\n两个应用都需要的公共依赖，如 React、Vue。确保所有应用共享同一份依赖实例，避免重复加载和版本冲突\n\nModule Federation 通过在 Webpack 构建输出中添加特殊的 **“容器 (Container)”** 机制来实现：",
          "hasAnswer": true
        },
        {
          "id": "engineering-11",
          "title": "Code Splitting 的多种方案",
          "content": "1.入口点分割 (Entry Points)\n\n这是最基础的分割方式。开发者手动在配置文件中定义多个入口文件，Webpack 会为每一个入口点生成一个独立的 Bundle。\n\n- **实现方式：** 在 `webpack.config.js` 的 `entry` 配置中定义多个键值对。\n\n- **适用场景：** 传统多页应用 (MPA)，每个页面对应一个入口；或者当你有两个完全独立的 SPA，想用一个 Webpack 配置打包时。\n\n- 示例 entry: {\n   pageA: './src/page-a.js',\n   pageB: './src/page-b.js',\n   },\n\n- **缺点：** 无法动态加载，且公共依赖代码（如 React 库）会被重复打包到每个入口的 Bundle 中\n\n当构建工具遇到 `import('./moduleA')` 时，它会将 `moduleA` 及其所有依赖单独打包成一个或多个 **Chunk（代码块）**，并在运行时异步加载。\n\nTree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n\n2.动态导入 (Dynamic Imports / 运行时加载)\n\n这是最常用、最灵活的代码分割方案，基于 ES Module 的 `import()` 语法，在运行时根据需要加载代码。\n\n- **实现方式：** 在代码中使用 `import('./path/to/module')`。\n\n- **适用场景：**\n  \n  - **路由懒加载：** 将每个路由页面打包成独立的 Chunk。\n  \n  - **组件懒加载：** 将不常用或在视口外的组件进行懒加载。\n  \n  - **条件加载：** 例如，用户点击某个按钮或满足某个条件时才加载特定的库。\n\n- **优点：** 实现了真正的**按需加载 (On-demand)**，大幅减少初始加载体积。\n\n- **缺点：** 必须处理加载状态（如使用 Suspense 或 Loading 占位符）。\n\n3.提取公共模块 (Vendor/Commons)\n\n目的是将多个模块（入口或动态导入）共享的依赖（如 React, Lodash, jQuery 等第三方库）提取出来，形成一个独立的公共 Chunk，以利用客户端的**缓存机制**。\n\n- **实现方式：** 使用 Webpack 的 `optimization.splitChunks` 配置。\n\n- **适用场景：** 任何包含大量第三方依赖或有多个入口点的应用。\n\n- **配置策略 (`optimization.splitChunks`)：**\n  \n  - **`vendors` (第三方库)：** 将所有来自 `node_modules` 的模块打包在一起。\n  \n  - **`default` (公共模块)：** 将应用内被多个模块（通常是两个以上）引用的代码提取出来。\n\n- **优点：** 充分利用浏览器缓存，核心库代码（如 React）稳定后，用户无需重复下载。\n\n- 示例 \n\n```js\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 对所有类型的 Chunk 生效\n      cacheGroups: {\n        // 自动提取 node_modules 中的库\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          priority: -10,\n        },\n        // 提取被多次使用的公共模块\n        default: {\n          minChunks: 2, \n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  },\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "engineering-12",
          "title": "Babel编译原理和插件开发",
          "content": "Babel 的编译过程严格遵循计算机科学中的编译器原理，可以划分为三个核心阶段：**解析 (Parse)**、**转换 (Transform)** 和 **生成 (Generate)**。\n\n阶段一：解析：此阶段的目标是将原始源代码转换为抽象语法树 (AST)。\n\n1. **词法分析 (Lexical Analysis/Tokenizing):**\n   \n   - 将输入的代码字符串分解成一个个独立的、最小的语法单元，称为 **Token**（标记）。\n   \n   - 例如：`const a = 1;` 会被分解为 `const`, `a`, `=`, `1`, `;` 等 Token。\n\n2. **语法分析 (Syntactic Analysis/Parsing):**\n   \n   - 将 Token 流组合成一个树状的结构，即 **AST (Abstract Syntax Tree)**。\n   \n   - AST 中的每个节点都代表了代码中的一个结构，如变量声明 (`VariableDeclaration`)、标识符 (`Identifier`)、函数调用 (`CallExpression`) 等。\n   \n   - Babel 默认使用 **`@babel/parser`** (以前叫 Babylon) 来进行解析。\n\n获得的AST是个很大超大的JSON，好在Webpack 或 Babel 是**逐个文件**读取和处理的。并且AST不存储时，是临时的数据\n\n阶段二：转换 (Transformation)\n\n这是 Babel 工作的核心，**插件**主要在这个阶段发挥作用。\n\n1. **遍历 (Traversing):**\n   \n   - Babel 会深度优先遍历整个 AST。\n\n2. **插件执行:**\n   \n   - 当遍历器遇到特定的节点类型时，它会调用注册了该节点类型的 **Babel 插件**。\n   \n   - 插件通过操作 AST 节点（增、删、改、替换），将高版本语法转换为目标环境支持的语法。\n   \n   - 例如，将 ES6 的箭头函数 (`ArrowFunctionExpression`) 节点转换成 ES5 的普通函数表达式 (`FunctionExpression`) 节点。\n\n3. **Babel 默认使用 **`@babel/traverse`** 来进行 AST 遍历和节点操作。\n\n阶段三：生成 (Generating)\n\n此阶段的目标是将转换后的 AST 重新渲染为目标代码字符串。\n\n1. **递归生成:** Babel 递归地遍历修改后的 AST，将每个节点打印成对应的代码字符串。\n\n2. **Source Map:** 同时，还会生成 **Source Map**，用于将转译后的代码映射回原始源代码，以便于调试。\n\n3. **Babel 默认使用 **`@babel/generator`** 来进行代码生成。",
          "hasAnswer": true
        },
        {
          "id": "engineering-13",
          "title": "Tree shaking原理和条件",
          "content": "Tree Shaking 的原理可以概括为两步：**标记（Marking）和清除（Sweeping）**。\n\n1. 标记：基于 ES Module 的静态分析\n\n- **静态结构：** ESM 的 `import` 和 `export` 语句在代码执行前就已经确定了模块之间的依赖关系和导出的名称。这意味着，构建工具可以在**编译阶段（编译时）**，而不是运行阶段，确定哪些代码被使用了，哪些没有。\n\n- **依赖图构建：** 构建工具会从入口文件开始，构建一个完整的模块依赖图（Module Dependency Graph）。\n\n- **使用标记：** 在遍历依赖图的过程中，构建工具会标记出**实际被导入和使用的**模块、函数或变量。没有被任何地方导入或引用的代码则会被标记为“未使用”。\n\n2. 清除：移除未标记的代码\n- 在标记阶段完成后，优化器（通常是 UglifyJS 或 Terser）会执行清除操作。\n\n- 它会遍历所有模块，**物理性地移除**那些被标记为“未使用”（即 Dead Code）的代码块。\n\nwebpack  Tree Shaking 的生效条件\n\n 1. 必须使用 ES Module 语法\n\n- **导出：** 必须使用 `export` 或 `export default`。\n\n- **导入：** 必须使用 `import` 语句。\n\n- ESM 的 `import()` 动态导入不会阻止 Tree Shaking，反而会成为 Tree Shaking 的起点，实现更精细的按需加载。\n\n- 在这个动态导入的场景中，Tree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n\n2. 保证代码是“无副作用的” (Side-Effect Free)：Tree Shaking 的机制是安全的移除**没有副作用**的代码。\n\n- **定义：** “副作用”是指执行该模块时，除了导出值之外，还会修改全局状态或执行其他操作（例如：修改 DOM、调用 API、修改原型链）。\n\n- **标记：** 如果一个模块被标记为有副作用，即使它的导出没有被使用，构建工具也可能出于安全考虑保留整个模块。\n\n- **实践：`package.json` 的 `\"sideEffects\": false`** 为了告诉构建工具一个库（或文件）是完全无副作用的，可以在项目的 `package.json` 中添加\n\n3. 配置生产模式优化，通过设置 `mode: 'production'` 启用，因为它默认包含了像 Terser 这样的代码压缩工具，而压缩工具是执行最终清除（Sweeping）步骤的关键。\n\n4. 转换工具的配置。如果使用了 Babel 等工具进行代码转换，必须配置它**不将 ES Module 转换成 CommonJS 模块**。\n\n- 例如，在 Babel 配置中，需要确保 `@babel/preset-env` 中**没有**设置 `modules: 'commonjs'`，或者明确设置为 `modules: false`",
          "hasAnswer": true
        },
        {
          "id": "engineering-14",
          "title": "介绍一下vite",
          "content": "**Vite 是一个基于原生 ES Modules 的前端构建工具，核心目标是提升开发阶段的启动速度和热更新性能。**\n\n它在开发阶段不做整体打包，而是利用浏览器的模块加载能力，按需加载源码，从而实现极快的冷启动和热更新。Vite 在开发阶段：\n- **不做整体打包**\n- 每个文件作为一个模块\n- 浏览器请求哪个模块，Vite 就按需返回哪个\n同时通过 esbuild 对第三方依赖做预构建，减少请求数量。 **第一次启动时**用 esbuild 把第三方依赖：\n- 转成 ESM    \n- 合并成少量文件\n- 缓存在 `.vite` 目录\nHMR：热更新基于模块级别，当修改一个文件时：\n- 只更新这个模块\n- 不重新打包整个依赖图\n\n生产环境下，Vite 仍然使用 Rollup 进行打包，保证产物质量。Rollup的优点：\n- Tree-shaking 成熟\n- 产物质量高\n- 社区生态稳定\n\nvite 的优缺点（必须会）\n ✅ 优点\n- 冷启动极快\n- HMR 速度快\n- 配置简单，心智负担小\n- 贴近浏览器原生能力\n ⚠️ 局限\n- 依赖浏览器 ESM（IE 不支持）\n- 对某些非标准包需要额外配置\n- 对老项目迁移有成本",
          "hasAnswer": true
        },
        {
          "id": "engineering-15",
          "title": "Vite HMR 边界是怎么找的？",
          "content": "Vite 的 HMR 边界是沿着 ESM 的 import 依赖链向上查找，直到遇到显式接受更新的模块为止。\n 一、什么叫 HMR 边界？\n **HMR 边界 = 能安全“吞掉”更新、不需要整页刷新的模块** 。也就是：不需要把影响继续往父模块传播 的边界\n 二、Vite 为什么能精确找 HMR 边界？\n 核心前提：ESM 是静态的\n - import 关系是**编译期确定的**\n- Vite 能维护一张模块依赖图（Module Graph）\n注意：Vite 不是每次 HMR 重新构建依赖图，而是增量维护。\n三、Vite 查找 HMR 边界的完整过程\n假设改了 `Foo.vue`\nStep 1：定位变更模块，Vite 先重新 transform 这个模块。\nStep 2：向上查找 importer\nStep 3：判断是否能 accept 更新：对每一层父模块，Vite 会检查是否是HMR的边界\nStep 4：如果一路向上，找不到边界 ，直到到达入口（如 `main.ts`）, Vite 会触发全量刷新\n\n追问：\n1️⃣ 那 CSS 为什么几乎总是热更新成功？\nCSS 天然是副作用模块，不影响 JS 执行状态，Vite 会直接替换 style 内容，本身就是 HMR 边界。\n2️⃣ 为什么有时改一个文件会整页刷新？\n 因为这次修改影响的模块链路上没有任何模块接受更新，Vite 找不到 HMR 边界，只能 fallback 到 full reload。\n3️⃣ HMR 边界是插件决定的吗？\n **部分是**。   框架插件（如 Vue / React）会自动注入 HMR accept 逻辑，从而人为制造 HMR 边界。Vue / React 插件会在 transform 阶段自动为组件注入 accept 逻辑\n4️⃣ 什么叫显式接受 HMR，具体如何判断？\n显式接受 HMR 指的是开发者针对模块通过 `import.meta.hot.accept` 明确声明自己可以安全处理热更新。  \n5️⃣ 插件是如何添加accept的？\n插件只敢给 **“幂等、可替换、无全局副作用”** 的模块加 HMR 边界。\n插件不是“判断模块安全”，而是“识别已知安全模式的模块”，只对这些模式注入 HMR accept。在 transform 阶段，通过 AST 分析识别符合框架约定的模块，比如 Vue 组件或 React 组件，这些模块的生命周期和重建行为是框架可控的。\n插件判断一个模块能否成为 HMR 边界，依据的是：\n1. **文件类型**（`.vue  .jsx`）因为 组件可销毁，可重新挂载，状态由框架管理，生命周期可控\n2. **导出结构**（导出一个组件对象）\n3. **框架约定**（组件生命周期可控）\n4. **白名单策略**（只对已知安全模式生效）\n6️⃣ 为什么 store / router 往往会触发全量刷新？\n因为 store / router 通常是“全局单例 + 强副作用模块”，插件不敢也不能自动给它们加 HMR 边界。",
          "hasAnswer": true
        },
        {
          "id": "engineering-16",
          "title": "webpack vite区别",
          "content": "1. 构建原理\n\t- Webpack：构建期打包，bundle-first\n\t- Vite：开发阶段基于原生 ESM，production 基于Rollup打包\n2. 热更新：文件发生变化时：\n\t- Webpack 重新 **构建依赖图** ， 生成新的 chunk， 通过 HMR Runtime 把更新后的模块推送到浏览器，浏览器端执行 `module.hot.accept`，替换模块。webpack 必须重新分析模块依赖关系，重新生成 chunk。所以项目越大，**依赖图越复杂，重建成本越高**，即使只改一个文件，也可能触发大范围构建。\n\t- Vite 开发环境下，每个文件就是一个原生 ESM 模块， Vite 只重新处理这个文件， 找到该模块的 HMR 边界，通过 WebSocket 通知浏览器， 浏览器直接替换这个模块。更新粒度是**单文件 / 单模块**，不需要重新构建整个依赖图，所以HMR 成本与项目规模几乎无关\n3. 生产打包：\n\t- webpack:  插件 + loader 可高度定制，适合复杂工程（微前端、多入口、老模块）。输出结果容易偏“工程化”，不够干净\n\t\t构建完整依赖图\n\t\tloader 转换源码\n\t\tplugin 参与优化\n\t\t拆 chunk（SplitChunks）\n\t\t压缩、混淆\n\t\t输出最终 bundle\n\t - vite: 生产环境用Rollup，Tree Shaking 更彻底，Bundle 体积更小，输出代码结构更清晰\n\t    基于 AST 静态分析 ESM\n\t    精准 Tree Shaking\n\t    更干净的 chunk 划分  \n\t\tVite 插件会转成 Rollup 插件执行\n4. 配置与心智负担\n\t- Webpack 配置项多，学习成本高\n\t- Vite 配置偏约定式，上手成本低\n5. 生态\n\t- Webpack 插件和 loader 生态成熟\n\t- Vite 插件生态增长快，但在复杂工程上仍不如 Webpack\n总结来说：\n\tWebpack 胜在**可控性和复杂场景**  \n\tVite 胜在**开发体验和现代工程**",
          "hasAnswer": true
        },
        {
          "id": "engineering-17",
          "title": "为什么 Webpack 很难做到像 Vite 那样精细的 HMR？",
          "content": "因为 Webpack 的 HMR 是建立在 bundle / chunk 体系之上的，而不是建立在原生 ESM 模块体系之上。模块替换、依赖传播和边界判断都需要运行时协调，粒度难以做到很细。\nWebpack 模块最终会被**打包进 chunk**，运行时加载的是 bundle，HMR 更新的是 **chunk 中的模块**。Webpack的模块并不是浏览器原生模块，而是运行在 Webpack runtime 中的函数。\n而 Vite 基于原生 ESM，每个文件就是独立模块，HMR 只需要替换单个模块并沿 import 链传播，因此更精细也更稳定。",
          "hasAnswer": true
        },
        {
          "id": "engineering-18",
          "title": "讲讲Rollup 的原理 特点 适用场景",
          "content": "Rollup 是一款专注于 **ESM (ES Modules)** 的深度打包工具。\n**原理**\n- 基于 **ESM 的静态结构**\n- 在构建阶段通过 AST 分析模块依赖\n- 标记未使用的导出，实现 Tree Shaking\n- 最终生成更干净、可读性更高的 bundle\n**特点：** \n- **构建产物纯净：** 几乎没有冗余代码，体积最小化。\n- **插件机制：** 采用双钩子机制，非常灵活。\n- **天然支持 ESM：** 输出格式支持 ESM、CommonJS 和 UMD。\n**适用场景：** Rollup 是**类库（Library）和组件库**打包的首选（如 React/Vue 源码都用它）。但它对 HMR（热更新）和图片等静态资源处理较弱，通常不建议用于大型业务应用开发。",
          "hasAnswer": true
        },
        {
          "id": "engineering-19",
          "title": "讲讲Parcel",
          "content": "提供一个**极速、开箱即用**的现代前端开发体验，让开发者可以专注于代码本身，而不是复杂的构建配置, 设计初衷是简化工程化复杂度。对于大多数常见的项目类型（如 JavaScript、CSS、HTML、图片等），它不需要任何配置文件 (`parcel.config.js` 或 `webpack.config.js`) 就能直接工作。\n\n 核心特点\n- 几乎不需要配置：零配置**支持基于 ES 模块的**动态导入 (`import()`)，并自动将应用分割成更小的块，实现按需加载。\n- 资源支持：Parcel 天生支持各种文件类型，内置对 TS、JS、CSS、图片等的处理\n- 支持开箱即用的 HMR：Parcel 默认启用快速的热模块替换，可以保留应用状态并即时更新模块，提高开发效率。\n- 极速打包：**Parcel 利用 **多核处理 (Worker 进程)** 来并行编译资源，并使用文件系统缓存。这使得它的初始构建和二次构建速度都非常快。\n\n**总结：** Parcel 上手成本极低，是一个适合快速启动、中小型项目，以及追求简单配置和极致开发速度的开发者的优秀选择。",
          "hasAnswer": true
        },
        {
          "id": "engineering-20",
          "title": "前端自动化测试策略",
          "content": "前端自动化测试常见的三个维度：\n\n1. **单元测试 (Unit Testing)：** 成本最低、速度最快。主要针对工具函数、纯逻辑 Hooks 或公共组件。常用工具：**Jest, Vitest**。\n2. **集成测试 (Integration Testing)：** 关注多个组件或模块协同工作的逻辑，模拟用户交互行为（如点击按钮后列表是否刷新）。常用工具：**React Testing Library, Vue Test Utils**。\n3. **端到端测试 (E2E Testing)：** 成本最高，但信心最强。模拟真实用户在浏览器环境的操作流程（如登录流程、下单流程）。常用工具：**Playwright, Cypress**。\n\n 业务项目中，优先覆盖核心逻辑的**集成测试**，对底层库强制要求**单测覆盖率**，对主业务路径配置关键的 **E2E 冒烟测试**。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "cicd",
      "name": "CI&CD",
      "questions": [
        {
          "id": "cicd-1",
          "title": "CI/CD流程",
          "content": "持续集成 (CI)：快速、自动化地验证代码质量。包括\n代码质量检查lint：代码 提交前的lint校验，保证代码质量、风格一致\ngit hook触发流程：开发者提交代码到远程仓库；git Webhook 监听到代码变动触发流水线。\nbuild构建：执行 `npm install` 和 `npm run build`，产出 `dist` 文件。\n\n持续交付 (CD)：确保代码随时可以自动化地部署到生产环境。包括\n发布：将 `dist` 内容推送到服务器或 OSS\n流量切换：多服务器时部署后的合理切换策略，比如蓝绿等\n回滚：必要时能快速回滚到指定版本\n\n**核心意义**：减少人为操作失误（比如忘了跑 build 就上线），确保上线过程可追溯、可回滚。",
          "hasAnswer": true
        },
        {
          "id": "cicd-2",
          "title": "前端工程化的理解，如何自动化，成熟的体系应该具备哪些要素",
          "content": "前端工程化的本质是——让前端开发从“手工活”变成“可规模化、可度量、可迭代的生产体系”，核心目标是：提效、稳定、可控。\n\n自动化质量控制 lint prettier git规范等\n\n自动化构建，自动化发布，保证性能、产物可控、灰度发布、流量分配、自动回滚\n\n监控报警\n\n前端工程化的核心是标准化 + 自动化 + 流程化 + 度量化。  \n成熟体系应该覆盖整个研发生命周期：从代码规范、项目结构、组件库沉淀、构建优化，到测试、CI/CD、灰度发布、监控报警。  \n最终目标是：让开发提效、质量可控、上线可回滚、运行可监控。",
          "hasAnswer": true
        },
        {
          "id": "cicd-3",
          "title": "nginx配置",
          "content": "Nginx 主要用于作为**反向代理**、**静态资源服务器**和**负载均衡器**。\n\n前端常用：配置SPA 、静态资源路径、反向代理解决跨域、缓存配置、Gzip 压缩等\n\n核心配置项：\n\n```\nserver {\n    listen 80;\n    server_name example.com;\n\n    # 1. 静态资源托管\n    location / {\n        root /usr/share/nginx/html;\n        index index.html;\n        try_files $uri $uri/ /index.html; # 关键：解决 Vue/React Router 刷新 404 问题\n    }\n\n    # 2. 反向代理（解决跨域）\n    location /api/ {\n        proxy_pass http://api.backend.com/; # 转发到真实后端\n    }\n\n    # 3. 开启 Gzip 压缩\n    gzip on;\n    gzip_types text/plain application/javascript text/css;\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "cicd-4",
          "title": "cdn配置",
          "content": "将静态资源分发到全球边缘节点，使用户可以从最近的节点获取资源，加速访问\n\n- **前端配合:** 构建工具（Webpack/Vite）需要配置 **`publicPath`** 为 CDN 域名地址。\n\n- **CDN 关键配置:**\n  \n  - **回源策略:** 配置 CDN 节点在缓存未命中时，回源到 Nginx 或 OSS。\n  \n  - **缓存规则:** 区分可缓存（如带 Content Hash 的 JS/CSS）和不可缓存（如 `index.html`）。通常对带 Hash 的资源设置长缓存（如 1 年），对 `index.html` 设置短缓存（如 5 分钟）或不缓存。\n  \n  - **预热/刷新:** 部署后对新的资源文件进行预热，对旧的资源路径进行缓存刷新。",
          "hasAnswer": true
        },
        {
          "id": "cicd-5",
          "title": "oss 是什么？有什么作用和优势",
          "content": "- 高可靠、高并发、低成本的静态文件存储服务（如 AWS S3, 阿里云 OSS）。\n\n- **前端应用:** 通常将前端构建产物直接上传到 OSS 存储桶中，然后通过 CDN 绑定该存储桶的域名进行加速访问。\n\n- **优势:** 免维护服务器、高可用性。\n\n和cdn对比：\nOSS (Object Storage Service - 对象存储)\n- **作用**：像一个海量的硬盘，专门存静态文件（图片、JS、CSS、视频）。\n- **优势**：高可靠（文件不丢）、按量付费（省钱）、不占用服务器磁盘。\n\nCDN (Content Delivery Network - 内容分发网络)\n- **作用**：像连锁店。在全国各地放服务器，缓存 OSS 里的内容。\n- **优势**：**就近访问**。你在北京访问，CDN 就从北京节点给你发货，速度极快。\n\n| **维度** | **OSS**            | **CDN**                 |\n| ------ | ------------------ | ----------------------- |\n| **本质** | **仓库**（存东西的地方）     | **快递**（送东西的地方）          |\n| **位置** | 固定的中心机房            | 分布在全国各地的边缘节点            |\n| **配合** | 前端产物 `dist` 传给 OSS | 域名指向 CDN，CDN 回源 OSS 拿数据 |",
          "hasAnswer": true
        },
        {
          "id": "cicd-6",
          "title": "OSS 怎么配合 CDN 做缓存刷新的主流方案",
          "content": "文件哈希 + 强缓存：这是目前不需要手动频繁刷新 CDN 的最稳妥方案：\n\n- **静态资源 (JS/CSS/Image)**：文件名带上 Hash（如 `main.a1b2c3.js`）。设置 CDN 为**强缓存**（Cache-Control: max-age=31536000）。\n    - _原理_：文件名变了，CDN 没见过这个文件，会自动回源 OSS 拿新的。\n\n- **入口文件 (index.html)**：文件名不变。设置 CDN 为**协商缓存**（Cache-Control: no-cache）。\n    - _原理_：每次访问 index.html，CDN 都会回源头对比一下。如果 index.html 更新了，它就下发新的，从而引导浏览器去加载新的 Hash 资源。",
          "hasAnswer": true
        },
        {
          "id": "cicd-7",
          "title": "npm install后发生了什么",
          "content": "- **检查本地缓存:** 检查 `node_modules` 是否存在，以及 `lock` 文件是否与 `package.json` 匹配。\n\n- **下载依赖:**\n  \n  - **npm/Yarn:** 访问 npm Registry，根据 `lock` 文件中记录的 URL/Hash/Version 下载依赖包，并存入全局缓存。\n  \n  - **pnpm:** 检查本地内容寻址存储中是否已存在该版本的包。如果存在，跳过下载。\n\n- **构建依赖树:**\n  \n  - **npm/Yarn:** 根据下载的包创建**扁平化**的依赖树结构，解决依赖冲突（如果能解决）。\n  \n  - **pnpm:** 根据 `lock` 文件创建**严格的非扁平化**依赖树，使用**硬链接和符号链接**连接到全局存储的包。\n\n- **执行生命周期脚本:** 运行依赖包中定义的 `install`、`postinstall` 等脚本（例如 `node-sass` 或 `Puppeteer` 的编译步骤）。\n\n- **生成/更新 Lock 文件:** 如果 `package.json` 有变化，更新 `package-lock.json` 或 `pnpm-lock.yaml`，确保团队构建环境的一致性。",
          "hasAnswer": true
        },
        {
          "id": "cicd-8",
          "title": "npm 为什么要做依赖提升？会带来什么问题？",
          "content": "- **减少重复依赖**：多个包共用同一版本 → 顶层放一份\n- **缩短 node_modules 路径**：避免嵌套过深（历史上还会触发 Windows 路径长度问题）\n- **更快的 Node 解析/更少磁盘占用**（间接收益）\n\n带来的问题：\n问题 1：幽灵依赖（phantom dependency）\n某个包 **没有声明**依赖 A，但因为 A 被 hoist 到顶层，它居然也能 `require('A')` 成功。  \n一旦安装结构变化（或换包管理器），就炸。\n问题 2：依赖解析不一致 / 隐式耦合\n不同安装顺序、不同 lock、不同平台，hoist 结果可能不完全一致（现代工具好很多，但仍是风险点）。  \n导致“本地没问题，CI/线上有问题”。",
          "hasAnswer": true
        },
        {
          "id": "cicd-9",
          "title": "npm vs yarn vs pnpm",
          "content": "- **npm / Yarn classic（v1）**：传统 node_modules 布局，**会 hoist**，容易出现幽灵依赖。\n    \n- **Yarn Berry（v2+）**：默认 **PnP**（不一定生成 node_modules），依赖解析更严格（但生态兼容要配）。\n    \n- **pnpm**：使用 **全局内容寻址 store**，项目里通过链接组织依赖，默认更严格、磁盘更省，，且安装快速，也能显著减少幽灵依赖。",
          "hasAnswer": true
        },
        {
          "id": "cicd-10",
          "title": "模块化发展历程(AMD/CMD/UMD/ES6)",
          "content": "**CommonJS (CJS)** 同步加载，`require()` 和 `module.exports`。用在node环境\n\n**AMD 异步**加载，适合浏览器，如 RequireJS。**依赖前置**，模块定义时所有依赖就绪并加载（预先加载）。\n\n**CMD**异步加载，推崇就近依赖。模块代码执行到 `require` 时才加载（按需加载）。\n\n**UMD**通用模式，兼容 CJS、AMD 和全局变量，用于库的发布。是**打包规范**，用于让一个模块或库同时兼容多种加载环境。\n\n**ES Module (ESM)** 静态加载、`import` / `export`，支持 Tree Shaking 和 `import()` 动态加载。\n\nAMD CMD UMD 它们都需要引入各自的模块加载器库，因为浏览器不原生支持这些规范。\n\nWebpack（以及其他现代构建工具，如 Rollup, Parcel, Vite）在编译时处理了 CJS 的引用和依赖关系，并消除了对原生 CJS 运行时环境的需求\n\n本题核心：\n模块化最早是 CommonJS，用于 Node.js，采用同步加载，不适合浏览器。\n随着浏览器端需求出现，AMD 和 CMD 提供了异步加载方案，分别采用依赖前置和依赖就近的方式。  \nUMD 本质上是一种兼容写法，用于同时适配多种模块规范。  \nES Module 是语言层面的标准，支持静态依赖分析和 Tree Shaking，是现代前端构建工具和浏览器的基础模块方案。\n\n补充：JavaScript 模块化机制中最核心、最稳定的特性：**模块单例（Module Singleton）**。对于所有现代 JavaScript 模块规范（CJS, AMD, **ESM**），无论是同步导入还是动态导入，一旦一个模块被加载并执行，它的结果就会被**缓存**起来。",
          "hasAnswer": true
        },
        {
          "id": "cicd-11",
          "title": "浏览器对模块脚本的加载和执行，具体什么过程和规则？",
          "content": "模块方式加载是浏览器先解析 import 构建依赖图，再按依赖顺序加载和执行，每个模块有独立作用域且只执行一次，这让代码更安全、可维护，也更适合大型工程。\n\n核心：`<script type=\"module\" src=\"...\">`\n过程：\n- 浏览器在执行前\n- **先构建模块依赖图**\n- 再按依赖顺序加载所有模块\n- 和 `require` 的“运行时加载”不同。\n\n模块脚本的加载特性\n- 默认 **defer 行为**（不阻塞 HTML，DOM 解析完成后执行，多个 module 按依赖顺序执行）\n- 模块作用域（不挂到 `window`，每个模块有独立作用域，避免全局污染）\n- 自动开启严格模式\n- 支持依赖的 **按需加载**\n\n缓存：\n- 每个模块只导入一次，后续 import 直接复用结果",
          "hasAnswer": true
        },
        {
          "id": "cicd-12",
          "title": "前端模块化方案有哪些？在工程中你是如何选择的？",
          "content": "现在业务应用开发基本统一用 ES Module，因为它支持静态分析、tree-shaking 和动态 import，配合构建工具体验最好。\n\n真正需要做选择的通常是做“库”的时候：为了兼容不同消费方，我会在构建产物上同时输出 ESM 和 CJS；如果要支持直接 script 引入，则额外输出 UMD/IIFE。服务端项目则根据 Node 版本和生态选择 CJS 或 ESM。",
          "hasAnswer": true
        },
        {
          "id": "cicd-13",
          "title": "动态 import()",
          "content": "这是前端性能优化重要方式，也就是所谓的**路由懒加载**。\n用法：返回一个 Promise 对象。可以用.then或者async await\n\n- **作用：** 只有当代码真正运行到这一行时，才去服务器下载对应的 JS 模块。\n\n- **原理（Webpack 实现）：**\n    1. **代码分割 (Code Splitting)**：构建工具识别到 `import()`，会将该模块打包成一个独立的子包（Chunk）。\n    2. **JSONP 加载**：运行到该行时，浏览器动态插入一个 `<script>` 标签指向子包地址。\n    3. **异步执行**：脚本加载完成后，Promise 状态变为 `resolved`，执行后续逻辑。\n\n- **优势：**\n    1. **减小首屏体积**：不用一次性下载几 MB 的代码。 \n    2. **按需加载**：用户不点击的功能永远不下载，省流量。",
          "hasAnswer": true
        },
        {
          "id": "cicd-14",
          "title": "前端微服务架构实践",
          "content": "**核心目标:** 将一个庞大的前端应用拆分为多个独立开发、独立部署、独立运行的小应用。\n\n- **Module Federation (推荐):** Webpack 5 联邦模块功能，实现运行时模块共享和依赖去重。\n\n- **Single-SPA/Qiankun (基于框架):** 通过路由劫持和沙箱机制，实现应用级的集成。\n\n- **Web Components/Iframe (隔离):** 通过浏览器原生技术实现 UI 隔离。",
          "hasAnswer": true
        },
        {
          "id": "cicd-15",
          "title": "Monorepo 项目管理",
          "content": "**定义:** 将多个项目（Package）的代码存储在一个 Git 仓库中。最终的构建（Build）和部署（Deploy）仍然是**按需、独立**进行的。\n\n**常用工具:** Lerna, Nx, Turborepo, Yarn/pnpm Workspace。\n\n**优势:**\n  - **代码共享:** 易于在不同项目间共享代码和配置。\n  - **原子提交:** 一个 Commit 可以涉及多个项目，尤其对于公共代码修改，提交历史清晰。\n  - **统一依赖:** 容易实现跨项目依赖一致性。\n  - 本地开发体验更好：不用反复 `npm link` / 发测试包\n\n **挑战:** \n 仓库体积大，工具配置复杂，权限控制难度增加。\n 项目间依赖关系复杂，需要工具辅助管理\n 如果缺乏变更感知机制，构建和 CI 成本会急剧上升\n\n实现：\n- CI：**Monorepo 工具的集成 (Nx/Turborepo):** 这些工具可以智能地判断**哪些项目**受到了代码变动的影响。例如，在 CI 中运行 `npx nx affected:build`，只构建那些代码或其依赖发生变化的子项目。\n- 通常会有一个位于 Monorepo 根目录下的**主 CI 配置文件**，它负责调用 Monorepo 工具，并确定哪个子项目的部署流程需要被触发。\n- **部署脚本：** 具体的部署逻辑（例如如何将文件上传到 S3 或如何调用 K8s 部署 API）通常会封装成每个项目内部的独立脚本，或由主 CI 配置文件通过参数动态调用。",
          "hasAnswer": true
        },
        {
          "id": "cicd-16",
          "title": "包管理和版本控制策略",
          "content": "- **版本锁定:** 强制使用 `package-lock.json` 或 `pnpm-lock.yaml` 锁定依赖版本，确保不同环境下的依赖一致性。\n\n- **包管理:** 使用 **pnpm Workspace**（基于 Monorepo 的包管理）来实现依赖共享和节省空间。\n\n模块的单例行为与 React Hooks 或 Vue Composition API 中的 `composable`（组合式函数）的行为，构成了前端状态管理和逻辑复用的两种截然不同的模式。\n\n模块：共享的应用级状态\n\nHooks / Composable：隔离的组件级状态",
          "hasAnswer": true
        },
        {
          "id": "cicd-17",
          "title": "说说前端代码规范 lint prettier，你怎么看？工作中怎么用？",
          "content": "前端代码规范主要通过 **Lint（如 ESLint）** 和 **格式化工具（如 Prettier）** 来统一代码质量和风格。\n\n- **Lint**：偏向**代码质量和潜在错误检查**，结合框架规范进行逻辑校验，预防潜在性能或 Bug 风险\n- **Prettier**：偏向**代码格式统一**，统一缩进、换行、分号、引号等\n\n作用：\n- 避免低级错误（未使用变量、错误依赖、危险写法）\n- 保证多人协作时代码风格一致\n- 减少 Code Review 在“格式问题”上的时间浪费\n- **让规范“自动化”，而不是靠人记**\n\n实际工程中的使用：\n- **项目初始化**\n    - ESLint + Prettier + 对应框架插件\n    - ESLint 关闭和 Prettier 冲突的规则\n- **开发阶段**\n    - 编辑器保存自动格式化\n    - Lint 实时提示问题\n- **提交阶段**\n    - husky + lint-staged\n    - 提交前只检查本次变更\n- **CI 阶段**\n    - Lint 作为质量门禁，避免不合规代码进主分支\n\n总结：Lint 保证代码质量，Prettier 保证风格统一，规范的核心目标是降低协作成本，而不是限制个人习惯。规范不是越严越好，而是**在可读性、效率和团队接受度之间取平衡**。",
          "hasAnswer": true
        },
        {
          "id": "cicd-18",
          "title": "工作中git 怎么用？pull和pull --rebase的区别",
          "content": "Git 是分布式版本控制工具，用来做 **版本管理、协作和回溯问题**。\n日常高频命令：\n- `clone / add / commit`\n- `branch / checkout / merge`\n- `pull / push`\n- `rebase / reset / cherry-pick`\n\npull和pull --rebase的区别：\n`git pull` 本质是：`git pull = git fetch + git merge`\n- 会生成一次 **merge commit**\n- 历史是**非线性的**\n `git pull --rebase` 是：`git pull --rebase = git fetch + git rebase`\n- 把**本地提交挪到最新远程提交之后**\n- 不产生 merge commit\n- 历史更线性、干净\n实际使用：\n- **个人功能分支**：`pull --rebase`\n- **公共分支（main / develop）**：`merge`\n- **已经 push 的公共提交**：不随意 rebase",
          "hasAnswer": true
        },
        {
          "id": "cicd-19",
          "title": "说说SemVer规则，^ 和 ~ 有什么区别？还有什么其他常用方案？",
          "content": "1. `^`**兼容升级**，**允许升级到“同一 major 版本”的最新 minor/patch** （特殊的`^0.x.y` **很保守**，等同于~）\n2. `~`更保守，只允许 PATCH 升级\n3. 固定版本 `1.2.3`，不会自动升级\n4. `*`（完全放开，**强烈不推荐**）\n5. `>=` / `<=` / `>` / `<`（范围约束）\n6. 预发布版本（alpha / beta / rc），比如`1.2.0-beta.3`\n\t1. npm 在解析依赖时，默认不会自动升级到 `alpha / beta / rc` 版本\n\t2. **显式指定**预发布版本时，即使用^，比如`^1.2.0-beta.3`，npm **允许升级**， 但**只在同一条预发布线内**，也就是会升级到`1.2.0-beta.4` 不会到`1.3.0`",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "open-questions",
      "name": "开放题&场景题",
      "isFolder": true,
      "questions": [
        {
          "id": "open-questions-1",
          "title": "H5主动推送、组件更新通知、自动化发布",
          "content": "#### 如果界面需要实时更新用户信息（比如玩家的得分），你会如何设计前端架构来实现这一功能?\n\n如何选轮询 / SSE / WebSocket，我会按 5 个维度选：\n\t1. 更新频率（秒级 / 100ms / 更高）\n\t2. 数据量（单值/小 JSON/大 payload）\n\t3. 是否双向（只接收 vs 需要频繁发送）\n\t4. 可靠性要求（可丢/不能丢/最终一致即可）\n\t5. 成本与复杂度（后端/网关/运维）\n结合业务问题：\n- 每秒更新多少次？\n- 同时在线多少用户？\n- 允许延迟多少？\n\n2. 轮询（Polling）——“简单、稳，但有浪费”\n\t**适用场景**\n\t- 更新频率低：比如 **10s~60s** 更新一次\n\t- 数据量小：比如积分、状态、小红点\n\t- 并发不大或服务端压力可控\n\t**优点**\n\t- 实现成本最低\n\t- 容错强（网络抖动也能下一次再拉）\n\t- 缓存/网关/监控体系成熟\n\t**缺点**\n\t- 资源浪费（没变化也请求）\n\t- 延迟取决于轮询间隔\n\t**工程实践（加分）**\n\t- **增量轮询**：带上 `since` / `etag`\n\t- **退避策略**：失败后指数退避\n\t- 页面隐藏时暂停：`visibilitychange`\n3. SSE（Server-Sent Events）——“单向推送的性价比”\n\t**适用场景**\n\t- 只需要**服务端 → 客户端**推送，无需双向实时交互\n\t- 更新频率中等：**1s~200ms** 级别\n\t- 消息为文本/JSON，不复杂\n\t- 典型：公告、通知、进度、状态变化、比分更新\n\t**优点**\n\t- 基于 HTTP，穿透代理/负载均衡更友好\n\t- 浏览器原生支持自动重连（EventSource）\n\t**缺点**\n\t- 单向；客户端发消息还是要走 HTTP\n\t- 需要服务端支持\n4. WebSocket ——“高频/交互/多路复用的最终形态”\n\t**适用场景**\n\t- 高频更新：**100ms 甚至 16ms**（实时位置、游戏状态）\n\t- 需要双向：客户端也要实时发送（操作、确认、订阅变更）\n\t- 需要在一条连接上订阅多种业务 topic（积分、排名、事件）\n\t**优点**\n\t- 真正双向、低延迟\n\t- 支持多路复用（topic/channel）\n\t- 更适合高频小消息\n\t**缺点**\n\t- 复杂度高：鉴权、心跳、重连、订阅恢复、消息顺序\n\t- 运维要求高：连接数、网关、限流、消息队列\n\t- “不丢消息”通常要协议层配合（seq/ack/补发）\n\t**工程实践（加分）**\n\t- 心跳 + 指数退避重连\n\t- 订阅协议：subscribe/unsubscribe\n\t- 消息 `seq` + 去重，必要时 `ack` + 补发\n\t- 高频 UI 更新：用 rAF/批处理，避免每条消息都 setState\n\n#### 自动化发布怎么实现\n\n1. 版本号规则（SemVer）：团队需要统一 commit 规范\n\t- 版本号规则：**SemVer（Semantic Versioning）是一套用版本号来表达“变更影响范围”的约定**，标准格式是：  `major.minor.patch`\n\t- 通过 commit 规范自动推断版本（Conventional Commits）：\n\t    - `fix:` → patch\n\t    - `feat:` → minor\n\t    - `BREAKING CHANGE` → major\n2. CI 里自动：简单可以用 npm version patch\n    - 更新 `package.json` 版本号，自动生成 changelog\n    - 生成一个 commit 并生成 git tag（tag 是给某个 commit 打的“版本标记”，便于后续查找版本号、定位、回滚）\n    - push commit + tag，CI 监听 tag → 构建 → 发布\n3. 发布提醒（版本号/变更内容）\n\t- 在 PR / merge 时自动评论：预计 bump 到哪个版本、包含哪些变更\n\t- release 成功后发通知：\n\t    - 企业机器人 + @相关人\n\t    - 包含：版本号、breaking、迁移指引、回滚指令\n4. 发布安全阀\n\t- 灰度：按环境/用户分流（canary）\n\t- 一键回滚：回到上一个 tag / 上一个 CDN 版本\n\n#### 停留页面提示版本更新\n\n1.方案 1：轮询版本文件（最通用）\n- 发布时生成 `/version.json` 或写到 HTML meta：\n    - `{ \"version\": \"1.2.3\", \"buildTime\": ... }`\n- 客户端每隔 N 分钟拉一次：\n    - 发现 version 变化 → toast：**“发现新版本，点击刷新”**\n    - 用户确认后 `location.reload()`\n- 优点：实现简单、跨技术栈 ；缺点：有轮询\n2.Service Worker（更强）\n- 有 SW 的项目：更新检测更标准\n- 新 SW ready 时提示用户刷新\n- 能做到更精细的缓存策略\n3.WebSocket/SSE 推送（实时）\n- 发布成功后推一条 “newVersion” 消息\n- 在线用户秒级感知，无需轮询\n- 只做版本更新有点杀鸡用牛刀了\n\n风险与兜底（面试加分）\n- 如果是**交易/编辑中**页面，不要强刷：\n    - 做“温和提示”，让用户选“稍后”\n    - 关键流程完成后再提示\n#### 组件库升级怎么让使用这个组件的人都知道\n\n1. 技术层面\n\t- TS 的 `/** @deprecated */` 标注：`@deprecated` 是 TypeScript/IDE 识别的“废弃标记”。不一定阻止编译，但IDE会给开发者明显提示。\n\t- **TypeScript 类型变化**：使用方编译就报错（最有效）\n\t- **严格执行版本号规则**：破坏性更新必须更新 major，能避免自动升级带来的问题\n\t- 强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要\n2. 流程层\n\t- 发版自动生成 release notes（含 breaking/迁移步骤）\n\t- 自动推送到群/邮件：\n\t    - @到组件使用最多的 repo/负责人\n3. 文档层\n\t- 组件站点文档展示：\n\t    - 最新版本\n\t    - 变更日志\n\t    - 迁移指南\n\t- 给出 **Before/After** 代码片段\n#### 如果让你设计一个组件库项目的安全设计，应该考虑哪些方面\n\n核心目标：  \n1）让使用方**及时感知**新版本；\n2）通过门禁、灰度、监控确保**安全**；\n3）可快速回滚\n\n1. 发布侧：版本与变更“可机器理解”（系统成败关键）\n\t统一规范：SemVer + Conventional Commits\n\t强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要\n2. 依赖侧：版本发布后自动推送到群/邮件等方式通知依赖的业务方，必要时可以通过扫描所有业务仓库的 `package.json` + lockfile 来建立“全局依赖图”\n3. 安全设计：从“编译安全”到“线上安全”的多层门禁\n\tA. 编译期门禁（最有效、最便宜）\n\t- TS 类型检查：API 不兼容直接失败\n\t- ESLint/规则：禁用 deprecated API（逐步收敛）\n\tB. 测试门禁（按成本分层），单测/快照\n\tC. 灰度与回滚（线上安全核心）\n\t- **灰度策略**（按 repo 或按用户），先让少量应用升级到新组件库版本，观测一段时间再扩大范围\n\t- **回滚策略**\n\t    - 使用方回滚：回退依赖版本（PR 自动生成 revert）\n\t    - 组件库回滚：回退 tag / CDN 产物（如果是 CDN）\n\tD. 监控与自动熔断\n\t- 关键指标按“组件库版本维度”聚合：\n\t    - JS error rate（含 chunk load error）\n\t    - 性能指标（LCP/INP）\n\t    - 业务埋点（转化、下单成功率等）\n\t- 超阈值触发回滚/告警",
          "hasAnswer": true
        },
        {
          "id": "open-questions-2",
          "title": "SSR-SSG-SPA-MPA",
          "content": "####  CSR-SSR-SSG-ISR\n##### 1️⃣ CSR（Client-Side Rendering，客户端渲染）\n- HTML 基本是空壳\n- JS 下载完成后在浏览器渲染页面\n\n**特点**\n- 首屏慢（白屏时间长）\n- SEO 不友好（需额外方案）\n- 交互流畅（路由切换快）\n\n**适用场景**\n- 后台系统\n- 强交互应用（B 端、管理台）\n- 对 SEO 不敏感的场景\n\n##### 2️⃣ SSR（Server-Side Rendering，服务端渲染）\n- 请求时在服务端拉数据\n- 生成完整 HTML 返回给浏览器\n- 浏览器再进行 **Hydration（水合）**\n\n**优点**\n- 首屏快（HTML 有内容）\n- SEO 友好\n\n**缺点**\n- TTI 较慢（要等 JS 水合）\n- 服务端压力大\n- 实现复杂\n\n**适用场景**\n- 首页 / 落地页\n- 内容型页面\n- 对 SEO 要求高的页面\n\n##### 3️⃣ SSG（Static Site Generation，静态生成）\n- **构建阶段**生成 HTML\n- 部署后直接 CDN 返回静态文件\n\n**优点**\n- 性能最好（几乎没有计算）\n- 成本最低\n- SEO 非常好\n- 稳定性强\n**缺点**\n- 内容更新不灵活\n- 构建时间可能很长\n**适用场景**\n- 博客\n- 文档站\n- 活动页\n- 内容更新不频繁的页面\n\n##### 4️⃣ ISR（Incremental Static Regeneration，增量静态生成）\n- **SSG + 按需重新生成**\n- 页面先用旧静态 HTML\n- 到达一定时间或触发条件后，在后台重新生成\n\n**特点**\n- 不阻塞用户请求\n- 兼顾性能和内容更新\n\n**一句话理解**： **ISR = 静态页面 + 后台悄悄更新**\n\n**适用场景**\n- 商品详情页\n- 新闻列表\n- 内容会变，但不要求实时\n\n#### 对比（面试最清晰）\n\n|模式|HTML 生成时机|首屏性能|SEO|服务器压力|适用场景|\n|---|---|---|---|---|---|\n|CSR|浏览器|❌ 慢|❌ 差|低|后台 / 强交互|\n|SSR|请求时|✅ 快|✅ 好|高|首页 / SEO|\n|SSG|构建时|🚀 极快|🚀 极好|极低|博客 / 文档|\n|ISR|构建 + 后台|🚀 快|🚀 好|低|商品 / 内容站|\n\n#### 总结：\nCSR 是在浏览器端通过 JS 渲染页面，首屏慢但交互灵活；  \nSSR 是在请求时由服务端生成 HTML，首屏和 SEO 更好，但需要水合，服务器压力较大；  \nSSG 在构建阶段生成静态 HTML，性能和稳定性最好，但内容更新不灵活；  \nISR 是在 SSG 基础上支持增量更新，兼顾性能和内容时效性。  \n实际工程中通常根据页面类型混合使用这些方案。\n\n\n#### SPA-MPA\n\nS**PA（Single Page Application）**\n- 整个应用只有一个 HTML\n- 页面切换通过 **前端路由**\n- 数据驱动视图更新，不发生整页刷新\n ✅ 优点\n- 页面切换快，体验接近 App    \n- 前后端分离清晰\n- 复杂交互和状态管理更友好\n⚠️ 缺点\n- 首屏依赖 JS，可能慢\n- SEO 不友好（需 SSR/预渲染）\n\n**MPA（Multi Page Application）**\n- 每个页面都是一个独立 HTML\n- 页面跳转会 **重新加载页面**\n- 服务端负责页面切换\n ✅ 优点\n- SEO 天然友好\n- 首屏快、结构简单\n ⚠️ 缺点\n- 页面跳转慢\n- 状态难共享\n\n适合 SPA\n- 后台管理系统\n- 复杂交互应用\n- Web App（重交互、重状态）\n适合 MPA\n- 官网 / 营销页\n- 内容型网站\n- SEO 要求高的场景\n\n|维度|SPA|MPA|\n|---|---|---|\n|页面结构|单一 HTML|多 HTML|\n|路由方式|前端路由|服务端路由|\n|页面跳转|不刷新|整页刷新|\n|状态管理|前端维护|页面级，刷新即丢|\n|首屏|可能慢|通常快|\n|后续交互|非常流畅|每次跳转慢|\n|SEO|较弱（需 SSR）|天然友好|\n|架构复杂度|高|低|",
          "hasAnswer": true
        },
        {
          "id": "open-questions-3",
          "title": "web worker & service worker",
          "content": "##### Web Workers 的工作原理和使用场景\n\nWeb Workers 是浏览器提供的**多线程解决方案**，允许在后台线程中运行 JavaScript 代码，避免阻塞主线程（UI 线程）。\n\n特点：\n\n- **没有 DOM 访问权限**：Worker 线程无法操作 `window`、`document`、`parent` 对象。\n    \n- **同源限制**：Worker 脚本文件必须与主页面同源。\n    \n- **通信机制**：主线程与 Worker 线程之间通过 `postMessage` 传递数据，通过 `onmessage` 监听。\n    \n- **独立上下文**：它有自己的全局对象 `self`，支持 `navigator`、`location`（只读）、`XMLHttpRequest` 和 `fetch`。\n\n分类：\n\n- 普通Web Worker (Dedicated Worker)： **不能**直接拦截网络请求，需要通过主线程代为请求。   \n    \n- **Shared Worker**：可以被多个窗口、iframe 或标签页共享（前提是同源）。\n    \n- **Service Worker**：拦截和处理网络请求，可以用来实现离线缓存、消息推送、后台同步，充当代理服务器。\n\n主要优势：\n\n- 提高用户体验：耗时计算放在后台，保证主界面流畅。\n    \n- 利用多核 CPU：现代浏览器可以将 Worker 调度到不同的 CPU 核心上并行执行。\n\n##### 解释什么是服务工作线程(Service Worker)，以及它可以如何帮助提高一个游戏网站的性能?\"\n\nservice worker是web worker的一种，Service Worker 脚本在后台运行，与网页的生命周期分离。它最强大的能力是拦截和处理流经它的网络请求，以及持久化存储的能力，这使得缓存控制和离线体验成为可能。\n\n关键能力：\n\n- **离线缓存 (Caching)：** 通过 `Cache Storage API` 控制缓存，实现“网络优先”或“缓存优先”等策略，使用户在离线时也能访问内容。\n    \n- **请求拦截：** 在 Service Worker 的 `fetch` 事件中，可以自定义如何响应网络请求（例如返回缓存、发送请求到网络、或返回自定义响应）。\n    \n- **消息推送 (Push Notification)：** 配合 Push API，在用户未打开页面时，也能接收服务器推送的消息。\n    \n- **后台同步 (Background Sync)：** 允许应用在离线时操作数据，待设备联网后自动进行同步。\n\n使用限制：\n\n- **必须在 HTTPS 环境下使用：** 为了安全考虑，Service Worker 只能在通过 HTTPS 提供的页面上注册和运行（本地开发环境的 `localhost` 除外）。\n    \n- **同源限制：** 只能控制相同源（协议、域名、端口）下的页面。\n    \n- **不能访问 DOM：** 与 Web Worker 一样，不能直接操作 DOM。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-4",
          "title": "不同来源的 API 的数据格式不同怎么统一",
          "content": "##### 有这样一个场景：如果你从多个系统的 API 拉数据，但这些系统的数据结构不一致，比如 A 系统返回 camelCase、B 系统是 snake_case，还有一些是中文 key，你怎么统一数据结构，来复用\n\n核心思想：在逻辑和外部 API 之间，建立一个专门负责转换的中间层——**适配器 (Adapter)**。每个外部系统都有一个专属的适配器，该适配器只负责：从外部系统获取数据 $\\rightarrow$ 将其转换成规范模型 $\\rightarrow$ 传递给你的应用核心逻辑。\n\n对于 **`camelCase` 和 `snake_case`** 之间的转换，可以使用成熟的库进行自动化处理\n\n对于中文 Key 或需要复杂的**业务值转换**，需要硬编码映射规则，维护一个 JSON 或 YAML **映射文件**",
          "hasAnswer": true
        },
        {
          "id": "open-questions-5",
          "title": "与外部协作场景",
          "content": "##### 如果要集成一个船上的摄像监控系统（第三方页面，但它不能改代码，只能iframe嵌进去，而且还要求根据用户权限控制展示内容，你会怎么处理\n\n方案1：通过代理服务器实现内容过滤，iframe嵌套后端路径，有权限时跳转，无权限时返回一个兜底\n\n方案2：利用 **第三方系统自身的 URL 参数** 进行控制，前提是第三方已有支持\n\n方案3：用前端遮罩进行视觉控制，只控制是否展示，内容有泄漏风险\n\n##### 提供给其他协作方的H5要注意什么？\n\n把它当成“可被集成的 SDK 页面”，核心目标：**可嵌、可控、可观测、可降级**。\n通用能力：参数、路由、权限、风控\n\n- **接入参数规范**：URL 参数建议只放“非敏感、可短期失效”的东西（例如 `scene, channel, traceId`），敏感数据走一次性 code 换 token。\n- **鉴权与防篡改**：可用 `签名 + 时间戳 + nonce`，避免参数被改导致越权。\n- **埋点与日志**：至少要有：\n    - 宿主信息（app/mini/iframe + 版本）\n    - traceId（贯穿宿主→H5→后端）\n    - 关键错误上报（JS error、资源加载失败、接口失败）\n- **资源与缓存**：公共 H5 一般需要更稳：\n    - 静态资源 hash + 长缓存\n    - HTML 短缓存或不缓存，避免发布后白屏\n    - Service Worker 谨慎：一旦宿主 WebView 缓存怪异，排查成本很高\n- **首屏与体积**：嵌套场景用户耐心更低，尽量：\n    - 关键路径代码拆分\n    - skeleton/占位\n    - 兜底页（加载失败可重试/反馈）\n- **样式隔离**：如果是 iframe 还好；如果是同页嵌入（微前端非 iframe），要做 CSS 隔离（BEM/前缀、Shadow DOM、css-modules）。\n\n##### 如果要写一个公共库需要考量哪些？比如模块化，打包，版本，暴露的参数方法，文档等等\n\n把公共库当“产品”来做，核心就是：**API 稳定、兼容可靠、发布可控、可维护**。\n\n A. 定位与边界\n- **这是工具库、组件库、还是 SDK（bridge/埋点/鉴权）？**\n- 明确：\n    - 负责什么、不负责什么\n    - 运行环境（浏览器/Node/小程序/React/Vue）\n    - 兼容范围（最低浏览器、WebView、React/Vue 版本）\n\n B. API 设计（最关键）\n- **稳定、少而精**：先设计“最小可用 API”，避免一次性暴露一堆未来要背兼容包袱的方法。\n- **输入输出要可预测**：参数默认值、错误场景、返回值结构固定。\n- **异步统一 Promise**：不要一会回调一会 Promise。\n- **错误处理**：明确错误类型（如 `ErrorCode`）、可观测（日志钩子、debug 开关）。\n- **可扩展性**：插件机制/中间件机制（比如拦截请求、注入自定义实现）。\n\n C. 模块化与产物形态（面向消费者）\n通常考虑这几种输出：\n- **ESM**：给现代构建（tree-shaking）\n- **CJS**：Node 或老构建\n- **UMD/IIFE**：直接 script 引入（可选）\n- **Types**：`.d.ts`（TS 项目必需）\n要考虑：\n- **Tree-shaking 友好**：尽量用具名导出、避免副作用（配置 `sideEffects: false` 或精确标注）。\n- **跨环境依赖**：避免在顶层直接引用 `window/document`（SSR 会炸），用惰性访问。\n\nD. 打包与依赖管理\n- 打包工具：Rollup / tsup / Vite library mode（都行，关键是产物正确）。\n- **external / peerDependencies**：\n    - React/Vue 这类大依赖通常放 `peerDependencies`，避免打进包导致重复实例。\n- **多入口**：按模块拆入口（`lib/core`, `lib/react`, `lib/vue`）降低体积。\n- **Polyfill 策略**：不要默认全量 polyfill；给出兼容说明或提供“compat 构建”。\n\n E. 版本与发布（SemVer）\n- **遵循 SemVer**：\n- **发布流程自动化**：\n    - changeset / conventional commits 自动生成 changelog\n    - CI 跑 lint/test/build，tag 后发布\n- **废弃策略**：API 要下线必须先 `deprecate`，给迁移期和替代方案。\n\nG. 文档与可用性\n- **README 不够**：至少要有：\n    - 快速开始（3 分钟跑通）\n    - API 文档（参数、返回、错误码）\n    - 示例（常见场景）\n    - 迁移指南（版本升级）\n- **示例项目 / playground**：真实接入更能暴露问题。\n- **变更日志**：每次发布要能让使用方快速判断“要不要升级”。\n\nH. 兼容与运行时保护\n- **feature detect** + fallback\n- 防御式编程：参数校验、空值处理、重复调用幂等\n- **避免全局污染**：尤其 UMD/IIFE，命名空间固定、可配置。\n\n\n##### 如何平衡暴露出的参数或者api的数量和复杂度？\n\n平衡“暴露多少 API/参数”和“复杂度”本质上是：**把变化隔离在库内部，把稳定点暴露给外部**。\n\n 1）先定“用户路径”，只为路径设计 API\n不要从“能力清单”出发（会越做越多），而是从**Top 3 接入场景**出发：\n- 80% 使用方只需要 1～2 步就能跑通（默认配置足够好）    \n- 只有少数高级场景才需要扩展点\n落地：先做主干 API，其余能力走扩展。\n\n 2）用“分层 API”控制复杂度：基础层稳定，高级层可选\n推荐三层：\n\t**L1：默认开箱即用（最少参数）**\n\t**L2：可配置但有限（参数有边界）**（参数数量控制在“人能读懂”的范围，比如 5～10 个以内）\n\t**L3：扩展点（不把所有开关都做成参数）**，而是通过插件/中间件/回调钩子，复杂能力通过“注入实现”而不是“堆参数”。\n\n 3）优先“聚合参数”而不是“散装开关”，当参数开始变多（>10）通常就该收敛：\n- 对一组相关参数打包\n- 用 `preset` 提供预设方案\n好处：**外部认知负担低**，内部还能不断演进。\n\n4）避免“布尔参数爆炸”，改成枚举/配置对象\n布尔开关特别容易无限增长，更好的方式是使用枚举或配置对象\n\n5）保持 API “可组合”，避免“万能函数”\n不要做一个 `request(url, {…几十个参数})` 试图覆盖全部场景。\n更好的思路：\n- 主函数只做核心能力\n- 辅助能力通过组合实现：\n\n6）用“数据驱动”决定是否暴露参数\n每增加一个参数，都要回答：\n- 这个需求出现频率高吗（>=20% 用户）？\n- 没这个参数能不能通过扩展点解决？\n- 这个参数未来会不会变（变就别暴露，做策略/插件）\n- 文档能不能用一句话说明白？说不清就说明太复杂\n**规则**：能内部推导的不要暴露；能通过注入实现的不要暴露成参数。\n\n我会用 **“默认好用 + 分层暴露 + 扩展点替代堆参数”** 来控制 API 数量：  \n**高频需求做成主干 API + 少量配置，低频和变化大的需求走插件/注入，不轻易增加布尔开关**。并通过 preset、策略对象、escape hatch 保证既简单又不失去扩展性。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-6",
          "title": "从零搭建和系统设计",
          "content": "##### 大型电商网站的架构，你会如何设计?考虑哪些问题如何解决\n\n高并发：忙绿兜底 下单锁 防刷\n\nSEO：ssr\n\nSKU复杂：SKU矩阵选择控件 库存变化要实时同步\n\n支付下单：流程复杂、强一致性要求高：必须 表单自动保存  交易失败兜底提示 幂等提交\n\n性能优化；OSS CDN \n\nA/B 测试、埋点\n\n安全\n\n##### 从0搭建一个内部脚手架项目\n\n##### 如果让你从零开始搭建一个大型电商网站的前端架构，你会如何设计?考虑哪些问题如何解决\n\n##### 如果让你从零开始搭建一个大型前端项目\n\n##### 设计一套全站点请求耗时统计工具\n\n##### 如果让你来你现在负责一个项目，有20+个页面，需求方经常改字段、加字段，你每次都要改组件，这个时候你怎么来设计\n\n思路：数据驱动渲染+配置化\n\n配置层：把字段抽象出一套配置文件\n\n业务组件和渲染逻辑层都不需要关心如何配置，而是根据配置自动化地应用\n\n##### 设计一个在线文档协同编辑的方案，需要考虑哪些技术点\n\n##### 设计一套全站点请求耗时统计工具\n\n##### 如何设计一个高可用的B端系统\n\n##### 如果要做一个拖拽式仪表盘Dashboard用户能自己拖拽、组合图表组件展示不同数据源的信息，你会怎么来设计这个系统\n\n我会把这个系统拆成四层：**布局层、组件层、数据层、权限与发布层**，保证既能拖拽搭建，又能稳定扩展。\n\n1) 布局层（Layout）\n   - Dashboard 的核心产物是一个 **Layout Schema**：  \n     记录每个卡片（Widget）的 `id、位置(x,y)、尺寸(w,h)、层级、响应式断点`。\n   - 前端用成熟的栅格拖拽方案（类似 react-grid-layout 这种思想）：拖拽只改 layout，不直接影响数据逻辑。\n   - 支持：对齐/吸附、最小尺寸、断点布局（desktop/tablet/mobile）。\n2) 组件层（Widget/图表物料）\n   - 每个图表是一个可注册的 Widget：  \n     `meta(配置面板schema) + render(运行时组件) + dataAdapter(数据适配器)`。\n   - 配置面板是 schema-driven：用户选指标、维度、过滤器、样式；平台把它存成 `widgetConfig`。\n   1) 数据层（Data Gateway + Query Model）\n   - 性能策略：\n   - 请求合并：同一数据源相同 query 做 dedupe\n   - 缓存：按 query key 缓存 + TTL\n   - 并发控制与取消：切过滤器时 cancel 旧请求\n   - 大表/高频：优先用聚合接口，必要时异步查询（返回 jobId 轮询）\n3) 权限与发布\n   - 权限到 dashboard / widget / 数据源 / 字段（必要时行级）。\n   - 支持“私有/团队共享/公开”，公开也走 token + 限流 + 脱敏策略。\n   - 可观测：每个 widget 的 query 耗时、失败率、命中缓存率，方便定位哪个卡片拖慢整页。\n\n这个系统的关键是把复杂度隔离：**布局只是布局、组件只是展示、数据统一走网关、权限和审计在服务端兜底**，这样才能扩展物料和数据源且不失控。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-7",
          "title": "低代码平台",
          "content": "#### 业界主流的实现思路和架构\n\n核心：Schema（DSL） → 编辑器（搭建器） → 运行时引擎（渲染 / 执行） → 扩展机制\n1. Schema / DSL 是什么？不是 JSX，不是模板，而是**纯配置化的 UI / 逻辑描述**。业界 Schema 通常覆盖 5 类：\n\tUI 结构：组件树、布局\n\t组件属性：props、样式、校验\n\t数据源：API、Mock、静态数据\n\t事件：点击、变更、提交\n\t逻辑：条件显隐、联动、流程\n2. 编辑器本质是什么？**一个“操作 Schema 的 UI”**\n\t- 增删改 Schema 节点\n\t- 改节点属性\n\t- 维护组件树结构\n\t常见的实现方式：左中右三栏布局，物料区+画布区+属性区\n\t注意：画布区，编辑时!=运行时\n\t- 组件有「选中态 / hover / 边框」\n\t- 支持拖拽排序（dnd-kit / react-dnd）\n\t- 支持插槽高亮、占位符\n\t业界成熟平台画布区一定是 **双渲染器**。\n\t- 编辑态要**辅助交互**\n\t- 运行态要**极致稳定和性能**\n\n3. 运行时引擎：低码平台的核心，目的：Schema 渲染成组件\n\t- 把 Schema 转成真实 UI（一棵真实的组件树）\n\t- 处理数据流、事件、联动逻辑，要把“页面数据”做成统一的模型\n\t\t- 数据初始化与合并（默认值、URL 参数、预加载数据）\n\t\t- 订阅与派发（哪些组件依赖哪些数据）\n\t- 标准化数据读取路径（`$page.xxx` / `$form.xxx` / `$ds.list.data`）\n\t- 动作系统：动作系统用来描述**用户交互触发的一整套行为流程**，把 schema action 编译/解释成可执行动作：提供动作执行的上下文 ctx（数据、组件引用、路由、权限、埋点）\n\n4. 扩展机制\n\t自定义组件\n\t自定义动作\n\t自定义表单校验\n\n架构：\n1. 编辑器(B端)一个项目，预览/运行时一个项目（最常见、最稳）\n\t- **B 端**：搭建器/编辑器（画布、属性面板、物料管理、权限、发布）\n\t- **运行时**：预览页 + 线上最终页面（同一套 runtime 包）\n\t- 集成方式（iframe / 微前端 / 直挂）\n\t- 优点：编辑器复杂度不会污染运行时；运行时可以做极致性能/体积优化；最利于保证一致性（预览和线上共用 runtime）；**C 端可以换壳**（Next.js / 小程序 / 原生 WebView），但**runtime/渲染引擎/物料协议最好一致**，否则样式/行为一致性很难保证。**\n\t- 缺点：工程上需要共享物料协议、版本管理更严格\n2. 全部一个项目（早期、团队小、迭代快）\n\t- 编辑器和预览都在一个前端项目里\n\t- 运行时作为一个模块被引用\n\t- 优点：开发简单、联调快  \n\t- 缺点：包会越来越大、边界容易糊、后期难维护\n\n#### 怎么保证“预览样式”和“最终生成页面”一致？\n\n核心原则：预览不要走“模拟渲染”，预览必须走“同一套运行时 + 同一份物料 + 同一份主题样式”。\n① 预览和线上共用同一个 Runtime 渲染器（最重要）\n② 物料（组件库）版本锁定：预览用哪个版本，线上就用哪个版本\n③ 主题与样式体系统一：Design Token / CSS 变量化\n\n预览和线上一致性的关键不是“截图对齐”，而是工程上保证它们**同源**：  \n**同一套 runtime、同一套物料版本、同一套主题 token、同一套基础样式和数据请求链路**。  \n只要把版本和环境锁住，一致性就可控。\n\n#### 有哪些性能瓶颈和核心难点\n\n瓶颈 1：Schema 解析 + 组件树构建过于频繁。\n- 节点很多（几百到上千）； props 多、表达式多；布局复杂（表格/表单/动态容器）\n- 如果每次 state 变动都从 root 重新 `render(schema)`，会导致页面频繁的重新渲染\n\n瓶颈2：表达式求值太多：表达式系统主要解决的是**配置里的“动态值”问题**，运行时需要在数据变化时**不断对这些表达式求值**，成熟平台一般会有 **依赖追踪和表达式缓存**\n- 每次 React render 都重新跑 N 个表达式\n- 表达式里还读深层对象、做过滤/排序\n- **解决方向**\n\t- 把表达式变成“计算属性”：依赖没变就不重算（memo）\n\t- 依赖追踪：只在依赖字段变化时更新\n\t- 表达式编译：字符串 → AST → 纯函数（避免重复 parse）\n\n瓶颈 3：数据更新粒度太粗（导致大面积重渲染）\n- 如果数据层是一个大 store，任何字段改动都触发全局订阅，那么：一个输入框 change → 整页组件都 rerender\n- **常用方案**\n\t- 分片 store：按作用域拆（page/form/ds）\n\t- 细粒度订阅：组件只订阅自己依赖的路径\n\t- 类似 mobx 的 derivation，或 proxy track（读取即收集）\n\n瓶颈 4：异步请求与联动风暴\n- 例如：A 字段 change → 触发 3 个请求 → 更新 5 个组件 → 又触发表达式 → 又触发请求…\n- **治理手段**\n\t- request 去重 / 取消（AbortController）\n\t- 防抖节流（输入联动必须）\n\t- “联动图”静态分析：避免循环依赖\n\t- 统一调度队列（batch updates）\n\n#### 为什么同一套 runtime 在 C 端会成为性能瓶颈\n\n线上 C 端确实不会频繁更新 Schema，但低码运行时真正高频变化的是数据层。  \n如果数据更新是粗粒度的，就会导致大量与本次变化无关的组件和表达式被重新计算，这个问题在联动多、表达式多的低码页面里会被成倍放大。\n前面讨论的那些“数据更新粒度粗导致的性能问题”，主要预设的是：  C 端是「复杂、强数据驱动」的页面。\n如果只是典型的活动页（展示为主、交互简单），**大多数情况下确实不会成为核心问题**。\n\n低码 C 端，其实分成两大类\n ① 强数据驱动型（最容易出问题）\n典型特征：\n- 表单多、字段联动多\n- Dashboard / 报表 / BI\n- 多数据源、实时/准实时刷新\n- 复杂条件显示 / 计算\n👉 **前面所有性能讨论，100% 针对这一类。**\n② 展示/活动页型（你说的场景）\n典型特征：\n- 内容以静态展示为主\n- 数据来源少（1–2 个接口）\n- 几乎无复杂联动\n- 交互偏简单（点击跳转、弹窗）\n👉 **这一类页面通常不会被“数据更新粒度”卡死。**\n\n#### 预览页面请求实际数据怎么做鉴权？\n\n配置端：\n**第一步：预览页本身先鉴权**\n- 平台内预览：B端复用公司的 SSO / 登录态（Cookie / OAuth token），预览路由需要登录。\n- 对外分享预览：用**一次性或短期有效的 Preview Token**，链接里带 token 或者扫码授权，且可随时撤销。\n第二步：**权限模型要到“资源级 / 字段级”**\n- 不是“能预览就能查所有数据”，而是按：应用/页面/组件/数据源/字段/行级规则（可选）授权。\n- 对外预览通常只给“只读 + 脱敏 + 限制范围（比如只看最近7天、只看聚合结果）”。\n**第三步：安全细节**\n- Token 短 TTL + 绑定场景（appId/pageId）+ 可撤销\n- 防重放：nonce / jti，必要时绑定 IP/UA（看业务）\n- CORS、CSRF、SameSite、HTTPS 必须到位\n- 全链路日志：谁在什么时候查了什么数据\n#### 业界开源平台或常用方案\n\n阿里 LowCode Engine：目前最“教科书级”的实现\n运行时具体怎么做？\n- Schema → React Element\n- 表达式：字符串表达式 + 运行时解析\n- 动作：事件 → Action Pipeline\n- 强插件化：几乎所有能力都可 Hook\n**优点**\n- 架构清晰\n- 引擎边界非常干净\n**缺点**\n- 表达式 / 动作偏“工程师友好”\n- 对纯业务方不够傻瓜\n\n业界主流低码平台本质都是 **Schema 驱动的运行时引擎**。  \n运行时负责三件核心事情：  \n**根据 Schema 渲染 UI、通过表达式系统做动态计算、通过动作系统执行用户行为。**\n\n成功的平台一般都选择“配置优先，但允许工程师兜底”。\n\n#### 低代码平台如何实现远程组件的动态加载?\n\n低代码平台实现远程加载组件，一般有三个方向：\n\n1. **按需异步加载**：将组件按功能或场景拆分成独立模块，打包成独立的 chunk，通过动态 import 或类似机制在真正使用组件时才加载。这种方式减少了初始包大小，提高加载性能。\n2. **组件独立打包为远程包**：将每个大型组件打包成单独的 npm 包或远程模块，组件之间耦合度低，更新和发布可以独立处理。在运行时，通过动态加载这些包实现按需渲染，保证低代码平台的灵活性和扩展性。\n3. **Webpack 模块联邦**：允许模块在运行时动态加载远程模块或微前端应用，实现模块之间的共享和独立打包。\n\n**总结**：核心思想是 **减少初始加载体积 + 动态按需获取组件**，既能保证性能，也便于扩展和维护。\n\n补充亮点\n- **缓存策略**：远程组件通常会结合浏览器缓存或 CDN，加快再次加载速度。\n- **版本管理**：低代码平台可能需要支持不同版本的组件远程加载，避免依赖冲突。典型做法：\n\t- 每个组件独立发布版本（npm 或私有 registry）\n\t- 通过版本号或 hash 动态加载，支持多版本共存\n- **安全性**：远程加载的组件需要做沙箱隔离，防止组件内部执行影响全局。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-8",
          "title": "前端存储",
          "content": "#### 对比说说前端存储 localStorage，sessionStorage，IndexDB，Cookie\n\n| 方案             | 容量（大概）            | 生命周期              | 是否随请求发送                 | 访问方式   | 性能/特征             | 典型用途           |\n| -------------- | ----------------- | ----------------- | ----------------------- | ------ | ----------------- | -------------- |\n| Cookie         | ~4KB/条（总量也有限）     | 可会话/可持久           | ✅ 同域请求自动带（受SameSite等影响） | 同步     | 小、开销大（会走网络）       | 登录会话、偏好（少量）    |\n| localStorage   | ~5MB-10MB         | 持久（手动清/配额）        | ❌                       | 同步     | API简单但**同步阻塞主线程** | 用户偏好、简单缓存      |\n| sessionStorage | ~5MB-10MB         | **Tab级会话**（关tab清） | ❌                       | 同步     | 同上，且隔离更强          | 表单草稿、一次会话状态    |\n| IndexedDB      | 通常几十MB~更大（看浏览器配额） | 持久                | ❌                       | **异步** | 结构化、可索引、适合大数据     | 离线数据、大列表、缓存、队列 |\n\n1) Cookie：它不是“存储”，更多是“协议层会话载体”\n- **会随 HTTP 请求自动发送**（同域/同路径/符合 SameSite 等时）\n- 容量小（4KB量级），且每次请求都带 → **增加网络开销**\n- 可以设置：\n    - `HttpOnly`：JS 读不到（防 XSS 窃取 cookie）\n    - `Secure`：只走 HTTPS\n    - `SameSite`：控制跨站携带，影响 CSRF 风险\n    - `Domain/Path/Expires/Max-Age`\n- 典型场景：**登录态 / session**（强烈推荐：HttpOnly + Secure + SameSite）\n\n2) localStorage：简单、粗暴、但同步阻塞\n- `key -> string`（只能存字符串）\n- **同步 API**：读写大数据会卡 UI（尤其移动端）\n- 同源共享：同一个 origin 下的所有 tab 共享\n- 会触发 `storage` 事件（别的 tab 修改时）\n- 典型场景：\n\t- 用户偏好（主题、语言）；\n\t- 小体积缓存（如最近搜索词）\n\t- 跨 tab 简单同步（利用 storage event）\n- 不适合\n\t- 大对象、大数组（序列化/反序列化慢） \n\t- 高频写入（每次输入都写会卡）\n\t- 存敏感 token（XSS 一偷一个准）\n\n3) sessionStorage：更“短命”的 localStorage（Tab 级）\n- 和 localStorage API 一样，同步阻塞 \n- **每个 tab 独立**（同源但不同 tab 不共享）\n- 关闭 tab 即清空（更适合临时态）\n- 典型场景\n\t- 多步骤表单的中间状态\n\t- 一次会话的临时数据（比如从 A 页带到 B 页但不想持久化）\n\t- 防止同站不同 tab 相互污染（隔离）\n\n4) IndexedDB：浏览器内置“本地数据库”，离线与大数据首选\n- **异步**（不阻塞主线程）\n- 存结构化数据：对象、数组、Blob、File\n- 支持索引、范围查询、游标（cursor）\n- 事务（transaction）保证一致性\n- 适合大数据量、离线、复杂查询\n- 典型场景\n\t- 离线 PWA（文章列表、消息、草稿）\n\t- 大量缓存（接口数据、搜索索引）\n\t- 上传队列（断网重试）、日志队列\n\t- “数百/数千项列表”的本地检索、分页\n\n其他：\n**Service Worker 内存 / 全局变量**：短期缓存（会重启，不可靠）\nCache Storage：更像“浏览器里的 HTTP 缓存可编程版”\n\n总结：\n需要随请求携带、服务端会话相关用 Cookie（HttpOnly/Secure/SameSite）；  \n简单小量配置用 localStorage/sessionStorage（注意同步阻塞）；  \n大量结构化数据和离线查询用 IndexedDB；  \n资源和接口响应的离线缓存用 Cache Storage + Service Worker。\n\n#### Token 到底放哪？\n\n面试官经常想听你的“安全取舍”。\n- **最稳（常见 Web 应用）**：\n    - **HttpOnly Cookie**\n    - 配合 `SameSite` + CSRF 防护\n    - XSS 也读不到 cookie（但仍要防 XSS，因为可以发起请求）\n\n- 不能用 cookie的架构，建议用双token：**Refresh Token+Access Token**\n\t- refresh token 放在 HttpOnly Cookie 里，JS 读不到，配合Secure SameSite\n\t- access token 只存在内存中，页面刷新即失效（攻击窗口最小），避免 XSS 直接窃取长期凭证\n#### PWA (Progressive Web Apps)是什么?它的核心技术有哪些\n\nPWA 是一种通过 Web 技术提供“接近原生 App 体验”的应用形态，核心目标是：可安装、可离线、可快速加载。\n\nPWA想解决什么问题？\n- Web：依赖网络; 首屏慢; 不能离线        \n- Native：开发成本高; 发布审核慢\n**PWA 试图在中间找平衡**\n\n核心技术：通过 Service Worker 结合Manifest，把 Web 应用增强为可离线、可安装的形态，适合内容型和轻交互应用，但在系统能力上仍弱于原生。\n\n① Service Worker（核心中的核心）\n- 运行在浏览器后台线程\n- 拦截网络请求\n- 控制缓存策略\n- 支持离线\n- Service Worker **必须 HTTPS **，防中间人攻击，保证缓存可信\n②Web App Manifest\n- 一个 `manifest.json`\n- 定义：\n    - 应用名\n    - 图标\n    - 启动页\n    - 显示模式（standalone）",
          "hasAnswer": true
        },
        {
          "id": "open-questions-9",
          "title": "前端调试和单测",
          "content": "#### 说说常用的chrome调试工具，具体怎么用 \n\n常用的 DevTools 主要有：Elements / Console / Sources / Network / Performance / Application /Memory\n\n**Elements（查样式、定位布局问题）**\n- **选元素**\n- **查样式覆盖链路**：Styles 里看哪条规则生效/被划线，点规则跳到来源文件。\n- **强制状态**：`:hov` 强制 hover/active/focus，复现交互样式问题。\n- **改 DOM/样式做验证**：临时改 class/style 验证方案可行，再回代码修复。\n\n**Console（看日志、现场验证表达式）**\n- **过滤日志**：按 level/关键字过滤，快速找到报错链路。\n- **抓 DOM**：`$0` 代表当前选中元素，`$()`/`$$()` 快速 query。\n- **监控事件**：`monitorEvents(node, 'click')` 临时监控事件触发（排查重复绑定/冒泡问题）。\n\n**Sources（断点、单步、定位是谁改了数据）**\n- **Source map**：确保线上/本地 sourcemap 正常，能从 bundle 映射回源码。\n- **断点**：行断点、条件断点（例如 `id === xxx` 才停）、`logpoint`（不改代码直接打印）。\n- **异步栈**：开启 async stack traces，排查 Promise/async 调用链。 \n- **XHR/Fetch 断点**：对某个接口 URL 设置断点，接口一发就停，查是谁触发的请求。\n- **Event Listener Breakpoints**：勾选 `click`/`keydown` 等，事件一触发就停，查是谁绑的、为什么触发多次。\n\n**Network（接口、缓存、跨域、性能）**\n- **保留日志 & 禁用缓存**：勾 `Preserve log`（避免跳转丢请求），开发排查勾 `Disable cache`。\n- **看请求构成**：Headers/Query/Payload/Response，重点：请求头、cookie、CORS、返回码。\n- **看耗时**：Timing 里 DNS/TCP/TTFB/Content download，判断是后端慢还是前端阻塞。\n- **模拟弱网和低端机**\n- **缓存策略**：看 `from memory cache / from disk cache`、`cache-control/etag`，排查“明明改了但没生效”。\n\n**Performance（卡顿、长任务、掉帧）**\n- **录制一次操作**：录制→做一次交互→停止，找 Main 线程长任务（Long Task）和 layout/recalc style。\n- **看火焰图**：确认时间花在哪：脚本执行、布局、绘制、合成。\n- **定位 React/Vue 渲染问题**：配合框架 DevTools（React Profiler / Vue devtools）一起看 commit、重复渲染、组件耗时。\n\n**Application（存储、SW、PWA、缓存）**\n- **Storage**：LocalStorage/SessionStorage/IndexedDB/Cookies，排查登录态、缓存数据是否污染。\n- **Clear site data**：一键清站点数据，快速验证“是不是缓存导致的问题”。\n\n**Memory（内存泄漏/频繁 GC）**\n- **Heap snapshot**：对比快照，找 detached DOM、事件监听未解绑。\n\n 面试里可以补一句“排查路径”：**Network 定位请求→Console 看报错→Sources 断点定位逻辑→Elements 验证 DOM/CSS→Performance 看卡顿→Application/Memory 查缓存/泄漏**。\n\n#### 平时开发中怎么进行自测？写不写单测\n\n开发中自测一般分三层：**功能正确性、边界与异常、线上一致性**，尽量用“可复现步骤 + 可观测指标”把问题提前暴露。\n\n**功能正确性**\n- 按需求 checklist 逐条走：主流程、关键交互、表单校验、空态/加载态/错误态。\n- 控制台无报错、埋点/日志关键字段符合预期（比如上报参数、跳转参数）。\n\n**边界与异常**\n- 弱网/超时/500/重试：Network 里模拟慢网，或用 mock 返回不同 code，确保 UI 有兜底。\n- 极端数据：空数组、超长文本、超大列表、特殊字符、时间/时区问题。\n- 权限与登录态：cookie 失效、无权限、token 刷新等。\n\n**线上一致性**\n- 对齐环境配置：域名、灰度开关、feature flag、缓存策略（disable cache 复现）。\n- 多端验证：至少 Chrome + Safari（Mac），移动端用真机/模拟器看触控和字体渲染。\n\n**关于单测：写，但看模块类型**\n- **会写单测**，但不追求“为写而写”。我通常把单测优先放在：\n    1. **纯函数/工具函数**（格式化、计算、解析）\n    2. **复杂业务规则**（价格/权限/状态机）\n    3. **容易回归的公共组件**（表单组件、表格组件）\n- UI 强依赖样式、频繁变动的页面，可能更多用 **集成测试/E2E** 或 Storybook 回归，而不是堆大量脆弱的快照。\n\n#### 怎么看待前端单测？了解哪些库\n\n**怎么看待**\n- 单测的价值主要是：**防回归、提升重构信心、降低联调成本**。特别是多人协作和组件库/平台型项目，收益很明显。\n- 但单测也有成本：**写/维护时间、测试脆弱性（尤其是实现细节驱动的测试）**。所以我倾向于：\n    - **测行为，不测实现**（不强依赖内部 state/私有方法）\n    - 优先覆盖 **稳定的业务规则** 和 **高风险模块**\n    - 控制投入产出：关键路径 + 易错边界 > 追求 100% 覆盖率\n\n**了解/使用的库（按场景）**\n- **测试框架/运行器**：Jest、Vitest（Vite 项目更顺手，速度快）\n- **断言库**：Jest expect、Chai（不一定单独用）\n- **组件测试**：\n    - React：React Testing Library（RTL）+ user-event（更贴近用户行为）\n    - Vue：Vue Test Utils + Testing Library/Vitest\n    - Enzyme（了解，偏旧，更多测实现细节）\n- **E2E**：Cypress、Playwright（Playwright 多浏览器更强，适合关键链路回归）\n- **Mock**：\n    - MSW（拦截 fetch/xhr，做“更接近真实网络”的 mock）\n    - nock（Node 环境接口 mock，了解即可）\n- **覆盖率**：istanbul（Jest/Vitest 集成）\n- **补充**：Storybook + interaction test / visual regression（了解，有条件时用于组件回归）",
          "hasAnswer": true
        },
        {
          "id": "open-questions-10",
          "title": "前端通信",
          "content": "1. `postMessage`（最通用、跨域 iframe 必会）\n适用：必须拿到对方 window 引用（open 的返回值、iframe.contentWindow、opener、parent 等）。\n- 父页面 ↔ iframe\n- A tab ↔ B tab（window.open 得到引用）\n- **跨域**也可以（这是它最大价值）\n核心机制\n- `otherWindow.postMessage(message, targetOrigin)`\n- 目标窗口 `window.addEventListener('message', handler)`\n缺点/坑\n- **安全**：必须校验 `event.origin` + `event.source`\n- `targetOrigin` 不要乱写 `'*'`（除非你同时严格校验 origin）\n- 复杂场景要做握手/心跳等\n\n 2. `MessageChannel`（“高频双向专线”，常配合 postMessage）\n适用\n- **像“socket”的双向通信**\n- 需要**把通道转交**给 iframe/worker（更干净的隔离）\n- 消息量大、希望避免全局 message 事件混乱 \n核心机制\n- `const channel = new MessageChannel()`\n- `channel.port1` / `channel.port2`\n- 把 `port2` 通过 `postMessage` 传给对方（transferable）\n优点\n- 通信通道是“私有的”，不跟全局 message 混在一起\n- 结构更清晰，适合封装 RPC\n缺点/坑\n- 仍然要靠 `postMessage` 去“交付端口”\n- 需要管理 port 生命周期（关闭、重连）\n\n3. `localStorage`（严格说它不是通信 API，但能“广播”）\n这里指的是：**localStorage + storage 事件**。\n当成“事件总线”用没问题，但只适合低频、幂等的状态同步，不适合高频实时消息。\n适用\n- **同源** 多 Tab 之间的低频同步    \n- 简单事件通知：登录态变化、主题切换、登出\n机制\n- A tab `localStorage.setItem(key, value)`\n- B tab 触发 `window.addEventListener('storage', ...)`\n优点\n- 非常简单\n- 兼容好\n缺点/坑（重要）\n- **同一个 tab不会触发 storage 事件**（只在其他文档触发）\n- 写入是同步的，频繁写会卡\n- 容量小、只支持字符串\n- 事件可能丢（你写得太快、只保留最后一次值）\n\n4. URL 参数 + 监听 URL 变化（“可分享状态”）\n这里其实分两类：`hash` 和 `history`。\n适用\n- 需要**可复制链接、可回放**的状态：筛选条件、分页、tab、搜索关键词\n- iframe 里跟父页面共享“状态”也可以（但通常同源更方便）\n监听方式\n- `hashchange`：监听 `location.hash` 变化\n- `popstate`：监听浏览器前进/后退引起的 history 变化\n- 如果你用 `pushState/replaceState`，要么自己封装事件，要么依赖框架路由\n优点\n- 状态天然可分享、可刷新恢复\n- SEO/可观测性更好（视情况）\n缺点/坑\n- 不是实时通信，只适合“状态同步”\n- 参数暴露在 URL：别放敏感信息\n- URL 长度限制（不要塞大 JSON）\n- 跨域 iframe 控制父 URL 受限（同源策略）\n\n4. `BroadcastChannel` **同源的发布-订阅广播通道。** （同源多 Tab 广播首选） \n同一个 origin 下：\n- 多个 Tab\n- 多个 iframe\n- 同源 worker  \n都能加入一个 channel，并互相广播消息。\n特点\n- API 比 localStorage 事件更像真正的消息系统\n- 适合：实时通知、协同、状态广播\n缺点：部分老环境兼容性略差（但现代浏览器基本 OK）\n\n5. `SharedWorker`\n- 多个 Tab 共享一个 worker 实例，天然“中枢”\n- 适合：多 Tab 共享 websocket 连接、共享缓存/状态\n- 缺点：兼容性、复杂度更高\n\n\n总结：\n1. **跨窗口/跨域 iframe 通信首选：`postMessage`**\n    \n2. **需要“高频双向、可建立专用通道”：`MessageChannel` + `postMessage` 传端口**\n    \n3. **同源多 Tab 广播：`BroadcastChannel`**\n    \n4. **同源多 Tab 低频同步：`localStorage` 的 `storage` 事件**\n    \n5. **需要把状态放进 URL（可分享/可回放）：URL 参数（或 hash）**\n    \n6. **需要更强的后台能力/离线：Service Worker / SharedWorker",
          "hasAnswer": true
        },
        {
          "id": "open-questions-11",
          "title": "前端鉴权的几种方式和优缺点",
          "content": "##### Session-Cookie 鉴权（传统主流）\n\n这是最经典的“有状态”鉴权方式。\n\n- **流程**：用户登录成功，服务器创建一个 **Session** 记录并存储在内存/Redis中，同时向浏览器返回一个包含 `SessionID` 的 **Cookie**。后续请求浏览器会自动带上该 Cookie。\n    \n- **优点**：\n    \n    - **安全性高**：敏感数据存在服务端，Cookie 设置 `HttpOnly` 可防 XSS。\n        \n    - **可控性强**：服务端可以随时销毁 Session 强制用户下线。\n        \n- **缺点**：\n    \n    - **扩展性差**：多台服务器时需要做 Session 共享（如同步到 Redis），否则负载均衡会导致登录失效。\n        \n    - **跨端不友好**：原生 App 或小程序对 Cookie 的支持不如浏览器。\n        \n    - **CSRF 风险**：因为依赖 Cookie 自动携带，容易受到 CSRF 攻击。\n\n##### OAuth 2.0 (第三方授权)\n\n这通常用于“第三方登录”（如微信、GitHub 登录）或分布式系统间的权限委派。\n\n- **流程**：\n    1. 用户向授权服务器申请授权。\n    2. 授权服务器返回 **Code (授权码)**。\n    3. 后端用 Code 换取 **Access Token**。\n- **优点**：\n    - **安全性**：用户不需要将密码交给第三方应用。\n    - **细粒度**：可以控制只授权读取头像、不授权发动态等权限。\n- **缺点**：\n    - **逻辑复杂**：需要多次跳转和 Code 换 Token 的过程。\n\n##### SSO (Single Sign-On, 单点登录)\n\n解决“一个公司有多个子系统，登录一次即可访问所有”的需求。\n\n- **实现方式**：\n    \n    - **同父域**：通过设置 Cookie 的 `Domain` 为父域名（如 `.baidu.com`），让子域共享 Cookie。\n        \n    - **跨域**：使用 CAS (Central Authentication Service) 模式。用户重定向到独立的 **认证中心**，登录后携带 Ticket 回跳。\n        \n- **优点**：提升用户体验，统一管理账号。\n    \n- **缺点**：认证中心一旦宕机，所有关联系统全部瘫痪（单点故障）。\n\n#####  JWT (JSON Web Token)？\n\n**J这是“无状态”鉴权的代表，非常适合前后端分离及分布式架构。\n\n- **结构：** 它由三部分组成：`Header`（算法信息）、`Payload`（用户信息，如 user_id）、`Signature`（签名，防止篡改）。\n- **存储：** 前端拿到后，通常不存在 Cookie 里，而是存在 `localStorage` 或 `sessionStorage` 中。\n- **传递：** 发请求时，前端手动把它塞进 HTTP Header 的 `Authorization` 字段里（例如：`Authorization: Bearer <token>`）\n\n##### 为什么 JWT 天然免疫 CSRF？\n\n**原因很简单：CSRF 攻击靠的是浏览器的“自动带 Cookie”机制。**\n\n- **Cookie 机制：** 它是浏览器的**原生行为**。不管你愿意不愿意，只要地址匹配，浏览器就自动帮你贴上 Cookie。黑客就是利用这种“自动”来完成攻击。\n    \n- **JWT 机制：** 它是**手动行为**。存在 `localStorage` 里的 JWT，浏览器绝对不会自动帮你带在 Header 里。必须由你（开发者）写代码 `headers: { 'Authorization': token }` 才能带上去。\n\n当用户点击黑客的 `a.com` 诱导链接时，黑客的脚本无法读取你 `b.com` 域名下的 `localStorage`（受同源策略保护），且浏览器不会自动给跨站请求加上 `Authorization` 头。**既然请求里没有 Token，服务器就会直接拒绝，CSRF 攻击就此失效。**\n\n#### JWT vs Cookie (Session) 深度对比\n\n| **维度**      | **Cookie + Session (传统)**      | **JWT (现代)**                 |\n| ----------- | ------------------------------ | ---------------------------- |\n| **存储位置**    | 服务器存 Session，客户端存 Cookie       | 服务器不存（无状态），客户端存 Token        |\n| **CSRF 防护** | **风险高**，需额外配合 Token 或 SameSite | **天然免疫**，因为不依赖浏览器自动行为        |\n| **水平扩展**    | 较难（多台服务器需要共享 Session）          | **非常容易**（服务器只要有密钥就能解密 Token） |\n| **时效性**     | 可以在服务端随时注销                     | 一旦签发，很难在有效期内提前作废             |\n#### JWT 就绝对安全了吗？（新的挑战）\n\n虽然 JWT 解决了 CSRF，但它引入了新的风险：**XSS 风险。**\n\n- **风险点：** 如果你的页面有 XSS 漏洞，黑客可以运行 JS 代码 `localStorage.getItem('token')`。一旦 Token 被偷走，黑客可以在任何地方冒充你。\n    \n- **对比：** Cookie 如果设置了 `HttpOnly`，JS 是读不到的，所以 Cookie 在防范 XSS 偷取凭证方面比 JWT 强。\n\n#### JWT进阶：双令牌机制 (Access Token + Refresh Token)\n\n**双令牌机制**（Dual Token Mechanism）是为了解决 JWT（JSON Web Token）的一个核心矛盾：**“安全性”与“用户体验”的博弈。**\n\n**双令牌机制的本质**：把“验证频率”和“登录频率”拆分开。\n\n| **令牌名称**                 | **作用**                                   | **有效期**           | **存储位置建议**                       |\n| ------------------------ | ---------------------------------------- | ----------------- | -------------------------------- |\n| **Access Token** (访问令牌)  | 真正的“通行证”，每次请求都携带。安全性高，即使被盗也很快失效。         | **短**（如 15-30 分钟） | 内存 (Vuex/Pinia) 或 SessionStorage |\n| **Refresh Token** (刷新令牌) | 专门用来换取新的 Access Token。只在刷新时才发送一次，暴露频率极低。 | **长**（如 7-14 天）   | LocalStorage 或 HttpOnly Cookie   |\n\n工作流程（无感续期）\n1. **用户登录**：服务端返回两个 Token：`accessToken` 和 `refreshToken`。\n2. **正常访问**：前端将 `accessToken` 放在 Header 里请求数据，后端验证通过。\n3. **令牌过期**：\n    - `accessToken` 过期，后端返回 **401 Unauthorized**（或特定错误码）。\n4. **无感刷新**：\n    - 前端拦截到 401 错误，**不跳转登录页**。\n    - 前端自动发起一个隐藏请求，携带 `refreshToken` 访问“刷新接口”。\n    - 服务端验证 `refreshToken` 有效，颁发一个新的 `accessToken` 给前端。\n5. **重新请求**：前端用新的 `accessToken` 重新发起刚才失败的那个业务请求。用户完全感觉不到中途发生了令牌置换。\n#### 如果 refresh token 也失效了，但你这时挂起了一堆请求，刷新失败了，怎么处理\n\n当 Refresh Token 也失效时，意味着用户必须重新登录。此时核心问题是挂起的一堆请求如何在刷新登录后重试，方案是用一个全局的 **刷新锁** 和一个 **请求队列**。\n\n#### 工程上怎么选登录方案？\n\n- **Session-Cookie**：最成熟，安全性高，但对分布式系统不友好，且存在 CSRF 风险。需要配合 `HttpOnly`、`Secure`、`SameSite=Lax` 以及 `CSRF Token`，全方位防护。\n\n- **JWT**：目前最流行，它是无状态的，易于横向扩展，适合跨端，但要注意 XSS 防护以及 Token 吊销的问题。尤其 **移动端 (App / 小程序)** 首选 **JWT**。因为 App 没有浏览器的 Cookie 限制，JWT 跨域和扩展性极强。\n\n- **OAuth 2.0**：主要用于授权，是实现第三方登录的标准。\n\n- **SSO**：解决多系统间的统一登录问题。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-12",
          "title": "国际化和本地化",
          "content": "##### 前端国际化 主要解决 5 件事：\n\n1. 文案翻译（自己维护的多语言文案资源文件），一般按语言分文件或者按模块分文件\n2. 日期/时间/数字/货币格式（本地化格式）一般用第三方库比如 Intl\n3. 路由与 SEO（多语言 URL、hreflang、索引）\n4. 资源加载与性能（按需加载语言包、缓存、回退）\n##### 工具：i18n vs l10n\n\n- **i18n（internationalization）**：把系统改造成“可支持多语言/多地区”的能力（抽取文案、格式化、路由、字体等）\n    \n- **l10n（localization）**：把具体语言/地区资源补齐（翻译、校对、区域格式、货币、时间、法律合规）\n\n##### 语言选择与回退策略（必须有）\n- 语言来源优先级（常用）：\n    1. URL（`/en/...`）或域名（`en.xxx.com`）\n    2. 用户设置（profile）\n    3. 浏览器 `Accept-Language`\n    4. 默认语言（比如 `en`）\n- 回退策略：\n    - `zh-HK` 找不到 → 回退 `zh` → 回退 `en`\n##### 路由与 SEO（Next.js/SSR 项目重点）\n URL 策略（常见 3 种）\n1. **路径前缀**：`/en/about`, `/zh-CN/about`（最常用，SEO 友好）\n2. **子域名**：`en.example.com`（更像国际站）\n3. **参数**：`?lang=en`（SEO 最差，通常不选）\nSEO 必做\n- `<link rel=\"alternate\" hreflang=\"...\">`    \n- canonical 规范化\n- sitemap 按语言输出\n\n##### 性能：语言包怎么加载（高频追问）\n小项目：全量加载也行\n- 语言包很小（几十 KB），一次加载搞定\n中大型：按需加载（推荐）\n- 按语言 + 按页面 namespace 分包\n- 路由切换时动态 import：\n    - 首屏只加载当前语言的必要 namespace\n    - 其他页面进入再加载\n缓存\n- 语言包可走静态资源缓存（hash 文件名）\n\n##### 总结\n前端做国际化会先确定语言来源优先级（URL/用户设置/浏览器/默认）和回退策略，然后把文案抽成多语言资源文件，提供统一的 `t()` 翻译函数，支持插值、复数、namespace。日期数字货币用 `Intl` 做本地化格式化。中大型项目会做语言包按需加载和缓存，并结合 lint/CI 检测缺失 key 与硬编码文案。SSR/Next.js 场景会用多语言路由并补齐 hreflang、sitemap，保证 SEO 和首屏一致性。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-13",
          "title": "大文件&长列表&大数据&频繁计算等优化场景",
          "content": "#### 大文件上传\n\n大文件上传核心是 4 件事：**分片、断点续传、并发控制、秒传/校验**，再加上**服务端合并与校验**。\n1. 分片上传（Chunk Upload）\n\t- 前端把文件切片：`Blob.slice(start,end)`\n\t- 每片带上：`fileId/hash + chunkIndex + chunkSize + totalChunks`\n\t- 服务端每片落盘（或对象存储 multipart upload），记录已上传分片。\n\t- **好处：**\n\t\t- 网络抖动只重传少量片\n\t\t- 可并发提升吞吐\n2. 断点续传\n\t- 上传前先请求服务端：`GET /upload/status?fileId=xxx`\n\t- 服务端返回已存在的 chunkIndex 列表\n\t- 前端跳过已传分片，只补缺口\n 3. 秒传（去重）\n\t- 计算文件 hash（通常用 spark-md5 / wasm）：\n\t    - 大文件不要一次性读入内存，**分片增量算 hash**\n\t- 先问服务端：`POST /upload/exists {hash}`\n\t- 服务端如果已存在，直接返回文件 URL / fileKey，前端秒完成\n4. 并发与重试（非常容易被问）\n\t- 并发通常 3~6（看带宽与服务端限制）\n\t- 失败分片指数退避重试\n\t- 支持暂停/继续（中断 fetch / XHR，保存状态）\n5. 服务端合并与校验（很多人只讲前端）\n\t- 合并顺序：按 chunkIndex 串行写入\n\t- 合并完必须校验：\n\t    - 合并后的 hash 与客户端 hash 一致\n\t- 合并后清理临时分片\n6. 进度条怎么做（加分）\n\t- 分片上传进度 = 已完成分片数 / total\n\t- 更精细：每片用 XHR `upload.onprogress` 汇总（fetch 不好拿上传进度）\n#### 长列表渲染\n\n长列表性能瓶颈是：**DOM 数量、布局/重排、重绘、JS 计算与事件处理**。解决就是：**虚拟列表 + 稳定高度 + 渐进渲染**。\n1. 虚拟列表（Virtualization）只渲染可视区 + buffer：\n\t- React：react-window / react-virtualized\n\t- Vue：vue-virtual-scroller\n\t- 原理：容器撑起总高度；只渲染 start~end 的 items；用 translateY 定位\n2. 高度不固定怎么办？两种策略：\n\t- **估算高度 + 动态修正**（测量后更新偏移）\n\t- **分组/锚点**（按块维护前缀和，降低重算成本）\n3. 交互与更新优化\n\t- item 组件 `memo` / `PureComponent`\n\t- key 必须稳定（不要用 index）\n\t- 滚动事件节流，避免每帧 setState\n\t- 减少复杂样式（阴影、滤镜）和图片布局抖动\n4. 进一步优化（加分）\n\t- **窗口化 + 分页/增量加载**（infinite scroll）\n\t- 首屏优先：先渲染前 N 个，后面 idle time 再补\n\t- 大量图片：懒加载 + 低清占位（LQIP）\n#### 如果你有一个含有数百个项目的数组，你将如何有效地搜索特定项目?\n\n1. 一次性查找 / 查得不频繁\n- 直接 `Array.find` / `for` 即可：O(n)\n- “数百”其实很小，过度优化反而复杂\n**面试口径：** 如果只是偶尔查找，线性扫描就够了，代码简单且可维护。\n\n2. 频繁查询（比如输入框实时搜索）\n\n做索引：\n ① 按 id 精确查：Map\n ② 按字段检索：倒排索引（关键词→id 列表）\n- 适用于 tags / 多关键字匹配\n ③ 前缀搜索：Trie（前缀树）：适用于“搜用户昵称/商品名”这种前缀匹配\n ④ 模糊搜索：第三方库比如 fuse.js（加分）：小数据量直接 fuse.js，非常工程化\n#### 如果现在一个页面要同时展示 300 辆车的实时位置+轨迹，你怎么来优化\n\n数据层面+渲染层面\n\n数据：后续更新只传输增量变化的字段\n\n渲染：分区绘制/懒加载；WebGL/Canvas 渲染；前端聚合（在地图缩放级别较低时，将前端可见的密集点聚合成一个集群图标）；动画优化GPU加速和requestAnimationFrame\n\n**最佳实践组合：** 在后端实现 **视窗过滤** 和 **轨迹简化**，并使用 **WebSocket** 推送增量位置数据。在前端，使用 **WebGL 地图库** (如 Mapbox GL JS) 进行高性能渲染。\n\n\n#### js写倒计时组件代码，长时间怎么解决误差，如果页面需要大量倒计时组件，怎么优化？\n\n1. 误差：\n- 不要用自减计数，因为 `setInterval` 会漂移（后台 tab、主线程忙、定时器 clamp）。正确思路：基于“目标时间戳”计算差值，这样即使定时器延迟 5 秒，下一次也会立刻校正。\n\t- 记录 `endAt = Date.now() + duration`\n\t- 每次 tick 用 `endAt - Date.now()` 计算剩余\n\t- UI 显示取 `Math.max(0, diff)`，再格式化\n- 不复杂的情况，可以减小 setInterval 的时间间隔，通过高频检查降低误差\n- 用 `performance.now()` 做相对计时更稳定（但跨刷新要落到 Date.now）\n- 服务端时间：如果要求对齐服务器（如抢购），做一次 `serverTimeOffset = serverNow - clientNow`\n- 用requestAnimationFrame实现setTimeout，参数timestamp用来计算时间\n\n2. 大量倒计时\n\t核心原则：**不要 N 个组件各自 setInterval**。  \n\t要做**单一时钟源 + 批量订阅 + 按需渲染**。\n\t\n\t1：全局单例 ticker（推荐）\n\t- 页面只有一个 timer（比如 250ms 或 1000ms）\n\t- 所有倒计时订阅它\n\t- 每次 tick 统一计算并分发\n\t好处：\n\t- 定时器数量从 N → 1\n\t- 主线程压力大幅下降\n\t\n\t2：按可见区域更新\n\t- 列表里的倒计时：配合虚拟列表，只更新可见项\n\t- 或 IntersectionObserver：不可见的倒计时暂停更新\n\t\n\t3：降低刷新频率\n\t- UI 只显示“秒”，就没必要 250ms 更新，1s 足够\n\t- Tab 不可见时（`visibilitychange`）降频到 5s 或暂停\n\t\n\t4：减少 React/Vue 重渲染（框架场景）\n\t- 倒计时变化频繁，避免触发整行 item 重渲染：\n\t    - 把倒计时显示拆成最小组件\n\t    - memo / computed 缓存\n\t    - 只更新 text node（极端优化）",
          "hasAnswer": true
        },
        {
          "id": "open-questions-14",
          "title": "微前端",
          "content": "##### 解决：\n多团队共同维护一个大前端项目时，不同团队之前各自维护不同的模块，互相之间又有少量依赖的场景，如何保证项目的长期维护和迭代\n\n##### 技术难点：\n样式隔离，JavaScript 隔离，路由管理和应用切换，公共依赖的打包和互相引用、应用之间事件和数据传输。包括两个角色，主应用和子应用\n\n1. 样式隔离：CSS Modules+CSS-in-JS\n\n2. js隔离：所有微应用共享全局环境（`window` 对象），如果微应用 A 在全局对象上挂载了变量，微应用 B 可能会意外使用或覆盖它。主流方案是：利用 ES6 的 `Proxy` 对象劫持对 `window` 对象的访问。微应用对 `window` 的读写操作都被 `Proxy` 拦截，读操作从全局 `window` 读取，写操作写入到**当前微应用自己的代理对象**中，从而隔离了对真实全局 `window` 的污染\n\n3. 路由管理和应用切换：路由切换时，主应用能正确加载/卸载对应的微应用，并保持 URL 同步。监听 `hashchange` 或 `popstate` 事件，匹配路由，加载/卸载模块\n\n4. 公共依赖：避免每个微应用都打包相同的库。方案两个方向，1是子应用不处理外部模块的打包，主应用负责加载公共包，2是webpack5的联邦模块，允许应用 A **暴露**其内部的模块（如 React 库）给应用 B **消费**，实现真正的运行时共享\n\n5. 事件和数据传输：发布订阅模式/基于全局状态管理\n\n##### 业界常见实现方案：\n\n1. Qiankun：上手难度低，做了css  js隔离，有完整的生命周期钩子，支持多种技术栈。核心是沙箱机制和生命周期管理\n\n2. single-spa：核心作用是作为一个应用路由器（Application Router）和生命周期管理器\n\n3. 联邦模块 (Webpack 5)，只用来处理公共依赖包的情况\n\n**最佳实践**通常是：**使用 Qiankun 或 Single-SPA 来管理应用的隔离和生命周期，同时使用 Webpack 联邦模块来优化公共依赖和公共组件的加载性能。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-15",
          "title": "性能优化",
          "content": "##### 针对框架的性能优化\n\nreact 核心：减少“不必要的渲染”和“昂贵的计算”\n\n- `useMemo/useCallback`结合React.memo 避免重计算/避免传递函数导致子组件变化\n-  useTransition 把非紧急更新降优先级（搜索/筛选）；  useDeferredValue 输入不被卡住\n- `useEffect` 依赖正确，避免重复订阅/重复计算\n- 慎用 Context 当全局状态：一个字段变动导致全量 consumer 更新\n- 列表 key 必须稳定（避免 index）\n\nvue 核心：减少“响应式追踪开销”和“无意义更新”\n\n- `shallowRef/shallowReactive`：大对象只关心顶层变动\n- 避免把“不会变化的大数据”做成深度响应式\n- 用 `computed` 替代模板里的复杂表达式\n- 少用深度 watch；必要时用精确依赖\n- watchEffect 注意依赖收集范围，别把无关的也收进去\n\n##### 代码层面的\n\n1) 渲染/布局\n\t- 避免频繁触发布局：读写 DOM 分离（先读后写）\n\t- 动画优先用 `transform/opacity`（减少 layout）\n\t- 减少大阴影/滤镜（GPU/合成开销）\n\t- 静态资源优化比如压缩、webp等\n\t- 长列表考虑虚拟列表\n2) 计算与数据结构\n\t- 重计算做缓存（memoization）、增量更新（diff）\n\t- 大量查找用 Map/Set 建索引\n\t- 避免复杂的计算（比如 嵌套循环、反复 find/filter）\n\t- JSON 序列化/反序列化大对象要谨慎（可移到 Worker）\n3) 事件与任务调度\n\t- scroll/resize/input：节流/防抖\n\t- 大任务切片：`requestIdleCallback` / `setTimeout(0)` / scheduler\n\t- 非关键任务延后：首屏优先\n\t- 使用 Web Worker 处理 CPU 重任务（解析、压缩、hash）\n4) 资源与缓存\n\t- 请求合并、并发控制、避免瀑布流\n\t- 合理缓存（HTTP cache / SWR / local cache）\n\t- 预加载/懒加载：图片、模块、路由\n\t- 合理keepalive\n5) 内存与泄漏\n\t- 事件监听/定时器/订阅及时清理\n\t- DOM 引用、闭包引用大对象注意释放\n\t- 列表频繁增删注意 key 与复用策略\n\n##### 工程层面\n\n1) 构建产物体积\n\t- 代码分割（路由级、组件级、依赖级）\n\t- tree-shaking（ESM、sideEffects 配置）\n\t- 去掉无用 polyfill、按需引入（lodash-es、babel plugin）\n\t- 压缩：JS/CSS（terser/cssnano），图片压缩（webp/avif）\n 2) 缓存策略（极重要）\n\t- 静态资源 hash + 长缓存（immutable）\n\t- HTML 入口短缓存/不缓存（保证版本更新）\n\t- CDN 加速\n\t- 服务端配 `Cache-Control` 合理分层",
          "hasAnswer": true
        },
        {
          "id": "open-questions-16",
          "title": "性能监控&错误监控和上报",
          "content": "#### 前端监控系统如何设计?如何上报和分析数据?\n\n一个完整的前端监控系统通常分为三个维度：\n\n- **错误监控：** JS 运行时错误、Promise 未捕获异常、资源加载失败、HTTP 请求错误。\n    \n- **性能监控：** 核心 Web 指标（LCP, FID, CLS）以及传统指标（FP, FCP, TTI）。\n    \n- **行为监控：** 用户路径跟踪\n\n**上报方式：**\n\n- **`navigator.sendBeacon(url, data)`：** **业界首选**。它能在浏览器卸载页面（如关闭标签页）时异步发送数据，不阻塞主线程，不影响下一页面的加载。\n- 普通HTTP请求\n- **Image 对象 (GIF 上报)：** 传统的 `(new Image()).src = 'url?data=...'`。优点是跨域兼容性极好，且请求体积小。\n\n#### 项目报错如何定位\n\n**定位：** 在生产环境，代码是压缩混淆过的（如 `app.js:1:15234`），无法直接阅读。我们需要将报错的堆栈信息（Line, Column）配合 **SourceMap** 文件还原回原始源码。\n\n**Sourcemap 是源码和编译后代码的映射文件**，让浏览器能将压缩混淆后的代码映射回原始源代码。在复杂的现代前端项目中，代码经过构建工具（如 Webpack、Vite）的打包、压缩、混淆，生产环境在监控工具或浏览器控制台中，错误堆栈显示的是 **压缩后的文件名、行号和列号**（例如 `main.js:123:45`）。当浏览器或监控工具遇到一个指向 `main.js:123:45` 的错误时，根据sourcemap 查找对应的 `main.js.map` 文件。这个 `.map` 文件存储了原始代码和压缩代码之间的**映射关系**（即 `main.js` 的第 123 行第 45 列对应于 `src/components/UserForm.vue` 的第 50 行第 10 列）。map文件建议不部署到生产服务器。而是将 `.map` 文件上传到错z误监控平台（如 Sentry）。\n\n#### 除了sourcemap还有什么方法？\n\n**用户行为回溯 (Replay/Breadcrumbs)：** Sentry 等工具会记录用户报错前的点击路径、路由跳转、Console 日志。即使不知道报错的具体代码行，通过看用户的操作轨迹，也能大概猜出是在哪个业务逻辑出错的。\n#### sourcemap带来的安全性怎么办？\n\n**SourceMap 安全问题：** 如果把 `.map` 文件直接发到线上，任何人都可以在控制台看到你的源码。 **解决方案：**\n\n1. **私有化部署：** 将 `.map` 文件上传到内部的监控平台（如 Sentry），不放在 CDN 静态资源服务器上。\n    \n2. **黑白名单限制：** 只有公司内网 IP 才能访问 `.map` 文件。\n    \n3. **构建后删除：** Webpack 编译完成后，脚本自动将 `.map` 移动到安全的地方，并从 dist 目录中删除。\n\n##### 怎么衡量一个页面的渲染速度和性能？你对首屏时间，可交互时间等概念的理解和看法？\n\n- **首次内容渲染 (First Contentful Paint, FCP)：** 浏览器第一次渲染出任何文本、图像或画布的时间。这是用户感知“页面动了”的关键点。\n- **FP (First Paint):** 像素级首次渲染。\n- **LCP (Largest Contentful Paint):** 最大内容绘制。衡量**加载速度**。常用标准：<$2.5s$。\n- **CLS (Cumulative Layout Shift):** 累积布局偏移。衡量**视觉稳定性**（页面跳来跳去吗）。常用标准：<$0.1$。\n- **可交互时间 (Time to Interactive, TTI)：** 页面内容已渲染，且主线程空闲，能响应用户输入的时间。\n- **INP (Interaction to Next Paint):** 交互到下次绘制。衡量**交互延迟**（取代了旧的 FID）。标准：<$200ms$。\n\n**看法：** 我认为 **LCP (Largest Contentful Paint)** 现在比 FCP 更重要，因为它衡量的是页面“主体内容”什么时候出来。\n\n#### 错误监控和报警业界方案\n\n- **sentry**：Sentry 是目前前端监控领域事实上的“行业标准”。有开箱可用的SDK，会记录用户报错前的点击路径、路由跳转、Console 日志；会自动收集浏览器版本、操作系统等上下文信息；支持**数据清洗与聚合**，将成相同的报错聚合起来避免告警风暴；\n- **阿里云 ARMS / 腾讯云 RUM：** 云服务商提供的成熟商业方案，开箱即用。\n- **app 消息报警：** 通常对接 **企微/钉钉/飞书 Webhook**，设置阈值告警（如：某接口报错率 > 5% 立即触发报警）。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-17",
          "title": "海报绘制",
          "content": "##### 1. 客户端方案（最常用）\n\n这类方案直接在用户的浏览器中运行，优点是响应快、不消耗服务器资源。\n\n- **HTML5 Canvas 绘图 (原生)**\n    \n    - **原理：** 使用 `canvas.drawImage()` 将图片、文字手动绘制到画布上，再通过 `canvas.toDataURL()` 生成 Base64 图片。\n    - **缺点：** 手动计算位置非常痛苦，不适合复杂的 DOM 结构。\n\n```\nconst generatePoster = async () => {\n  // 1. 创建canvas\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n\n  // 2. 设置画布尺寸\n  canvas.width = 600;\n  canvas.height = 800;\n\n  try {\n    // 3. 输出图片\n    const dataURL = canvas.toDataURL('image/png');\n    console.log('生成的海报Base64:', dataURL);\n  } catch (err) {\n    console.error('绘制失败', err);\n  }\n};\n```\n\n- **html2canvas (业界主流标准)**\n    \n    - **原理：** 它并不是真正的“截图”，而是通过 **JS 重新渲染**。它会读取 DOM 结构、解析 CSS 样式，然后在 `<canvas>` 上按像素重新画一遍。\n    - **优点：** 使用简单，支持度高。\n    - **缺点：** * **样式兼容性：** 对某些高级 CSS（如 `box-shadow`、某些 `flex` 布局、复杂的 `filter`）支持不完美。\n        - **跨域：** 图片必须支持跨域，否则会报“画布被污染”错误。\n        - **清晰度：** 在高分屏下容易模糊（需要设置 `scale` 参数，配合 `devicePixelRatio` 优化）。\n\n```\nimport html2canvas from 'html2canvas';\n\nconst captureElement = async () => {\n  const element = document.getElementById('poster-area'); // 要截图的 DOM 节点\n  \n  try {\n    const canvas = await html2canvas(element, {\n      useCORS: true,          // 允许跨域图片\n    });\n\n    // 将 canvas 转为图片下载或预览\n    const imageData = canvas.toDataURL('image/png');\n    const link = document.createElement('a');\n    link.href = imageData;\n    link.download = 'screenshot.png';\n    link.click();\n  } catch (error) {\n    console.error('截图失败:', error);\n  }\n};\n```\n\n- **dom-to-image (SVG 方案)**\n    \n    - **原理：** 利用 SVG 的 `<foreignObject>` 特性。它将 DOM 序列化为 XML，放入 SVG 中，再利用浏览器原生的 SVG 渲染引擎。\n    - **优点：** 性能通常优于 html2canvas，生成的图片更接近真实 DOM 效果。\n\n```\nimport domtoimage from 'dom-to-image';\n\nconst captureBySvg = () => {\n  const node = document.getElementById('my-node');\n\n  // 1. 调用插件的方法，把要截图的元素里的内容转成 PNG 格式的字符串 (dataUrl)\n  domtoimage.toPng(node)\n    .then((dataUrl) => {\n      const img = new Image();\n      img.src = dataUrl;\n      document.body.appendChild(img); // 直接展示生成的图片\n    })\n    .catch((error) => {\n      console.error('生成图片出错!', error);\n    });\n};\n```\n### 2. 服务端方案（高还原度）\n\n如果需要 100% 还原页面（包含复杂动画、阴影、外部字体），或者需要批量生成图片，通常采用服务端截图。\n\n- **Puppeteer / Playwright (Headless Browser)**\n    \n    - **原理：** 在 Node.js 服务端运行一个**无头浏览器**（无界面的 Chrome）。\n    - **流程：** 服务端接收请求 -> 浏览器打开指定 URL -> 等待页面加载完成 -> 调用浏览器底层的 `screenshot` API -> 返回图片。\n    - **优点：** **最完美还原**。页面长什么样，截出来就长什么样。\n    - **缺点：** 实现相对复杂，且消耗服务器 CPU/内存资源巨大，并发量大时会有明显的延迟。\n\n### 3. 常见痛点与解决方案\n\n| **痛点**      | **解决方案**                                              |\n| ----------- | ----------------------------------------------------- |\n| **图片模糊**    | 将 Canvas 放大 `window.devicePixelRatio` 倍，再通过 CSS 缩小显示。 |\n| **图片跨域**    | 后端设置 CORS，或者前端配置 `useCORS: true`。                     |\n| **字体丢失**    | 客户端截图通常无法读取系统外的字体，需将字体转为 Base64 嵌入 CSS。               |\n| **滚动内容截不全** | 截图前临时设置 `height: auto` 或克隆一份 DOM 放到屏幕外隐藏位置进行渲染。       |",
          "hasAnswer": true
        },
        {
          "id": "open-questions-18",
          "title": "虚环境",
          "content": "#### 前端虚环境\n一般用 PR preview （Pull Request Preview = “这条 PR 的可访问预览环境”）\n方案：每个 PR 自动构建并部署到独立子域名，页面会标注 PR/commit 信息。静态资源走 hash 长缓存，入口短缓存，避免缓存串。配置用运行时注入，默认连接 staging 后端，必要时配合 mock 或后端分支环境。安全上会加内网/鉴权，PR 合并或关闭后自动回收环境，控制成本。\n\n实现：\n- 每个分支/PR：构建出一份前端产物\n- 部署到 CDN/静态托管\n- 分配一个独立 URL，比如：\n    - `https://preview-<pr>.xxx.com`\n    - 或 `https://<branch>.preview.xxx.com`\n- nginx需要按不同域名映射到不同目录\n\n\n#### 访问后端虚环境\n\n适用场景：前端通过“配置”把 API 请求切到某个后端临时域名（虚环境 / 临时分支域名）用于联调/回归。\n\n实现：\n- 提供一个设置入口，修改 apiBase\n- 把 `apiBase` 存在：\n    - localStorage（简单）\n    - 或 cookie（配合代理更复杂）\n    - 或页面内存\n- 请求层每次从“配置源”取 base\n- 切换后清理缓存或重新请求页面数据\n- 需要对配置的入口做权限，以及校验 apiBase",
          "hasAnswer": true
        },
        {
          "id": "open-questions-19",
          "title": "设计思想",
          "content": "##### 函数式编程，在项目中的应用?\n强调：**函数是一等公民、尽量纯函数、不可变数据、用组合替代修改状态**。  \n目标不是“写得像数学”，而是：**降低副作用，让代码更可测试、可复用、可推理**。\n\n在前端项目中的应用（很常见）\n1. **数据转换层**（最稳的 FP 落地点）\n\t- 接口数据 → 视图模型（mapping/formatting）\n\t- 用纯函数做 format / normalize\n\t    - 好测试、好复用、不会跟 UI 耦合\n2. **状态更新**（不可变更新）\n\t- React/Redux/Reducer：本质偏 FP\n\t- reducer = 纯函数：`(state, action) => newState`\n3. **表单校验/规则引擎**\n\t- 把校验拆成小函数组合：`required -> length -> regex -> asyncCheck`\n4. **工具函数与中间件**\n\t- 比如请求参数处理、错误映射、埋点事件构造，都适合写成纯函数\n##### 命令式编程，在项目中的应用?\n\n强调：**一步一步告诉计算机怎么做**，通过变量赋值、循环、条件分支推进过程。  \n关键词：**过程、控制流、可操作性**。\n\n在前端项目中的应用（很多场景 FP 不如它）\n1. **复杂交互流程/状态机式流程**\n\t- 例如：上传大文件（分片、并发、重试、暂停恢复）\n\t- 这类天然是“流程控制”，命令式更清晰\n2. **动画/Canvas/游戏循环**\n\t- 每帧更新位置、速度、碰撞检测：明显是命令式\n3. **DOM 操作与性能敏感路径**\n\t- 极致性能时，直接 for 循环比 map/reduce 更可控\n4. **调度器/队列**\n\t- 并发控制、任务队列：典型命令式\n\n##### 单例模式\n\n保证**全局只有一个实例**，并提供一个全局访问点。\n\n前端项目里典型使用\n1. **全局配置/运行时配置中心**\n\t- `ConfigStore`：保存 apiBase、envKey、feature flags\n2. **日志/埋点/监控 SDK**\n\t- 埋点需要统一队列、统一 sessionId、统一上报\n3. **全局事件总线 / WebSocket 连接**\n\t- 避免每个页面/组件都建一条 ws\n4. **缓存管理器**\n\t- 比如请求缓存、图片缓存、LRU cache\n\n##### 工厂模式\n\n把“创建对象/实例”的逻辑封装起来，通过参数返回不同实现。  \n核心价值：**解耦“使用”与“创建细节”，便于扩展与替换**。\n\n前端项目里典型使用\n1. **请求客户端工厂**\n\t- 根据 env/租户/鉴权方式创建不同 client：\n\t    - `createApiClient({ baseUrl, authType })`\n\t- 甚至 mock / real 两套实现，切换很方便\n2. **组件/渲染器工厂（低码/动态表单）**\n\t- schema → 组件实例\n\t- `type: \"input\"` → Input 组件\n\t- `type: \"date\"` → DatePicker",
          "hasAnswer": true
        },
        {
          "id": "open-questions-20",
          "title": "跨浏览器 跨终端开发的兼容性处理方案",
          "content": "##### 跨浏览器 跨终端开发的兼容性处理方案\n\n确保同一个网页或Web应用在**不同的浏览器**上和在**不同类型的设备**上都能具有**一致的外观、布局和功能**，提供**良好的用户体验**。\n\n挑战：\n不同浏览器：CSS 渲染差异，JavaScript API 支持度不同\n不同设备：屏幕尺寸与分辨率，输入方式差异，性能与网络条件\n\n主要分两步：  \n 1️⃣ **识别环境**：通过 UA、屏幕尺寸、触控点数等判断设备类型、操作系统和浏览器环境，以便做差异化处理。  \n 2️⃣ **处理兼容性**： \n1) CSS 层面\n- **前缀处理**：使用 autoprefixer 自动加 `-webkit-` 等\n- **现代 CSS 特性降级**：`flex` → `float` fallback\n- **媒体查询**：针对不同屏幕尺寸适配\n 2) JS / API 层面\n- **特性检测**（Feature Detection）：`if ('IntersectionObserver' in window)`\n- **Polyfill**：为不支持的 API 提供替代实现\n- **事件差异处理**：如触屏事件 `touchstart` / `touchmove` vs 鼠标事件 `mousedown` / `mousemove`\n3) **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）\n4) 开发工具链：一些常用的库结合现代化构建工具，自动化进行兼容处理\n```js\n\"@babel/core\": \"^7.20.0\",          // JavaScript 转译\n\"autoprefixer\": \"^10.4.13\",        // CSS 自动前缀\n\"postcss\": \"^8.4.21\",              // CSS 后处理\n\"eslint\": \"^8.30.0\",               // 代码检查\n\"stylelint\": \"^14.16.0\",           // CSS 检查\n```\n\n补充：检测与兼容性查询能力：\n\n```js\nserviceWorker：'serviceWorker' in navigator\nIntersectionObserver：'IntersectionObserver' in window\n响应式图片：<picture> + <source > 等\nwebp：document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0\nCan I Use：caniuse.isSupported(feature, navigator.userAgent)\n```\n\n总体原则和思路：\n\n- **渐进增强**：从基础功能开始，逐步为现代浏览器增强体验\n\n- **优雅降级**：现代功能不可用时，提供可用的降级方案\n\n- **移动优先**：从小屏幕开始设计，逐步适配大屏幕\n\n- **使用标准 API**：优先选择广泛支持的 Web 标准\n\n- **特性检测**：运行时检测浏览器能力，而非浏览器嗅探\n\n- **响应式设计**：使用弹性布局和媒体查询\n\n- **性能考量**：考虑不同设备的性能差异\n\n- **工具自动化**：使用构建工具处理大部分兼容性问题\n\n- **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "miniprogram",
      "name": "小程序",
      "questions": [
        {
          "id": "miniprogram-1",
          "title": "小程序登录 支付",
          "content": "小程序登录本质是：\n前端通过 wx.login 获取临时 code，把code发送给后端，后端再通过微信接口换取 openid 和 session_key，并建立自己的业务登录态，通过set-cookie下发token等会话登录态标志。\n- 微信登录 ≠ 业务登录\n- 微信只负责 **身份识别**\n- 业务权限、用户体系仍在自己后端\n\n小程序支付：前端只负责调起支付，所有金额、订单和校验都在后端完成。\n前端向后端发起支付请求\n后端校验订单合法性，然后调用微信「统一下单接口」，得到 **prepay_id**，返回支付参数给前端\n前端通过 wx.requestPayment 调起支付\n用户完成支付后微信异步通知后端，作为支付成功的唯一依据\n支付后 前端应：不直接信任 `success`，再次请求后端",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-2",
          "title": "选框架 uniapp taroapp",
          "content": "总体：需要考虑**技术栈一致性、平台范围、性能边界、团队协作方式**。\n\n1.团队主要技术栈是vue还是react\n2.考量目标平台需求：如果覆盖的平台更广，比如需要发布到 App 端，需要覆盖最多平台，优选 uni-app\n3.考虑业务需求可能的大型复杂交互，比如长列表，结合框架是否有成熟的支持\n3.如果更注重小程序性能 unia-app（taro由于底层基于 React Virtual DOM，相较于原生小程序的渲染可能会有轻微性能损耗，但在绝大多数场景下足够使用。）\n4.生态：**uni-app**：生态集中（插件/组件/工具链/统一 API），交付效率高；**Taro**：更“开放”，更像 Web 工程化；但你可能更需要自己补齐一些工程/规范/组件方案。\n\n更注重H5性能的大型项目 优选taro  由于基于 React 体系，更适合大型项目中的组件化、状态管理和架构规范。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-3",
          "title": "小程序rpx和px在不同手机上有误差",
          "content": "rpx 是小程序里的相对单位，规定屏幕宽度等于 750rpx，不同设备上会根据屏幕宽度换算成不同的 px。\npx 是绝对单位，在不同设备上不自适应；  rpx 是相对单位，理论上 rpx 可以适配不同设备，但在实际渲染时，由于屏幕宽度和 DPR 不同，rpx 换算成 px 时会出现小数，最终需要取整，不同平台的取整和渲染机制也存在差异，因此在不同手机上可能会有细微误差。  误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。\n\n解决：\n避免使用极小的 `rpx` 值。尽量使用偶数的 rpx 值，必要时利用 CSS transform 缩放结合微元素 伪类解决\n尽量用 flex / 自适应布局，减少“精确像素依赖”",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-4",
          "title": "小程序和h5的性能和用户体验差异对比",
          "content": "运行环境差异（最根本）：小程序运行在 **平台容器**（微信 / 支付宝），双线程，沙箱受限，低端机慢；H5 运行在 **浏览器**，浏览器内存大，可用 Worker，所以性能上限高\n\n首次加载：小程序需下载框架和代码包，H5 可按需加载。小程序通过主包限制和分包机制约束体积，H5 则依赖代码分割和浏览器加载能力；\n\n热启动：小程序更快，H5取决于缓存策略\n\n渲染性能：小程序有双线程能避免 JS 阻塞渲染，交互更流畅；H5容易因为 JS 阻塞导致渲染掉帧。\n\n操作DOM：小程序框架底层对DOM 操作有更严格控制，但是频繁地setData也可能会导致性能瓶颈；H5类似的操作DOM可能会导致性能瓶颈，一般要依赖框架的响应式数据更新或者渲染优化。\n\n在页面切换和交互体验上，小程序更稳定，由原生页面栈实现，返回、切换体验稳定状态保留相对自然，但是分包可能轻微延迟；H5 路由切换快，单页应用路由切换 = 组件卸载/挂载，需要通过keep-alive、预加载、状态缓存等方法优化。\n\n生态及api：小程序：依托微信生态丰富，登录、支付等微信能力更流畅，容易接入官方API，用户触达 分享等方面更有微信的优势。H5：浏览器 API功能无限制，技术栈成熟、生态丰富，拉新/留存不如小程序便利",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-5",
          "title": "小程序底层架构详解",
          "content": "小程序采用的是双线程（Dual-Thread）的运行模型，这是其架构的基石。这个模型将页面的逻辑处理和界面渲染分别放在两个独立的运行环境中，通过异步消息通道通信。开发者编写的**逻辑代码**运行在一个根本，是一个没有 DOM 逻辑层和 BOM 的独立环境中。\n\n逻辑层 (JS Thread) 由独立的 JavaScript 引擎 实现 。\n\n渲染层 (View Thread) 基于浏览器的 WebView，负责渲染页面的容器。\n\n（**WebView 是一种宿主环境提供的、内嵌式的浏览器内核功能。它允许应用程序（App）或小程序框架在原生界面中加载和渲染 Web 内容，它包含了浏览器的大部分核心功能，它运行在原生 App 内部，本质上就是一个浏览器内核组件**）\n\n这种分离架构的好处是解决传统 Web 应用的**性能瓶颈**（双线程）和**安全问题**（无法直接操作DOM），同时保证**跨平台能力**（渲染层可以对不同平台做不同的渲染）。\n\n缺点是：增加了一层数据传输，可能带来通信延迟，增加了调试复杂性，增加一定的内存占用；开发者无法使用完整的浏览器 API和一些成熟的web库；频繁调用setData可能会引起性能问题，因为涉及了两个线程之间的**跨线程通信**和**数据处理**",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-6",
          "title": "为什么小程序在复杂业务下更容易保持性能稳定？",
          "content": "小程序在复杂业务下更容易保持性能稳定，核心原因并不只是双线程，而是多重平台约束共同作用的结果。\n\n一方面，小程序采用逻辑线程与渲染线程分离的双线程模型，避免了 JS 执行直接阻塞渲染；另一方面，小程序通过主包大小限制和分包机制，强制将复杂业务拆分到不同页面和分包中，减少单一上下文的复杂度。\n\n同时，小程序以页面为单位管理生命周期和状态，更容易在页面切换时回收资源；而 SPA 运行在单一 JS 上下文中，如果工程拆分和状态管理不当，复杂业务下更容易出现性能退化。\n\n因此，小程序的稳定性更多来自平台约束，而不是单纯的执行效率优势。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-7",
          "title": "小程序没有dom是如何渲染的",
          "content": "小程序没有浏览器 DOM，它采用逻辑层和渲染层分离的双线程架构。逻辑层负责运行 JS 和业务逻辑，渲染层负责根据 WXML 和数据进行视图渲染。开发者通过 setData 更新状态，框架会把数据变更同步到渲染层，由渲染层重新计算并更新 UI。这样的设计可以提升性能稳定性、保证跨平台一致性，但也要求开发者控制 setData 的频率和数据量。\n \n编译阶段：将开发者定义的 WXML/WXSS 转换为渲染指令（类似虚拟DOM的结构对象）和和css\n运行阶段：根据渲染指令（类似VDOM）构建真实DOM，数据发生更新时，先diff然后把增量数据发给渲染层，渲染层精确更新 DOM",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-8",
          "title": "小程序开发中最常见的性能瓶颈是什么？你会怎么定位和优化？",
          "content": "1）逻辑层 ↔ 渲染层通信过多（setData 过频 / 数据量大）\n**现象**\n- 列表滚动卡、交互延迟、页面掉帧\n- 频繁 setData 或一次 setData payload 很大\n**优化**\n- 合并 setData：把多次更新合并成一次\n- 缩小更新范围：只更新必要字段（避免 whole data 替换）\n- 降低频率：节流/批处理（尤其 scroll、drag、实时输入）\n- 列表用 **分页 + 虚拟列表/分片渲染**（长列表核心）\n- 大对象避免频繁深拷贝：尽量扁平化数据结构\n\n2）长列表/复杂节点导致渲染压力大\n**现象**\n- 页面首屏慢、滚动掉帧\n- 节点层级深、wxml 结构复杂\n**定位**\n- 开发者工具看 **渲染耗时、节点数**\n- 观察是否存在“超长列表一次性渲染”\n**优化**\n- 虚拟列表 / 分批渲染（分帧渲染）\n- 减少节点层级、减少不必要的 view 包裹\n- 能用 `hidden` 就别频繁 `wx:if`（避免反复创建销毁）\n- 图片列表：固定尺寸 + 懒加载 + 合理占位\n \n3）图片/资源加载（尤其首屏大图、弱网）\n\n**定位**\n- Network：图片体积、并发、是否命中缓存  \n    **优化**\n- 压缩、裁剪、WebP（看平台支持）\n- 首屏优先：关键图优先，其余懒加载\n- CDN + 缓存策略（本地缓存、版本化 URL）",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-9",
          "title": "说说小程序的性能优化方案",
          "content": "1）小程序最常见的瓶颈\n1. **setData 通信成本**：频率高、数据量大、更新范围大\n2. **渲染压力**：节点数多、层级深、长列表一次性渲染\n3. **首屏慢**：资源大、请求多、逻辑初始化重\n4. **图片与网络**：大图、弱网、并发、缓存不佳\n5. **交互卡顿**：scroll/touch 高频事件 + 频繁 setData\n2）怎么定位（面试要点）\n- 微信开发者工具：**性能面板 / 渲染性能 / Network**  \n    重点看：\n    - setData **次数、单次 payload 大小、耗时**\n    - **渲染耗时、节点数、重排重绘**\n    - 首屏关键请求、图片体积、是否命中缓存\n- **真机测试**（尤其 Android 中低端）：工具数据 + 真实体感一起看\n\n3）**优化**\n1. setData（最关键、最常考）\n\t- 把多次 setData **合并成一次**\n\t- 对高频更新（scroll、drag、input）做 **节流/批处理**\n\t- 避免 `this.setData({ list: newList })` 这种整块替换\n\t- 用路径更新：只改变动字段\n\t    - `this.setData({ ['list[3].checked']: true })`\n\t- 数据结构尽量**扁平化**，减少深层对象整体替换\n2. 渲染优化：\n\t- 长列表：只渲染可视区 + 缓冲区，或首屏先渲染一部分，剩下分帧追加\n\t- 降低节点复杂度，减少 view 套娃，控制层级\n\t- 列表项组件化，但注意组件层级也别过深\n\t- `wx:if` 频繁切换成本高；仅切换显示优先 `hidden`\n\t- 选择合适的滚动容器，避免在 scroll 中频繁触发布局相关逻辑\n3. 首屏优化（用户最敏感）\n\t- 关键接口优先，非关键延后（骨架屏/占位）\n\t- 减少首屏请求数：合并接口、并发控制、缓存\n\t- 图片：压缩/裁剪、固定尺寸、首屏优先加载、其余懒加载\n\t- 静态资源上 CDN，做好缓存版本策略\n4. 交互与动画优化\n\t- 高频事件：节流/防抖，减少 setData\n\t- 动画优先用 **CSS/小程序动画能力**，避免 JS 驱动大量帧更新\n\t- 减少昂贵样式（阴影/滤镜等）在大面积区域使用",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-10",
          "title": "自定义组件和原生组件渲染有什么区别？",
          "content": "**总结：原生组件由客户端原生直接渲染，性能最好但层级受限；自定义组件运行在 WebView 渲染层，灵活但性能和层级不如原生组件。**\n\n小程序中的原生组件由客户端原生直接渲染，不在 WebView 内，性能最好，但存在层级限制，样式和遮罩控制能力有限。\n自定义组件运行在渲染层 WebView 中，参与 WXML 的布局和层级计算，交互和样式更灵活，但性能受 setData 和渲染复杂度影响。实际开发中通常根据性能需求和 UI 复杂度选择合适的组件类型。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-11",
          "title": "小程序为什么长列表特别容易卡？",
          "content": "核心原因是：节点数量大 + setData 通信和 diff 成本高 + 渲染层重排重绘压力大。核心思路就是减少节点、减少 setData、减少不必要的计算。\n\n1 节点数量爆炸（最直接原因），渲染层需要维护一个**非常大的节点树**\n2 setData 的通信 & diff 成本被放大（核心瓶颈），由于小程序的双线程\n3 如果滚动过程中的频繁更新，触发 setData，会导致JS 线程和渲染线程互相拖慢\n\n和H5对比：\n- H5：\n    - JS 和 DOM 在同一线程\n    - 可以直接操作 DOM\n    - 虚拟列表成熟\n- 小程序：\n    - JS ↔ 渲染层通信，每次更新都有“桥”的成本\n    - 所以 **更怕大数据量**\n\n优化方案：\n1 虚拟列表：只渲染**可视区域 + 缓冲区**\n2 分片 / 分帧渲染：首屏先渲染一部分，剩余用 `setTimeout / requestAnimationFrame` 分批塞\n3 降低 setData 频率：滚动事件节流，- 合并多次更新",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "ai",
      "name": "AI",
      "questions": [
        {
          "id": "ai-1",
          "title": "用过的 AI 大模型，使用方式，用了他们那些功能，觉得 AI 大模型他们存在有什么样的缺点",
          "content": "我主要用过 **通用大模型（Chat 类）+ 编程向模型（Code 类）**，日常是“问题分析 + 代码生成 + 校验优化”结合使用。\n\n**使用方式**\n\n- 需求理解 / 技术方案拆解（让模型帮我把问题结构化）\n- 写代码骨架 / 示例实现（我负责判断可行性）\n- Debug：解释报错、分析边界 case\n- 文档/注释/测试用例生成\n  **常用功能**\n- 多轮对话推理（不是一次性生成）\n- 代码补全 / 重构建议\n- 解释陌生代码或项目结构\n- 对比方案（如性能、可维护性）\n  **我看到的主要缺点（重点说这段）**\n\n1. **幻觉问题**：会“自信地胡说”，尤其是 API、版本差异\n2. **上下文有限**：复杂项目需要我主动裁剪、喂关键信息\n3. **缺乏真实运行反馈**：生成的代码不等于可上线代码\n4. **工程判断不可靠**：架构/边界/取舍仍要人来定\n5. **不会推测交互上下文**：需要依赖程序员的经验",
          "hasAnswer": true
        },
        {
          "id": "ai-2",
          "title": "你对 AI Coding 的理解？",
          "content": "我理解的 AI Coding 不是“替代程序员写代码”，而是**把程序员从低价值的重复劳动中解放出来**。\n\n我把 AI Coding 分成三层能力：\n\n1. **生成层**：\n   - 写样板代码、CRUD、工具函数\n2. **理解层**：\n   - 拆解需求、解释代码、总结逻辑、帮助我快速上手陌生项目\n3. **协作层（我更看重）**： - 和我一起查问题、分析方案、发现盲点\n   但它**不擅长**：\n\n- 复杂业务建模\n- 架构取舍\n- 非显性需求（性能、稳定性、灰度、回滚）\n- 涉及交互上下文的场景，AI 不会联系上下文和预设用户操作逻辑\n\n所以我把 AI 当成“非常快的初级工程师 + 技术顾问”\\*\\*，最终决策仍由我负责。",
          "hasAnswer": true
        },
        {
          "id": "ai-3",
          "title": "使用 AI 工具方面，你自己有没有最佳实践？",
          "content": "**我总结最佳实践有三点：**\n\n1. **先给上下文，再让它写**，可以通过配置项目 rules 来简化流程\n   - 项目背景 / 技术栈 / 约束条件\n   - 不直接丢一句“帮我写代码”\n2. **让 AI 解释它写的代码**\n   - 看它的解释，能快速发现逻辑漏洞或误解\n3. 可以让 AI 先给出方案，再对他的方案进行选择和优化，再执行\n4. **永远保留人工校验**\n   - 类型检查\n   - 代码 review\n   - 单测+自测，尤其关键路径我一定自己过一遍\n\n一句话总结：**AI 负责速度，程序员负责正确性和边界**",
          "hasAnswer": true
        },
        {
          "id": "ai-4",
          "title": "平时的 AI 工作流 是怎样的？",
          "content": "一个典型流程是：\n\n1. **我先自己分析需求点和方向，捋清楚目标和约束**\n2. 复杂问题先帮我拆步骤 / 给实现思路和方案\n3. **我来判断方案是否合理**\n   - 是否符合现有架构\n   - 是否有性能/安全问题\n4. 再让 AI 生成代码，然后 review 再做针对性调整，优化细节",
          "hasAnswer": true
        },
        {
          "id": "ai-5",
          "title": "用过哪些 AI IDE？差异在哪？",
          "content": "1. Cursor：目前的“全能王者”。**核心功能：**\n   - **Tab (预测式补全)：** 极其强大的上下文预测，能根据你的逻辑预测下一段代码。\n   - **产品化程度最高**。它将 AI 深度集成到 UI 层（如下滑提示、浮动按钮），体验远超“编辑器 + 插件”的组合。通过配置 cursor rule，结合一系列 ai 工具快捷键，**Agent 模式**能极大提升效率\n2. **claude code**：运行在终端的“高级机器人”\n   - \\*\\*运行在终端，无 UI，不限制在项目内，拥有读写文件和执行命令的完整闭环（会请求操作权限）\n   - \\*\\*逻辑推理强，处理复杂逻辑能力强\n   - 自主循环 (Loop)：读代码-分析-修改-验证，自主性比较强\n3. 国内\n   1. Trae：**独立的 IDE**，Agent 模式，跨文件的全局重构能力更强，基于 Claude GPT 等模型\n   2. 通义灵码：国内目前生态最成熟、用户量最大的 AI 编程助手，主要以 **IDE 插件**（VS Code, JetBrains）形式存在。对中文 Prompt 的理解非常细腻，单元测试生成、研发文档编写能力好，底层通义千问大模型",
          "hasAnswer": true
        },
        {
          "id": "ai-6",
          "title": "对 Agent / MCP / Tab 补全模型 的理解？",
          "content": "我把它们理解成三种不同抽象层级的 AI 能力。\n\n1. Tab 补全模型（最低层）\n\n   - 基于上下文预测下一段代码\n   - 适合：\n     - 写样板代码\n     - 局部修改\n   - **优点**：快、低打扰\n   - **缺点**：不理解“任务目标”，尤其没有完整的任务和需求观\n\n2. Agent（任务级）\n\n   - 能理解“我要完成一件事”\n   - 会拆步骤、调用工具、反复修正\n   - ## 适合：\n     - 重构\n     - 批量修改\n     - 跨文件操作\n   - 风险：\n     - **权限过大时需要强约束**，尽量结合自定义规则\n     - agent 生成的代码经常过度（写很多不需要的东西），需要比较细致的 review\n\n3. MCP（能力/工具协议层）\n\n   - MCP 我更倾向理解为 **“让 AI 安全、可控地接入外部能力的标准接口”**。\n     - 规范 AI 能调用什么\n     - 能看到什么数据\n     - 能做多大范围的事\n   - **价值在于：**\n     - 降低 Agent 的失控风险\n     - 让 AI 更工程化，而不是玩具化\n\nTab 补全解决“写得快”，Agent 解决“做成事”，MCP 解决“做得安全、可控”。",
          "hasAnswer": true
        },
        {
          "id": "ai-7",
          "title": "说说 mcp 的原理和底层架构",
          "content": "**MCP（Model Context Protocol）是一套标准化协议，用来把 LLM 与外部工具/数据源解耦连接**。  \n它通过 **Host → Client → Server** 的分层架构，把“模型如何思考”和“工具如何实现”彻底分开，使模型可以在不改代码的情况下安全、可控地调用外部能力。\n\n1. MCP 要解决的核心问题是什么？\n\t在 MCP 之前，LLM 调工具通常有几个痛点：\n\t- 工具接口**不统一**（每个工具一套 schema）\n\t- LLM **强绑定实现细节**（换个工具就要改 prompt / 代码）\n\t- **权限、安全、环境**混在一起（LLM 直接碰真实系统）\n\t- 工具发现、能力描述不规范（模型“猜着用”）\n\t**MCP 的目标**：把「能力」标准化、把「执行」隔离出去，让 LLM 只做“决策”，不做“执行”。\n\t\n2. MCP 整体架构和角色\n\t1. Host（宿主）：用户交互入口（IDE、Chat App），负责：\n\t\t- 管理 MCP Server 配置\n\t\t- 启动/连接 MCP Server\n\t\t- 把 LLM 的 MCP 调用转成真实请求\n\t2. LLM（模型）\n\t\t- **不直接访问任何系统** \n\t\t- 理解用户意图\n\t\t- 决定“要不要调用 MCP”\n\t\t- 生成 **符合 MCP schema 的结构化请求** \n\t3. MCP Client（协议客户端），通常是 **Host 内部的一个模块**\n\t\t- 校验 MCP 请求是否合法\n\t\t- 路由到正确的 MCP Server\n\t\t- 做协议层通信（stdio / http / ws）\n\t4. MCP Server（能力提供方）\n\t\t- 独立进程 / 服务\n\t\t- 向外声明：\n\t\t    - 自己有哪些能力（tools / resources / prompts）\n\t\t    - 每个能力的 schema（JSON Schema）\n\t\t- 负责：\n\t\t    - 真正执行系统操作\n\t\t    - 返回结构化结果\n\t\t- **可以是任何语言实现**\n\t\n3. MCP 的调用流程\n\t1. 用户提问\n\t2. Host 把上下文 + MCP 能力列表给 LLM\n\t3. LLM 判断：需要调用 MCP\n\t4. LLM 输出 **结构化 MCP 调用**\n\t5. Host 解析 → MCP Client\n\t6. MCP Client → MCP Server\n\t7. MCP Server 执行真实操作\n\t8. 返回结果\n\t9. Host 把结果再交给 LLM\n\t10. LLM 生成最终自然语言回复\n\t\n4. MCP Server的内部结构（底层视角）\n\t1. Transport Layer（传输层）\n\t\t- 常见的 stdio（本地工具） / http / ws\n\t2. Protocol Layer（协议层）负责 MCP 的 **schema 的结构化协议**\n\t\t- schema核心特征：\n\t\t    - 明确的 request / response\n\t\t    - 参数、返回值都有 JSON Schema\n\t\t    - 不靠 prompt 文本约定\n\t3. Capability Layer（能力声明层）这是 MCP 的灵魂\n\t\tMCP Server 可以暴露三类能力：\n\t\t- tools：可执行动作（最常见），类似函数调用\n\t\t- resources：只读或半结构化数据，类似“数据源”\n\t\t- prompts：可复用 prompt 模板\n\t4. Adapter Layer（适配层）\n\t\t- 真正对接：\n\t\t    - 文件系统\n\t\t    - Git\n\t\t    - 数据库\n\t\t    - 内部服务",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "tech-selection",
      "name": "技术选型",
      "questions": [
        {
          "id": "tech-selection-1",
          "title": "框架 vue/react/nextjs",
          "content": "**选型考量维度**：团队主要技术栈、偏中后台还是前台、业务数据和交互复杂性、是否性能要求高、是否交付速度优先、是否有SEO或SSR需求、是否有用到典型库的需求、是否有跨端或多端需求、未来模块会不会持续膨胀、多人并行开发多不多、主要瓶颈是**首屏**还是 **交互响应**还是**列表渲染/大数据量**等\n\n- **Vue**：\n    - 适合：团队 Vue 经验多、交付速度优先\n    - 优点：上手快、约束更强（模板+响应式）、代码风格一致性更好\n    - 风险：大型复杂项目仍需工程规范（状态/依赖/性能边界）\n\n- **React**：\n    - 适合：复杂交互、组件抽象强、团队工程化能力强、、多团队开发跨端生态需要（RN/小程序生态间接）\n    - 优点：组合能力强，生态丰富；复杂场景更“可编程”\n    - 风险：自由度高 => 需要更强规范（状态、目录、Hooks 约束、性能）\n\n- **Next.js**：\n    - 适合：**需要 SEO / 首屏性能 / 内容与交易混合 / 需要 SSR/SSG/ISR** 的 Web\n    - 优点：开箱 SSR/SSG/路由/数据获取/分包优化，工程体系更完整\n    - 风险：服务端成本与复杂度上升；缓存、数据一致性、部署方式要设计\n\n总结：\n做框架选型会先看约束：团队熟悉度和交付周期是底线，然后看业务形态——中后台还是前台内容型，**数据和交互复杂度决定我们更需要‘强约束的规范’还是‘高自由度的组合能力’**。 \n如果是登录后中后台、SEO 不重要、交付优先，通常结合需要面向的端，优先选团队更熟的方案（比如 Vue 或 React），并把工程规范、状态管理、性能治理配套做好。 \n如果是 ToC 内容/交易，对 SEO 和首屏体验有硬要求，会优先考虑 Next.js 这种一体化 SSR/SSG 方案。  \n最后必要时可以提前验证关键风险点，对可能的性能瓶颈提前预估。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-2",
          "title": "模块化方案",
          "content": "- **现代前端默认优先 ESM**\n    - 原因：天然支持静态分析、tree-shaking、按需加载；与 Vite/Rollup/现代浏览器契合\n        \n- **Node 侧 / 老生态**可能仍有 CJS\n    - 场景：历史包、Node 运行环境、某些工具链\n    - 策略：库开发可用 **双产物**（`exports` 同时提供 ESM/CJS）\n        \n- **UMD**：\n    - 场景：要被 script 直接引入、或兼容非常老的环境（现在越来越少）\n        \n- **落地规则**：\n    - 应用项目：ESM + Vite / Webpack5（优先 ESM）\n    - 公共库：ESM 为主，必要时提供 CJS fallback\n    - 关键点：关注 `sideEffects`、`exports`、依赖是否可 tree-shake\n\n**一句结论**：\n- 应用侧统一 ESM；\n- 库侧 ESM 主产物 + 必要的 CJS 兼容，保证 tree-shaking 和生态兼容。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-3",
          "title": "SSR vs CSR vs SSG",
          "content": "**选型考量维度**：是否要 SEO、首屏性能诉求、内容更新频率、个性化程度、后端/缓存能力、部署成本。\n\n- **CSR（纯前端渲染）**\n    - 适合：登录后系统、中后台、强交互应用、SEO 不重要\n    - 优点：架构简单、服务器压力小\n    - 缺点：首屏依赖 JS；SEO 弱\n        \n- **SSR（服务端渲染）**\n    - 适合：SEO 重要、首屏强诉求（电商/内容/营销）\n    - 优点：首屏更快、SEO 更好\n    - 成本：服务端渲染与缓存、数据请求、部署与稳定性更复杂\n        \n- **SSG（静态生成）**\n    - 适合：内容型、更新不频繁（文档、博客、活动页）\n    - 优点：性能最好、成本低（CDN）\n    - 缺点：更新需要重新构建\n        \n- **ISR（增量静态再生）**（以 Next 为代表）\n    - 适合：既要静态性能又要一定实时性（内容更新频繁但可接受延迟）\n\n**一句结论**：\n- 后台/登录态强交互 => CSR；\n- 要 SEO/首屏 => SSR 或 SSG；\n- 内容多且更新可延迟 => SSG/ISR 是性价比最高的。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-4",
          "title": "SPA VS MPA",
          "content": "**选型维度**：页面形态是否强关联、是否需要极致首屏、多入口/多团队协作、SEO、复杂度。\n\n- **SPA**\n    - 适合：强交互、页面间共享状态多（IM、工作台、复杂表单）\n    - 优点：路由切换快、状态共享方便\n    - 缺点：首屏可能更重；路由/状态/性能治理要求更高；需要结合NGINX等配置\n\n- **MPA**\n    - 适合：多入口、页面相对独立（营销站、活动页、老系统渐进改造）\n    - 优点：首屏天然更轻、隔离性好、稳定性强\n    - 缺点：状态共享困难、体验一致性要额外做\n\n**一句结论**：\n- 强交互 + 状态共享多 => SPA；\n- 多入口且相互独立、追求隔离与首屏 => MPA 或多应用架构更合适。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-5",
          "title": "Redux VS Zustand",
          "content": "**选型维度**：状态规模与复杂度、调试与规范性、团队协作、性能、样板代码接受度。\n\n- **Redux（尤其 React Toolkit）**\n    - 适合：大型应用、复杂业务流、强规范团队、需要完整的中间件体系（日志/埋点/异步/回放）\n    - 优点：可预测、生态成熟、调试工具强、团队协作一致性高\n    - 缺点：心智和样板更多（RTK 已明显改善）\n\n- **Zustand**    \n    - 适合：中小型项目、需要更轻量、更少样板、组件局部状态较多\n    - 优点：API 简单、性能好、开发快\n    - 风险：大型项目需要自建规范（store 划分、依赖管理、异步/错误处理约束）\n\n**一句结论**：\n- 状态复杂、多人协作、需要强治理 => Redux/RTK；\n- 追求轻量高效、业务中等 => Zustand，但会配套 store 分层和规范。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-6",
          "title": "Vuex VS Pinia",
          "content": "- **Pinia（Vue3 时代主推）**\n    - 优点：更贴合 Composition API （state/getters/actions 就是一个自然的对象/函数组合）、类型推导更友好、模块化更自然、心智更轻\n    - 适合：新项目、Vue3 项目默认选\n\n- **Vuex**\n\t- 强调**单向数据流**和**严格的状态修改规范（mutation/action/commit/dispatch + module）、相对适合大型项目、但模板代码较多、TS 支持需要额外配置\n    - 策略：渐进迁移：新模块用 Pinia，旧模块逐步替换\n\n**一句结论**：\nVuex 和 Pinia 更像官方状态管理的代际更替：Vue3 之后组合式 API 和 TS 成为主流，Pinia 在类型推导、样板代码、store 组织方式上都更契合官方心智，而且是官方推荐路线；Vuex 主要保留在存量项目或迁移成本高的场景，新项目默认 Pinia 风险最低。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-7",
          "title": "移动端适配方案(rem/vw/响应式)",
          "content": "**选型维度**：设计稿体系、是否需要等比缩放、是否要支持复杂断点、组件库/业务形态。\n\n- **vw/vh**\n    - 适合：H5 活动页/业务页等比布局\n    - 优点：天然跟随视口，不需要 JS 动态计算 root font-size\n    - 注意：处理极小/极大屏可配合 clamp() 或断点兜底\n\n- **rem（配合动态 root font-size）**\n    - 适合：历史方案、已沉淀一套 rem 工具链（postcss-pxtorem + lib-flexible 等）\n    - 风险：依赖 JS 设置；多端/嵌套容器场景要注意\n\n- **响应式（媒体查询 + flex/grid）**\n    - 适合：需要多断点、Pad/桌面也要兼容的页面\n    - 通常：实际工程中一般会结合上面两种一起用\n\n**一句结论**：\n- 纯移动 H5 我优先 vw + clamp；\n- rem 多用于历史项目或已有体系\n- 结合多端断点 走响应式",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-8",
          "title": "小程序选框架 Uniapp VS Taroapp",
          "content": "**选型维度**：团队技术栈（Vue/React）、目标平台（微信/支付宝/抖音/快应用/H5/App）、生态成熟度、性能与原生能力、长期维护。\n\n- **uni-app**\n    - 适合：团队 Vue 为主、目标平台多（小程序 + H5 + App）且追求一套代码多端\n    - 优点：多端覆盖广、上手快、社区方案多\n    - 风险：遇到深度定制/复杂性能场景时，需要评估桥接和兼容成本\n- **Taro**\n    - 适合：团队 React 为主、希望用 React 心智做小程序多端\n    - 优点：React 生态更好融入；工程化能力强\n    - 风险：复杂场景要关注运行时开销与一些平台差异；仍需规范组件与渲染性能\n\n**一句结论**：\n- 看团队栈：Vue 团队优先 uni-app，React 团队优先 Taro；\n- 结合面向的平台，uniapp支持平台略多；\n- 结合可能需要的第三方能力\n- 必要时提前做关键页面性能验证（长列表、图表、地图等）",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "teamwork",
      "name": "工作协作",
      "questions": [
        {
          "id": "teamwork-1",
          "title": "如何平衡重构和需求时间冲突",
          "content": "(1) 风险控制\n\n- **评估重构风险**：提前评估改动对现有业务的影响\n- **保留回滚方案**：必要时做 feature flag 或分支策略\n  (2) 渐进式策略\n- **模块化重构**：只重构最影响维护性的模块，减少一次性改动\n- **分阶段迭代**：把重构拆分到多个版本逐步上线\n  (3) 团队协作\n- **跨角色沟通**：和产品、测试协商重构计划，保证上线不影响业务\n- **代码 review + 测试覆盖**：确保重构质量\n  (4) 工具与实践\n- **使用自动化工具**：静态检查、单元测试、CI/CD 提高重构安全性\n- **记录和文档**：对重构部分做文档说明，方便团队理解和接手\n\n面试加分点：可以结合自己实际经验举例，比如某个上线紧急需求中，如何渐进式重构，体现“业务优先 + 质量保障 + 团队协作”。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-2",
          "title": "谈谈你对“大前端”的理解",
          "content": "(1) 技术上\n\n- **多平台统一**：大前端不仅是 Web，还包括小程序、移动端、桌面端（Electron）、后台管理系统等。\n- **前端全栈意识**：涉及前端框架、Node.js、服务端渲染、前端工程化、构建工具等。\n- **微前端 / 组件化 / 工程化**：在大团队、多模块、多项目的环境下，强调可复用、可组合、可扩展。通过微前端架构、共享 NPM 包、组件库统一管理等方式，保证项目整体稳定性和开发效率。\n  (2) 工程化和流程\n- **代码规范 & CI/CD**：统一 eslint、prettier、git hook，自动化部署流程，保证团队质量。\n- **版本管理 / 依赖管理**：NPM 包、私有组件库、依赖升级策略。\n- **测试和监控**：单元测试、集成测试、前端性能监控、日志收集等。\n  (3) 团队协作和知识管理\n- **文档标准化**：设计规范、接口文档、组件库文档\n- **团队共享和复盘机制**：技术分享会、代码 review 流程、经验沉淀",
          "hasAnswer": true
        },
        {
          "id": "teamwork-3",
          "title": "如何带领一个前端团队?如何提升团队的技术能力",
          "content": "(1) 团队管理\n\n- **任务分解 & 目标设定**：按能力分配任务，设置短期/长期目标\n- **沟通机制**：定期会议、即时沟通渠道、跨组协作流程\n- **绩效与成长**：明确晋升路径、技术成长规划、code review 作为学习手段\n  (2) 技术能力提升\n- **技术分享**：定期分享最新技术、最佳实践或项目经验\n- **代码规范 & 工程化**：推动统一规范、组件化、可复用库\n- **培训与实践**：安排小项目练习、Pair Programming、内部 Hackathon\n- **学习新技术趋势**：关注前端社区、开源项目、前沿框架（React/Next/Vue/微前端等）\n  (3) 风险控制与质量保障\n- **重构与迭代策略**：控制大规模重构风险，采用渐进式重构\n- **测试覆盖率**：单元、集成、E2E 测试\n- **性能与监控**：前端性能指标 (FCP/LCP/TTI/FID/INP) 和异常监控\n  > 面试加分点：你可以顺便结合“如何带新人上手”和“大前端视角”，说明你不仅懂管理，也懂技术驱动团队。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-4",
          "title": "平时如何学习前端技术？",
          "content": "(1) 系统化学习\n\n- **专题学习**：对某一块技术（如 React、TypeScript、前端性能优化）系统学习，而不是零散碎片化\n- **做学习计划**：安排周期性学习、练习和总结\n  (2) 实践与落地\n- **小项目练习**：练习新框架、新工具或设计模式\n- **复盘总结**：在项目中尝试新技术后，做复盘文档或者分享，巩固理解\n  (3) 社交学习\n- **技术分享 / 内部培训**：参加团队分享会、线上/线下 meetup\n- **交流讨论**：通过评论、issue 或社群讨论问题，加深理解\n  (4) 利用工具和 AI\n- **查阅资料**：官方文档、源码、GitHub issue\n- **借助 AI 提高效率**：快速定位问题或理解概念，但核心还是自己实践和总结",
          "hasAnswer": true
        },
        {
          "id": "teamwork-5",
          "title": "讲几个你觉得会越来越重要的前端技术？",
          "content": "1.**服务端渲染（SSR）与全栈前端技术**\n\n- 例如 Next.js、Nuxt.js 等框架，结合 React Server Components 或 Vue 3 的 SSR，可以提升首屏加载速度和 SEO 体验。\n- 越来越多的项目希望前端不仅负责交互，也能优化性能和 SEO，因此前端对服务端渲染的理解会越来越重要。\n\n2️. **微前端和模块化架构**\n\n- 随着大型前端项目和多团队协作增多，微前端可以让多个团队独立开发、独立部署，减少耦合。\n- 技术上涉及模块联邦（Module Federation）、Web Components、iframe 沙箱隔离等，这些能力会越来越吃香。\n\n3️.**前端性能优化与体验监控**\n\n- 包括前端性能指标（FCP、LCP、TTI、INP/FID）、懒加载、代码分割、缓存策略、离线体验（PWA）。\n- 用户体验要求越来越高，性能优化和监控能力直接影响产品质量和业务指标。\n\n  4.**AI 与前端结合**：自动化测试、智能推荐、代码生成工具\n\n  5.**TypeScript / 强类型化前端**：在大项目中保证可维护性\n\n  6.**WebAssembly**：性能敏感场景（图形、游戏、音视频处理）",
          "hasAnswer": true
        },
        {
          "id": "teamwork-6",
          "title": "说说你的职业发展规划，如何做短期计划和长期规划",
          "content": "思路框架\n\n短期：可量化、可验证（6–12 个月）\n\n长期：方向性、非绑定岗位（3–5 年）\n\n核心逻辑：能力成长 > 职级 title",
          "hasAnswer": true
        },
        {
          "id": "teamwork-7",
          "title": "你认为一个优秀的前端架构师/高级工程师需要具备哪些特质?",
          "content": "我觉得优秀的前端架构师不只是代码写得好，而是三点：\n第一是技术深度，知道框架、性能、工程化的边界在哪里；\n第二是系统视角，能从业务、团队规模和长期维护成本来设计方案；\n第三是工程和协作能力，能把技术方案变成团队可执行的规范，而不是只停留在“想法”。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-8",
          "title": "在你的团队中，你是如何推动技术规范落地和技术选型的?",
          "content": "一般会先在小范围试点，比如一个模块或新页面，验证在开发效率、维护成本或性能上的收益。\n在有实际数据或对比之后，再通过文档、示例和工具化（比如 lint、脚手架）来降低使用成本，让规范“被默认使用”，而不是靠口头要求。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-9",
          "title": "对于新技术，你是如何学习和评估的",
          "content": "思路框架：\n\n背景：解决什么问题？\n\n成熟度：生态、维护者、社区\n\n成本：学习/迁移/风险\n\n收益：性能、体验、效率\n\n我评估新技术时会先看它解决的核心问题是不是我们真的存在的，其次看成熟度和社区活跃度。\n真正落地前我会做最小验证，比如用在非核心模块或内部工具上，确认收益大于引入成本，再决定是否推广。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-10",
          "title": "你认为前端未来 3-5 年的发展方向是什么?",
          "content": "我觉得前端会在三个方向持续演进：\n一是前后端边界会继续模糊，比如 BFF、Server Components，让前端更靠近数据层；\n二是性能和体验会成为默认要求，而不是专项优化；\n三是工程复杂度会越来越高，AI 会更多作为辅助工具，而不是替代工程师。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-11",
          "title": "讲一个工作中遇到的复杂模块的设计思路、遇到的性能瓶颈及解决方案",
          "content": "思路模板（通用）\n\n背景 → 复杂点 → 决策 → 瓶颈 → 优化 → 结果",
          "hasAnswer": true
        },
        {
          "id": "teamwork-12",
          "title": "你遇到的最大的技术挑战是什么?从中学习到了什么?",
          "content": "思路框架\n\n挑战本身不重要\n\n你如何思考和调整更重要\n\n面试可说版：\n对我来说最大的挑战不是某个 API，而是在复杂业务里做取舍。\n比如有一次方案在技术上很优雅，但实现成本和团队理解成本都很高，后来我选择了一个更“笨但稳定”的方案。\n这让我意识到，工程里正确比完美更重要。\n\n加分点\n\n展现反思能力\n\n不把挑战包装成“炫技”",
          "hasAnswer": true
        },
        {
          "id": "teamwork-13",
          "title": "想找机会的原因是什么？有什么技术上想学习的具体方向",
          "content": "目前的工作在业务稳定性上很好，但技术挑战相对有限。我希望在下一阶段能接触更复杂的前端场景，比如更大的工程规模、更复杂的性能问题或更完整的前后端协作模式。\n技术上我也希望进一步加强在工程化、Node/BFF 以及架构设计方面的能力。",
          "hasAnswer": true
        }
      ]
    }
  ],
  "generatedAt": "2026-01-18T06:07:17.848Z"
}