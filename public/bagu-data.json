{
  "categories": [
    {
      "id": "js-basic",
      "name": "JS基础",
      "questions": [
        {
          "id": "js-basic-1",
          "title": "浮点数精度问题",
          "content": "计算机底层是用二进制存储数据的。虽然 $0.1$ 和 $0.2$ 在十进制看起来很整，但在转换成二进制时，它们是**无限循环小数**，JavaScript 中的 `Number` 类型使用的是 64 位双精度浮点数，这导致存进去的数本身就不是精确的 0.1。\n\n办法：\n\n转成整数运算 (常规解法)**；\n\n使用专业库比如`decimal.js`、`bignumber.js` 或 `big.js`\n\n追问：绝大多数编程语言都有，只要它们使用的浮点数类型是基于 **IEEE 754 国际标准**实现的，核心问题是：无限循环的二进制+尾数位数的限制 导致的强制截断和精度丢失",
          "hasAnswer": true
        },
        {
          "id": "js-basic-2",
          "title": "js的字符长度",
          "content": "js字符串的 `length` 属性返回的是字符串中代码单元的数量,而不是传统意义上的字符数量或字节数量，由ECMAScript 标准规定\n\nJS 字符串使用 **UTF-16** 编码格式，一个**代码单元**就是 **16 位（即 2 字节）**\n\n**普通字符**：大多数字符都位于 Unicode 的基本多语言平面 (BMP) 内。它们只需要 **1 个代码单元**来表示，特殊字符/表情符号：位于 BMP 之外的字符（如某些不常见的汉字、最新的 Emoji 🌧️）需要 2 个代码单元。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-3",
          "title": "this上下文",
          "content": "this指的是函数执行时所关联的对象，取决于函数在运行时**调用**的方式。\n\n1 直接调用\n\n2 对象. 调用（隐式绑定\n\n3 bind call apply (显式调用)\n\n4 new `this` 绑定到**新创建的实例对象\n\n特殊情况 箭头函数没有this\n\n原生 `setTimeout` 的 this 指向规则：\n\n1. **默认情况下**，回调函数中的 `this` 指向全局对象（浏览器中的 `window`）\n\n2. **严格模式下**，指向 `undefined`\n\n3. this 指向与调用 `setTimeout` 的上下文无关",
          "hasAnswer": true
        },
        {
          "id": "js-basic-4",
          "title": "原型与原型链",
          "content": "1.函数的`prototype`：Constructor.prototype,  仅存在于函数（构造函数/类）上**它指向一个对象，这个对象就是未来**所有实例对象**将继承的公共属性和方法的集合。\n\n2.`__proto__` :存在于所有实例对象上这是一个内部属性 (`[[Prototype]]` )，它指向创建该实例的构造函数的 `prototype` 对象。`Object.getPrototypeOf()`来访问\n\n原型链是由于对象通过 `__proto__` (内部的 `[[Prototype]]`) 链接到其构造函数的原型对象，而构造函数的原型对象本身也是一个对象，它也有自己的 `__proto__`，如此层层递进，直到链的末端。\n\n原型链是 JavaScript 实现**继承和属性共享**的机制。属性和方法都存储在原型上，所有实例共享同一份，这大大节省了内存空间。\n\n当访问实例对象上的一个属性，JS 引擎会首先检查该实例对象自身是否有这个属性，如果实例自身没有找到，引擎会沿着 `__proto__` 链接向上，到它的原型对象上查找。 如果仍未找到，查找会沿着原型链一直向上，直到到达 `Object.prototype`。`Object.prototype` 的 `__proto__` 是 `null`。如果查找到 `null` 仍未找到，则返回 `undefined`。\n\n**`class` 语法：** ES6 的 `class` 语法是原型和原型链的**语法糖**。它没有改变底层机制，只是提供了一种更清晰的方式来定义构造函数和方法。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-5",
          "title": "继承",
          "content": "核心：原型链继承**原型链** 是 JS 继承的**唯一底层机制**\n\n1.原型继承，核心：让子类原型对象指向父类实例。\n\n- **做法**：`Child.prototype = new Parent()`\n- **缺点**：**引用类型属性共享**。当父类的原型上包含**引用类型**的属性时（比如一个数组），其中一个子类改了数组，所有子类都会跟着变。\n\n2.组合继承：【核心优化】：创建父类原型对象的副本，并赋值给子类原型+【构造器指针修正】：将子类构造器指向自身。特点：独立属性+原型共享。缺点是`Parent` 构造函数被调用了两次\n\n```\nfunction Child(name, age) { \n\t// 【核心步骤 A】：继承属性 \n\t// 通过 call 调用父类构造函数，将 Parent 的属性绑定到 Child 的实例上 \n\tParent.call(this, name); \n\tthis.age = age; \n}\n\n// 【核心步骤 B】：继承方法: 将 Child 的原型指向 Parent 的一个实例，从而接入原型链 Child.prototype = new Parent(); \n// 4. 修复 constructor 指向 \n// 因为重写了原型，Child.prototype.constructor 现在指向的是 Parent，需要手动改回来 Child.prototype.constructor = Child; \n```\n\n3.终极方案：寄生组合式继承（必杀技）\n\n**这是面试官最想听到的答案，也是 ES6 `class` 背后的核心原理。**\n\n- **核心思想**：不 `new Parent()` 了，直接造一个父类原型的副本。    \n- **优势**：只调用一次父类构造函数，原型链保持完整，效率最高。\n\n```\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n```\n\n3.es6的class extend super,  **本质**是寄生组合继承的**语法糖**。\n\n`class` 关键字**并没有改变底层原型继承的机制**，它只是提供了一套更清晰的 API 来定义构造函数、原型方法和静态方法。\n\n`extends` 的底层操作：\n\n1. **设置子类的原型链：** 自动将 `Child.prototype` 的原型（即 `Child.prototype.__proto__`）设置为 `Parent.prototype`，实现了**方法继承**。\n\n2. **构造函数关联：** 自动将 `Child.__proto__` 设置为 `Parent`，实现了**静态属性和方法的继承**。\n\n`super` 关键字： `super` 是在 `class` 继承中最核心、最关键的机制，它在两个场景下工作：\n\n1. **在 `constructor` 中：** 必须调用 `super()`。它负责调用父类的构造函数，并**将子类实例的 `this` 绑定到父类**。在子类构造函数中，必须在引用 `this` 之前调用 `super()`。\n\n2. **在方法中：** 用于调用父类原型上的同名方法（如 `super.methodName()`）。\n\n```\nclass Child extends Parent {\n    constructor(name, age) {\n        // 【核心】：必须先调用 super()，它负责执行父类的构造函数并创建 this\n        super(name); \n        this.age = age;\n    }\n\n    // 子类自己的方法\n    sayAge() {\n        console.log(`我今年 ${this.age} 岁了`);\n    }\n\n    // 【重写/多态】：子类可以覆盖父类的方法\n    sayName() {\n        // 也可以通过 super 调用父类被覆盖的方法\n        super.sayName(); \n        console.log('这是子类重写后的逻辑');\n    }\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-6",
          "title": "new操作符做了什么",
          "content": "1创建新对象\n\n2新对象原型指向构造函数原型对象\n\n3绑定this并执行构造函数\n\n4如果构造函数有返回就直接返回，否则返回新对象",
          "hasAnswer": true
        },
        {
          "id": "js-basic-7",
          "title": "讲讲js的事件循环",
          "content": "宏任务和微任务的区分是为了做什么? 优先级有什么区别?\n\n答：是为了保证异步代码执行的**确定性、优先级和性能**。微任务享有绝对的**插队权**。\n\n核心目的在于创建**两级异步优先级系统**，确保高优先级、对性能敏感的任务能够快速执行，同时避免长时间阻塞浏览器渲染。\n\n微任务 (Microtasks) 的目的：高优先级，保证状态一致性。微任务在**当前同步代码执行完毕后，浏览器进行下一次渲染之前**立即执行。例如，Promise 链需要保证在一个 DOM 或 UI 渲染周期内全部解析完成，以避免 UI 闪烁或数据不一致。\n\n宏任务 (Macrotasks) 的目的：低优先级，调度 I/O 和 UI 渲染。不阻塞渲染\n\n注意：初始同步脚本执行完毕，**执行上下文栈（ECS）清空时**，事件循环机制才真正开始接管，并进入检查队列的循环。\n\n所有的异步事件一定是当前浏览器执行完同步任务空闲了才做的",
          "hasAnswer": true
        },
        {
          "id": "js-basic-8",
          "title": "全局对象",
          "content": "在不同的环境下，全局对象的名字和表现有所不同：\n\n- **浏览器环境**：全局对象是 `window`。\n- **Node.js 环境**：全局对象是 `global`。\n- **统一规范**：为了跨环境兼容，ES11 引入了 **`globalThis`**，无论在哪个环境下，它都指向当前环境的全局对象。\n\n> **面试避坑指南：** 在全局作用域下用 `var` 声明的变量会挂载到全局对象上，但用 `let` 或 `const` 声明的变量**不会**。这是因为 ES6 之后，全局作用域内部还存在一个“块级作用域”的顶层环境。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-9",
          "title": "js类型转换",
          "content": "显式转换 (Explicit Coercion)**：通过 `Number()`、`String()`、`Boolean()` 等内置函数或 `parseInt` 等方法进行的**主动**转换。\n\n隐式转换 (Implicit Coercion)**：在运行时，由 JS 引擎根据操作符（如 `==`、`+`、`-`）的需要**自动**进行的转换。\n\n1.转换为 Boolean (转布尔)。这是最简单的转换，发生在逻辑判断、`if` 语句和 `!` 操作符中。\n\n2.转换为 String (转字符串)。发生在字符串拼接（`'a' + b`）、`alert()` 或 `String(value)` 中。规则：原始值直接转换。对象通过调用内部的 **`ToString` 抽象操作**实现\n\n3.转换为 Number (转数字)。发生在数学运算（`-`, `*`, `/`）或一元加操作符（`+a`）中。\n\n规则： 原始值有明确的转换规则（如 `null` 转 $0$，`\"123\"` 转 $123$）。对象通过调用内部的 `ToNumber` 抽象操作实现。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-10",
          "title": "闭包",
          "content": "注意：闭包 = 函数 + 它能访问的、已脱离当前执行上下文的外部变量\n\n作用：创建私有变量；外部访问私有变量；延长变量生命周期；模块化基础\n\n注意：使用不当容易内存泄漏；性能开销比普通函数大\n\n如何避免内存泄漏? \n\n解除引用：当你确定一个闭包不再需要使用时，应该手动解除对它的引用。通过将持有闭包的变量设置为 `null` 或 `undefined`，使其失去引用。\n\n```js\nlet closureFunc = outerFunc(); // 创建闭包\n// ... 使用 closureFunc ...\nclosureFunc = null; // 手动解除引用，帮助 GC 回收内存\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-11",
          "title": "for..in for..of区别",
          "content": "记忆：KEY in OBJECT, VALUE of ITERABLE，`in` 拿 Key（下标），`of` 拿 Value（内容）\n\n| **特性**   | **for..in**          | **for..of (ES6)**                      |\n| -------- | -------------------- | -------------------------------------- |\n| **迭代内容** | 迭代的是 **Key (键名/索引)** | 迭代的是 **Value (键值)**                    |\n| **适用范围** | 主要用于**对象**，也可用于数组    | 只要部署了 **Iterator 接口** (数组、Map、Set、字符串) |\n| **原型链**  | **会**遍历原型链上的可枚举属性    | **不会**遍历原型链                            |\n| **顺序**   | 顺序不确定（对象属性无序）        | 按迭代器的顺序执行（数组是有序的）                      |",
          "hasAnswer": true
        },
        {
          "id": "js-basic-12",
          "title": "call  apply bind 区别",
          "content": "这三个方法都是为了**改变函数执行时的 `this` 指向**。\n\n- **`call(context, arg1, arg2...)`**：立即执行。参数是一个个传进去的。\n\n- **`apply(context, [args])`**：立即执行。参数是以**数组**形式传进去的。\n\n- **`bind(context, arg1...)`**：**不会立即执行**。它会返回一个新的函数，并永久绑定了 `this`，后续调用时再传入剩余参数。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-13",
          "title": "导致js里this指向混乱的原因是什么?",
          "content": "根本原因在于：**普通函数采用动态绑定（Dynamic Binding），其 `this` 的值不是在函数定义时确定的，而是在函数被调用时，根据函数调用的方式（Call Site）临时决定的。**\n\n`this` 的值高度依赖于**调用函数时的上下文**，这种运行时（Runtime）绑定机制与 JS 的词法作用域规则形成了鲜明对比，造成了巨大的认知负担。\n\nES6 的解决方案：箭头函数，没有自己的动态 `this`，`this` 变得可预测、不可变，不再受调用方式的影响",
          "hasAnswer": true
        },
        {
          "id": "js-basic-14",
          "title": "你觉得js里this的设计怎么样?有没有什么缺点",
          "content": "`this` 的设计初衷是为了实现高度的**灵活性**和**代码复用**。通过显式绑定隐式绑定可以更加灵活\n\n`this` 的所有缺点都源于一个核心问题：**它的值是动态绑定（Runtime Dynamic Binding）的，依赖于函数的调用点 (Call Site)，而不是定义点。**\n\n有严重的上下文丢失陷阱：回调函数问题： 当一个对象的方法被作为参数传递给异步函数（如 `setTimeout`、`Promise.then()`）或事件处理器时，它通常会失去其隐式绑定，退化为**默认绑定（指向全局对象或 `undefined`）**。\n\n违反词法作用域原则 ：JavaScript 的变量（使用 `let/const`）是词法作用域（静态确定）的，但 `this` 却是动态作用域的。这种不一致性打破了语言的统一性，使得在阅读嵌套代码时很难预测 `this` 的值。\n\nes6通过箭头函数和class弥补了这个问题，开发者应当尽可能利用箭头函数和 `class` 语法来避免直接依赖普通函数的动态 `this` 机制",
          "hasAnswer": true
        },
        {
          "id": "js-basic-15",
          "title": "运算符",
          "content": "ES2020 新增：空值合并运算符 `??` (Nullish Coalescing)\n\n用途：** 专门用于处理 `null` 或 `undefined` 的默认值设置。解决了 `||` 在处理 `0` 和 `\"\"` 时的缺陷。\n\n规则：** 只有当左侧操作数是 `null` 或 `undefined` 时，才返回右侧操作数。\n\nES2021 新增：逻辑赋值运算符\n\n- **`||=` (OR 赋值)：** 只有当左侧为 Falsy 时才赋值。\n\n- **`??=` (空值赋值)：** 只有当左侧为 `null` 或 `undefined` 时才赋值。\n\n其他：typeof  instanceof  delete",
          "hasAnswer": true
        },
        {
          "id": "js-basic-16",
          "title": "执行上下文",
          "content": "JavaScript 引擎在运行代码时，会维护一个 **执行上下文栈 (Execution Context Stack)**，也称为调用栈 (Call Stack)。\n\n- **入栈：** 当代码开始执行或调用函数时，新的执行上下文会被创建并推入栈顶。\n\n- **出栈：** 当函数执行完毕，其上下文会从栈中弹出，控制权返回给栈中的上一个上下文。\n\n- **流程：** 栈底永远是 **全局执行上下文**。\n\n全局执行上下文：它创建全局对象（ `window`、Node.js 中的 `global`）和 `this` 绑定。\n\n函数执行上下文 ：每当一个函数被调用时，都会创建一个新的~~。每次调用都是独立的\n\n阶段一：创建阶段 (Creation Phase / 编译阶段)\n\n在代码执行之前，引擎会扫描函数代码，完成以下三项任务：\n\n1. 确定 `this` 绑定 (ThisBinding)：全局 EC绑定到全局对象；函数EC按调用方式绑定\n\n2. 创建词法环境 (LexicalEnvironment)：存储 `let`、`const`  `class` 声明\n\n3. 创建变量环境 (VariableEnvironment)：用于存储 `var` 变量声明和函数声明\n\n阶段二：执行阶段 (Execution Phase)\n\n引擎开始逐行执行代码，完成以下任务：\n\n1. **变量赋值：** 将值赋给变量（之前在创建阶段被初始化为 `undefined` 或保持未初始化状态）。\n\n2. **代码执行：** 执行所有函数调用和其它语句。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-17",
          "title": "词法环境",
          "content": "**词法环境 (Lexical Environment)** 是 **ECMAScript 标准中定义的具体数据结构**，它是执行上下文（EC）的核心组成部分。它是一个**运行时 (runtime) 对象**，在每个执行上下文创建时生成。它有两个关键部分：\n\n1. **环境记录 (Environment Record)：**\n   \n   - 实际存储变量和函数声明的地方。\n   \n   - **声明式环境记录：** 存储 `let`、`const`、`class`。它们被创建时不会初始化，从而产生**暂时性死区 (TDZ)**。\n   \n   - **对象环境记录：** 在全局 EC 中，存储 `var` 变量和函数。\n\n2. **外部环境引用 (Outer Environment Reference)：**\n   \n   - 指向**创建该执行上下文时的父级执行上下文的词法环境**。\n   \n   - 这个引用链条就是 **作用域链 (Scope Chain)** 的基础，用于变量查找。\n\n总结： 当我们在函数内部访问变量时，JS 引擎会首先在当前 执行上下文 的中查找，如果找不到，就会沿着 **作用域链** 向上查找，直到全局 EC，所以函数能访问外部的变量，这也是闭包的前提。\n\n`let` 在 `for` 循环中会为每次迭代创建独立的词法环境，因此闭包捕获的是不同的 i，而不是同一个变量。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-18",
          "title": "说说js的作用域",
          "content": "A. 三种作用域：\n\n1. **全局作用域**：代码任何地方都能访问。\n2. **函数作用域**：变量只在函数内部可见。\n3. **块级作用域 (ES6+)**：由 `{}` 包裹的区域（配合 `let` / `const` 使用）。\n\nB. 作用域链 (Scope Chain)：\n\n当 JS 引擎寻找一个变量时，会先在当前作用域找。如果找不到，就去**父级作用域**找，直到找到全局作用域为止。这种链式查找机制就是作用域链。\n\nC. JS 采用的是**静态作用域**（即词法作用域）。\n\n**词法作用域 (Lexical Scope)** 是一个**抽象的、静态的编程原则或规则**。\n\n- **性质：** 它只取决于代码在 **哪里被编写 (定义)**，与代码在运行时 **哪里被调用** 无关。\n- **作用：** 它决定了变量的可访问性范围。\n- 这意味着函数的作用域在**函数定义的时候**就决定了，而不是在函数调用的时候。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-19",
          "title": "Object.create(proto) 方法",
          "content": "其中 *proto* 是新对象的原型对象\n\n`Object.create()` 的主要目的**不是复制 (Clone)** 一个现有对象，而是创建一个**新对象**，并精确控制新对象的**原型 (Prototype)**。\n\n`Object.create()` 的第一个参数是 **强制要求** 传入的，它就是新创建对象的 **`[[Prototype]]` (即 `__proto__`)**。\n\n核心能力是作为 **ECMAScript 官方提供的、创建指定原型对象**的方法，它是实现纯净原型继承的最佳实践。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-20",
          "title": "Object.assign()",
          "content": "`Object.assign(target, ...sources)` 方法用于将所有**可枚举 (enumerable) 的自有属性 (own properties)** 的值，从一个或多个**源对象 (source)** 复制到**目标对象 (target)**。\n\n返回值： 返回修改后的目标对象 `target`。\n\n仅执行浅拷贝 (Shallow Copy Only)\n\n只复制可枚举的自有属性\n\n一般用于**合并配置对象 (Merging)：** 将默认配置与用户提供的配置合并。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-21",
          "title": "Object.defineProperties 的作用",
          "content": "把参数2的属性赋值给参数1，特点是不仅复制属性，还复制属性的属性，比如是否可枚举、可修改这些属性\n\n- 不仅仅是赋值，而是**使用属性描述符定义属性**\n\n- 可以控制属性的可写性、可枚举性、可配置性\n\n- 可以定义访问器属性（getter/setter）\n\n- 默认属性特性与普通赋值不同",
          "hasAnswer": true
        },
        {
          "id": "js-basic-22",
          "title": "es6新特性",
          "content": "1. 作用域与变量管理 (Scope & Mutability)\n- **`let` 和 `const`：** 引入**块级作用域 (Block Scoping)**，彻底解决了 `var` 导致的变量提升和作用域污染问题，增强了代码的稳定性和可预测性。\n2. 异步编程基石 (Async Foundation)\n- **Promises：** 提供了结构化、可链式调用的异步处理方案，解决了传统回调函数的**回调地狱 (Callback Hell)**，是 `async/await` 的底层基础。\n3. 函数与上下文 (Functions & Context)\n- **箭头函数 (`=>`)：** 语法简洁。核心价值在于使用**词法 `this`**，消除了普通函数中 `this` 绑定不明确的痛点，使上下文指向更加可靠。\n4. 数据结构与模块化 (Data & Structure)\n- **`class` 语法：** 基于原型继承的**语法糖**，使面向对象编程（OOP）更接近传统语言模式，提高了可读性。\n- **解构赋值/扩展运算符 (`...`)：** 极大地简化了数据操作，如数组合并、对象浅拷贝、函数参数收集等，提高了代码简洁性。\n- **`Map` 和 `Set`：** 提供了更高效的数据结构，解决了传统 JS 对象作为键的限制 (`Map`) 和快速去重 (`Set`) 的需求。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-23",
          "title": "Set、Map、WeakSet、weakMap 的区别",
          "content": "Weak 系列与普通系列的本质区别，就在于**垃圾回收 (GC)** 机制。\n\n1. 强引用 (Strong Reference)：Map & Set\n- 如果一个对象被 `Map` 或 `Set` 引用，那么这个对象就不会被垃圾回收机制回收。\n\n- **副作用：** 如果你将 DOM 元素或大型对象作为键或值存储在 `Map` 或 `Set` 中，即使该对象在代码中已无其他引用，它也会被 Map/Set **钉死在内存中**，直到你手动调用 `.delete()` 移除，否则会导致**内存泄漏**。\n2. 弱引用 (Weak Reference)：WeakMap & WeakSet\n- 如果一个对象**只**被 `WeakMap` 或 `WeakSet` 引用，那么这个对象**可以**被垃圾回收机制回收。\n\n- **自动清理：** 一旦对象被 GC 回收，它在 `Weak` 集合中的对应条目也会被 **自动移除**。\n\n- **副作用消除：** 它们专为**不干扰 GC** 的非核心数据存储而设计，是避免内存泄漏的强大工具。\n3. Weak 集合的特殊限制（不可迭代的原因）\n\n`WeakMap` 和 `WeakSet` 具有不可迭代性，也不支持 `.clear()` 或 `.size` 属性。\n\n- **原因：** 由于它们是弱引用，集合中的对象随时可能被 GC 回收而消失。\n\n- **后果：** 如果允许迭代，你将无法保证在迭代开始和结束时集合内容的一致性，这会导致代码逻辑不可预测。\n\n高级应用场景（Use Cases）\n\nA. WeakMap：关联私有数据或缓存\n\n- **场景：** 在不修改原对象的情况下，为其关联额外的数据或缓存。\n\n- **示例：** 创建一个 `WeakMap` 来存储 DOM 元素的事件监听器。当 DOM 元素被移除时（被 GC 回收），WeakMap 中对应的事件监听器也会自动清理，**防止内存泄漏**。\n\nB. WeakSet：跟踪对象状态或成员资格\n\n- **场景：** 简单地跟踪一个大型对象集合中，哪些对象处于“活动”或“已处理”状态，但又不想阻止这些对象被 GC 回收。\n\n- **示例：** 跟踪一个大型应用中哪些对象实例已经被初始化或激活，用于防止重复处理。\n\n总结来说，`Set` 和 `Map` 是通用的数据结构，用于**核心数据存储**；而 `WeakSet` 和 `WeakMap` 是用于**关联辅助数据、解决内存泄漏问题**的**工具**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-24",
          "title": "箭头函数与普通函数的差异",
          "content": "没有自己的this, 继承外层作用域的 `this`。\n\n不能new\n\n不能call bind apply\n\n没有 `arguments` 对象\n\n不支持 `yield` 关键字",
          "hasAnswer": true
        },
        {
          "id": "js-basic-25",
          "title": "ES6模块和Common]S模块的区别",
          "content": "核心区别在于 **CommonJS 是为服务器端同步加载设计的**，而 **ES Modules 是为浏览器端异步加载和静态分析设计的**。\n\n- CJS 是在 Node.js 环境中诞生的，文件模块通常存储在本地硬盘上。因此，CJS 可以使用 `require()` **同步阻塞**地加载文件。它在**运行时**执行代码后，才能知道导入了什么。\n\n- **ES Modules (异步)：** ESM 是为浏览器设计的，模块通常需要通过网络请求加载。因此，ESM 采用**异步加载**，以避免阻塞主线程。ESM 在**代码静态解析阶段**（编译时）就能确定所有依赖关系。\n\n- **CommonJS (动态值拷贝)：**\n  \n  - CJS 导出的是一个值的**拷贝**。一旦模块导出，原始模块内部对变量的修改不会影响到导入方。\n  \n  - `require()` 得到的是一份导出的**值的快照**。\n\n- **ES Modules (静态实时绑定/引用)：**\n  \n  - ESM 导出的是对原始变量的**引用**（Live Binding）。\n  \n  - 这意味着导入方和导出方共享同一个变量。如果导出方在后续代码中修改了该变量，导入方可以观察到这种变化。\n\n**ESM 的优势：** 由于 ESM 采用 `import` / `export` 这种**静态语法**，JS 引擎或构建工具（如 Webpack/Rollup）可以在不执行代码的情况下，分析出模块之间的依赖关系。这使得 **Tree-Shaking（摇树优化）**成为可能，即只打包实际用到的代码，极大地减小了最终产物大小。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-26",
          "title": "arguments 的定义与作用",
          "content": "`arguments` 是一个特殊的**类数组对象 (Array-like Object)**，它在函数被调用时自动创建，并包含函数被调用时实际传入的所有参数。\n\n**作用域：** 仅存在于**非箭头函数**的函数体内部。\n\n可迭代对象，但不是数组 可以通过传统的 `for` 循环进行遍历或者Array.from(arguments)\n\n```js\nfunction sum(a, b) {\n  // 访问第一个参数\n  console.log(arguments[0]); // 对应传入的 a\n  // 访问所有参数数量\n  console.log(arguments.length); \n\n  // 即使函数没有定义第三个参数，也可以通过 arguments 访问\n  if (arguments.length > 2) {\n    console.log('还有额外的参数：', arguments[2]);\n  }\n}\n\nsum(10, 20, 30); \n// 输出: 10\n// 输出: 3\n// 输出: 还有额外的参数： 30\n```\n\n更推荐用es6的剩余参数\n\n```js\nfunction sumAll(...args) {\n  // args 是一个真正的数组，可以直接使用数组方法\n  return args.reduce((acc, current) => acc + current, 0);\n}\n\n// 优势：\n// 1. args 是一个真正的数组，可以直接调用 map, reduce 等方法。\n// 2. 没有参数绑定的困扰。\n// 3. 语法更清晰。\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-27",
          "title": "let/const/var 的底层区别",
          "content": "1.作用域 \n\nvar 函数作用域。在函数外部声明时是全局作用域。\n\n`let` / `const`块级作用域 。变量的作用域限制在最近的一对花括号 `{}` 内\n\n2.变量提升\n\nvar 完整提升。声明和初始化同时提升到作用域顶部，但初始化为 `undefined`\n\n`let` / `const` 只提升声明。声明会被提升，但不会被初始化。存在暂时性死区，在变量声明语句执行之前，访问该变量都会抛出 `ReferenceError`\n\n3.绑定与赋值\n\nvar 可以重复声明，在全局作用域声明时，会挂载到 `window` 或 `global` 对象。\n\nlet、const **不允许重复声明**。在同一作用域内重复声明会抛出 `SyntaxError`。也不会挂载到全局对象上。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-28",
          "title": "说说Proxy",
          "content": "`Proxy` 的核心价值在于**对对象的操作进行非侵入式（Non-invasive）的拦截和定制**。它提供了一个代理层，允许我们在对象操作的 13 个内部方法（如 `get`, `set`, `apply`, `construct`）被调用时介入。\n\n应用：\n\n响应式系统和状态管理（最重要，比如vue）；`Proxy` 可以直接监听对象属性的增删改查，而不需要像 `Object.defineProperty` 那样预先遍历所有属性，解决了数组和新增属性的监听难题。\n\n数据校验与属性保护：在 `set` 拦截器中，加入自定义的校验逻辑（如类型检查、范围检查），如果不通过则抛出错误或拒绝赋值，防止不合规的数据流入\n\n实现私有属性：在 `get` 或 `has` 拦截器中，对特定前缀（如 `_` 开头的属性）返回 undefined` 或 `false`，模拟私有属性效果。\n\n写法：\n```javascript\nconst handler = {\n    // 陷阱 (Trap)：拦截属性的读取操作\n    get(target, prop, receiver) {\n        if (prop === 'message3') {\n            return `[${target.message1} ${target.message2}]`;\n        }\n        // 默认行为：返回目标对象的属性值\n        return Reflect.get(target, prop, receiver); \n    },\n    // ... 比如 set(target, prop, value, receiver) { ... }\n}\nconst target = {\n    message1: \"Hello\",\n    message2: \"World\"\n};\nconst proxy = new Proxy(target, handler);\n```",
          "hasAnswer": true
        },
        {
          "id": "js-basic-29",
          "title": "Reflect 是什么？怎么用",
          "content": "`Reflect` 是一个内置对象，它提供了一系列静态方法，这些方法与 `Proxy` 陷阱的方法**同名且参数一致**。它提供了 13 个静态方法，这些方法与 `Proxy` 的 13 个拦截器方法一一对应。\n\n例如：\n\n- 以前获取对象属性：`obj.prop` 或 `Object.getOwnPropertyDescriptor(obj, prop)`\n\n- 现在通过 `Reflect`：`Reflect.get(obj, prop)`\n\n- `'prop' in obj` $\\rightarrow$ `Reflect.has(obj, 'prop')`\n\n- `delete obj.prop` $\\rightarrow$ `Reflect.deleteProperty(obj, 'prop')`\n\n在 `Proxy` 的 `handler` 中，我们经常需要执行目标对象上的默认操作。使用 `Reflect` 可以干净、安全地实现这一点。\n\n`Reflect` 将一些命令式的操作符（如 `delete`）或命令式的方法调用（如 `new`）转换成了函数式的调用，使得代码更易于维护和理解。\n\nReflect 能提供操作失败的明确反馈，返回一个**布尔值**表示成功或失败，代码更简洁。一般的 `Object` 上的方法（例如 `Object.defineProperty`），在执行失败时会抛出异常，这需要用 `try...catch` 捕获。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-30",
          "title": "说说promise怎么用和优缺点",
          "content": "优点：\n\n解决回调地狱，改为链式回调，提高了代码的可读性和维护性\n\n统一的错误处理机制，集中捕获，简化流程\n\n规范异步状态管理，明确的三种状态：Pending/Fulfilled/Rejected, 使异步操作的结果可预测和可追踪。\n\n易于组合和并行处理，.all .race 等\n\n缺点：\n\n仍然是链式结构（未完全同步化）需要显式的 `.then()` 链来组织代码流程\n\n立即执行的特性，缺乏中断和取消机制\n\n一次性结果，一旦状态确定，就无法再次改变\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获\n\n错误静默，没有catch的话，不会在运行时立即抛出执行时才捕获",
          "hasAnswer": true
        },
        {
          "id": "js-basic-31",
          "title": "js有哪些异步方法",
          "content": "1. 计时器 settimeout setInterval，属于宏任务\n2. 异步流程控制与状态管理：Promise async/await，属于微任务\n3. 网络请求与文件操作：\n- **`fetch(url)` (现代标准):** 微任务\n  - 返回一个 Promise 对象，用于发起网络请求。\n  - 是最常用的网络请求 API，取代了大部分 XHR 用法。\n- **`XMLHttpRequest` (XHR) (传统方法):** 特指基于事件监听而不是promise的，是宏任务\n  - 传统的回调式 API，现在主要用于文件上传等特定场景，或需要浏览器底层控制的场合。\n- **`FileReader` / 各种 I/O 操作:** 也是通过回调或 Promise返回，宏任务",
          "hasAnswer": true
        },
        {
          "id": "js-basic-32",
          "title": "Generator是什么怎么用",
          "content": "Generator 函数（生成器）是一种特殊的函数，它能够**暂停执行**并在稍后**从暂停点恢复执行**。这是通过 Generator 函数内部维护的一个 **状态机 (State Machine)** 来实现的。本质是同步的\n\n`function`定义 Generator 函数\n\n`yield`暂停函数执行，并返回 `yield` 后的值\n\n`.next()`恢复函数执行，并返回一个包含 `{value, done}` 的对象。\n\n意义：简化异步编程；提供函数**暂停和恢复执行**的底层能力 (`yield` 机制)，这是实现“等待”的唯一方式；返回一个同时满足可迭代和迭代器协议的对象\n\nGenerator 解决了 **代码流的连续性** 问题，这是 Promise （依赖于 回调函数）无法做到的。\n\n`async/await` 的底层基础是 Promise，但它的核心机制是 Generator",
          "hasAnswer": true
        },
        {
          "id": "js-basic-33",
          "title": "Generator和 Async/Await 原理",
          "content": "核心机制：状态机\n\n普通函数从头到尾执行一次，没有状态。而 Generator 函数被编译后，其函数体内的每一行代码（特别是 `yield` 语句）都成为了状态机中的一个节点。\n\n`yield` 关键字：暂停的指令（将 Generator 函数的执行上下文完整地保存，并挂起，引擎立即将控制权返回给调用者所在的执行上下文，即调用 `gen.next()` 的那个上下文）\n\n`.next()` 方法：恢复的指令（执行优先级非常高，因为它是一个**同步操作**，讲挂起的上下文放入当前执行栈，会影响后续其他的宏任务微任务，就像一个同步函数调用）\n\nGenerator 对象的生命周期内，其内部状态（包括局部变量）被持续存储在内存中，这就是它能够从上次离开的地方继续执行的原因。\n\n```js\nfunction* numberGenerator() {\n  console.log('--- 启动 ---');\n  let result1 = yield 1;\n\n  console.log('--- 恢复，接收到:', result1, '---');\n  let result2 = yield 2; \n\n  console.log('--- 恢复，接收到:', result2, '---');\n  return 3;\n}\n\n// 1. 调用 Generator 函数，返回迭代器对象（Generator Object）\nconst gen = numberGenerator(); \n\nconsole.log(gen.next()); \n// 输出: --- 启动 ---\n// 输出: { value: 1, done: false } (遇到第一个 yield 暂停)\n\nconsole.log(gen.next('A')); // 将 'A' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: A ---\n// 输出: { value: 2, done: false } (遇到第二个 yield 暂停)\n\nconsole.log(gen.next('B')); // 将 'B' 作为上一个 yield 的返回值注入\n// 输出: --- 恢复，接收到: B ---\n// 输出: { value: 3, done: true } (遇到 return 结束)\n\nconsole.log(gen.next());\n// 输出: { value: undefined, done: true } (已完成)\n```\n\n`async/await` 是 ES7 (ES2016) 引入的，它的底层是基于 **Promise** 和 **Generator** 实现的**语法糖 (Syntactic Sugar)**。它的核心原理是**自动化**了 Generator 的驱动过程，相当于异步完成后自动调用了.next\n\n对比：\n- **Promise** 是 `async/await` 的**外部接口**（输入和输出）。\n- **Generator** 是 `async/await` 实现**暂停和恢复**的**内部引擎**。\n- **async/await**` 是对 **Promise** 和 **Generator** 的一种**语法糖 (Syntactic Sugar)**。",
          "hasAnswer": true
        },
        {
          "id": "js-basic-34",
          "title": "严格模式",
          "content": "严格模式是 ES5 引入的一种特殊模式，旨在选择性地限制 JavaScript 的某些不安全、低效或有缺陷的行为\n\n- **全局模式：** 在脚本文件顶部添加 `\"use strict\";`。\n\n- **函数模式：** 在函数体内部顶部添加 `\"use strict\";`\n\n严格模式是保证代码质量和项目维护性的要求\n\n重要规则：\n\n禁止隐式全局变量：尝试给未声明的变量赋值时，将不再自动在全局对象 (`window` 或 `global`) 上创建该变量，而是**直接抛出 `ReferenceError`**。\n\n规范 `this` 默认绑定（上下文可预测性）：独立函数调用 `this` 为 `undefined`\n\n静默失败转为抛出错误 (代码健壮性)\n\n禁用堆栈调用属性，禁止函数动态获取调用栈信息，（严重阻碍了js 引擎进行即时编译优化",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "typescript",
      "name": "TypeScript",
      "questions": [
        {
          "id": "typescript-1",
          "title": "type 和 interface 的区别",
          "content": "interface 接口 可合并可多次定义，更适合定义对象或者 api 的标准和形状\n\ntype 不可多次声明，可以定义任何类型，包括对象、联合类型、交叉类型、原始类型、元组",
          "hasAnswer": true
        },
        {
          "id": "typescript-2",
          "title": "TypeScript 与 JavaScript 的主要区别",
          "content": "ts: **静态类型**：类型在代码编写时确定。必须通过 **TS 编译器**（或 Babel/SWC 等）编译成 JS 后才能执行；编译时检查，**类型安全**高；JS 的**超集**，包含了 JS 的所有特性\n\njs：动态类型，类型在执行时确定；运行时检查，**类型安全**低（运行时错误多）",
          "hasAnswer": true
        },
        {
          "id": "typescript-3",
          "title": "什么是联合类型 (|) 和交叉类型 (&)",
          "content": "联合类型 | （或） 表示一个值可以是所列类型中的任意一种。\n\n交叉类型 & (且) **表示一个值必须同时满足所列的**所有类型。常用于合并接口或类型，实现 Mixin 效果。一个交叉类型对象必须拥有所有类型的属性。",
          "hasAnswer": true
        },
        {
          "id": "typescript-4",
          "title": "any 和 unknown 的区别",
          "content": "any **完全禁用**类型检查。可以赋值给任何类型，**破坏**类型安全。可以随意访问属性或调用方法，可能导致运行时错误。\n\nunknow **严格类型检查**，除非明确类型收窄，否则无法使用。只能赋值给 `any` 或 `unknown` 本身，**保持**类型安全。**必须先进行类型收窄**（如 `if (typeof x === 'string')`），才能操作。\n\n更推荐 unknow 提供了一个类型安全的占位符",
          "hasAnswer": true
        },
        {
          "id": "typescript-5",
          "title": "类型断言及其使用场景",
          "content": "类型断言是告诉 TypeScript 编译器“我比你更清楚这个变量的实际类型”的一种方式。它不会改变变量的运行时类型，只在编译时起作用\n\n**应避免使用的场景：**\n\n- **不确定的情况下：** 任何你不 100% 确定类型的时候。错误的断言会**绕过 TS 的保护**，导致在运行时出现错误（这是 TS 极力避免的）。\n\n- **可以进行类型收窄的情况下：** 应优先使用类型保护（`if`, `instanceof` 等）进行收窄，而不是使用断言",
          "hasAnswer": true
        },
        {
          "id": "typescript-6",
          "title": "解释 keyof 和 typeof 的用法",
          "content": "| **`typeof`** | **值到类型**。获取一个 JavaScript **变量**或**表达式**的类型。   | 常用于获取函数的返回值类型，或从常量对象中提取类型。  |\n| ------------ | --------------------------------------------- | --------------------------- |\n| **`keyof`**  | **键名提取**。获取一个**对象类型**中所有属性名组成的**联合字符串字面量类型**。 | 常用于泛型约束，确保传入的属性名是对象中真实存在的键。 |\n\n```js\nconst User = {\n    name: 'Alice',\n    age: 30\n};\n\n// 1. typeof：获取 User 变量的类型\ntype UserType = typeof User; // 结果: { name: string; age: number; }\n\n// 2. keyof typeof：获取 User 类型的所有键名\ntype UserKeys = keyof typeof User; // 结果: \"name\" | \"age\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-7",
          "title": "tsconfig.json 中的 strict 模式",
          "content": "**`\"strict\": true`** 是 `tsconfig.json` 中的一个总开关，它同时开启了一系列严格的类型检查规则。它的作用是**最大化地提升代码的类型安全性**。\n\n我认为 **`strictNullChecks`**（严格空值检查）是最重要的子选项。\n\n- **作用：** 默认情况下，`null` 和 `undefined` 可以赋值给任何类型。开启后，`null` 和 `undefined` 只能赋值给它们自己的类型或 `any`，除非类型定义中明确包含它们（如 `string | null`）。",
          "hasAnswer": true
        },
        {
          "id": "typescript-8",
          "title": "装饰器及其应用场景",
          "content": "饰器是一种特殊的声明，它能够附加到类、方法、属性或参数上，用于**修改或扩展**这些目标的功能或行为。它们是 **ES 阶段性提案**，TS 率先实现。\n\n装饰器本质上就是一个**函数**。这个函数在运行时会被调用，它接收关于被装饰目标的元数据（如目标类、方法名、属性描述符等），并可以通过返回新的值来**修改或替换**被装饰目标的定义。\n\n装饰器允许我们在不修改原有类结构和代码的情况下，通过注入元数据或实现额外逻辑，对现有功能进行扩展。\n\n1. 语法\n\n装饰器使用 `@expression` 的形式，紧挨着要装饰的声明之前。\n\n```ts\n@sealed // 这是一个装饰器\nclass Example {\n  @logMethod // 这是另一个装饰器\n  myMethod() {}\n}\n```\n\n2. 启用\n\n装饰器目前是 ECMAScript 的**阶段性提案**（Stage 3），不是标准的 JS 语法。要在 TypeScript 中使用它，必须在 `tsconfig.json` 中启用：\n\nJSON\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true, // 必须开启\n    \"emitDecoratorMetadata\": true // 如果需要依赖注入等元数据，也需要开启\n  }\n}\n```\n\n3.类型：类 属性 方法 Getter/Setter 方法参数\n\n作用\n\n1 依赖注入 (DI) 和框架配置，装饰器（或等效的语法）来标记类和处理依赖注入。比如 vue-property-decorator\n\n2 混入 (Mixins) 或功能增强（类装饰器）：可以利用类装饰器返回一个新的构造函数，为类添加新方法或属性：\n\n3.运行时 添加通用逻辑（方法装饰器）：方法装饰器常用于不修改原函数体的情况下，在其执行前后添加通用逻辑\n\n当一个声明上有多个装饰器时，它们的执行顺序如下：\n\n1. **参数装饰器 $\\to$ 属性装饰器 $\\to$ 方法/访问器装饰器 $\\to$ 类装饰器**（从内向外，从上到下）。\n\n2. **同一类型装饰器：** 如果同一目标上有多个装饰器，它们会像函数组合一样，**从下到上**（从右到左）执行。",
          "hasAnswer": true
        },
        {
          "id": "typescript-9",
          "title": "处理第三方库没有类型定义的问题",
          "content": "当引入一个没有内置类型定义的第三方 JS 库时，需要手动为其添加类型声明，以让 TS 编译器识别其结构。\n\n**处理步骤：**\n\n1. **检查 `@types/` 库：** 首先尝试 npm 生态系统中有没有针对这个第三方 JavaScript 库的**对应的类型定义库**。比如@types/jquery @types/lodash，有的话安装库就行了\n\n2. **创建自定义声明文件 (`.d.ts`)：** 如果 `@types` 包不存在，需要手动创建声明文件，通常命名为 `custom.d.ts` 或 `library-name.d.ts`。\n   \n   a.**模块声明：** 使用 `declare module` 声明整个模块的类型。\n\n```typescript\n// my-library.d.ts\ndeclare module 'my-library' {\n  // 声明库导出的函数\n  export function initialize(config: object): void;\n  // 声明库导出的类\n  export class AwesomeClient {\n    connect(): Promise<string>;\n  }\n  // 声明默认导出\n  export default AwesomeClient;\n}\n```\n\nb.全局变量声明：如果库是注入全局变量的（如 jQuery），则使用 `declare var` 或 `declare function`。\n\n这样，TypeScript 编译器就会信任您提供的类型信息，并在您的项目代码中提供类型检查和智能提示。\n\n注意：全局/局部声明：\n如果是 declare module xx{...}，就只针对引用这个 module 的模块，如果是有顶层 export 就只针对导入这个文件的模块，如果直接 declare xx 且文件里没有任何顶层 export 就是全局的\n\n这里的**全局**和**局部（模块）**指的完全是 **TypeScript 编译器**对您的代码和声明文件（`.d.ts`）中**类型和标识符作用域**的认识",
          "hasAnswer": true
        },
        {
          "id": "typescript-10",
          "title": "Extract、Exclude、Pick、Omit 的区别与用法",
          "content": "Extract 提取\n\n- 是一个内置的工具类型，它的作用是**从一个联合类型中，提取出符合特定条件的成员**，并组成一个新的联合类型。\n\n- 可以把它理解为联合类型的“过滤器”。支持**子类型**的匹配\n\n- 原理：遍历 `T` 中的每一个成员。如果该成员能够赋值给 `U`，就保留它（返回 `T`）；否则就丢弃它（返回 `never`）。 `type MyExtract<T, U> = T extends U ? T : never;`\n\n```ts\ntype Result = Extract<Type, Union>;\n\ntype Status = 'success' | 'error' | 'loading' | 'waiting';\n// 我只想从中提取出 'error' 和 'success'\ntype FinalStatus = Extract<Status, 'success' | 'error'>;\n// 结果：'success' | 'error'\n\ntype MyData = string | number | boolean | (() => void);\n// 提取出所有可以赋值给 Function 的类型\ntype OnlyFunction = Extract<MyData, Function>; // 结果：() => void\n```\n\nExclude 排除\n\n**Exclude** 就是 **Extract** 的反义词\n\n`Exclude<T, U>`：排除 `T` 中属于 `U` 的\n\n```ts\ntype Status = 'success' | 'error' | 'loading';\ntype NoError = Exclude<Status, 'error'>; // 结果：'success' | 'loading'\n```\n\nPick（挑选）\n\n`Pick<Type, Keys>` 允许你从一个类型中，选择一组特定的属性来构造新类型。\n\n- **语法**：`Pick<T, K>`，其中 `T` 是源类型，`K` 是由 `T` 的键组成的联合类型。\n\n- **适用场景**：当你只需要一个大型对象中的某几个字段时\n\n- **实现**：它遍历 `K` 中的每一个键，并在 `T` 中找到对应的类型。\n\nOmit（剔除）\n\n`Omit<Type, Keys>` 与 `Pick` 相反，它会从一个类型中剔除指定的属性，剩下的属性组成新类型。\n\n- **语法**：`Omit<T, K>`。\n\n- **适用场景**：当你想复用一个类型，但其中某个字段不需要，或者需要被重新定义时\n\n- **实现**：它结合了 `Exclude` 和 `Pick`。先从 `T` 的所有键中排除掉 `K`，再把剩下的键 `Pick` 出来。\n\n```ts\ntype Hello = { a: string; b: string; c: number };\n\n// 使用 Pick 挑选属性\ntype OnlyAB = Pick<Hello, 'a' | 'b'>;\n// 结果为：\n// type OnlyAB = { a: string; b: string;}\n```\n\n对比：\n\n- **`Extract Exclude`**：操作的是**联合类型**，第二个参数是类型集合。是从一堆类型选项里选出几个\n\n- **`Pick Omit`** 处理的是对象类型, 第二个参数是属性集合，根据属性键进行选择或忽略\n\n- **`Pick`**：可以理解为白名单操作的是**对象接口（Interface/Object Type）**。它是从一个对象的属性里选出几个。 `Pick` 会严格检查选择的键是否存在于原类型中，如果你 Pick 一个不存在的键，编译器会报错\n\n- **Omit**：可以理解为黑名单。在使用 `Omit` 时，TS **不会**检查你剔除的键是否存在于原类型中（因为 `K extends keyof any`）。\n\n```ts\ninterface User {\n  id: string;\n  name: string;\n  age: number;\n}\n// 剔除 id 属性\ntype CreateUserDto = Omit<User, 'id'>;\n/*\n等同于：\ntype CreateUserDto = {\n  name: string;\n  age: number;\n};\n*/\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-11",
          "title": "TypeScript 基本数据类型",
          "content": "- boolean（布尔类型）\n- number（数字类型）\n- string（字符串类型）\n- array（数组类型）\n- null 和 undefined 类型\n- object 对象类型\n- tuple（元组类型） 允许表示一个已知元素数量和类型的数组，各元素的类型不必相同\n- enum（枚举类型）\n- void 类型 用于标识方法返回值的类型，表示该方法没有返回值\n- any（任意类型）可以指定任何类型的值，不进行类型检查而是通过编译阶段的检查\n- unknow 不确定的类型 ：**严格类型检查**，除非明确类型收窄，否则无法使用。\n- never 类型 代表从不会出现的值，是其他所有类型的子类型，可以赋值给任何类型\n\n```\nlet tupleArr:[number, string, boolean];\ntupleArr = [12, '34', true]; //ok\ntypleArr = [12, '34'] // no ok\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-12",
          "title": "TypeScript 类与修饰符",
          "content": "形式跟`ES6`十分的相似，`typescript`在此基础上添加了修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问（ ES6 私有字段用#表示（ES2022））\n- 受保护 protected：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n- 只读属性`readonly`：只读属性必须在声明时或构造函数里被初始化\n- static (ES6 也有) ：静态属性/方法：是类的属性而不是实例的属性，直接通过类调用\n\n```ts\nclass Square {\n    static width: number // 类的属性\n    public static height: number\n    public name: string;     // 公开（默认）\n    private secret: string;  // 仅类内访问\n    protected age: number;   // 类和子类访问\n    readonly id: number;     // 只读属性\n    public readonly publicReadonly: string  // 只读\n    static readonly PI: number = 3.14159; // static + readonly\n    public static readonly staticPublicReadonly: string = \"\";\n    // 方法类似\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-13",
          "title": "抽象类",
          "content": "抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n\n```ts\nabstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earch...');\n  }\n}\n\nclass Cat extends Animal {\n  makeSound() {\n    console.log('miao miao');\n  }\n}\nconst cat = new Cat();\ncat.makeSound(); // miao miao\ncat.move(); // roaming the earch...\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-14",
          "title": "和 ES6 对比",
          "content": "TypeScript 类在 ES6 类的基础上增加了**静态类型系统**和**面向对象增强特性**。主要区别有：\n\n1. **类型注解**：属性、方法、参数都有明确类型\n\n2. **访问修饰符**：`public/private/protected/readonly`\n\n3. **抽象类和抽象方法**：不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\n4. **额外语法**：装饰器、泛型等\n\n**关键理解**：TypeScript 类是带类型的 ES6 类，大部分特性在编译后会被移除，最终生成标准的 JavaScript 类。",
          "hasAnswer": true
        },
        {
          "id": "typescript-15",
          "title": "TypeScript 函数特性",
          "content": "默认参数：es6 写法\n\n剩余参数：es6 写法\n\n可选参数：ts\n\n和 ES6 对比：TypeScript 函数在 ES6 函数的基础上增加了**静态类型系统**。主要区别有：\n\n1. **类型注解+更严格的编译时检查**：参数、返回值都有明确类型\n\n2. **函数重载**：支持多个函数签名，提高类型安全\n\n3. **泛型函数**：支持类型参数化，创建可复用的函数模板\n\n4. **可选参数语法**：使用  `?`  明确表示可选参数",
          "hasAnswer": true
        },
        {
          "id": "typescript-16",
          "title": "泛型的定义与使用",
          "content": "泛型允许编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型\n\n在`typescript`中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性\n\n泛型通过`<>`的形式进行表述，可以声明：函数 接口 类\n\n```\nfunction returnItem<T>(para: T): T {\n    return para\n}\ninterface ReturnItemFn<T> {\n    (para: T): T\n}\nclass Stack<T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-17",
          "title": "高级类型",
          "content": "- 交叉类型 `T & U`\n\n- 联合类型 `T | U`\n\n- 条件类型 `T extends U ? X : Y`\n\n- 类型别名 ,可以是泛型 ,也可以使用类型别名来在属性里引用自己：\n  \n  ```ts\n  type some = boolean | string;\n  type Container<T> = { value: T };\n  type Tree<T> = {\n    value: T;\n    left: Tree<T>;\n  };\n  ```\n\n- 类型索引：keyof，类似于  `Object.keys` ，用于获取一个接口中 Key 的联合类型。\n\n- 类型约束：通过关键字  `extend`  进行约束，泛型内使用的主要作用是对泛型加以约束\n  \n  ```ts\n  type BaseType = string | number | boolean;\n  // 这里表示 copy 的参数\n  // 只能是字符串、数字、布尔这几种基础类型\n  function copy<T extends BaseType>(arg: T): T {\n    return arg;\n  }\n  ```\n\n- 映射类型：通过  `in`  关键字做类型的映射，遍历已有接口的  `key`  或者是遍历联合类型\n  \n  ```ts\n  type Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n  };\n  interface Obj {\n    a: string;\n    b: string;\n  }\n  type ReadOnlyObj = Readonly<Obj>;\n  // 等同于\n  interface ReadOnlyObj {\n    readonly a: string;\n    readonly b: string;\n  }\n  ```",
          "hasAnswer": true
        },
        {
          "id": "typescript-18",
          "title": "命名空间 namespace",
          "content": "解决命名污染，使用  `namespace`  来定义，类似模块化\n\n```ts\nnamespace SomeNameSpaceName {\n  export interface ISomeInterfaceName {}\n  export class SomeClassName {}\n}\n// 使用\nSomeNameSpaceName.SomeClassName;\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-19",
          "title": "条件类型中的 extends 判断",
          "content": "T extends U ：是 TypeScript 的条件类型语法，用于判断类型  `T`  是否可以赋值给类型  `U`，类似于判断  `T`  是否为  `U`  的子类型（或相同类型）。在分布式条件下，如果  `T`  是联合类型，那么会拆开每个成员分别判断。\n\n```ts\ntype A = 'a' | 'b' | 'c';\ntype B = 'a' | 'b';\n\n// 判断 'a' 是否可以赋值给 B？可以，因为 'a' 在 B 中。\n// 判断 'b' 是否可以赋值给 B？可以。\n// 判断 'c' 是否可以赋值给 B？不可以。\n\n// 所以 Exclude<A, B> 会计算：\n// 'a' extends B ? never : 'a' → never\n// 'b' extends B ? never : 'b' → never\n// 'c' extends B ? never : 'c' → 'c'\n// 合并：never | never | 'c' → 'c'\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-20",
          "title": "为什么  string | null extends null  是  false？",
          "content": "**理解  `extends`  的含义**：在 TypeScript 中，`T extends U`  表示：\n\n- **类型 T 的值可以安全地赋值给类型 U 的变量**\n\n- 或者说：**类型 T 是类型 U 的子类型**",
          "hasAnswer": true
        },
        {
          "id": "typescript-21",
          "title": "infer 关键字的用法",
          "content": "只能在 **条件类型 (Conditional Types)** 的 `extends` 子句中使用。在类型的条件判断中，“声明”一个变量来捕获（提取）某个特定的类型。\n\n可以理解为：infer 告诉编译器：不要让我手动指定这个类型，请你根据当前的上下文，帮我**推断**出这里的具体类型并挂载到变量名下。\n\n我不需要知道 R 是什么，我让 TS 自己去“挖”，不是开发者指定的，是编译器“猜”出来的。\n\n对比泛型：本质上是**参数**，调用时具体什么类型是明确的\n\n可以像正则表达式一样拆分字符串。\n\n```ts\n// 不需要知道 R 是什么，我让 TS 自己去“挖”\ntype MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n// 使用时：\ntype Result = MyReturnType<() => string>;\n// TS 就像做“填空题”一样，把 () => string 和 (...args: any[]) => R 对齐，\n// 发现 R 的位置刚好是 string，于是 R 就被赋值为 string。\n\n// 拆分字符串\ntype GetColor<T> = T extends `color:${infer C}` ? C : 'unknown';\ntype MyColor = GetColor<'color:red'>; // \"red\"\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-22",
          "title": "映射类型中的 - + 修饰符",
          "content": "- `-`  只能用于  `readonly`  和  `?`，**不能用于  `private`/`protected`!**\n\n- 这些操作只能在映射类型（`[P in keyof T]`）中使用\n\n- 可以组合使用：`-readonly -?`\n\n- 可以递归应用以处理嵌套对象\n\n添加修饰符（默认或显式使用  `+`）\n\n```ts\n// 显式添加（可选写法）\ntype ExplicitReadonly<T> = {\n  +readonly [P in keyof T]: T[P];  // 显式添加 readonly\n};\n\ntype ExplicitPartial<T> = {\n  +? [P in keyof T]: T[P];  // 显式添加 ?\n};\n```\n\n移除修饰符（使用  `-`）\n\n```ts\n// 移除 readonly\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n// 移除可选（?）\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// 同时移除 readonly 和 ?\ntype MutableRequired<T> = {\n  -readonly [P in keyof T]-?: T[P];\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-23",
          "title": "映射类型",
          "content": "遍历一个类型的属性，并对每个属性应用某种转换，生成新的类型。注意不能遍历私有属性\n\n核心语法：`{ [K in Keys]: Type }`\n\n常用场景：批量修改修饰符；批量转换属性；批量改变键名\n\n语法支持：条件过滤，as 断言\n\n注意：\n\n- **一个类型内部只能有一个映射类型**\n- **映射不处理私有和受保护属性**\n- **映射类型会保留索引签名**\n- `keyof any = string | number | symbol`",
          "hasAnswer": true
        },
        {
          "id": "typescript-24",
          "title": "类型收窄（Type Narrowing）",
          "content": "类型收窄是指 TypeScript 通过代码流分析，在特定代码块中将变量的类型从较宽泛的类型缩小到更具体的类型。\n\n**常见的类型收窄方式：**\n\n1. **typeof 类型守卫**：\n\n```ts\nfunction print(x: string | number) {\n  if (typeof x === 'string') {\n    console.log(x.toUpperCase()); // x 被收窄为 string\n  } else {\n    console.log(x.toFixed(2)); // x 被收窄为 number\n  }\n}\n```\n\n2. **instanceof 类型守卫**：\n\n```ts\nfunction logDate(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toISOString()); // x 是 Date\n  }\n}\n```\n\n3. **in 操作符**：\n\n```ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    animal.swim(); // animal 是 Fish\n  }\n}\n```\n\n4. **自定义类型守卫（is 关键字）**：\n\n```ts\nfunction isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n```\n\n5. **真值收窄**：`if (x)` 排除 `null`、`undefined`、`0`、`''` 等\n\n6. **相等性收窄**：`if (x === y)` 或 `if (x !== null)`",
          "hasAnswer": true
        },
        {
          "id": "typescript-25",
          "title": "tsconfig.json 重要配置",
          "content": "| 配置项                 | 作用                        |\n| ------------------- | ------------------------- |\n| `strict`            | 总开关，开启所有严格类型检查            |\n| `strictNullChecks`  | null/undefined 不能赋值给其他类型  |\n| `noImplicitAny`     | 禁止隐式 any 类型               |\n| `target`            | 编译目标版本（ES5/ES6/ESNext）    |\n| `module`            | 模块系统（CommonJS/ESNext/AMD） |\n| `moduleResolution`  | 模块解析策略（node/bundler）      |\n| `baseUrl` + `paths` | 路径别名配置                    |\n| `outDir`            | 输出目录                      |\n| `rootDir`           | 源码根目录                     |\n| `declaration`       | 生成 `.d.ts` 声明文件           |\n| `esModuleInterop`   | 兼容 CommonJS 和 ES Module   |\n| `skipLibCheck`      | 跳过声明文件类型检查，加快编译           |\n| `resolveJsonModule` | 允许导入 JSON 文件              |\n| `jsx`               | JSX 编译方式（react/preserve）  |",
          "hasAnswer": true
        },
        {
          "id": "typescript-26",
          "title": "TypeScript 模块化",
          "content": "TypeScript 完全支持 ES Module 语法，同时兼容 CommonJS。\n\n**ES Module 语法**：\n\n```ts\n// 导出\nexport const name = 'hello';\nexport default function () {}\nexport type { MyType };\nexport { value as alias };\n\n// 导入\nimport defaultExport from './module';\nimport { name } from './module';\nimport type { MyType } from './module';\nimport * as all from './module';\n```\n\n**模块解析**：\n\n- `moduleResolution: \"node\"` - Node.js 风格解析\n- `moduleResolution: \"bundler\"` - 现代打包器风格（推荐）\n\n**路径别名**：\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n**命名空间 vs 模块**：现代 TS 项目推荐使用 ES Module，命名空间主要用于全局脚本环境。",
          "hasAnswer": true
        },
        {
          "id": "typescript-27",
          "title": "TypeScript 中的异步处理",
          "content": "TypeScript 为异步操作提供了完整的类型支持：\n\n**1. Promise 类型**：\n\n```ts\nfunction fetchData(): Promise<string> {\n  return fetch('/api').then((res) => res.text());\n}\n\n// 泛型指定返回值类型\nconst promise: Promise<number> = Promise.resolve(42);\n```\n\n**2. async/await**：\n\n```ts\nasync function getData(): Promise<User[]> {\n  const response = await fetch('/api/users');\n  return response.json(); // 自动推断返回 Promise<User[]>\n}\n```\n\n**3. 错误处理类型**：\n\n```ts\nasync function safeFetch<T>(url: string): Promise<T | null> {\n  try {\n    const res = await fetch(url);\n    return res.json();\n  } catch {\n    return null;\n  }\n}\n```\n\n**4. 并发处理**：\n\n```ts\n// Promise.all 自动推断元组类型\nconst [user, posts] = await Promise.all([\n  fetchUser(), // Promise<User>\n  fetchPosts(), // Promise<Post[]>\n]); // user: User, posts: Post[]\n```",
          "hasAnswer": true
        },
        {
          "id": "typescript-28",
          "title": "接口继承",
          "content": "**单继承**：\n\n```ts\ninterface Animal {\n  name: string;\n}\ninterface Dog extends Animal {\n  breed: string;\n}\n// Dog 拥有 name 和 breed 两个属性\n```\n\n**多继承**：\n\n```ts\ninterface Flyable {\n  fly(): void;\n}\ninterface Swimmable {\n  swim(): void;\n}\ninterface Duck extends Flyable, Swimmable {\n  quack(): void;\n}\n```\n\n**接口继承类**：\n\n```ts\nclass Point {\n  x: number = 0;\n  y: number = 0;\n}\ninterface Point3D extends Point {\n  z: number;\n}\n```\n\n**interface vs type 继承对比**：\n\n- interface 用 `extends` 继承\n- type 用 `&` 交叉类型实现类似效果\n- interface 可以被多次声明并自动合并，type 不行",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "css-html",
      "name": "CSS & HTML",
      "questions": [
        {
          "id": "css-html-1",
          "title": "tailwind",
          "content": "Tailwind 是一个原子化 CSS 框架，每个类名对应一个单独的 CSS 属性，通过组合类名来构建组件样式。  \n **优点**：1️⃣ 打包时只包含使用到的类，CSS 文件体积小；2️⃣ 响应式和状态样式有内置支持，熟悉后可快速阅读 HTML/JSX，无需跳转 CSS 文件。  \n **缺点**：1️⃣ HTML/JSX 中类名可能很长，阅读略困难；2️⃣ 对复杂动效和状态管理，需要组合更多类，前期学习成本高。\n\n 简单一句话概括：**Tailwind 用类名组装替代传统 CSS，更轻量、可维护，但初学者上手和复杂交互处理略有挑战。**",
          "hasAnswer": true
        },
        {
          "id": "css-html-2",
          "title": "less sass scss 作用",
          "content": "Less、Sass、SCSS*都是 CSS 预处理器。它们的作用是：\n\n- **扩展 CSS 语言：** 引入了变量、嵌套、混合 (Mixins)、函数、继承、条件语句等编程特性，让 CSS 的编写更具逻辑性和可维护性。\n\n- **提高开发效率：** 通过嵌套可以减少重复选择器；通过变量可以实现主题和统一管理颜色值。\n\n- **编译到原生 CSS：** 浏览器无法直接识别预处理器的语法，因此它们都需要一个**编译 (Compile)** 过程，将其特有的语法转换为浏览器能理解的 **标准 CSS 文件**。",
          "hasAnswer": true
        },
        {
          "id": "css-html-3",
          "title": "em rem",
          "content": "em 是以父元素font-size为基准，常用于局部比例计算\nrem 是以页面根元素font-size为基准，常用于页面的整体适配",
          "hasAnswer": true
        },
        {
          "id": "css-html-4",
          "title": "小程序rpx和px在不同手机上有误差",
          "content": "rpx 是小程序里的相对单位，规定屏幕宽度等于 750rpx，不同设备上会根据屏幕宽度换算成不同的 px。\npx 是绝对单位，在不同设备上不自适应；  rpx 是相对单位，理论上 rpx 可以适配不同设备，但在实际渲染时，由于屏幕宽度和 DPR 不同，rpx 换算成 px 时会出现小数，最终需要取整，不同平台的取整和渲染机制也存在差异，因此在不同手机上可能会有细微误差。  误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。\n\n解决：\n避免使用极小的 `rpx` 值。尽量使用偶数的 rpx 值，必要时利用 CSS transform 缩放结合微元素 伪类解决\n尽量用 flex / 自适应布局，减少“精确像素依赖”",
          "hasAnswer": true
        },
        {
          "id": "css-html-5",
          "title": "苹果手机1px",
          "content": "- **设备像素比 (DPR > 1)：** 在 iPhone 等高分屏设备上，`1px` (CSS 像素) 可能等于 $2$ 个或 $3$ 个物理像素。但开发者希望绘制的是**最细的 1 物理像素线**。\n\n- **浏览器最小绘制限制：** 当你使用 `border: 1px solid #000;` 时，浏览器会将这个 CSS 像素值放大。如果你在 JavaScript 或 CSS 中尝试计算出 $0.5px$ 并应用，浏览器（尤其是 iOS 上的 Safari/WebView）可能会认为 $0.5px$ **低于其最小渲染阈值**，从而将该边框**优化（忽略）**掉，导致边框看起来被“隐藏”了。\n\n解决方案：利用 CSS transform 缩放 (主流且有效)\n\n该方案利用伪元素，将元素放大到 2 倍，然后使用 `transform: scale(0.5)` 缩放回 1 倍，达到 1 物理像素的边框效果。",
          "hasAnswer": true
        },
        {
          "id": "css-html-6",
          "title": "meta标签",
          "content": "`<meta>` 标签用于定义 HTML 文档中的**元数据 (Metadata)**，即描述 HTML 文档本身的信息。它通常放在 `<head>` 标签内。\n\n常见应用场景：\n\n1. **字符集声明:** `<meta charset=\"UTF-8\">`（**最重要**，定义文档的编码方式）。\n\n2. **视口设置 (Viewport):** 移动端适配核心\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   \n   ```html\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   ```",
          "hasAnswer": true
        },
        {
          "id": "css-html-7",
          "title": "script标签有哪些参数？async和defer有什么区别",
          "content": "`<script>` 用于加载和执行 JavaScript，默认行为是**阻塞 HTML 解析**。\n 常见属性\n- `src`：外部脚本\n- `type=\"module\"`：表示该脚本是 **ES Module**，浏览器会按模块方式加载和执行。\n- `async` 异步请求js，不阻塞html解析，下载完立刻执行，不保证执行顺序\n- `defer`：异步请求js，不阻塞html解析，等待DOM 解析完成后执行，按顺序执行\n- `crossorigin`：控制**跨域资源请求的凭证模式**\n- `nomodule`：`nomodule` 用于 **兼容老浏览器**，加载降级脚本\n\nasync和defer使用场景\n- **async**\n    - 不依赖 DOM\n    - 不依赖其他脚本\n    - 如统计、监控脚本\n- **defer**\n    - 依赖 DOM\n    - 脚本之间有顺序\n    - 主业务 JS\n总结：async 重在‘谁先下完谁先跑’，defer 重在‘等 DOM 好了按顺序跑’。\n工作中：业务脚本优先 `defer`，第三方统计用 `async`，避免阻塞首屏。",
          "hasAnswer": true
        },
        {
          "id": "css-html-8",
          "title": "script link img标签的crossorigin属性作用是什么？",
          "content": "参数：默认 anonymous 表示不携带 cookie，use-credentials 表示携带 cookie\n\n规则：\n1. 默认情况下`<script src=\"https://cdn.xxx.com/app.js\"></script>` ，浏览器**允许跨域加载并执行**，不需要 CORS 头\n2. `type=\"module\"` 下，跨域规则完全不同。ES Module 脚本默认开启 CORS 检查，没有 `Access-Control-Allow-Origin` → 直接加载失败\n\n`crossorigin` 在 script 里的真正意义：\n- 告诉浏览器：  \n    **“这是一个受 CORS 约束的脚本请求”**\n- 前提：\n    - 服务端返回 `Access-Control-Allow-Origin`\n- 结果：\n    - 可以拿到**完整错误堆栈**\n    - 监控系统才能正常工作\n\n为什么：\n根本原因：**防止信息泄露**\n错误堆栈里可能包含：\n- 代码结构\n- 变量名\n- 文件路径\n- 业务逻辑线索\n如果任意网站都能：\n- 引入你的 JS\n- 再读取完整错误信息\n那就是一个 **跨站信息泄露漏洞**。\n\n所以浏览器规定： **跨域脚本，默认只允许“执行”，不允许“读取细节”**，会的，只要是跨域且未通过 CORS 授权的脚本，语法错误、运行时错误、Promise 未捕获异常都会被折叠成 `Script error.`\n\n总结：模块默认严格模式并强制 CORS，是为了安全和可分析性；而跨域脚本错误被隐藏，是浏览器防止跨站信息泄露的安全设计，需要 crossorigin + 服务端 CORS 才能拿到完整堆栈。\n实际工程中：静态资源一般会部署到 CDN。可以在CDN层面配置跨域，或者NGINX层面配置",
          "hasAnswer": true
        },
        {
          "id": "css-html-9",
          "title": "script标签的type=\"module\" 有什么作用",
          "content": "浏览器规范 **直接规定**：`type=\"module\"` 脚本具有 **类 defer 行为**：不阻塞 HTML 解析；DOM 解析完成后执行；多个 module 按依赖顺序执行\n\n1. 为什么模块脚本必须“类 defer”？\n\t因为模块是「静态依赖系统」\n\t模块脚本在执行前要**先解析 import / export，构建完整的模块依赖图**\n\t这件事要求：\n\t- DOM 可以继续解析（不能阻塞）\n\t- 等依赖关系确定后，再统一调度执行\n\t\n\t如果模块像普通 script 一样“下载完就执行”，会导致：\n\t- DOM 未 ready\n\t- 依赖模块还没准备好\n\t- 执行顺序不稳定\n2. 多个 module 按依赖顺序执行\n\t### defer 的顺序规则\n\t- **按 script 在 HTML 中的顺序执行**\n\t- 和 JS 内部逻辑无关\n\tmodule 的顺序规则\n\t- **按模块依赖图（import 关系）执行**\n\t- 执行顺序由依赖关系决定\n\n初次之外还有自己的特点：自动开启严格模式 / 支持按需加载 / 受 CORS 限制\n1. 自动开启严格模式（use strict）模块脚本默认在 strict mode 下执行，因为：\n\t- 模块是**静态可分析**的\n\t- 容忍 `this === window`、隐式全局、重复参数等行为会破坏分析\n2. 支持依赖的按需加载（动态 import）\n\t- 模块系统是**可控、可缓存、可追踪的**\n\t- 浏览器可以安全地：下载；解析；执行；缓存 模块\n3. 必须走 CORS\n\t- 因为模块脚本：会被解析；会被别的模块 import；会影响执行顺序和依赖\n\t- 如果允许“随便跨域加载模块”：会形成 **跨站代码注入**；会泄露模块结构和依赖关系\n\t- 所以模块脚本：**强制 CORS 校验**；子模块同样受限\n\n总结：\n`type=module` 的类 defer 行为不是因为 defer 本身，而是模块脚本需要先构建依赖图并保证依赖有序执行，这是 ES Module 语义的一部分；\n模块脚本默认严格模式、支持动态 import，并强制 CORS，是因为模块是可分析、可组合的资源，浏览器必须在安全边界内管理它们。",
          "hasAnswer": true
        },
        {
          "id": "css-html-10",
          "title": "什么是css预处理器？",
          "content": "CSS 预处理器（如 Sass / Less）是在 CSS 之上提供**更强表达能力**的工具，最终会被编译成标准 CSS。\n\n常见能力\n- 变量\n- 嵌套：用结构化写法描述 DOM 层级\n- mixin：封装可复用样式片段，避免重复代码。\n- 继承：复用已有选择器的样式，适合语义化类共享样式。\n- 模块拆分：通过 `@import / @use` 拆分样式文件，提升维护性\n\n解决了什么问题\n- 原生 CSS 在早期缺乏变量和逻辑能力\n- 大型项目样式难以维护\n- 重复代码多\n优势\n- 提升可维护性\n- 降低重复\n- 结构更清晰\n- 方便主题化和换肤\n\n使用：在webpack的Loader中配置；vite原生支持 Sass / Less",
          "hasAnswer": true
        },
        {
          "id": "css-html-11",
          "title": "语义化标签的应用场景和优势",
          "content": "用恰当的 HTML 元素来描述内容的**结构和含义**，而不是仅仅关注其默认的样式\n\nheader nav main article section footer h1-h6  form等\n\n可访问性 搜索引擎优化 可读性和可维护性  跨设备兼容性",
          "hasAnswer": true
        },
        {
          "id": "css-html-12",
          "title": "Canvas vs SVG 的区别和选择",
          "content": "1️. Canvas vs SVG 的本质区别\n\n|特性|Canvas|SVG|\n|---|---|---|\n|绘制方式|**基于像素**，一次性绘制，渲染后不保留对象|**基于矢量**，DOM节点形式，每个图形元素可操作|\n|更新|需要重绘整个画布或部分区域|可以单独操作某个元素，自动重渲染|\n|性能|大量动态像素操作（游戏、动画）效率高|大量元素节点多时，性能可能下降|\n|调试|不像 DOM 元素可直接 inspect，调试相对困难|可直接 inspect DOM 节点，样式、位置可见|\n2️. 优缺点\n Canvas\n- **优点**：\n    - 适合大量动态渲染或复杂动画（游戏、可视化图表）\n    - 渲染速度快，像素级控制灵活\n- **缺点**：\n    - 不保留对象，不容易对单个元素操作\n    - 调试困难\n    - 对响应式、交互事件支持有限\n SVG\n- **优点**：\n    - 矢量图形，缩放不失真\n    - DOM 节点可操作，易调试，事件绑定方便\n    - 适合图标、静态或轻量级动画\n- **缺点**：\n    - 大量节点性能开销大，不适合复杂动画或实时渲染\n\n3️. 使用场景参考\n- **Canvas**：游戏渲染、粒子动画、复杂图表、图像处理\n- **SVG**：图标、流程图、矢量图、轻量动画、交互图表\n\n总结：Canvas 是基于像素的绘制方式，渲染后不保留对象，适合大量动态渲染和复杂动画，但调试相对困难；SVG 是基于矢量的，每个元素都是 DOM 节点，可单独操作，适合图标、静态图、轻量动画。选择时一般原则：**动态、像素级操作选 Canvas，静态或矢量图形选 SVG**",
          "hasAnswer": true
        },
        {
          "id": "css-html-13",
          "title": "HTML5 表单验证和自定义验证",
          "content": "1. HTML5 表单验证，原生提供了**内置验证属性**，常见的有：\n\t- **required**：必填字段\n\t- **type**：比如 `email`、`number`、`url`，浏览器会自动检查格式\n\t- **pattern**：自定义正则，匹配特定格式\n\t- **min / max / step**：数值范围限制\n\t- **maxlength / minlength**：字符长度限制\n\t- 特点：\n\t\t- 浏览器自动触发验证\n\t\t- 不需要 JS 代码\n\t\t- 用户体验好，移动端也会弹出原生提示\n2. 自定义验证：有些场景 HTML5 自带的验证无法满足，比如：\n\t- 复杂密码规则\n\t- 异步验证（用户名是否已存在）\n\t- 联动验证（两个字段必须匹配）\n   这时就需要**JavaScript 自定义验证**，常用方法：\n\t1. **oninput / onchange**：输入实时验证\n\t2. **onSubmit 拦截**：`form.addEventListener('submit', function(e) {...}`\n总结：HTML5 表单验证主要分两类：一是浏览器原生验证，通过 `required`、`type`、`pattern`、`min/max` 等属性自动检查输入；二是自定义验证，通过 JavaScript 检查复杂逻辑或异步条件，并通过 Constraint Validation API 或表单 submit 事件阻止非法提交。原生验证简单易用，但灵活性有限，自定义验证可以覆盖更复杂的场景。",
          "hasAnswer": true
        },
        {
          "id": "css-html-14",
          "title": "CSS3 动画性能优化方案",
          "content": "性能优化核心是**减少重排 (Reflow/Layout)** 和**重绘 (Repaint)**，并尽可能利用 GPU 加速。\n\n1.使用 `transform` 和 `opacity` 进行动画： 只会触发**合成 (Compositing)**，不会触发重排和重绘，性能最高，可以直接利用 GPU 加速。\n\n2.开启 GPU 硬件加速：`transform: translateZ(0);` 或 `will-change: transform, opacity;`，将元素提升到合成层，利用 GPU 渲染\n\n3.使用 `will-change` 属性：\n\n4.避免使用 `all` 进行transition：\n\n5.**减少 DOM 元素和层次：",
          "hasAnswer": true
        },
        {
          "id": "css-html-15",
          "title": "CSS 模块化和作用域方案",
          "content": "目的：\n- **解决全局污染：** 默认情况下，CSS 所有的选择器都是全局的。不同组件同名的 `.title` 会相互覆盖。\n- **提高复用性：** 像 JS 模块一样方便地导入、导出样式。\n- **提升维护性：** 明确样式与组件的绑定关系，删除组件时能放心地删除其样式。\n\n核心原理：\n1. **命名约定/空间隔离：** 通过人为约定的规范（如 BEM）来模拟作用域。\n2. **构建转换（哈希化）：** 通过构建工具（Webpack/Vite）自动重命名选择器。\n    - **原理：** 当你导入一个 CSS 模块时，编译器会将你的类名（如 `.button`）转换成一个唯一的哈希字符串（如 `._button_x1y2z`）。\n    - **映射：** 编译器会生成一个 JSON 映射表，让 JS 能够引用这个变色后的类名。\n\n常见方案：\n1. CSS Modules：基于 JS 映射的哈希化。开发者编写正常的 CSS 文件（通常命名为 `.module.css`），打包工具在构建时对类名进行转换增加hash，比如`._title_1a2b3_5`，并把引用处也做相同的修改。\n2. Scoped CSS：基于属性选择器的隔离： 打包工具在编译模板时，会给该组件内所有的 DOM 节点加上一个唯一的属性，例如 `data-v-7ba5bd90`，同时将对应的 CSS 选择器转换增加属性选择。\n3. Tailwind CSS：基于原子类的预扫描方案，不进行类名哈希化。优点是按需编译和极致复用。",
          "hasAnswer": true
        },
        {
          "id": "css-html-16",
          "title": "前端性能优化之 CSS 优化策略",
          "content": "1. **合并与压缩 CSS 文件：**\n\n2. **利用媒体查询 (Media Queries) 按需加载：**\n   \n   使用 `<link rel=\"stylesheet\" media=\"(max-width: 600px)\" href=\"mobile.css\">`，只有在符合条件时才加载相应样式。\n\n3. **减少 CSS 嵌套和选择器复杂度：**\n   \n   复杂的选择器（如 `div > ul > li:last-child`）会增加浏览器计算匹配的成本。\n\n4. 避免在 HTML 中使用内联样式 (`style=\"...\"`)：内联样式会增加 HTML 文件体积，且不利于样式复用和缓存。\n\n5. 将 `<link>` 标签放在 `<head>` 顶部：让浏览器尽快下载和解析 CSS，避免**白屏时间**过长。",
          "hasAnswer": true
        },
        {
          "id": "css-html-17",
          "title": "解释CSS中的BEM命名方法，并展示如何使用它来组织你的样式表。",
          "content": "**BEM** 是 **Block (块)、Element (元素)、Modifier (修饰符)** 的缩写，是一种用于组织 CSS 类名的命名规范。它旨在解决 CSS 全局作用域带来的命名冲突和样式依赖问题，使样式代码更具可读性和可维护性。示例：.card__title--large   .card__image--dark\n\n```css\n.user-card {\n    display: flex;\n    padding: 20px;\n    border: 1px solid #ccc;\n\n    /* 2. Modifier: .user-card--vip (变体) */\n    &--vip {\n        border-color: gold;\n        box-shadow: 0 0 5px gold;\n    }\n...\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "css-html-18",
          "title": "在一个复杂的页面上，用户操作导致多次不必要的DOM操作，你将如何优化它?",
          "content": "不必要的 DOM 操作是前端性能的常见瓶颈，因为它会频繁触发浏览器的 **重排 (Reflow/Layout)** 和 **重绘 (Repaint)**。优化策略核心是**减少操作次数**和**批量处理操作**。\n\n1. **使用文档片段 (DocumentFragment) 批量操作：**\n   \n   - **原理：** `DocumentFragment` 是一个轻量级的容器，它**不是真实的 DOM 树的一部分**。将所有需要添加或修改的元素先插入到 `DocumentFragment` 中，然后只需进行**一次**操作，将 `DocumentFragment` 整体插入到 DOM 中。\n   \n   - **优化效果：** 只触发**一次**重排和重绘。\n\n2. **避免频繁读写 DOM 属性：**\n   \n   - **问题：** 连续读取（如 `element.offsetWidth`）和写入（如 `element.style.width = '100px'`）操作会导致“强制同步布局”——浏览器为了保证读取到的值是最新的，会立即执行挂起的重排。\n   \n   - **优化：** 应该**先读取**所有需要的 DOM 属性，然后**集中进行写入**操作。\n\n3. **使用防抖 (Debounce) 和节流 (Throttle)：**\n   \n   - **场景：** 针对用户输入、`resize`、`scroll`、`mousemove` 等高频触发的事件。\n   \n   - **防抖：** 将多次触发合并成一次，只在事件停止触发后执行一次（如搜索框输入）。\n   \n   - **节流：** 在一个时间周期内，事件只执行一次（如页面滚动）。\n\n4. **使用 Virtual DOM (适用于组件化框架)：**\n   \n   - React、Vue 等框架通过 **Virtual DOM** 将所有的 DOM 操作放入内存中进行对比，计算出最小的更新路径，然后一次性批量应用到真实 DOM 上，从框架层面解决了不必要的 DOM 操作问题。\n\n5. **用 CSS 类代替内联样式：**\n   \n   - 避免直接操作 `element.style`，因为它会导致样式计算和布局的开销。\n   \n   - **优化：** 预先定义好 CSS 类，通过增删改元素的 `className` 或 `classList` 来改变样式。\n\n6. **将元素脱离文档流：**\n   \n   - 如果必须对一个元素进行多次复杂的 DOM 操作，可以先通过设置 `display: none` 或将其从 DOM 中移除，进行操作，然后重新插入/显示。脱离文档流的操作不会触发整个页面的重排。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "react",
      "name": "React",
      "questions": [
        {
          "id": "react-1",
          "title": "谈谈你对 React 的了解",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-2",
          "title": "React 中 keys 的作用是什么",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-3",
          "title": "说说对受控组件和非受控组件的理解，以及应用场景",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-4",
          "title": "Redux中的connect有什么作用?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-5",
          "title": "说说你对immutable的理解?如何应用在react项目中",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-6",
          "title": "说说React服务端渲染怎么做?原理是什么?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-7",
          "title": "什么是无状态组件，与有状态组件的区别？它们的本质区别是什么？现在还推荐这样区分吗？",
          "content": "无状态组件通常指的是不维护自身状态、只依赖 props 渲染 UI 的组件，更多用于展示型组件。\n\n有状态组件则是指内部维护 state，并负责业务逻辑或交互行为的组件。\n\n在早期 React 中，无状态组件通常是函数组件，有状态组件通常是类组件；但在 Hooks 引入之后，这种区分已经不再严格适用，函数组件同样可以是有状态组件。\n\n现代 React 更推荐从组件职责和状态归属的角度进行设计，而不是强调组件是否“有状态”。",
          "hasAnswer": true
        },
        {
          "id": "react-8",
          "title": "为什么虚拟 DOM 会提高性能? 一定能提高性能吗？",
          "content": "虚拟 DOM 本质上是用 JavaScript 对象描述 UI 结构的抽象层。\n\n它提升性能的核心在于通过 diff 算法精确计算出最小化的 DOM 更新，并将多次状态变更合并后，在 commit 阶段一次性、有序地更新真实 DOM，从而减少不必要的重排和重绘。\n\n在列表场景中，key 可以帮助 React 高效地复用节点，进一步提升更新效率。\n\n但虚拟 DOM 并不一定在所有场景下都更快，例如页面几乎不发生变化、DOM 结构极其简单，或者高频动画、Canvas 等场景下，虚拟 DOM 的计算成本反而可能成为额外开销。",
          "hasAnswer": true
        },
        {
          "id": "react-9",
          "title": "说说react中引入css的方式有哪几种?区别?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-10",
          "title": "怎么给 children 添加额外的属性？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-11",
          "title": "对比类组件和函数组件，有什么本质区别？代码层面如何判断",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-12",
          "title": "React 组件高度抽象和复用的自由有没有代价？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-13",
          "title": "为什么说react更适合B端大型项目",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-14",
          "title": "React 组合能力强会带来哪些坑？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-15",
          "title": "为什么说react的组件和逻辑抽象和复用比vue强",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-16",
          "title": "组件状态保存keep-alive怎么用？原理是什么？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-17",
          "title": "路由懒加载原理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-18",
          "title": "react的link标签和a标签的区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-19",
          "title": "分别讲讲react16 17 18 19新特性",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-20",
          "title": "什么是jsx? 为什么浏览器无法读取 JSX",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-21",
          "title": "说说jsx转DOM过程和原理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-22",
          "title": "react diff算法核心，和vue的diff有什么区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-23",
          "title": "讲讲react项目的性能优化",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-24",
          "title": "说说你对 React Hook的闭包陷阱的理解，有哪些解决方案",
          "content": "React Hook 的闭包陷阱，本质上是**函数组件在某一次 render 时创建的回调函数，会捕获当次 render 的状态快照**。  \n如果这个回调在之后被异步执行（如 effect、事件、定时器），即使组件已经重新 render，回调内部拿到的仍然是**旧作用域里的变量**。\n\n产生原因\n1. **函数组件不是实例**，每次 render 都是一次新的函数执行\n2. Hook 回调（useEffect / useCallback 等）**绑定的是创建时的作用域**\n3. 依赖数组为空或不完整时，React 不会重新创建这个回调\n4. 导致回调中使用的 state / props 永远停留在旧值\n\n常见的解决方案包括：\n1. 正确声明依赖数组，确保状态变化时重新创建回调\n2. 使用函数式 setState，避免依赖外部状态\n3. 使用 useRef 保存最新值，因为 ref 在多次 render 之间保持同一个引用，可以绕开闭包快照问题",
          "hasAnswer": true
        },
        {
          "id": "react-25",
          "title": "说说 hooks 的思想和原理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-26",
          "title": "react hook如何以链表存储",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-27",
          "title": "为什么hook只能写在顶层",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-28",
          "title": "看过 hooks 相关的草案吗",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-29",
          "title": "说说react里你常用的hook",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-30",
          "title": "React 中 refs 的作用是什么",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-31",
          "title": "useRef和useState的区别",
          "content": "useRef 返回的是一个普通的可变对象 `{ current }`，  这个对象在组件的多次 render 之间**不会被重新创建**，闭包捕获的是这个对象本身，而不是某次 render 的值快照，因此通过 `ref.current` 访问到的始终是最新写入的值。",
          "hasAnswer": true
        },
        {
          "id": "react-32",
          "title": "为什么usestate返回数组而不是对象",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-33",
          "title": "useState如何实现？怎么获得下一次更新后的值",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-34",
          "title": "调用 setState 之后发生了什么",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-35",
          "title": "setState 何时同步何时异步?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-36",
          "title": "useEffect是如何实现的？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-37",
          "title": "useLayoutEffect和useEffect的区别",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-38",
          "title": "useEffect为什么不支持async await？怎么解决？",
          "content": "useEffect 不能直接写成 async，是因为 effect 的返回值会被 React 当作清理函数，在组件卸载或 effect 重新执行前同步调用。而 async 函数一定返回 Promise，React 不会也不能去 await 这个 Promise，因此无法作为合法的 cleanup。\n\n如果需要在 effect 中使用 async / await，正确做法是在 effect 内部定义并立即执行一个 async 函数，保证 effect 本身的返回值仍然是清理函数或 undefined。",
          "hasAnswer": true
        },
        {
          "id": "react-39",
          "title": "React.memo 是做什么的？为什么它通常需要和 useMemo / useCallback 配合使用？",
          "content": "React.memo 是一个用于函数组件的性能优化手段，它通过对 props 做浅比较，在父组件重新渲染时，如果子组件的 props 没有发生引用层面的变化，就跳过子组件的重新渲染。\n\n由于对象和函数在每次 render 时都会产生新的引用，因此通常需要配合 useMemo 和 useCallback 来稳定 props 的引用，否则 React.memo 很容易失效。\n\n同时，React.memo 也并非适用于所有场景，如果组件本身渲染成本很低，或者 props 变化频繁，使用 memo 反而可能带来额外的比较开销。",
          "hasAnswer": true
        },
        {
          "id": "react-40",
          "title": "React.memo的第二个参数是什么 作用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-41",
          "title": "ref useRef forwardRef 区别和作用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-42",
          "title": "useContext是什么作用？有什么优缺点？",
          "content": "useContext 用于在组件树中跨层级共享数据，主要解决 props drilling 的问题，而不是以性能优化为目标。\n\n它的优点是让数据传递更加清晰，适合全局性、低频变化的状态。\n\n缺点在于，当 Context 的 value 发生变化时，所有消费该 Context 的组件都会重新渲染，更新粒度较粗，如果使用不当可能带来性能问题。\n\n常见的优化方式包括拆分 Context、保持 value 引用稳定，以及在复杂场景下配合 selector 或专门的状态管理库使用。",
          "hasAnswer": true
        },
        {
          "id": "react-43",
          "title": "说说useReducer是什么怎么用",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-44",
          "title": "对比useReducer和useState",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-45",
          "title": "18以前为什么useState不能批量更新，18以后为什么可以？",
          "content": "18以前在浏览器原生事件（如 setTimeout、Promise 回调、addEventListener 内部）中，React 认为已经脱离了控制流，也就是他们的回调是在一个全新的、异步的、与 React 渲染无关的执行上下文中运行的，所以setstate无法批量更新",
          "hasAnswer": true
        },
        {
          "id": "react-46",
          "title": "react自定义hooks 和 Vue3 composable 本质区别？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-47",
          "title": "React Fiber是什么?  说说fiber 架构的工作原理?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-48",
          "title": "为什么react需要 fiber架构，而Vue却不需要?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-49",
          "title": "讲讲React Fiber 是如何实现更新过程可控的",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-50",
          "title": "react如何确定具体场景的执行优先级",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-51",
          "title": "fiber怎么进行任务的终止和恢复的？为什么不直接使用requestldleCallback?",
          "content": "React Fiber 通过把一次渲染拆分成多个小的工作单元（Fiber Node），使渲染过程变成**可中断、可恢复的增量执行过程**。\n \n在渲染阶段，React 每次只处理一个 Fiber 节点，处理完成后会判断当前时间片是否用尽，如果有更高优先级任务或者时间不够，就主动让出主线程。\n \n 中断时，React 会保存当前的 `workInProgress Fiber`，等下次调度继续从这个 Fiber 节点开始执行，而不是从头重新渲染整棵树。\n \n React 并不是直接依赖浏览器调度，而是自己实现了一套 Scheduler。  通过MessageChannel 来创建一个**稳定、可控、优先级更高的异步调度入口**，用来触发一次新的调度循环，而不是用来通信任务完成状态。\n\nrequestIdleCallback 的最大问题是：  **调度时机完全由浏览器决定，React 无法精确控制优先级和执行时长。**\n回调时机不可预测：浏览器“觉得”空闲才会调用，在动画、输入密集时可能长期不执行\n优先级控制能力弱：只区分是否空闲而没有优先级\n与 React 的调度模型不匹配：React 需要在不同优先级任务之间频繁切换，rIC 不适合高频、精细的任务切分\n\n总结：Fiber 的本质是把同步、不可中断的递归渲染，改造成基于 Fiber Node 的可中断工作流；React 通过自建 Scheduler 控制调度节奏，而不是把渲染节奏完全交给浏览器。",
          "hasAnswer": true
        },
        {
          "id": "react-52",
          "title": "详细说说fiber架构的commit阶段过程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-53",
          "title": "详细说说fiber架构的render阶段过程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-54",
          "title": "react如何实现时间切片",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-55",
          "title": "fiber为什么是性能飞跃",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-56",
          "title": "redux的使用原则",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-57",
          "title": "说说 Redux的核心方法和工作流程",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-58",
          "title": "redux的优缺点",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-59",
          "title": "说说对Redux中间件的理解?常用的中间件有哪些?实现原理?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-60",
          "title": "Redux中异步的请求怎么处理",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-61",
          "title": "React中组件之间进行数据通信有哪些方式？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-62",
          "title": "除了 redux mbox dva 还用过其他的 状态管理没",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-63",
          "title": "对比redux zustand",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-64",
          "title": "说说react的事件代理机制原理和优缺点",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-65",
          "title": "说说react事件和浏览器原生事件执行先后顺序，为什么？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-66",
          "title": "react的事件为什么要委托，有什么好处？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-67",
          "title": "react事件委托如何解决模态框的事件冒泡？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-68",
          "title": "react17 之后的事件机制有什么区别？",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "react-69",
          "title": "子组件portal能冒泡到父组件吗",
          "content": "",
          "hasAnswer": false
        }
      ]
    },
    {
      "id": "vue",
      "name": "Vue",
      "questions": [
        {
          "id": "vue-1",
          "title": "Vuex 的核心概念和工作流程",
          "content": "**State** 单一状态树，存储应用的全部状态，作为\"唯一数据源\"。\n\n**Getter** 类似于计算属性，用于从 State 派生出新状态，具有缓存特性。\n\n**Mutation** 唯一允许修改 State 的方法。必须是**同步**函数，便于 DevTools 追踪状态变化。\n\n**Action** 负责提交 (`commit`) Mutation，可以包含**异步**操作或复杂的业务逻辑。\n\n**Module** 将 Store 分割成模块，每个模块拥有自己的 State、Getter、Mutation、Action，支持命名空间 (`namespaced: true`)。\n\nVuex 的数据流是**单向**的，遵循以下流程：\n\n1. **View (视图)**：用户在组件中触发一个操作。\n\n2. **Dispatch (分发)**：组件通过 `store.dispatch('actionName', payload)` 提交一个 **Action**。\n\n3. **Action (动作)**：Action 执行异步逻辑（如 API 调用）。一旦数据准备好，Action 会通过 `store.commit('mutationName', payload)` 提交一个 **Mutation**。\n\n4. **Commit (提交)**：**Mutation** 是唯一能修改 **State** 的地方。它同步地修改状态。\n\n5. **State (状态)**：状态被更新。\n\n6. **Render (渲染)**：由于 State 是响应式的，所有依赖此 State 的 **View** 组件会自动更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-2",
          "title": "对比 Vuex 和 Pinia",
          "content": "**Vuex** 是 Vue 2 时代的官方状态管理库，采用 Flux 架构，强调**单向数据流**和**严格的状态修改规范**（必须通过 Mutation）。适合大型项目，但模板代码较多，TS 支持需要额外配置。\n\n**Pinia** 是 Vue 3 官方推荐的状态管理库，可视为 Vuex 5。设计更简洁，去掉了 Mutation，原生支持 TypeScript，每个 Store 独立无需命名空间。\n\n| 特性         | Vuex                            | Pinia                               |\n| ---------- | ------------------------------- | ----------------------------------- |\n| 核心概念       | State, Getter, Mutation, Action | State, Getter, Action (去掉 Mutation) |\n| 修改状态       | 必须通过 Mutation（同步）               | Action 中直接修改 State                  |\n| TypeScript | 需要额外类型声明，配置繁琐                   | **原生支持**，类型自动推导                     |\n| 模块化        | 嵌套 Module，需要 `namespaced: true` | **独立 Store 实例**，按需导入，无需命名空间         |\n| 体积         | ~10KB                           | **~1KB**，更轻量                        |\n| DevTools   | 支持                              | 支持，体验更好                             |\n| SSR        | 需要额外配置                          | 开箱即用                                |\n| API 风格     | Options API 风格                  | 同时支持 Options 和 Composition API      |\n\n**选型建议**：\nVuex 和 Pinia 更像官方状态管理的代际更替：Vue3 之后组合式 API 和 TS 成为主流，Pinia 在类型推导、样板代码、store 组织方式上都更契合官方心智，而且是官方推荐路线；Vuex 主要保留在存量项目或迁移成本高的场景，新项目默认 Pinia 风险最低。",
          "hasAnswer": true
        },
        {
          "id": "vue-3",
          "title": "响应式开发比命令式开发有什么优势？",
          "content": "1. **声明式编程**：只需描述**状态与视图的映射关系**，无需手动操作 DOM，代码更易读易维护。\n\n2. **自动更新**：状态变化时，框架自动处理 DOM 更新，开发者无需关心\"何时更新、更新哪里\"。\n\n3. **高效渲染**：Virtual DOM + Diff 算法，**精确计算最小 DOM 变化集**，避免不必要的 DOM 操作。\n\n4. **减少 Bug**：手动 DOM 操作容易遗漏或出错，响应式系统保证状态与视图一致性。\n\n5. **组件化开发**：状态封装在组件内部，提高代码复用性和可测试性。",
          "hasAnswer": true
        },
        {
          "id": "vue-4",
          "title": "什么是装饰器？在 Vue 中怎么用？",
          "content": "装饰器 (Decorator) 是一种特殊的声明，用于**修改类或类成员的行为**，本质是一个函数。\n\n**在 Vue 中的应用**（主要是 Vue 2 + TypeScript）：\n\n```typescript\nimport { Component, Prop, Watch } from 'vue-property-decorator';\n\n@Component\nexport default class MyComponent extends Vue {\n  @Prop({ default: '' }) readonly title!: string; // 声明 props\n\n  @Watch('title') // 监听属性变化\n  onTitleChange(val: string) {}\n}\n```\n\n**Vue 3 现状**：Composition API 已取代装饰器方案，官方不再推荐使用装饰器。原因：\n\n- Composition API 提供更好的类型推导\n- 装饰器提案尚未稳定\n- 函数式组合比类继承更灵活",
          "hasAnswer": true
        },
        {
          "id": "vue-5",
          "title": "如何保持组件状态、避免重复渲染？（keep-alive）",
          "content": "主要通过 Vue 的内置抽象组件 **`<keep-alive>`** 来实现。\n\n作用： ` <keep-alive>` 包裹动态组件或路由组件时，会**缓存不活动的组件实例**，而不是销毁它们。这可以避免组件在切换时被重复创建和渲染，从而**保持组件的状态**（如表单输入内容、滚动位置等），并提升性能。\n\n实现原理与钩子函数\n\n1. **缓存机制**：内部使用 `Map` 缓存 VNode，key 为组件名或自定义 key。\n\n2. **生命周期变化**：缓存后 `unmounted`/`destroyed` 不会触发，新增两个钩子：\n   \n   - **`activated()`**：组件被激活时（切换进来）触发\n   - **`deactivated()`**：组件被停用时（切换出去）触发\n\n3. **常用属性**：\n   \n   - `include`：只缓存匹配的组件（字符串/正则/数组）\n   - `exclude`：排除匹配的组件\n   - `max`：最大缓存数量，超出时使用 **LRU 算法**淘汰最久未使用的\n\n```html\n<keep-alive :include=\"['Home', 'List']\" :max=\"10\">\n  <router-view />\n</keep-alive>\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-6",
          "title": "Vue 2 和 Vue 3 响应式原理的区别？为什么改用 Proxy？",
          "content": "| 对比项  | Vue 2 (Object.defineProperty) | Vue 3 (Proxy)   |\n| ---- | ----------------------------- | --------------- |\n| 初始化  | 递归遍历所有属性，开销大                  | **惰性处理**，访问时才递归 |\n| 新增属性 | ❌ 无法检测，需用 `$set`              | ✅ 自动响应          |\n| 删除属性 | ❌ 无法检测，需用 `$delete`           | ✅ 自动响应          |\n| 数组索引 | ❌ 无法检测 `arr[0] = x`           | ✅ 自动响应          |\n| 数组长度 | ❌ 无法检测 `arr.length = 0`       | ✅ 自动响应          |\n\n**Vue 3 改用 Proxy 的原因**：\n\n1. **功能更全面**：Proxy 可拦截 13 种操作（get/set/delete/has/ownKeys 等）\n2. **性能更优**：惰性响应式，减少初始化开销\n3. **代码更简洁**：无需为数组方法打补丁",
          "hasAnswer": true
        },
        {
          "id": "vue-7",
          "title": "Vue 的渲染过程（模板 → DOM）",
          "content": "总结：\n\n初次：1 编译模板（解析 AST+标记+生成渲染函数）2 执行渲染函数生成 VDOM 3 渲染\n\n后续数据更新：1 执行渲染函数生成新 VDOM 2 diff 获得 patch 3 更新 DOM\n\n阶段一：模板编译 (Template Compilation)\n\n1. **解析 (Parse)**：将 HTML 模板字符串解析成抽象语法树 (AST - Abstract Syntax Tree)。AST 是一种用 JavaScript 对象来描述模板结构的树形结构。\n\n2. **优化 (Optimize)**：遍历 AST，标记静态节点 (Static nodes)。静态节点是指内容不会变化的节点。Vue 在后续的 Diff 过程中会跳过这些节点，**大幅提高性能**。\n\n3. **代码生成 (Generate)**：将优化后的 AST 转换成 **Render Function (渲染函数)**。渲染函数返回的就是 VNode (Virtual Node) 树。\n\n阶段二：创建虚拟 DOM (Virtual DOM Creation)\n\n1. **首次渲染**：执行第一步生成的 **Render Function**，它返回一棵 **VNode Tree (虚拟 DOM 树)**。\n\n阶段三：渲染和更新 (Patching & DOM Update)\n\n1. **首次渲染**：将 VNode Tree 转换成真实的 DOM 元素，并插入到页面中。同时，Vue 将这棵 VNode Tree 保存为 `oldVNode`。\n\n2. **数据更新**：响应式数据发生变化时，会触发组件的 Watcher，重新执行 Render Function，生成一棵 **`newVNode` Tree**。\n\n3. **比对 (Patch)**：Vue 运行 **Diff 算法**（Patch 过程），将 `newVNode` 与 `oldVNode` 进行递归比对。\n\n4. **最小化 DOM 操作**：Diff 算法找出两棵树之间**最小的差异集**。\n\n5. **更新 DOM**：Vue 只对这些有差异的真实 DOM 节点进行必要的创建、更新、移动或删除操作，从而完成视图更新。",
          "hasAnswer": true
        },
        {
          "id": "vue-8",
          "title": "Vue Router 原理？Hash 和 History 模式的区别？",
          "content": "Vue Router 的核心是监听 URL 的变化，并根据配置的路由映射表，动态地渲染对应的组件。\n\n1. **路由映射 (Route Mapping)**：定义 URL 路径 (`path`) 与组件 (`component`) 的映射关系。\n\n2. **监听 URL 变化**：根据配置的模式（Hash 或 History），监听浏览器地址栏 URL 的变化事件。\n\n3. **匹配路由**：当 URL 变化时，Router 捕获新 URL，并在路由映射表中查找匹配的配置。\n\n4. **渲染组件**：将匹配到的组件渲染到 `<router-view>` 占位符的位置上。\n\n| 对比项    | Hash 模式               | History 模式                       |\n| ------ | --------------------- | -------------------------------- |\n| URL 形式 | `example.com/#/user`  | `example.com/user`               |\n| 原理     | `window.onhashchange` | `history.pushState/replaceState` |\n| 服务器配置  | 无需配置                  | **需要配置回退**（所有路由返回 index.html）    |\n| SEO    | 不友好（爬虫忽略 # 后内容）       | 友好                               |\n| 兼容性    | 所有浏览器                 | IE10+                            |\n\n**导航守卫**（补充高频考点）：\n\n- `beforeEach`：全局前置守卫，常用于登录验证\n- `beforeResolve`：全局解析守卫\n- `afterEach`：全局后置钩子\n- `beforeEnter`：路由独享守卫\n- `beforeRouteEnter/Update/Leave`：组件内守卫",
          "hasAnswer": true
        },
        {
          "id": "vue-9",
          "title": "如何自定义 Vue 指令？有哪些钩子函数？",
          "content": "自定义指令用于对 DOM 元素进行**底层操作**，实现可复用的 DOM 行为。例如：自动获取焦点、权限控制、拖拽功能等。\n\n```js\n// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nconst app = createApp(App);\n\n// 注册一个全局自定义指令 v-focus\napp.directive('focus', {\n  // 元素挂载到 DOM 时调用\n  mounted(el) {\n    el.focus(); // 使元素自动获取焦点\n  },\n});\n\napp.mount('#app');\n\n//组件内用directives注册\n```\n\n**Vue 3 指令钩子函数**：\n\n- `created`：元素属性/事件监听器应用前\n- `beforeMount`：挂载前\n- `mounted`：挂载后（常用）\n- `beforeUpdate`：更新前\n- `updated`：更新后\n- `beforeUnmount`：卸载前\n- `unmounted`：卸载后\n\n**常见应用场景**：自动聚焦、权限控制（v-permission）、防抖点击、图片懒加载、拖拽",
          "hasAnswer": true
        },
        {
          "id": "vue-10",
          "title": "Vue 应用性能优化有哪些方向？",
          "content": "- **运行时性能优化 (Runtime Performance)**\n  \n  - **合理使用 `v-if` 和 `v-show`**：\n    \n    - **`v-if`**：真正销毁/重建组件，适用于不频繁切换的场景。\n    \n    - **`v-show`**：仅切换 CSS `display` 属性，适用于频繁切换的场景。\n  \n  - **`v-for` 必须使用 `key`**：帮助 Vue Diff 算法更高效地进行元素追踪和复用。\n  \n  - **使用 `v-once`**：对于内容不依赖数据的静态子树，使用 `v-once` 只渲染一次，避免了后续的更新开销。\n  \n  - **组件拆分和懒加载 (Async Components)**：将大组件拆分为小组件，并使用动态 `import()` 实现组件的按需加载。\n  \n  - 精准依赖，对 store 或外部属性，精准引入，依靠 vue 对响应式数据的优化\n  \n  - **大列表优化 (虚拟滚动/Virtual Scrolling)**：对于包含数千个项目的长列表，只渲染可见区域的 DOM，大幅减少 DOM 节点数量。\n  \n  - **合理使用 `computed` vs `watch`**：`computed` 具有缓存机制，只有依赖项变化时才会重新计算，比 `watch` 更高效。\n  \n  - **使用 Vue 3 的 `shallowRef` (如果可以)**：对于嵌套层级很深但我们只关心顶层引用的数据，使用 `shallowRef` 来减少不必要的深度响应式处理。\n\n- **加载性能优化 (Loading Performance)**\n  \n  - **图片优化**：WebP 格式、懒加载、响应式图片\n  \n  - **路由懒加载**：使用 `const route = () => import('./components/Path')`，将不同路由组件的代码分割成不同的 chunk，实现按需加载。\n  \n  - **第三方库按需引入**：如使用 Babel 插件或 Vite 插件，对 Element-UI/Plus、Ant Design Vue 等库进行按需导入，而不是全量导入。\n\n- **工程化优化**\n  \n  - **Tree Shaking**：确保使用 ES Module，移除未使用代码\n  \n  - **代码分割**：Webpack/Vite 的 splitChunks，合理拆分 vendor 和业务代码\n  \n  - **Gzip 压缩**：服务端开启压缩，减少传输体积\n  \n  - **CDN 加速**：静态资源上 CDN，利用边缘节点加速\n  \n  - **预加载/预获取**：`<link rel=\"prefetch/preload\">` 提前加载关键资源\n  \n  - **缓存策略**：合理配置 HTTP 缓存头，利用浏览器缓存",
          "hasAnswer": true
        },
        {
          "id": "vue-11",
          "title": "项目中遇到过哪些 Vue 相关的难题？如何解决？",
          "content": "**示例回答框架**（根据实际经验调整）：\n\n**场景 1：大列表性能问题**\n\n- 问题：渲染上万条数据导致页面卡顿\n- 方案：引入虚拟滚动（vue-virtual-scroller），只渲染可视区域 DOM\n- 效果：DOM 节点从 10000+ 降到 ~50，滚动流畅\n\n**场景 2：组件通信复杂**\n\n- 问题：多层嵌套组件间状态共享困难，props 层层传递\n- 方案：引入 Pinia 管理全局状态 + provide/inject 处理局部共享\n- 效果：代码解耦，维护性提升\n\n**场景 3：内存泄漏**\n\n- 问题：组件卸载后定时器/事件监听未清理\n- 方案：在 `onUnmounted` 中统一清理，封装 `useInterval` 等 hooks\n- 效果：内存占用稳定\n\n**回答技巧**：描述具体场景 → 分析原因 → 解决方案 → 量化效果",
          "hasAnswer": true
        },
        {
          "id": "vue-12",
          "title": "nextTick 的作用和原理？",
          "content": "**作用**：在下次 DOM 更新循环结束之后执行回调，确保操作的是最新 DOM。\n\n**原理**：\n\n1. Vue 的数据变化触发 DOM 更新是**异步批量**的（同一事件循环内的多次修改合并为一次更新）\n2. DOM 更新任务被推入**微任务队列**（优先使用 `Promise.then`，降级用 `MutationObserver`、`setImmediate`、`setTimeout`）\n3. `nextTick(callback)` 将回调推入同一个微任务队列，排在 DOM 更新之后执行\n\n**执行顺序**：数据变化 → Setter → 派发更新 → 收集 Watcher → **微任务队列**（DOM 更新 → nextTick 回调）\n\n**常见使用场景**：\n\n```javascript\nthis.show = true;\nthis.$nextTick(() => {\n  this.$refs.input.focus(); // 确保 DOM 已渲染\n});\n```",
          "hasAnswer": true
        },
        {
          "id": "vue-13",
          "title": "Vue 3 响应式丢失的原因和解决方案？",
          "content": "常发生在解构（Destructuring）**或**展开（Spreading）响应式对象时。\n\n```javascript\nconst state = reactive({\n  count: 0, // 这是一个被 Proxy 追踪的属性\n  name: 'Alice',\n});\n\n// --- ❌ 错误做法：响应式丢失 ---\n// 解构：将 state.count 的原始值赋给了新的局部变量 count。\n// 这两个变量已经没有任何关联。\nconst { count, name } = state;\n```\n\n**解决方案**：\n\n```javascript\n// 方案1：使用 toRefs 保持响应式\nconst { count, name } = toRefs(state); // count.value 是响应式的\n\n// 方案2：直接引用，不解构\nstate.count;\n\n// 方案3：使用 toRef 获取单个属性\nconst count = toRef(state, 'count');\n```\n\n**延伸：ref vs reactive**\n\n- `ref`：用于基本类型，通过 `.value` 访问，解构不丢失响应式\n- `reactive`：用于对象/数组，直接访问属性，解构会丢失响应式\n\n**最佳实践**：统一使用 `ref`，或始终用 `toRefs` 解构 `reactive` 对象。",
          "hasAnswer": true
        },
        {
          "id": "vue-14",
          "title": "ref和reactive有什么区别？为什么这样设计",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "vue-15",
          "title": "ref为什么要用.value?为什么模板不需要",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "vue-16",
          "title": "React 自定义 Hooks 和 Vue 3 的 composable，本质区别是什么？",
          "content": "React 自定义 Hook 本质上是对官方 Hook 的组合，它依赖 Hooks 在 Fiber 中按调用顺序存储状态，因此必须遵守严格的调用顺序规则。\n\nVue 3 的 composable 则是基于响应式系统的逻辑封装，状态由 ref 或 reactive 对象本身标识，而不是由调用顺序决定，因此机制上更加灵活。\n\n两者在写法上相似，但底层原理不同：React Hook 是“顺序绑定状态”，Vue composable 是“引用绑定状态”。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "browser",
      "name": "浏览器",
      "questions": [
        {
          "id": "browser-1",
          "title": "浏览器点击url发生什么",
          "content": "> 当在浏览器输入 URL 并回车后，整体可以分为 **网络阶段** 和 **渲染阶段** 两大部分。\n\n1. **URL 解析 & DNS 查询**  \n    浏览器解析 URL，判断协议、域名和路径，通过 DNS 将域名解析成 IP\n2. **建立连接**\n    - HTTP：TCP 三次握手\n    - HTTPS：在 TCP 之上增加 TLS 握手，完成证书校验和密钥协商\n3. **发送 HTTP 请求并接收响应**  \n    - 请求HTML文件并解析。\n    - 解析HTML的过程中请求css js及其他资源，过程中css的请求和解析不阻塞构建 DOM 树但会阻塞渲染，js的请求和解析会阻塞 HTML 解析和渲染（使用 defer 可以避免阻塞解析，而 async 则不保证执行时机和顺序，适合独立脚本。）\n4. **浏览器解析与渲染**\n    - HTML → DOM：构建 DOM 树\n    - CSS → CSSOM：解析 CSS 样式，生成 CSSOM (CSS Object Model) 树。\n    - 合成 Render Tree ：将 DOM 树和 CSSOM 树合并，排除不可见的节点\n    - 计算布局并绘制\n5. **JS 文件加载后开始执行**  \n    JS 执行过程中可能修改 DOM/CSS，触发重新渲染。\n\n👉 **优化点**：DNS 缓存、HTTP 缓存、资源并行加载、减少阻塞资源、SSR/SSG。",
          "hasAnswer": true
        },
        {
          "id": "browser-2",
          "title": "浏览器渲染流程",
          "content": "浏览器的渲染流程本质是把 HTML 和 CSS 转换成像素。\n\n核心步骤：\n1. **HTML 解析生成 DOM**\n2. **CSS 解析生成 CSSOM**\n3. **DOM + CSSOM → Render Tree**\n4. **Layout（回流）**：计算元素几何信息\n5. **Paint（重绘）**：绘制样式\n6. **Composite（合成）**：GPU 合成图层\n\n👉 追问：\n- 哪些操作会触发 **回流 / 重绘** \n- 为什么 `transform / opacity` 性能好（只走合成层）\n\t- `transform` 和 `opacity` 不会影响元素的布局和绘制，只会影响**合成阶段**。",
          "hasAnswer": true
        },
        {
          "id": "browser-3",
          "title": "window document",
          "content": "在浏览器环境中，所有全局变量和函数都是 `window` 的属性。它同时是全局作用域的代表。也是**DOM 和 BOM 的入口：** `document` (DOM) 和 `navigator`, `screen` 等 (BOM)。\n\n`document` 对象代表**浏览器窗口中加载的整个 HTML 文档**。是**DOM (Document Object Model) 的入口**。通过它，我们可以操作网页中的所有元素、内容和样式。\n\nDOM ：文档对象模型，提供了与页面内容和结构交互的能力（如查找元素、修改文本）\n\nBOM： 浏览器对象模型，提供了与浏览器窗口和环境交互的能力（如导航、历史记录、计时器），核心对象是window\n\n `window.document === document`\n\n👉 常见追问：\n- 全局变量为什么会挂到 window 上\n\t- 在浏览器环境中，`window` 是全局对象，**非模块环境下**，使用 `var` 或直接声明的全局变量会成为 `window` 的属性。\n\t- 常见风险：全局变量容易造成命名冲突和内存泄漏。\n- document 什么时候可用\n\t- `DOMContentLoaded` 事件表示 **DOM 树已经构建完成**，但不保证图片、样式等资源加载完成。\n\t- `window.load` 事件表示整个页面及其所有资源加载完成，包括：HTML、CSS、JS、**图片、字体、iframe**，注意只等资源下载完成，不等 JS 执行结束",
          "hasAnswer": true
        },
        {
          "id": "browser-4",
          "title": "requestAnimationFrame & 帧机制",
          "content": "`requestAnimationFrame` 会在浏览器下一帧渲染前执行回调。\n\n特点：\n- 与屏幕刷新率同步（≈16.6ms）\n- 页面不可见时自动暂停\n- 比 setTimeout 更适合动画\n\nrAF 在渲染流程中的时机：\n- `requestAnimationFrame` 的回调会在**下一帧渲染前执行**，通常发生在 **Layout 和 Paint 之前**。\n\n优势：\n- 跟随刷新率\n- 页面不可见自动暂停\n- 比 setTimeout 更省电、更流畅\n适合：\n- 频繁更新的动画\n- 与渲染强相关的状态更新\n\n用法：\n`requestAnimationFrame` 接收一个 **回调函数**，该回调会被传入一个 **高精度时间戳参数**。timestamp 是从页面加载开始到当前帧的时间（毫秒），是高精度（浮点数）\n\n示例\n```\nlet last = 0\nfunction animate(timestamp) {\n  const delta = timestamp - last // 获取两次回调的时间差\n  ...\n  requestAnimationFrame(animate)\n}\n\nrequestAnimationFrame(animate)\n```",
          "hasAnswer": true
        },
        {
          "id": "browser-5",
          "title": "重排 (Reflow) 重绘 (Repaint) 合成层",
          "content": "- **重排**：布局变，**代价高**\n\t- 修改 width / height / padding / margin\n\t- 修改 display、position\n\t- 添加 / 删除 DOM 节点\n\t- 获取 layout 信息（offsetTop、getBoundingClientRect）并穿插写操作\n- **重绘**：样式变化，不影响布局，代价相对低\n\t-  修改 color / background / box-shadow\n\t- visibility 变化\n- **合成**：transform/opacity\n\t- 浏览器会把元素提升到**独立合成层**\n\t- 动画只在 GPU 中做矩阵变换或透明度计算\n\t- **跳过 布局计算 和 绘制**\n\n回流一定会引起重绘，但重绘不一定回流。\n\n👉 优化原则：\n- 批量 DOM 操作\n- 读写分离\n- 动画优先用 transform",
          "hasAnswer": true
        },
        {
          "id": "browser-6",
          "title": "IntersectionObserver 作用",
          "content": "`IntersectionObserver` 是一个**异步 API**，用于监听目标元素与一个参照区域（root）之间的**位置关系变化**，**不依赖滚动事件**，性能更好。它关注的是：\n- **是否相交**\n- **相交比例**\n- **相交发生的时机**\n本质是：**“元素是否进入 / 离开某个区域”**\n\n使用场景：\n- 图片懒加载\n- 无限滚动\n- 曝光埋点\n优势：\n- 异步执行\n- 不阻塞主线程\n- 浏览器原生优化\n\n示例\n```\nnew IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.isIntersecting       // 是否相交\n    entry.intersectionRatio   // 相交比例\n    entry.boundingClientRect  // 元素自身位置\n    entry.rootBounds          // root 区域\n    entry.intersectionRect    // 实际相交区域\n  }),\n  {\n\t  root: container,  // 要校验的参照区域\n\t  threshold: 1, // 相交阈值，达到阈值会触发回调函数，也可以是数组\n\t  rootMargin: '200px' //要校验的相交关系\n  }\n)\n```\n\n总结：`IntersectionObserver` 本质是浏览器原生的‘位置关系监听器’，可以基于 root、rootMargin 和 threshold 精确描述元素与容器的相交状态，用来做懒加载、曝光埋点和位置校验，比手写滚动监听更高效。",
          "hasAnswer": true
        },
        {
          "id": "browser-7",
          "title": "JS 执行机制 & 事件循环",
          "content": "浏览器是单线程执行 JS，通过事件循环机制来处理异步任务。\n\n核心机制：\n1. 主线程执行同步代码\n2. 遇到异步任务，交给 Web APIs\n3. 回调按类型进入任务队列：\n    - **微任务**：Promise.then、MutationObserver\n    - **宏任务**：setTimeout、setInterval、I/O\n4. 每轮循环顺序：\n    - 执行一个宏任务\n    - 清空所有微任务\n\n👉 关键点：\n- 微任务会阻塞渲染，如果微任务不断追加（比如递归 Promise），浏览器就**无法进入渲染阶段**，页面会卡住。高频陷阱：大量 Promise.then 会导致页面假死。\n- 微任务优先级高于宏任务",
          "hasAnswer": true
        },
        {
          "id": "browser-8",
          "title": "浏览器缓存机制",
          "content": "浏览器缓存的目标是减少网络请求、提升加载性能。\nHTTP 缓存两类：\n\n 缓存层级：\n- 内存缓存\n\t- - 速度最快\n\t- 生命周期短（页面关闭即失效）\n\t- 常用于当前页面重复请求的资源\n- 磁盘缓存\n\t- 速度慢于内存\n\t- 持久化存储\n\t- 跨页面、跨会话复用\n- HTTP 缓存\n\t1. **强缓存**\n\t    - `Cache-Control`、`Expires`\n\t    - 命中后**不发请求**\n\t2. **协商缓存**\n\t    - `ETag / If-None-Match`\n\t    - `Last-Modified / If-Modified-Since`\n\t    - 返回 304，不传资源\n\n具体使用哪种由浏览器根据资源大小、使用频率自动决定。",
          "hasAnswer": true
        },
        {
          "id": "browser-9",
          "title": "什么是跨域？什么是同源策略？为什么需要跨域？常见解决方案",
          "content": "浏览器的同源策略要求：**协议、域名、端口** 三者一致，否则就是跨域。\n\n为什么有同源策略？\n- 防止恶意网站读取用户隐私数据\n- 属于浏览器的安全机制\n为什么需要跨域？\n- 前后端分离\n- 多服务、多子域部署\n\n跨域解决方案：\n1. **CORS（跨域资源共享）**：服务器设置响应头（如`Access-Control-Allow-Origin`）允许跨域。\n2. **JSONP**：利用`<script>`标签不受同源策略限制，通过回调函数获取数据。\n3. **WebSocket**：不受同源策略限制，可跨域通信。\n4. **postMessage**：iframe允许不同源窗口间通信。l\n5. **nginx反向代理**：配置nginx将请求代理到目标服务器。",
          "hasAnswer": true
        },
        {
          "id": "browser-10",
          "title": "浏览器存储体系",
          "content": "| 类型             | 特点            |\n| -------------- | ------------- |\n| Cookie         | 小、随请求发送、受同源限制 |\n| localStorage   | 持久化、同步 API    |\n| sessionStorage | 会话级           |\n| IndexedDB      | 大、异步、结构化      |\n- 为什么 cookie 不适合存 token\n- 为什么 localStorage 不适合高频读写",
          "hasAnswer": true
        },
        {
          "id": "browser-11",
          "title": "V8垃圾回收",
          "content": "总结 V8 GC 流程\n1. **新生代：** 高频、快速的 **Scavenge 算法**，负责快速清理短期对象。\n2. **老生代：** 低频、复杂的  标记-清除（Mark-Sweep） 和 标记-整理（Mark-Compact）。算法，通过 增量标记 和 并发/并行技术来减少 减少停顿时间。\n\n核心思想：\n- 大多数对象“朝生夕死”\n- 减少全量扫描，提升性能\n\n👉 追问：\n- 为什么闭包容易导致内存问题\n\t- 闭包会让内部变量被外部函数持续引用，导致变量**无法被 GC 回收**。\n\t- 解决思路：使用完后断开引用；避免在闭包中持有不必要的大对象\n- GC 会不会阻塞 JS\n\t- 会阻塞，但 V8 通过增量 GC 降低了阻塞时间。GC 本质要暂停 JS 执行；V8 将一次大 GC 拆成多次小步骤，在 JS 执行间隙逐步完成回收",
          "hasAnswer": true
        },
        {
          "id": "browser-12",
          "title": "内存泄漏",
          "content": "内存泄漏指的是对象不再使用，但仍被引用，无法被 GC 回收。\n\n常见原因：\n1. 意外的全局变量\n2. 未清除的定时器\n3. 未移除的事件监听器\n4. 闭包引用外部大对象\n5. 未清除的DOM 引用\n\n排查：Chrome DevTools 的 **Memory** 面板\n1. 录制堆快照-复现操作-录制快照\n2. 对比分析：重点关注 “Delta”：特别是那些**数量持续增加且没有被回收**的构造函数。找到泄露的对象\n3. 分析原因：**保留树**显示了**为什么这个对象没有被垃圾回收**。它列出了从全局根 (Root) 到该对象的引用链。顺着保留树向上查找，直到找到阻止 GC 回收的**不必要的全局引用、闭包、或 DOM 引用**。\n\n解决思路：\n- 组件卸载时清理副作用和事件监听器\n- 避免不必要的全局引用\n- 节点移除时清理事件监听器\n- 慎用闭包",
          "hasAnswer": true
        },
        {
          "id": "browser-13",
          "title": "浏览器内核",
          "content": "浏览器内核（或称渲染引擎，Rendering Engine）是浏览器的核心组件，主要负责：\n1. **渲染**：解析 HTML/XML/CSS，构建渲染树，并负责页面的布局和绘制。\n2. **脚本执行**：虽然 JavaScript 引擎（如 V8）是独立的部分，但渲染引擎需要协同 JavaScript 引擎。\n\n主流：\nblink: chrome edge \nWebKit: Safari\nGecko: Firefox\nTrident: IE\n\n注：JS 引擎（如 V8）是独立模块，但与渲染引擎紧密配合",
          "hasAnswer": true
        },
        {
          "id": "browser-14",
          "title": "了解哪些浏览器渲染引擎？渲染机制举例",
          "content": "主流浏览器渲染引擎包括 Blink、WebKit、Gecko，整体渲染机制一致，都是 DOM + CSSOM → Render Tree → Layout → Paint → Composite。\n\n举例：\n- Chrome 使用 Blink + V8\n- Safari 使用 WebKit + JavaScriptCore",
          "hasAnswer": true
        },
        {
          "id": "browser-15",
          "title": "V8 引擎优化机制",
          "content": "V8 通过 **JIT 编译 + 隐藏类 + 内联缓存** 提升 JS 执行性能。\n\n关键点：\n- **JIT**：热点代码从解释执行转为机器码\n- **Hidden Class**：对象结构稳定 → 访问更快\n- **Inline Cache**：缓存属性访问路径\n\n👉 开发建议：\n- 保持对象结构稳定\n- 避免频繁增删属性\n- 避免混合类型数组",
          "hasAnswer": true
        },
        {
          "id": "browser-16",
          "title": "JavaScript 执行性能优化",
          "content": "JS 性能优化的核心是减少阻塞主线程。\n\n常见手段：\n- 减少长任务（>50ms）\n- 合理拆分任务（结合setTimeout / requestAnimationFrame）\n- 避免频繁操作 DOM，减少重排 (Reflow) 和重绘 (Repaint)\n- 优化 JavaScript 执行效率：避免全局查找，减少复杂运算，减少作用域链查找\n- 内存管理：避免内存泄漏，及时释放大对象和事件监听器\n- 节流 (Throttle) 和防抖 (Debounce)\n- 使用 Web Workers：对于复杂的、耗时的计算任务（如大量数据处理），将其放在 **Web Worker** 中，避免阻塞主线程，确保 UI 响应流畅。",
          "hasAnswer": true
        },
        {
          "id": "browser-17",
          "title": "navigator.sendBeacon 是什么？怎么用",
          "content": "`navigator.sendBeacon` 是浏览器提供的**专门用于上报少量数据的异步接口**，核心特点是：  \n**在页面卸载（unload / pagehide）阶段也能可靠发送请求，且不阻塞页面跳转。**\n\n它最典型的用途就是：**埋点、日志、性能数据上报**。\n\n传统方案的问题\n- 在 `beforeunload / unload` 阶段：\n    - `fetch` / `XHR` **很容易被浏览器直接中断**\n    - 同步请求会 **阻塞页面关闭（被限制甚至禁止）**\n `sendBeacon` 的设计目标\n- 页面即将关闭 / 跳转\n- **保证“尽最大可能把数据送到服务端”**\n- 不影响用户体验\n\n特点：\n- 返回值是 `boolean`\n    - `true`：浏览器已接管发送任务\n    - `false`：参数非法或发送失败\n- **不返回 Promise**\n- **拿不到响应结果**\n缺点：\n- **只适合小数据量**（通常 < 64KB，浏览器实现不同）\n- 只能用 **POST**\n- 不能自定义 header（如 Authorization）\n- 不能读取响应\n- 不适合业务请求\n\n示例：\n```\nnavigator.sendBeacon('/log', JSON.stringify({\n  event: 'page_leave',\n  time: Date.now()\n}))\n```\n\n追问：对比 fetch keepalive\n`fetch keepalive` 确实能在页面卸载时继续请求，但：\n- 有严格的体积限制\n- 不同浏览器支持不一致\n- 仍然不如 `sendBeacon` 稳定\n所以在**埋点上报**这种场景，优先使用 `sendBeacon`。",
          "hasAnswer": true
        },
        {
          "id": "browser-18",
          "title": "如何判断页面要离开/卸载/隐藏",
          "content": "1. `pagehide`（最推荐，离开/进入 bfcache 都覆盖）\n**用途**：页面即将被卸载，或被放入 **bfcache**（前进后退缓存）时触发。  \n**优点**：比 `unload/beforeunload` 更可靠，移动端也相对稳。\n\n2.  `visibilitychange` + `document.visibilityState === 'hidden'`（隐藏/切后台最通用）\n**用途**：页面从可见变为隐藏（切 Tab、切后台、锁屏、打开系统任务切换）时触发。  \n**优点**：覆盖“隐藏”场景很全面；不一定意味着卸载，但对上报很实用。\n\n3. `beforeunload`（老方案：可拦截离开，但限制多）\n**用途**：尝试在离开页面前做确认提示（比如表单未保存）。  \n**现实**：现代浏览器对自定义文案基本禁用，而且触发时机/条件很多限制。\n\n4. 辅助方案：结合 组件卸载，路由变化等",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "node",
      "name": "Node.js",
      "questions": [
        {
          "id": "node-1",
          "title": "Node.js 事件循环机制",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "node-2",
          "title": "Stream 流处理和背压机制",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "node-3",
          "title": "Cluster 模块和多进程优化",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "node-4",
          "title": "内存泄漏排查和性能监控",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "node-5",
          "title": "中间件原理和实现",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "node-6",
          "title": "讲讲node 做BFF",
          "content": "node 做BFF通常用来代理前端请求，可以处理文件、注入信息、做中间层鉴权等\n1. 统一进行数据聚合与裁剪：从多个后端服务获取数据，聚合后返回给前端\n\n2. 统一鉴权并注入加密信息，可以隔离敏感信息。把获取重要的加密信息放在服务端做，然后对前端的请求增加一层转发携带accessToken，可以完成更安全的身份校验不必担心数据暴露的风险\n\n3. 处理文件或查询数据库或进行协议转换：前端不必关心中间层，BFF可以注入必要的信息或进行文件处理，然后进行转发\n   优点\n   解耦前后端：前端只需对接 BFF，无需关心后端服务细节 \n   提升前端性能：减少请求次数，减小数据传输量 \n   灵活适配多端：可以为不同端提供定制化接口 \n   安全性增强：统一鉴权，隐藏内部服务 \n   便于前端开发：前端团队可以主导 BFF 开发，接口更贴合需求\n   缺点：\n   增加一层调用：网络延迟可能略微增加\n   维护成本：需要额外维护 BFF 层代码\n   可能成为瓶颈：如果设计不当，BFF 可能成为性能瓶颈\n   职责边界模糊：需要明确 BFF 和后端服务的职责划分\n\n4. 数据聚合与裁剪\n   BFF 的核心职责之一是从多个后端服务获取数据，聚合后返回给前端。\n\n5. 代理前端请求，并注入加密信息，目的是隔离敏感信息。把获取重要的加密信息放在服务端做，然后对前端的请求增加一层转发携带accessToken，可以完成更安全的身份校验不必担心数据暴露的风险",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "nextjs",
      "name": "Next.js",
      "questions": [
        {
          "id": "nextjs-1",
          "title": "nextjs 适用场景",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "nextjs-2",
          "title": "SSR",
          "content": "在传统的 SSR 架构（如早期的 React SSR）中，您确实需要维护两套入口（client-entry.js 和 server-entry.js），配置两套 Webpack，处理注水 (Hydration) 的各种样板代码。\nNext.js 把这一切都封装了。您只需要写一个 page.tsx，Next.js 会自动在服务器上把它渲染成 HTML，然后在客户端把它“激活”。对于开发者来说，只有一套代码，一套逻辑\nNext.js 的伟大之处在于，它让您在同一个项目、同一个文件结构、同一种语言中，流畅地穿梭于“服务端”和“客户端”之间。您不需要配置复杂的环境，但您需要清晰地知道“我现在是在服务器上（获取数据）”还是“我现在是在浏览器里（处理交互）”。这种无缝融合，正是它作为全栈框架的体验确实是目前业界领先于业界的关键。\n\n客户端组件在服务端执行时，只会生成静态 HTML。它的 useEffect、onClick 等逻辑不会运行。这些逻辑只有代码被下载到浏览器并“注水 (Hydrate)”后，才会真正在客户端执行。\n服务端组件 (RSC) 的代码，只在服务器上运行。零 JS 发送：这些组件的 JavaScript 代码永远不会被打包发送给浏览器。浏览器收到了什么？：浏览器接收到的是 RSC 执行后的结果（一种特殊的 JSON 数据格式，描述了 UI 的结构）。![](/Users/wzz/Library/Application%20Support/marktext/images/2025-12-01-00-06-38-image.png)\n\n服务端内容变成了纯数据：`<h1>Hello Server</h1>`没有变成 HTML 标签，而是变成了一个描述：“这有一个 h1，内容是 Hello Server”。\n客户端组件变成了“占位符”：注意那个 \"$L2\"。它告诉浏览器：“这里应该放一个 ClientButton 组件。它的代码在 ClientButton.js 里，请去下载它，并把 initialCount: 10 传给它。”\n浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n在首次加载页面时，RSC Payload 是内嵌在 HTML 源码中的。浏览器拿到这个 JSON 后做了什么？\nReact 读取 JSON。\n把 div 和 h1 渲染出来（或者更新现有的）。\n看到 $L2，去加载客户端组件的代码。\n最关键的一步：如果页面上本来就有一个 ClientButton，React 会保留它现在的状态（比如用户已经把 count 点到了 15），然后只更新必要的 props，实现了无缝衔接。\n\n服务端组件只在服务端执行，所以不能调客户端的方法包括window等（Node.js 里根本就没有浏览器窗口的概念），也不能useeffect usestate，这些 Hooks 的作用是“在浏览器里管理状态和副作用”。既然 RSC 的代码都不发送给浏览器，这些 Hooks 自然也就毫无用武之地。\n\n客户端组件则是提前再服务端执行得到初始样式和HTML，浏览器加载完HTML后再下载并执行js文件进行水合（React 在浏览器里再次运行这个组件，这次它会执行 useEffect，并且把 onClick 事件监听器挂载到那个已经存在的按钮上。）\n\n当 Next.js 在服务器（Node.js）上渲染一个客户端组件时，它其实是在执行一个“阉割版”的 React 渲染流程：\n执行组件函数：Node.js 会像浏览器一样，去调用组件函数\n处理 Hooks (有特殊规则)：useState只取初始值；useEffect / useLayoutEffect: 直接跳过；useContext: 正常执行读取组件树上层的 Provider 里的值；\n生成 Virtual DOM：函数执行完，React 得到了一棵组件树。\n序列化为 HTML：React 的服务端渲染器 (ReactDOMServer) 遍历这棵树，把它转换成纯文本的 HTML 字符串（例如.  \\<div>\\<button>Click</button></div> ）。 \n\nApp Router 是 Next.js 13.4 之后推出的全新路由和渲染架构\n基于 app/ 目录：以前的页面写在 pages/ 里，现在的页面写在 app/ 里。\n默认 RSC：这是最大的区别。在 app/ 里写的组件，默认全是服务端组件。这彻底改变了开发模式。\n嵌套布局 (Nested Layouts)：支持 layout.tsx 嵌套，这是 Pages Router 做不到的。\n流式传输 (Streaming)：利用 React Suspense，可以把页面拆成碎片，一部分一部分地发给浏览器（比如先发个 loading 骨架屏，再发数据），极大地优化了 TTFB。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-3",
          "title": "RSC react server component",
          "content": "React Server Components 是 React 提出的 **一种让部分组件只在服务器端执行的渲染模式** \n它不是传统意义上的 SSR（Server-Side Rendering）那样生成完整 HTML，而是：\n\n> **在服务器执行组件逻辑，把渲染结果以特殊协议序列化成数据流发送给客户端，客户端再把这些数据解释成 UI。**\n\n核心特点：\n\n- 组件代码 **永远不发送到客户端**（不会打包到 bundle 里）。\n\n- 只能运行在服务器上，不能使用浏览器 API 和交互 Hooks（如 `useState`, `useEffect`）。主要用于数据密集型、展示型的 UI。\n\n- 主要用于数据密集型、展示型的 UI。\n\n这就能让 React 应用更“轻巧、高效、按需加载”。\n\n| 渲染方式        | JS 发送到客户端       | 数据获取模式         | 互动能力                 |\n| ----------- | --------------- | -------------- | -------------------- |\n| CSR (客户端渲染) | 全组件 JS          | 客户端请求 API      | 强                    |\n| SSR (服务端渲染) | 全组件 JS + HTML   | 服务端预取数据 → HTML | 交互需要 hydrate         |\n| **RSC**     | **只发送必要的交互 JS** | 服务器直接数据访问      | 交互需 Client Component |\n\nReact Server Components 是一种服务器执行的组件模式，它让 UI 的渲染和数据获取在服务端完成，只把 UI 结构通过序列化协议发送给客户端，从而减少 JS bundle、提高性能并简化数据获取，同时和交互组件协同工作，适配复杂应用。\n\n**RSC 适合：数据驱动、多页面/大列表/复杂查询、多数据源聚合，但客户端交互较轻**的页面。\n\n**不适合：交互复杂、状态频繁变化、强实时响应**的组件。",
          "hasAnswer": true
        },
        {
          "id": "nextjs-4",
          "title": "Next.js RSC 漏洞",
          "content": "这个漏洞（2024–2025 问题）本质是 **反序列化不可信数据 → 服务端执行恶意构造的代码（RCE）**\n\n漏洞点：服务端反序列化 RSC payload 时，默认信任客户端的数据，服务端代码，没有校验actionId 和 payload 结构是否可信，而是直接可以执行\n\n导致只要攻击者伪造结构正确的 payload，就能执行任意的 Server Action 函数\n\n正确的校验应该：\n\n**校验 1：payload 引用的 actionId 必须属于当前构建生成的 action map**\n\n**校验 2：反序列化过程中禁止还原任意类型对象，只允许白名单类型**",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "engineering",
      "name": "工程化",
      "questions": [
        {
          "id": "engineering-1",
          "title": "Webpack 构建流程和原理",
          "content": "阶段一：初始化 (Initialization)：Webpack 从启动到开始处理文件前的准备阶段。\n\n1. **参数合并:** 读取并合并 `webpack.config.js` 中的配置参数、Shell 命令行参数以及默认配置。\n\n2. **创建 Compiler:** 创建一个 `Compiler` 实例。`Compiler` 是 Webpack 的核心对象，它贯穿整个生命周期，负责协调整个构建流程。\n\n3. **加载插件:** 遍历配置中的 `plugins` 数组，依次执行插件的 `apply` 方法，注册各种 Hook（钩子）函数，监听 Compiler 或 Compilation 的事件。\n\n阶段二：构建模块 (Building Modules)：此阶段的核心是根据入口文件递归地构建**模块依赖图 (Module Dependency Graph)**。\n\n1. **确定入口:** 从配置中定义的 `entry` 入口文件开始。\n\n2. **创建 Compilation:** 创建一个 `Compilation` 实例。`Compilation` 对象负责本次构建过程的资源管理，包括模块、依赖图、Chunk、生成的资源文件等信息。\n\n3. **Module 构建循环:** Webpack 进入模块处理的循环：\n   \n   - **加载 (Loading):** 根据模块路径读取文件内容。\n   \n   - **解析 (Resolving):** 使用配置好的 `resolve` 规则，确定模块的绝对路径。\n   \n   - **处理 (Processing):**\n     \n     - 将文件内容传递给匹配的 **`Loader`**。Loader 负责将非 JS 类型的资源（如 TS, Sass, Vue 文件）转换为有效的 JavaScript 模块内容，或进行转换（如 Babel 转译）。\n     \n     - Loader 链式执行，前一个 Loader 的输出是后一个 Loader 的输入。\n   \n   - **依赖分析:** 使用 **`Parser`** (解析器) 遍历经过 Loader 处理后的代码内容。解析器会识别出代码中的 `import`、`require()`、`import()` 等模块导入语句。\n   \n   - **递归:** 每识别到一个依赖，就将其加入到依赖图，并对该依赖文件重复整个构建循环，直到所有依赖都被处理。\n\n阶段三：生成资源 (Sealing & Emitting)\n\n在依赖图构建完成后，Webpack 开始将模块组合成可部署的资源文件。\n\n1. **Chunk 分组:** 将构建好的模块根据它们的关系进行分组，形成 **Chunks** (代码块)。\n   - **Entry Chunk:** 对应入口文件及其同步依赖。\n   - **Lazy Chunk:** 对应通过 `import()` 动态导入形成的异步加载模块。\n   - **Vendor/Common Chunk:** 对应通过 `SplitChunksPlugin` 提取的公共/第三方模块。\n\n2. **Chunk 优化 (Tree Shaking/Code Splitting):** 运行优化步骤，如 Tree Shaking 移除未使用的代码，以及 `splitChunks` 配置提取公共代码。\n\n3. **生成 Bundle:** 将 Chunk 映射到最终的输出文件（Bundle）。Webpack 为每个 Chunk 添加 runtime 代码（用于加载和执行模块）和模块包装器。\n\n4. **写入文件:** 最终，执行 `emitAssets` 钩子，将内存中生成的 Bundle 文件内容写入到输出目录（`output` 配置）。",
          "hasAnswer": true
        },
        {
          "id": "engineering-2",
          "title": "webpack优化代码分割产物加载速度的机制",
          "content": "- **实现方式：** 使用 Webpack 内联注释（Magic Comments）或 HTML 标签。\n  \n  - **`/* webpackPreload: true */`**\n  \n  - **`/* webpackPrefetch: true */`**\n\n- **适用场景：**\n  \n  - **`Preload` (预加载)：** 用于当前页面**很快就会需要**的资源（如当前路由的字体、关键图片或首个动态加载的 Chunk）。它会和父 Chunk 并行加载，优先级较高。\n  \n  - **`Prefetch` (预取)：** 用于用户**未来可能会需要**的资源（如用户可能会跳转到的下一个路由页面）。它会在浏览器空闲时加载，优先级较低。",
          "hasAnswer": true
        },
        {
          "id": "engineering-3",
          "title": "loader plugin区别",
          "content": "这两者是 Webpack 的核心支柱，但作用维度完全不同：\n\n- **Loader (转化器)：** 它是文件级的转换。Webpack 只能理解 JS 和 JSON，Loader 的作用是让 Webpack 具备处理 **非 JS 文件** 的能力（如 `css-loader` 处理 CSS，`babel-loader` 转化 ES6）。它运行在打包之前，遵循‘从右往左’的链式调用。\n- **Plugin (插件)：** 它是系统级的扩展。基于 Webpack 的**事件流（Tapable）**机制。Plugin 会挂载在 Webpack 构建生命周期的各个钩子上，在整个构建流程中执行更复杂的任务。\n- **一句话总结：** Loader 是干活的工人（处理文件），Plugin 是监工（控制构建流程，如压缩代码、清空目录、生成 HTML）。”",
          "hasAnswer": true
        },
        {
          "id": "engineering-4",
          "title": "webpack常用配置项",
          "content": "首先是入口和输出配置，比如 `entry` 和 `output`，用于定义构建的入口文件以及最终打包产物的输出路径和文件名。\n其次是模块解析和处理相关的配置，包括 `resolve`，用于配置文件后缀名解析和路径别名，以及 `module.rules` 中的 loader，用来处理不同类型的资源文件。\n然后是插件相关配置，通过 `plugins` 在 webpack 构建的各个生命周期阶段执行特定逻辑。\n另外还有一些环境和开发相关的配置，比如 `mode` 区分开发和生产环境，`devServer` 用于本地开发配置，`devtool` 用于 source map 设置。\n最后是 `optimization`，用于构建优化，比如代码压缩、`splitChunks` 做代码分包，以及 `runtimeChunk` 抽离运行时代码以支持长期缓存。",
          "hasAnswer": true
        },
        {
          "id": "engineering-5",
          "title": "什么是webpack运行时",
          "content": "1. 什么是 Runtime？\n\nWebpack 运行时是**一段微型的代码块，负责在浏览器运行期间连接模块、加载模块、解析依赖。**\n\n没有它，浏览器根本不认识 `require()`、`import` 或 `module.exports`。\n\n2. Runtime 的核心功能\n\n- **模块映射表 (Module Manifest)**：里面记录了所有模块的 ID 和它们在打包后的文件位置。\n- **模块加载机制**：\n    - 实现同步加载：`__webpack_require__(moduleId)`。\n    - 实现异步加载（动态 import）：通过动态创建 `<script>` 标签并注入 JSONP 回调。\n- **缓存管理**：确保同一个模块在多次引用时只执行一次，后续直接从内存缓存中读取。\n\n实际工程中：我们通常会将它提取为独立的 `runtimeChunk`，防止业务代码变动导致映射表更新，从而破坏第三方库的长期缓存。",
          "hasAnswer": true
        },
        {
          "id": "engineering-6",
          "title": "webpack 如何处理require？",
          "content": "在 Webpack 的世界里，不论你在源码里写的是 `const a = require('./a')` 还是 `import a from './a'`，打包后它们的效果确实是**一样**的。\n\n- **编译阶段**：Webpack 会扫描所有的静态依赖，把它们全部塞进同一个（或指定的几个）Bundle 块中。\n    \n- **运行阶段**：Webpack 会在 Bundle 内部维护一个 `modules` 对象（即**模块定义映射表**）。\n    \n- **执行逻辑**：当你调用 Webpack 模拟的 `__webpack_require__` 时，它会去映射表里找。如果模块已经执行过，直接从缓存拿 `exports`；如果没有，就执行模块代码并存入缓存。\n    \n\n**结论：** 静态 `import` 和 `require` 都会被视为**同步依赖**。它们会被打包在一起，在页面启动时就全部加载完成，不会产生额外的网络请求",
          "hasAnswer": true
        },
        {
          "id": "engineering-7",
          "title": "Webpack 异步加载的底层原理（JSONP）",
          "content": "当你在代码里写下 `import('./A')`，Webpack 在运行时其实做了以下几件事：\n\n1. **发起请求**：通过 `document.createElement('script')` 动态创建一个标签，指向子包的 URL。\n2. **JSONP 回调**：子包的文件内容通常包裹在一个函数里，例如 `self[\"webpackChunk\"].push([[chunkId], { modules... }])`。\n3. **合并模块**：当脚本加载成功，这个全局回调被触发。Webpack 的 Runtime 接收到新模块，把它们合并到主 Bundle 的模块映射表中。\n4. **Resolve Promise**：原来 `import()` 返回的那个 Promise 被标记为成功，你就可以在 `.then()` 或 `await` 之后拿到模块内容了。",
          "hasAnswer": true
        },
        {
          "id": "engineering-8",
          "title": "webpack 如何拆分 Chunk 动态加载？",
          "content": "动态 `import()` 是触发“代码分割（Code Splitting）”的最主要开关\n- **静态加载**：`import A from './A'` $\\rightarrow$ A 模块被打包进 Main Bundle $\\rightarrow$ **网络一次性下载**。\n    \n- **动态加载**：`import('./A')` $\\rightarrow$ Webpack 自动将 A 模块及其依赖单独切出来，生成一个 `src_A_js.bundle.js` $\\rightarrow$ **运行到这一行时才发请求下载**。\n\n除了动态import ，还提供了**配置驱动**的拆分方案：\n\n- **`optimization.splitChunks` (抽离公共库)**： 这是最常用的。你可以配置“如果某个模块（如 `lodash` 或 `react`）被引用了超过 2 次，或者来自 `node_modules`，就把它单独拆成一个 `vendors.js`”。这样即使你没写动态 `import`，它也会被拆出来。\n    \n- **多入口配置 (`entry`)**： 如果你配置了多个入口（比如 `index.js` 和 `admin.js`），Webpack 会自动为每个入口生成独立的 Bundle。",
          "hasAnswer": true
        },
        {
          "id": "engineering-9",
          "title": "Webpack 的持久化缓存，如何判断文件是否需要重新编译",
          "content": "将上一次构建的结果（包括解析的模块、生成的 AST、转译后的代码等）存储到磁盘上，这样在后续构建中，如果文件或其依赖没有变化，就可以**跳过整个 Loader 链和模块构建过程**，直接复用缓存结果。这使得二次构建（特别是使用 HMR 时的开发构建）的速度大大加快。\n\n持久化缓存通过在 `webpack.config.js` 中设置 `cache` 属性来启用：\n\n```js\nmodule.exports = {\n  // ... 其他配置\n  cache: {\n    type: 'filesystem', // 启用基于文件系统的持久化缓存\n    buildDependencies: {\n      // 告诉 Webpack 哪些文件变动会导致缓存失效\n      config: [__filename], \n    },\n    // 默认缓存目录是 node_modules/.cache/webpack\n    // name: 'my-app-cache', // 可自定义缓存名称\n  },\n  // ...\n};\n```\n\n如何判断和检查是否可以用缓存：\n\n- **检查全局配置：** Webpack 检查自身的版本、Node.js 版本以及配置文件的哈希是否匹配。如果不匹配，清空所有缓存。\n\n- **检查模块哈希：** Webpack 检查当前文件的内容哈希。如果不匹配，缓存失效。\n\n- **检查 Loader/Plugin 配置：** Webpack 检查作用于该文件的 Loader 链和 Plugin 选项是否与缓存中记录的一致。如果不一致，缓存失效。\n\n- **检查依赖哈希：** Webpack 检查该模块所依赖的其他模块的哈希是否匹配。只要一个依赖项发生变化，当前模块的缓存就失效。",
          "hasAnswer": true
        },
        {
          "id": "engineering-10",
          "title": "说说webpack 联邦模块",
          "content": "它允许**多个独立的 Webpack 构建应用**在运行时共享代码和依赖，给**前端微服务架构**提供基础。\n\n它让一个应用（Host）可以在运行时动态加载另一个独立应用（Remote）的代码模块，就像加载本地模块一样。\n\nRemote (远程方)：独立打包的应用。暴露 (Expose) 自己的部分代码模块供其他应用使用。Host (主机方)：独立打包的应用。消费 (Consume) 远程应用暴露出的模块。\n\n两个应用都需要的公共依赖，如 React、Vue。确保所有应用共享同一份依赖实例，避免重复加载和版本冲突\n\nModule Federation 通过在 Webpack 构建输出中添加特殊的 **“容器 (Container)”** 机制来实现：",
          "hasAnswer": true
        },
        {
          "id": "engineering-11",
          "title": "Code Splitting 的多种方案",
          "content": "1.入口点分割 (Entry Points)\n\n这是最基础的分割方式。开发者手动在配置文件中定义多个入口文件，Webpack 会为每一个入口点生成一个独立的 Bundle。\n\n- **实现方式：** 在 `webpack.config.js` 的 `entry` 配置中定义多个键值对。\n\n- **适用场景：** 传统多页应用 (MPA)，每个页面对应一个入口；或者当你有两个完全独立的 SPA，想用一个 Webpack 配置打包时。\n\n- 示例 entry: {\n   pageA: './src/page-a.js',\n   pageB: './src/page-b.js',\n   },\n\n- **缺点：** 无法动态加载，且公共依赖代码（如 React 库）会被重复打包到每个入口的 Bundle 中\n\n当构建工具遇到 `import('./moduleA')` 时，它会将 `moduleA` 及其所有依赖单独打包成一个或多个 **Chunk（代码块）**，并在运行时异步加载。\n\nTree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n\n2.动态导入 (Dynamic Imports / 运行时加载)\n\n这是最常用、最灵活的代码分割方案，基于 ES Module 的 `import()` 语法，在运行时根据需要加载代码。\n\n- **实现方式：** 在代码中使用 `import('./path/to/module')`。\n\n- **适用场景：**\n  \n  - **路由懒加载：** 将每个路由页面打包成独立的 Chunk。\n  \n  - **组件懒加载：** 将不常用或在视口外的组件进行懒加载。\n  \n  - **条件加载：** 例如，用户点击某个按钮或满足某个条件时才加载特定的库。\n\n- **优点：** 实现了真正的**按需加载 (On-demand)**，大幅减少初始加载体积。\n\n- **缺点：** 必须处理加载状态（如使用 Suspense 或 Loading 占位符）。\n\n3.提取公共模块 (Vendor/Commons)\n\n目的是将多个模块（入口或动态导入）共享的依赖（如 React, Lodash, jQuery 等第三方库）提取出来，形成一个独立的公共 Chunk，以利用客户端的**缓存机制**。\n\n- **实现方式：** 使用 Webpack 的 `optimization.splitChunks` 配置。\n\n- **适用场景：** 任何包含大量第三方依赖或有多个入口点的应用。\n\n- **配置策略 (`optimization.splitChunks`)：**\n  \n  - **`vendors` (第三方库)：** 将所有来自 `node_modules` 的模块打包在一起。\n  \n  - **`default` (公共模块)：** 将应用内被多个模块（通常是两个以上）引用的代码提取出来。\n\n- **优点：** 充分利用浏览器缓存，核心库代码（如 React）稳定后，用户无需重复下载。\n\n- 示例 \n\n```js\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 对所有类型的 Chunk 生效\n      cacheGroups: {\n        // 自动提取 node_modules 中的库\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          priority: -10,\n        },\n        // 提取被多次使用的公共模块\n        default: {\n          minChunks: 2, \n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  },\n};\n```",
          "hasAnswer": true
        },
        {
          "id": "engineering-12",
          "title": "Babel编译原理和插件开发",
          "content": "Babel 的编译过程严格遵循计算机科学中的编译器原理，可以划分为三个核心阶段：**解析 (Parse)**、**转换 (Transform)** 和 **生成 (Generate)**。\n\n阶段一：解析：此阶段的目标是将原始源代码转换为抽象语法树 (AST)。\n\n1. **词法分析 (Lexical Analysis/Tokenizing):**\n   \n   - 将输入的代码字符串分解成一个个独立的、最小的语法单元，称为 **Token**（标记）。\n   \n   - 例如：`const a = 1;` 会被分解为 `const`, `a`, `=`, `1`, `;` 等 Token。\n\n2. **语法分析 (Syntactic Analysis/Parsing):**\n   \n   - 将 Token 流组合成一个树状的结构，即 **AST (Abstract Syntax Tree)**。\n   \n   - AST 中的每个节点都代表了代码中的一个结构，如变量声明 (`VariableDeclaration`)、标识符 (`Identifier`)、函数调用 (`CallExpression`) 等。\n   \n   - Babel 默认使用 **`@babel/parser`** (以前叫 Babylon) 来进行解析。\n\n获得的AST是个很大超大的JSON，好在Webpack 或 Babel 是**逐个文件**读取和处理的。并且AST不存储时，是临时的数据\n\n阶段二：转换 (Transformation)\n\n这是 Babel 工作的核心，**插件**主要在这个阶段发挥作用。\n\n1. **遍历 (Traversing):**\n   \n   - Babel 会深度优先遍历整个 AST。\n\n2. **插件执行:**\n   \n   - 当遍历器遇到特定的节点类型时，它会调用注册了该节点类型的 **Babel 插件**。\n   \n   - 插件通过操作 AST 节点（增、删、改、替换），将高版本语法转换为目标环境支持的语法。\n   \n   - 例如，将 ES6 的箭头函数 (`ArrowFunctionExpression`) 节点转换成 ES5 的普通函数表达式 (`FunctionExpression`) 节点。\n\n3. **Babel 默认使用 **`@babel/traverse`** 来进行 AST 遍历和节点操作。\n\n阶段三：生成 (Generating)\n\n此阶段的目标是将转换后的 AST 重新渲染为目标代码字符串。\n\n1. **递归生成:** Babel 递归地遍历修改后的 AST，将每个节点打印成对应的代码字符串。\n\n2. **Source Map:** 同时，还会生成 **Source Map**，用于将转译后的代码映射回原始源代码，以便于调试。\n\n3. **Babel 默认使用 **`@babel/generator`** 来进行代码生成。",
          "hasAnswer": true
        },
        {
          "id": "engineering-13",
          "title": "Tree shaking原理和条件",
          "content": "Tree Shaking 的原理可以概括为两步：**标记（Marking）和清除（Sweeping）**。\n\n1. 标记：基于 ES Module 的静态分析\n\n- **静态结构：** ESM 的 `import` 和 `export` 语句在代码执行前就已经确定了模块之间的依赖关系和导出的名称。这意味着，构建工具可以在**编译阶段（编译时）**，而不是运行阶段，确定哪些代码被使用了，哪些没有。\n\n- **依赖图构建：** 构建工具会从入口文件开始，构建一个完整的模块依赖图（Module Dependency Graph）。\n\n- **使用标记：** 在遍历依赖图的过程中，构建工具会标记出**实际被导入和使用的**模块、函数或变量。没有被任何地方导入或引用的代码则会被标记为“未使用”。\n\n2. 清除：移除未标记的代码\n- 在标记阶段完成后，优化器（通常是 UglifyJS 或 Terser）会执行清除操作。\n\n- 它会遍历所有模块，**物理性地移除**那些被标记为“未使用”（即 Dead Code）的代码块。\n\nwebpack  Tree Shaking 的生效条件\n\n 1. 必须使用 ES Module 语法\n\n- **导出：** 必须使用 `export` 或 `export default`。\n\n- **导入：** 必须使用 `import` 语句。\n\n- ESM 的 `import()` 动态导入不会阻止 Tree Shaking，反而会成为 Tree Shaking 的起点，实现更精细的按需加载。\n\n- 在这个动态导入的场景中，Tree Shaking 确保了即使是懒加载的代码块，也只包含真正用到的逻辑，实现了体积的最小化。\n\n2. 保证代码是“无副作用的” (Side-Effect Free)：Tree Shaking 的机制是安全的移除**没有副作用**的代码。\n\n- **定义：** “副作用”是指执行该模块时，除了导出值之外，还会修改全局状态或执行其他操作（例如：修改 DOM、调用 API、修改原型链）。\n\n- **标记：** 如果一个模块被标记为有副作用，即使它的导出没有被使用，构建工具也可能出于安全考虑保留整个模块。\n\n- **实践：`package.json` 的 `\"sideEffects\": false`** 为了告诉构建工具一个库（或文件）是完全无副作用的，可以在项目的 `package.json` 中添加\n\n3. 配置生产模式优化，通过设置 `mode: 'production'` 启用，因为它默认包含了像 Terser 这样的代码压缩工具，而压缩工具是执行最终清除（Sweeping）步骤的关键。\n\n4. 转换工具的配置。如果使用了 Babel 等工具进行代码转换，必须配置它**不将 ES Module 转换成 CommonJS 模块**。\n\n- 例如，在 Babel 配置中，需要确保 `@babel/preset-env` 中**没有**设置 `modules: 'commonjs'`，或者明确设置为 `modules: false`",
          "hasAnswer": true
        },
        {
          "id": "engineering-14",
          "title": "介绍一下vite",
          "content": "**Vite 是一个基于原生 ES Modules 的前端构建工具，核心目标是提升开发阶段的启动速度和热更新性能。**\n\n它在开发阶段不做整体打包，而是利用浏览器的模块加载能力，按需加载源码，从而实现极快的冷启动和热更新。Vite 在开发阶段：\n- **不做整体打包**\n- 每个文件作为一个模块\n- 浏览器请求哪个模块，Vite 就按需返回哪个\n同时通过 esbuild 对第三方依赖做预构建，减少请求数量。 **第一次启动时**用 esbuild 把第三方依赖：\n- 转成 ESM    \n- 合并成少量文件\n- 缓存在 `.vite` 目录\nHMR：热更新基于模块级别，当修改一个文件时：\n- 只更新这个模块\n- 不重新打包整个依赖图\n\n生产环境下，Vite 仍然使用 Rollup 进行打包，保证产物质量。Rollup的优点：\n- Tree-shaking 成熟\n- 产物质量高\n- 社区生态稳定\n\nvite 的优缺点（必须会）\n ✅ 优点\n- 冷启动极快\n- HMR 速度快\n- 配置简单，心智负担小\n- 贴近浏览器原生能力\n ⚠️ 局限\n- 依赖浏览器 ESM（IE 不支持）\n- 对某些非标准包需要额外配置\n- 对老项目迁移有成本",
          "hasAnswer": true
        },
        {
          "id": "engineering-15",
          "title": "Vite HMR 边界是怎么找的？",
          "content": "Vite 的 HMR 边界是沿着 ESM 的 import 依赖链向上查找，直到遇到显式接受更新的模块为止。\n 一、什么叫 HMR 边界？\n **HMR 边界 = 能安全“吞掉”更新、不需要整页刷新的模块** 。也就是：不需要把影响继续往父模块传播 的边界\n 二、Vite 为什么能精确找 HMR 边界？\n 核心前提：ESM 是静态的\n - import 关系是**编译期确定的**\n- Vite 能维护一张模块依赖图（Module Graph）\n注意：Vite 不是每次 HMR 重新构建依赖图，而是增量维护。\n三、Vite 查找 HMR 边界的完整过程\n假设改了 `Foo.vue`\nStep 1：定位变更模块，Vite 先重新 transform 这个模块。\nStep 2：向上查找 importer\nStep 3：判断是否能 accept 更新：对每一层父模块，Vite 会检查是否是HMR的边界\nStep 4：如果一路向上，找不到边界 ，直到到达入口（如 `main.ts`）, Vite 会触发全量刷新\n\n追问：\n1️⃣ 那 CSS 为什么几乎总是热更新成功？\nCSS 天然是副作用模块，不影响 JS 执行状态，Vite 会直接替换 style 内容，本身就是 HMR 边界。\n2️⃣ 为什么有时改一个文件会整页刷新？\n 因为这次修改影响的模块链路上没有任何模块接受更新，Vite 找不到 HMR 边界，只能 fallback 到 full reload。\n3️⃣ HMR 边界是插件决定的吗？\n **部分是**。   框架插件（如 Vue / React）会自动注入 HMR accept 逻辑，从而人为制造 HMR 边界。Vue / React 插件会在 transform 阶段自动为组件注入 accept 逻辑\n4️⃣ 什么叫显式接受 HMR，具体如何判断？\n显式接受 HMR 指的是开发者针对模块通过 `import.meta.hot.accept` 明确声明自己可以安全处理热更新。  \n5️⃣ 插件是如何添加accept的？\n插件只敢给 **“幂等、可替换、无全局副作用”** 的模块加 HMR 边界。\n插件不是“判断模块安全”，而是“识别已知安全模式的模块”，只对这些模式注入 HMR accept。在 transform 阶段，通过 AST 分析识别符合框架约定的模块，比如 Vue 组件或 React 组件，这些模块的生命周期和重建行为是框架可控的。\n插件判断一个模块能否成为 HMR 边界，依据的是：\n1. **文件类型**（`.vue  .jsx`）因为 组件可销毁，可重新挂载，状态由框架管理，生命周期可控\n2. **导出结构**（导出一个组件对象）\n3. **框架约定**（组件生命周期可控）\n4. **白名单策略**（只对已知安全模式生效）\n6️⃣ 为什么 store / router 往往会触发全量刷新？\n因为 store / router 通常是“全局单例 + 强副作用模块”，插件不敢也不能自动给它们加 HMR 边界。",
          "hasAnswer": true
        },
        {
          "id": "engineering-16",
          "title": "webpack vite区别",
          "content": "1. 构建原理\n\t- Webpack：构建期打包，bundle-first\n\t- Vite：开发阶段基于原生 ESM，production 基于Rollup打包\n2. 热更新：文件发生变化时：\n\t- Webpack 重新 **构建依赖图** ， 生成新的 chunk， 通过 HMR Runtime 把更新后的模块推送到浏览器，浏览器端执行 `module.hot.accept`，替换模块。webpack 必须重新分析模块依赖关系，重新生成 chunk。所以项目越大，**依赖图越复杂，重建成本越高**，即使只改一个文件，也可能触发大范围构建。\n\t- Vite 开发环境下，每个文件就是一个原生 ESM 模块， Vite 只重新处理这个文件， 找到该模块的 HMR 边界，通过 WebSocket 通知浏览器， 浏览器直接替换这个模块。更新粒度是**单文件 / 单模块**，不需要重新构建整个依赖图，所以HMR 成本与项目规模几乎无关\n3. 生产打包：\n\t- webpack:  插件 + loader 可高度定制，适合复杂工程（微前端、多入口、老模块）。输出结果容易偏“工程化”，不够干净\n\t\t构建完整依赖图\n\t\tloader 转换源码\n\t\tplugin 参与优化\n\t\t拆 chunk（SplitChunks）\n\t\t压缩、混淆\n\t\t输出最终 bundle\n\t - vite: 生产环境用Rollup，Tree Shaking 更彻底，Bundle 体积更小，输出代码结构更清晰\n\t    基于 AST 静态分析 ESM\n\t    精准 Tree Shaking\n\t    更干净的 chunk 划分  \n\t\tVite 插件会转成 Rollup 插件执行\n4. 配置与心智负担\n\t- Webpack 配置项多，学习成本高\n\t- Vite 配置偏约定式，上手成本低\n5. 生态\n\t- Webpack 插件和 loader 生态成熟\n\t- Vite 插件生态增长快，但在复杂工程上仍不如 Webpack\n总结来说：\n\tWebpack 胜在**可控性和复杂场景**  \n\tVite 胜在**开发体验和现代工程**",
          "hasAnswer": true
        },
        {
          "id": "engineering-17",
          "title": "为什么 Webpack 很难做到像 Vite 那样精细的 HMR？",
          "content": "因为 Webpack 的 HMR 是建立在 bundle / chunk 体系之上的，而不是建立在原生 ESM 模块体系之上。模块替换、依赖传播和边界判断都需要运行时协调，粒度难以做到很细。\nWebpack 模块最终会被**打包进 chunk**，运行时加载的是 bundle，HMR 更新的是 **chunk 中的模块**。Webpack的模块并不是浏览器原生模块，而是运行在 Webpack runtime 中的函数。\n而 Vite 基于原生 ESM，每个文件就是独立模块，HMR 只需要替换单个模块并沿 import 链传播，因此更精细也更稳定。",
          "hasAnswer": true
        },
        {
          "id": "engineering-18",
          "title": "讲讲Rollup 的原理 特点 适用场景",
          "content": "Rollup 是一款专注于 **ESM (ES Modules)** 的深度打包工具。\n**原理**\n- 基于 **ESM 的静态结构**\n- 在构建阶段通过 AST 分析模块依赖\n- 标记未使用的导出，实现 Tree Shaking\n- 最终生成更干净、可读性更高的 bundle\n**特点：** \n- **构建产物纯净：** 几乎没有冗余代码，体积最小化。\n- **插件机制：** 采用双钩子机制，非常灵活。\n- **天然支持 ESM：** 输出格式支持 ESM、CommonJS 和 UMD。\n**适用场景：** Rollup 是**类库（Library）和组件库**打包的首选（如 React/Vue 源码都用它）。但它对 HMR（热更新）和图片等静态资源处理较弱，通常不建议用于大型业务应用开发。",
          "hasAnswer": true
        },
        {
          "id": "engineering-19",
          "title": "讲讲Parcel",
          "content": "提供一个**极速、开箱即用**的现代前端开发体验，让开发者可以专注于代码本身，而不是复杂的构建配置, 设计初衷是简化工程化复杂度。对于大多数常见的项目类型（如 JavaScript、CSS、HTML、图片等），它不需要任何配置文件 (`parcel.config.js` 或 `webpack.config.js`) 就能直接工作。\n\n 核心特点\n- 几乎不需要配置：零配置**支持基于 ES 模块的**动态导入 (`import()`)，并自动将应用分割成更小的块，实现按需加载。\n- 资源支持：Parcel 天生支持各种文件类型，内置对 TS、JS、CSS、图片等的处理\n- 支持开箱即用的 HMR：Parcel 默认启用快速的热模块替换，可以保留应用状态并即时更新模块，提高开发效率。\n- 极速打包：**Parcel 利用 **多核处理 (Worker 进程)** 来并行编译资源，并使用文件系统缓存。这使得它的初始构建和二次构建速度都非常快。\n\n**总结：** Parcel 上手成本极低，是一个适合快速启动、中小型项目，以及追求简单配置和极致开发速度的开发者的优秀选择。",
          "hasAnswer": true
        },
        {
          "id": "engineering-20",
          "title": "前端自动化测试策略",
          "content": "前端自动化测试常见的三个维度：\n\n1. **单元测试 (Unit Testing)：** 成本最低、速度最快。主要针对工具函数、纯逻辑 Hooks 或公共组件。常用工具：**Jest, Vitest**。\n2. **集成测试 (Integration Testing)：** 关注多个组件或模块协同工作的逻辑，模拟用户交互行为（如点击按钮后列表是否刷新）。常用工具：**React Testing Library, Vue Test Utils**。\n3. **端到端测试 (E2E Testing)：** 成本最高，但信心最强。模拟真实用户在浏览器环境的操作流程（如登录流程、下单流程）。常用工具：**Playwright, Cypress**。\n\n 业务项目中，优先覆盖核心逻辑的**集成测试**，对底层库强制要求**单测覆盖率**，对主业务路径配置关键的 **E2E 冒烟测试**。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "cicd",
      "name": "CI&CD",
      "questions": [
        {
          "id": "cicd-1",
          "title": "CI/CD流程",
          "content": "持续集成 (CI)：快速、自动化地验证代码质量。包括\n代码质量检查lint：代码 提交前的lint校验，保证代码质量、风格一致\ngit hook触发流程：开发者提交代码到远程仓库；git Webhook 监听到代码变动触发流水线。\nbuild构建：执行 `npm install` 和 `npm run build`，产出 `dist` 文件。\n\n持续交付 (CD)：确保代码随时可以自动化地部署到生产环境。包括\n发布：将 `dist` 内容推送到服务器或 OSS\n流量切换：多服务器时部署后的合理切换策略，比如蓝绿等\n回滚：必要时能快速回滚到指定版本\n\n**核心意义**：减少人为操作失误（比如忘了跑 build 就上线），确保上线过程可追溯、可回滚。",
          "hasAnswer": true
        },
        {
          "id": "cicd-2",
          "title": "前端工程化的理解，如何自动化，成熟的体系应该具备哪些要素",
          "content": "前端工程化的本质是——让前端开发从“手工活”变成“可规模化、可度量、可迭代的生产体系”，核心目标是：提效、稳定、可控。\n\n自动化质量控制 lint prettier git规范等\n\n自动化构建，自动化发布，保证性能、产物可控、灰度发布、流量分配、自动回滚\n\n监控报警\n\n前端工程化的核心是标准化 + 自动化 + 流程化 + 度量化。  \n成熟体系应该覆盖整个研发生命周期：从代码规范、项目结构、组件库沉淀、构建优化，到测试、CI/CD、灰度发布、监控报警。  \n最终目标是：让开发提效、质量可控、上线可回滚、运行可监控。",
          "hasAnswer": true
        },
        {
          "id": "cicd-3",
          "title": "nginx配置",
          "content": "Nginx 主要用于作为**反向代理**、**静态资源服务器**和**负载均衡器**。\n\n前端常用：配置SPA 、静态资源路径、反向代理解决跨域、缓存配置、Gzip 压缩等\n\n核心配置项：\n\n```\nserver {\n    listen 80;\n    server_name example.com;\n\n    # 1. 静态资源托管\n    location / {\n        root /usr/share/nginx/html;\n        index index.html;\n        try_files $uri $uri/ /index.html; # 关键：解决 Vue/React Router 刷新 404 问题\n    }\n\n    # 2. 反向代理（解决跨域）\n    location /api/ {\n        proxy_pass http://api.backend.com/; # 转发到真实后端\n    }\n\n    # 3. 开启 Gzip 压缩\n    gzip on;\n    gzip_types text/plain application/javascript text/css;\n}\n```",
          "hasAnswer": true
        },
        {
          "id": "cicd-4",
          "title": "cdn配置",
          "content": "将静态资源分发到全球边缘节点，使用户可以从最近的节点获取资源，加速访问\n\n- **前端配合:** 构建工具（Webpack/Vite）需要配置 **`publicPath`** 为 CDN 域名地址。\n\n- **CDN 关键配置:**\n  \n  - **回源策略:** 配置 CDN 节点在缓存未命中时，回源到 Nginx 或 OSS。\n  \n  - **缓存规则:** 区分可缓存（如带 Content Hash 的 JS/CSS）和不可缓存（如 `index.html`）。通常对带 Hash 的资源设置长缓存（如 1 年），对 `index.html` 设置短缓存（如 5 分钟）或不缓存。\n  \n  - **预热/刷新:** 部署后对新的资源文件进行预热，对旧的资源路径进行缓存刷新。",
          "hasAnswer": true
        },
        {
          "id": "cicd-5",
          "title": "oss 是什么？有什么作用和优势",
          "content": "- 高可靠、高并发、低成本的静态文件存储服务（如 AWS S3, 阿里云 OSS）。\n\n- **前端应用:** 通常将前端构建产物直接上传到 OSS 存储桶中，然后通过 CDN 绑定该存储桶的域名进行加速访问。\n\n- **优势:** 免维护服务器、高可用性。\n\n和cdn对比：\nOSS (Object Storage Service - 对象存储)\n- **作用**：像一个海量的硬盘，专门存静态文件（图片、JS、CSS、视频）。\n- **优势**：高可靠（文件不丢）、按量付费（省钱）、不占用服务器磁盘。\n\nCDN (Content Delivery Network - 内容分发网络)\n- **作用**：像连锁店。在全国各地放服务器，缓存 OSS 里的内容。\n- **优势**：**就近访问**。你在北京访问，CDN 就从北京节点给你发货，速度极快。\n\n| **维度** | **OSS**            | **CDN**                 |\n| ------ | ------------------ | ----------------------- |\n| **本质** | **仓库**（存东西的地方）     | **快递**（送东西的地方）          |\n| **位置** | 固定的中心机房            | 分布在全国各地的边缘节点            |\n| **配合** | 前端产物 `dist` 传给 OSS | 域名指向 CDN，CDN 回源 OSS 拿数据 |",
          "hasAnswer": true
        },
        {
          "id": "cicd-6",
          "title": "OSS 怎么配合 CDN 做缓存刷新的主流方案",
          "content": "文件哈希 + 强缓存：这是目前不需要手动频繁刷新 CDN 的最稳妥方案：\n\n- **静态资源 (JS/CSS/Image)**：文件名带上 Hash（如 `main.a1b2c3.js`）。设置 CDN 为**强缓存**（Cache-Control: max-age=31536000）。\n    - _原理_：文件名变了，CDN 没见过这个文件，会自动回源 OSS 拿新的。\n\n- **入口文件 (index.html)**：文件名不变。设置 CDN 为**协商缓存**（Cache-Control: no-cache）。\n    - _原理_：每次访问 index.html，CDN 都会回源头对比一下。如果 index.html 更新了，它就下发新的，从而引导浏览器去加载新的 Hash 资源。",
          "hasAnswer": true
        },
        {
          "id": "cicd-7",
          "title": "npm install后发生了什么",
          "content": "- **检查本地缓存:** 检查 `node_modules` 是否存在，以及 `lock` 文件是否与 `package.json` 匹配。\n\n- **下载依赖:**\n  \n  - **npm/Yarn:** 访问 npm Registry，根据 `lock` 文件中记录的 URL/Hash/Version 下载依赖包，并存入全局缓存。\n  \n  - **pnpm:** 检查本地内容寻址存储中是否已存在该版本的包。如果存在，跳过下载。\n\n- **构建依赖树:**\n  \n  - **npm/Yarn:** 根据下载的包创建**扁平化**的依赖树结构，解决依赖冲突（如果能解决）。\n  \n  - **pnpm:** 根据 `lock` 文件创建**严格的非扁平化**依赖树，使用**硬链接和符号链接**连接到全局存储的包。\n\n- **执行生命周期脚本:** 运行依赖包中定义的 `install`、`postinstall` 等脚本（例如 `node-sass` 或 `Puppeteer` 的编译步骤）。\n\n- **生成/更新 Lock 文件:** 如果 `package.json` 有变化，更新 `package-lock.json` 或 `pnpm-lock.yaml`，确保团队构建环境的一致性。",
          "hasAnswer": true
        },
        {
          "id": "cicd-8",
          "title": "npm 为什么要做依赖提升？会带来什么问题？",
          "content": "- **减少重复依赖**：多个包共用同一版本 → 顶层放一份\n- **缩短 node_modules 路径**：避免嵌套过深（历史上还会触发 Windows 路径长度问题）\n- **更快的 Node 解析/更少磁盘占用**（间接收益）\n\n带来的问题：\n问题 1：幽灵依赖（phantom dependency）\n某个包 **没有声明**依赖 A，但因为 A 被 hoist 到顶层，它居然也能 `require('A')` 成功。  \n一旦安装结构变化（或换包管理器），就炸。\n问题 2：依赖解析不一致 / 隐式耦合\n不同安装顺序、不同 lock、不同平台，hoist 结果可能不完全一致（现代工具好很多，但仍是风险点）。  \n导致“本地没问题，CI/线上有问题”。",
          "hasAnswer": true
        },
        {
          "id": "cicd-9",
          "title": "npm vs yarn vs pnpm",
          "content": "- **npm / Yarn classic（v1）**：传统 node_modules 布局，**会 hoist**，容易出现幽灵依赖。\n    \n- **Yarn Berry（v2+）**：默认 **PnP**（不一定生成 node_modules），依赖解析更严格（但生态兼容要配）。\n    \n- **pnpm**：使用 **全局内容寻址 store**，项目里通过链接组织依赖，默认更严格、磁盘更省，，且安装快速，也能显著减少幽灵依赖。",
          "hasAnswer": true
        },
        {
          "id": "cicd-10",
          "title": "模块化发展历程(AMD/CMD/UMD/ES6)",
          "content": "**CommonJS (CJS)** 同步加载，`require()` 和 `module.exports`。用在node环境\n\n**AMD 异步**加载，适合浏览器，如 RequireJS。**依赖前置**，模块定义时所有依赖就绪并加载（预先加载）。\n\n**CMD**异步加载，推崇就近依赖。模块代码执行到 `require` 时才加载（按需加载）。\n\n**UMD**通用模式，兼容 CJS、AMD 和全局变量，用于库的发布。是**打包规范**，用于让一个模块或库同时兼容多种加载环境。\n\n**ES Module (ESM)** 静态加载、`import` / `export`，支持 Tree Shaking 和 `import()` 动态加载。\n\nAMD CMD UMD 它们都需要引入各自的模块加载器库，因为浏览器不原生支持这些规范。\n\nWebpack（以及其他现代构建工具，如 Rollup, Parcel, Vite）在编译时处理了 CJS 的引用和依赖关系，并消除了对原生 CJS 运行时环境的需求\n\n本题核心：\n模块化最早是 CommonJS，用于 Node.js，采用同步加载，不适合浏览器。\n随着浏览器端需求出现，AMD 和 CMD 提供了异步加载方案，分别采用依赖前置和依赖就近的方式。  \nUMD 本质上是一种兼容写法，用于同时适配多种模块规范。  \nES Module 是语言层面的标准，支持静态依赖分析和 Tree Shaking，是现代前端构建工具和浏览器的基础模块方案。\n\n补充：JavaScript 模块化机制中最核心、最稳定的特性：**模块单例（Module Singleton）**。对于所有现代 JavaScript 模块规范（CJS, AMD, **ESM**），无论是同步导入还是动态导入，一旦一个模块被加载并执行，它的结果就会被**缓存**起来。",
          "hasAnswer": true
        },
        {
          "id": "cicd-11",
          "title": "浏览器对模块脚本的加载和执行，具体什么过程和规则？",
          "content": "模块方式加载是浏览器先解析 import 构建依赖图，再按依赖顺序加载和执行，每个模块有独立作用域且只执行一次，这让代码更安全、可维护，也更适合大型工程。\n\n核心：`<script type=\"module\" src=\"...\">`\n过程：\n- 浏览器在执行前\n- **先构建模块依赖图**\n- 再按依赖顺序加载所有模块\n- 和 `require` 的“运行时加载”不同。\n\n模块脚本的加载特性\n- 默认 **defer 行为**（不阻塞 HTML，DOM 解析完成后执行，多个 module 按依赖顺序执行）\n- 模块作用域（不挂到 `window`，每个模块有独立作用域，避免全局污染）\n- 自动开启严格模式\n- 支持依赖的 **按需加载**\n\n缓存：\n- 每个模块只导入一次，后续 import 直接复用结果",
          "hasAnswer": true
        },
        {
          "id": "cicd-12",
          "title": "前端模块化方案有哪些？在工程中你是如何选择的？",
          "content": "现在业务应用开发基本统一用 ES Module，因为它支持静态分析、tree-shaking 和动态 import，配合构建工具体验最好。\n\n真正需要做选择的通常是做“库”的时候：为了兼容不同消费方，我会在构建产物上同时输出 ESM 和 CJS；如果要支持直接 script 引入，则额外输出 UMD/IIFE。服务端项目则根据 Node 版本和生态选择 CJS 或 ESM。",
          "hasAnswer": true
        },
        {
          "id": "cicd-13",
          "title": "动态 import()",
          "content": "这是前端性能优化重要方式，也就是所谓的**路由懒加载**。\n用法：返回一个 Promise 对象。可以用.then或者async await\n\n- **作用：** 只有当代码真正运行到这一行时，才去服务器下载对应的 JS 模块。\n\n- **原理（Webpack 实现）：**\n    1. **代码分割 (Code Splitting)**：构建工具识别到 `import()`，会将该模块打包成一个独立的子包（Chunk）。\n    2. **JSONP 加载**：运行到该行时，浏览器动态插入一个 `<script>` 标签指向子包地址。\n    3. **异步执行**：脚本加载完成后，Promise 状态变为 `resolved`，执行后续逻辑。\n\n- **优势：**\n    1. **减小首屏体积**：不用一次性下载几 MB 的代码。 \n    2. **按需加载**：用户不点击的功能永远不下载，省流量。",
          "hasAnswer": true
        },
        {
          "id": "cicd-14",
          "title": "前端微服务架构实践",
          "content": "**核心目标:** 将一个庞大的前端应用拆分为多个独立开发、独立部署、独立运行的小应用。\n\n- **Module Federation (推荐):** Webpack 5 联邦模块功能，实现运行时模块共享和依赖去重。\n\n- **Single-SPA/Qiankun (基于框架):** 通过路由劫持和沙箱机制，实现应用级的集成。\n\n- **Web Components/Iframe (隔离):** 通过浏览器原生技术实现 UI 隔离。",
          "hasAnswer": true
        },
        {
          "id": "cicd-15",
          "title": "Monorepo 项目管理",
          "content": "**定义:** 将多个项目（Package）的代码存储在一个 Git 仓库中。最终的构建（Build）和部署（Deploy）仍然是**按需、独立**进行的。\n\n**常用工具:** Lerna, Nx, Turborepo, Yarn/pnpm Workspace。\n\n**优势:**\n  - **代码共享:** 易于在不同项目间共享代码和配置。\n  - **原子提交:** 一个 Commit 可以涉及多个项目，尤其对于公共代码修改，提交历史清晰。\n  - **统一依赖:** 容易实现跨项目依赖一致性。\n  - 本地开发体验更好：不用反复 `npm link` / 发测试包\n\n **挑战:** \n 仓库体积大，工具配置复杂，权限控制难度增加。\n 项目间依赖关系复杂，需要工具辅助管理\n 如果缺乏变更感知机制，构建和 CI 成本会急剧上升\n\n实现：\n- CI：**Monorepo 工具的集成 (Nx/Turborepo):** 这些工具可以智能地判断**哪些项目**受到了代码变动的影响。例如，在 CI 中运行 `npx nx affected:build`，只构建那些代码或其依赖发生变化的子项目。\n- 通常会有一个位于 Monorepo 根目录下的**主 CI 配置文件**，它负责调用 Monorepo 工具，并确定哪个子项目的部署流程需要被触发。\n- **部署脚本：** 具体的部署逻辑（例如如何将文件上传到 S3 或如何调用 K8s 部署 API）通常会封装成每个项目内部的独立脚本，或由主 CI 配置文件通过参数动态调用。",
          "hasAnswer": true
        },
        {
          "id": "cicd-16",
          "title": "包管理和版本控制策略",
          "content": "- **版本锁定:** 强制使用 `package-lock.json` 或 `pnpm-lock.yaml` 锁定依赖版本，确保不同环境下的依赖一致性。\n\n- **包管理:** 使用 **pnpm Workspace**（基于 Monorepo 的包管理）来实现依赖共享和节省空间。\n\n模块的单例行为与 React Hooks 或 Vue Composition API 中的 `composable`（组合式函数）的行为，构成了前端状态管理和逻辑复用的两种截然不同的模式。\n\n模块：共享的应用级状态\n\nHooks / Composable：隔离的组件级状态",
          "hasAnswer": true
        },
        {
          "id": "cicd-17",
          "title": "说说前端代码规范 lint prettier，你怎么看？工作中怎么用？",
          "content": "前端代码规范主要通过 **Lint（如 ESLint）** 和 **格式化工具（如 Prettier）** 来统一代码质量和风格。\n\n- **Lint**：偏向**代码质量和潜在错误检查**，结合框架规范进行逻辑校验，预防潜在性能或 Bug 风险\n- **Prettier**：偏向**代码格式统一**，统一缩进、换行、分号、引号等\n\n作用：\n- 避免低级错误（未使用变量、错误依赖、危险写法）\n- 保证多人协作时代码风格一致\n- 减少 Code Review 在“格式问题”上的时间浪费\n- **让规范“自动化”，而不是靠人记**\n\n实际工程中的使用：\n- **项目初始化**\n    - ESLint + Prettier + 对应框架插件\n    - ESLint 关闭和 Prettier 冲突的规则\n- **开发阶段**\n    - 编辑器保存自动格式化\n    - Lint 实时提示问题\n- **提交阶段**\n    - husky + lint-staged\n    - 提交前只检查本次变更\n- **CI 阶段**\n    - Lint 作为质量门禁，避免不合规代码进主分支\n\n总结：Lint 保证代码质量，Prettier 保证风格统一，规范的核心目标是降低协作成本，而不是限制个人习惯。规范不是越严越好，而是**在可读性、效率和团队接受度之间取平衡**。",
          "hasAnswer": true
        },
        {
          "id": "cicd-18",
          "title": "工作中git 怎么用？pull和pull --rebase的区别",
          "content": "Git 是分布式版本控制工具，用来做 **版本管理、协作和回溯问题**。\n日常高频命令：\n- `clone / add / commit`\n- `branch / checkout / merge`\n- `pull / push`\n- `rebase / reset / cherry-pick`\n\npull和pull --rebase的区别：\n`git pull` 本质是：`git pull = git fetch + git merge`\n- 会生成一次 **merge commit**\n- 历史是**非线性的**\n `git pull --rebase` 是：`git pull --rebase = git fetch + git rebase`\n- 把**本地提交挪到最新远程提交之后**\n- 不产生 merge commit\n- 历史更线性、干净\n实际使用：\n- **个人功能分支**：`pull --rebase`\n- **公共分支（main / develop）**：`merge`\n- **已经 push 的公共提交**：不随意 rebase",
          "hasAnswer": true
        },
        {
          "id": "cicd-19",
          "title": "说说SemVer规则，^ 和 ~ 有什么区别？还有什么其他常用方案？",
          "content": "1. `^`**兼容升级**，**允许升级到“同一 major 版本”的最新 minor/patch** （特殊的`^0.x.y` **很保守**，等同于~）\n2. `~`更保守，只允许 PATCH 升级\n3. 固定版本 `1.2.3`，不会自动升级\n4. `*`（完全放开，**强烈不推荐**）\n5. `>=` / `<=` / `>` / `<`（范围约束）\n6. 预发布版本（alpha / beta / rc），比如`1.2.0-beta.3`\n\t1. npm 在解析依赖时，默认不会自动升级到 `alpha / beta / rc` 版本\n\t2. **显式指定**预发布版本时，即使用^，比如`^1.2.0-beta.3`，npm **允许升级**， 但**只在同一条预发布线内**，也就是会升级到`1.2.0-beta.4` 不会到`1.3.0`",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "open-questions",
      "name": "开放题&场景题",
      "isFolder": true,
      "questions": [
        {
          "id": "open-questions-1",
          "title": "H5主动推送、组件更新通知、自动化发布",
          "content": "#### 如果界面需要实时更新用户信息（比如玩家的得分），你会如何设计前端架构来实现这一功能?\n\n如何选轮询 / SSE / WebSocket，我会按 5 个维度选：\n\t1. 更新频率（秒级 / 100ms / 更高）\n\t2. 数据量（单值/小 JSON/大 payload）\n\t3. 是否双向（只接收 vs 需要频繁发送）\n\t4. 可靠性要求（可丢/不能丢/最终一致即可）\n\t5. 成本与复杂度（后端/网关/运维）\n结合业务问题：\n- 每秒更新多少次？\n- 同时在线多少用户？\n- 允许延迟多少？\n\n2. 轮询（Polling）——“简单、稳，但有浪费”\n\t**适用场景**\n\t- 更新频率低：比如 **10s~60s** 更新一次\n\t- 数据量小：比如积分、状态、小红点\n\t- 并发不大或服务端压力可控\n\t**优点**\n\t- 实现成本最低\n\t- 容错强（网络抖动也能下一次再拉）\n\t- 缓存/网关/监控体系成熟\n\t**缺点**\n\t- 资源浪费（没变化也请求）\n\t- 延迟取决于轮询间隔\n\t**工程实践（加分）**\n\t- **增量轮询**：带上 `since` / `etag`\n\t- **退避策略**：失败后指数退避\n\t- 页面隐藏时暂停：`visibilitychange`\n3. SSE（Server-Sent Events）——“单向推送的性价比”\n\t**适用场景**\n\t- 只需要**服务端 → 客户端**推送，无需双向实时交互\n\t- 更新频率中等：**1s~200ms** 级别\n\t- 消息为文本/JSON，不复杂\n\t- 典型：公告、通知、进度、状态变化、比分更新\n\t**优点**\n\t- 基于 HTTP，穿透代理/负载均衡更友好\n\t- 浏览器原生支持自动重连（EventSource）\n\t**缺点**\n\t- 单向；客户端发消息还是要走 HTTP\n\t- 需要服务端支持\n4. WebSocket ——“高频/交互/多路复用的最终形态”\n\t**适用场景**\n\t- 高频更新：**100ms 甚至 16ms**（实时位置、游戏状态）\n\t- 需要双向：客户端也要实时发送（操作、确认、订阅变更）\n\t- 需要在一条连接上订阅多种业务 topic（积分、排名、事件）\n\t**优点**\n\t- 真正双向、低延迟\n\t- 支持多路复用（topic/channel）\n\t- 更适合高频小消息\n\t**缺点**\n\t- 复杂度高：鉴权、心跳、重连、订阅恢复、消息顺序\n\t- 运维要求高：连接数、网关、限流、消息队列\n\t- “不丢消息”通常要协议层配合（seq/ack/补发）\n\t**工程实践（加分）**\n\t- 心跳 + 指数退避重连\n\t- 订阅协议：subscribe/unsubscribe\n\t- 消息 `seq` + 去重，必要时 `ack` + 补发\n\t- 高频 UI 更新：用 rAF/批处理，避免每条消息都 setState\n\n#### 自动化发布怎么实现\n\n1. 版本号规则（SemVer）：团队需要统一 commit 规范\n\t- 版本号规则：**SemVer（Semantic Versioning）是一套用版本号来表达“变更影响范围”的约定**，标准格式是：  `major.minor.patch`\n\t- 通过 commit 规范自动推断版本（Conventional Commits）：\n\t    - `fix:` → patch\n\t    - `feat:` → minor\n\t    - `BREAKING CHANGE` → major\n2. CI 里自动：简单可以用 npm version patch\n    - 更新 `package.json` 版本号，自动生成 changelog\n    - 生成一个 commit 并生成 git tag（tag 是给某个 commit 打的“版本标记”，便于后续查找版本号、定位、回滚）\n    - push commit + tag，CI 监听 tag → 构建 → 发布\n3. 发布提醒（版本号/变更内容）\n\t- 在 PR / merge 时自动评论：预计 bump 到哪个版本、包含哪些变更\n\t- release 成功后发通知：\n\t    - 企业机器人 + @相关人\n\t    - 包含：版本号、breaking、迁移指引、回滚指令\n4. 发布安全阀\n\t- 灰度：按环境/用户分流（canary）\n\t- 一键回滚：回到上一个 tag / 上一个 CDN 版本\n\n#### 停留页面提示版本更新\n\n1.方案 1：轮询版本文件（最通用）\n- 发布时生成 `/version.json` 或写到 HTML meta：\n    - `{ \"version\": \"1.2.3\", \"buildTime\": ... }`\n- 客户端每隔 N 分钟拉一次：\n    - 发现 version 变化 → toast：**“发现新版本，点击刷新”**\n    - 用户确认后 `location.reload()`\n- 优点：实现简单、跨技术栈 ；缺点：有轮询\n2.Service Worker（更强）\n- 有 SW 的项目：更新检测更标准\n- 新 SW ready 时提示用户刷新\n- 能做到更精细的缓存策略\n3.WebSocket/SSE 推送（实时）\n- 发布成功后推一条 “newVersion” 消息\n- 在线用户秒级感知，无需轮询\n- 只做版本更新有点杀鸡用牛刀了\n\n风险与兜底（面试加分）\n- 如果是**交易/编辑中**页面，不要强刷：\n    - 做“温和提示”，让用户选“稍后”\n    - 关键流程完成后再提示\n#### 组件库升级怎么让使用这个组件的人都知道\n\n1. 技术层面\n\t- TS 的 `/** @deprecated */` 标注：`@deprecated` 是 TypeScript/IDE 识别的“废弃标记”。不一定阻止编译，但IDE会给开发者明显提示。\n\t- **TypeScript 类型变化**：使用方编译就报错（最有效）\n\t- **严格执行版本号规则**：破坏性更新必须更新 major，能避免自动升级带来的问题\n\t- 强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要\n2. 流程层\n\t- 发版自动生成 release notes（含 breaking/迁移步骤）\n\t- 自动推送到群/邮件：\n\t    - @到组件使用最多的 repo/负责人\n3. 文档层\n\t- 组件站点文档展示：\n\t    - 最新版本\n\t    - 变更日志\n\t    - 迁移指南\n\t- 给出 **Before/After** 代码片段\n#### 如果让你设计一个组件库项目的安全设计，应该考虑哪些方面\n\n核心目标：  \n1）让使用方**及时感知**新版本；\n2）通过门禁、灰度、监控确保**安全**；\n3）可快速回滚\n\n1. 发布侧：版本与变更“可机器理解”（系统成败关键）\n\t统一规范：SemVer + Conventional Commits\n\t强制输出“升级所需信息”，每次发布必须产出：Changelog，迁移指南，类型定义（.d.ts）+ 变更摘要\n2. 依赖侧：版本发布后自动推送到群/邮件等方式通知依赖的业务方，必要时可以通过扫描所有业务仓库的 `package.json` + lockfile 来建立“全局依赖图”\n3. 安全设计：从“编译安全”到“线上安全”的多层门禁\n\tA. 编译期门禁（最有效、最便宜）\n\t- TS 类型检查：API 不兼容直接失败\n\t- ESLint/规则：禁用 deprecated API（逐步收敛）\n\tB. 测试门禁（按成本分层），单测/快照\n\tC. 灰度与回滚（线上安全核心）\n\t- **灰度策略**（按 repo 或按用户），先让少量应用升级到新组件库版本，观测一段时间再扩大范围\n\t- **回滚策略**\n\t    - 使用方回滚：回退依赖版本（PR 自动生成 revert）\n\t    - 组件库回滚：回退 tag / CDN 产物（如果是 CDN）\n\tD. 监控与自动熔断\n\t- 关键指标按“组件库版本维度”聚合：\n\t    - JS error rate（含 chunk load error）\n\t    - 性能指标（LCP/INP）\n\t    - 业务埋点（转化、下单成功率等）\n\t- 超阈值触发回滚/告警",
          "hasAnswer": true
        },
        {
          "id": "open-questions-2",
          "title": "SSR-SSG-SPA-MPA",
          "content": "####  CSR-SSR-SSG-ISR\n##### 1️⃣ CSR（Client-Side Rendering，客户端渲染）\n- HTML 基本是空壳\n- JS 下载完成后在浏览器渲染页面\n\n**特点**\n- 首屏慢（白屏时间长）\n- SEO 不友好（需额外方案）\n- 交互流畅（路由切换快）\n\n**适用场景**\n- 后台系统\n- 强交互应用（B 端、管理台）\n- 对 SEO 不敏感的场景\n\n##### 2️⃣ SSR（Server-Side Rendering，服务端渲染）\n- 请求时在服务端拉数据\n- 生成完整 HTML 返回给浏览器\n- 浏览器再进行 **Hydration（水合）**\n\n**优点**\n- 首屏快（HTML 有内容）\n- SEO 友好\n\n**缺点**\n- TTI 较慢（要等 JS 水合）\n- 服务端压力大\n- 实现复杂\n\n**适用场景**\n- 首页 / 落地页\n- 内容型页面\n- 对 SEO 要求高的页面\n\n##### 3️⃣ SSG（Static Site Generation，静态生成）\n- **构建阶段**生成 HTML\n- 部署后直接 CDN 返回静态文件\n\n**优点**\n- 性能最好（几乎没有计算）\n- 成本最低\n- SEO 非常好\n- 稳定性强\n**缺点**\n- 内容更新不灵活\n- 构建时间可能很长\n**适用场景**\n- 博客\n- 文档站\n- 活动页\n- 内容更新不频繁的页面\n\n##### 4️⃣ ISR（Incremental Static Regeneration，增量静态生成）\n- **SSG + 按需重新生成**\n- 页面先用旧静态 HTML\n- 到达一定时间或触发条件后，在后台重新生成\n\n**特点**\n- 不阻塞用户请求\n- 兼顾性能和内容更新\n\n**一句话理解**： **ISR = 静态页面 + 后台悄悄更新**\n\n**适用场景**\n- 商品详情页\n- 新闻列表\n- 内容会变，但不要求实时\n\n#### 对比（面试最清晰）\n\n|模式|HTML 生成时机|首屏性能|SEO|服务器压力|适用场景|\n|---|---|---|---|---|---|\n|CSR|浏览器|❌ 慢|❌ 差|低|后台 / 强交互|\n|SSR|请求时|✅ 快|✅ 好|高|首页 / SEO|\n|SSG|构建时|🚀 极快|🚀 极好|极低|博客 / 文档|\n|ISR|构建 + 后台|🚀 快|🚀 好|低|商品 / 内容站|\n\n#### 总结：\nCSR 是在浏览器端通过 JS 渲染页面，首屏慢但交互灵活；  \nSSR 是在请求时由服务端生成 HTML，首屏和 SEO 更好，但需要水合，服务器压力较大；  \nSSG 在构建阶段生成静态 HTML，性能和稳定性最好，但内容更新不灵活；  \nISR 是在 SSG 基础上支持增量更新，兼顾性能和内容时效性。  \n实际工程中通常根据页面类型混合使用这些方案。\n\n\n#### SPA-MPA\n\nS**PA（Single Page Application）**\n- 整个应用只有一个 HTML\n- 页面切换通过 **前端路由**\n- 数据驱动视图更新，不发生整页刷新\n ✅ 优点\n- 页面切换快，体验接近 App    \n- 前后端分离清晰\n- 复杂交互和状态管理更友好\n⚠️ 缺点\n- 首屏依赖 JS，可能慢\n- SEO 不友好（需 SSR/预渲染）\n\n**MPA（Multi Page Application）**\n- 每个页面都是一个独立 HTML\n- 页面跳转会 **重新加载页面**\n- 服务端负责页面切换\n ✅ 优点\n- SEO 天然友好\n- 首屏快、结构简单\n ⚠️ 缺点\n- 页面跳转慢\n- 状态难共享\n\n适合 SPA\n- 后台管理系统\n- 复杂交互应用\n- Web App（重交互、重状态）\n适合 MPA\n- 官网 / 营销页\n- 内容型网站\n- SEO 要求高的场景\n\n|维度|SPA|MPA|\n|---|---|---|\n|页面结构|单一 HTML|多 HTML|\n|路由方式|前端路由|服务端路由|\n|页面跳转|不刷新|整页刷新|\n|状态管理|前端维护|页面级，刷新即丢|\n|首屏|可能慢|通常快|\n|后续交互|非常流畅|每次跳转慢|\n|SEO|较弱（需 SSR）|天然友好|\n|架构复杂度|高|低|",
          "hasAnswer": true
        },
        {
          "id": "open-questions-3",
          "title": "web worker & service worker",
          "content": "##### Web Workers 的工作原理和使用场景\n\nWeb Workers 是浏览器提供的**多线程解决方案**，允许在后台线程中运行 JavaScript 代码，避免阻塞主线程（UI 线程）。\n\n特点：\n\n- **没有 DOM 访问权限**：Worker 线程无法操作 `window`、`document`、`parent` 对象。\n    \n- **同源限制**：Worker 脚本文件必须与主页面同源。\n    \n- **通信机制**：主线程与 Worker 线程之间通过 `postMessage` 传递数据，通过 `onmessage` 监听。\n    \n- **独立上下文**：它有自己的全局对象 `self`，支持 `navigator`、`location`（只读）、`XMLHttpRequest` 和 `fetch`。\n\n分类：\n\n- 普通Web Worker (Dedicated Worker)： **不能**直接拦截网络请求，需要通过主线程代为请求。   \n    \n- **Shared Worker**：可以被多个窗口、iframe 或标签页共享（前提是同源）。\n    \n- **Service Worker**：拦截和处理网络请求，可以用来实现离线缓存、消息推送、后台同步，充当代理服务器。\n\n主要优势：\n\n- 提高用户体验：耗时计算放在后台，保证主界面流畅。\n    \n- 利用多核 CPU：现代浏览器可以将 Worker 调度到不同的 CPU 核心上并行执行。\n\n##### 解释什么是服务工作线程(Service Worker)，以及它可以如何帮助提高一个游戏网站的性能?\"\n\nservice worker是web worker的一种，Service Worker 脚本在后台运行，与网页的生命周期分离。它最强大的能力是拦截和处理流经它的网络请求，以及持久化存储的能力，这使得缓存控制和离线体验成为可能。\n\n关键能力：\n\n- **离线缓存 (Caching)：** 通过 `Cache Storage API` 控制缓存，实现“网络优先”或“缓存优先”等策略，使用户在离线时也能访问内容。\n    \n- **请求拦截：** 在 Service Worker 的 `fetch` 事件中，可以自定义如何响应网络请求（例如返回缓存、发送请求到网络、或返回自定义响应）。\n    \n- **消息推送 (Push Notification)：** 配合 Push API，在用户未打开页面时，也能接收服务器推送的消息。\n    \n- **后台同步 (Background Sync)：** 允许应用在离线时操作数据，待设备联网后自动进行同步。\n\n使用限制：\n\n- **必须在 HTTPS 环境下使用：** 为了安全考虑，Service Worker 只能在通过 HTTPS 提供的页面上注册和运行（本地开发环境的 `localhost` 除外）。\n    \n- **同源限制：** 只能控制相同源（协议、域名、端口）下的页面。\n    \n- **不能访问 DOM：** 与 Web Worker 一样，不能直接操作 DOM。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-4",
          "title": "与外部协作场景",
          "content": "##### 如果要集成一个船上的摄像监控系统（第三方页面，但它不能改代码，只能iframe嵌进去，而且还要求根据用户权限控制展示内容，你会怎么处理\n\n方案1：通过代理服务器实现内容过滤，iframe嵌套后端路径，有权限时跳转，无权限时返回一个兜底\n\n方案2：利用 **第三方系统自身的 URL 参数** 进行控制，前提是第三方已有支持\n\n方案3：用前端遮罩进行视觉控制，只控制是否展示，内容有泄漏风险\n\n##### 提供给其他协作方的H5要注意什么？\n\n##### 如果要写一个公共库需要考量哪些？比如模块化，打包，版本，暴露的参数方法，文档等等",
          "hasAnswer": true
        },
        {
          "id": "open-questions-5",
          "title": "从零搭建和系统设计",
          "content": "##### 大型电商网站的架构，你会如何设计?考虑哪些问题如何解决\n\n高并发：忙绿兜底 下单锁 防刷\n\nSEO：ssr\n\nSKU复杂：SKU矩阵选择控件 库存变化要实时同步\n\n支付下单：流程复杂、强一致性要求高：必须 表单自动保存  交易失败兜底提示 幂等提交\n\n性能优化；OSS CDN \n\nA/B 测试、埋点\n\n安全\n\n##### 从0搭建一个内部脚手架项目\n\n##### 如果让你从零开始搭建一个大型电商网站的前端架构，你会如何设计?考虑哪些问题如何解决\n\n##### 如果让你从零开始搭建一个大型前端项目\n\n##### 设计一套全站点请求耗时统计工具\n\n##### 如果让你来你现在负责一个项目，有20+个页面，需求方经常改字段、加字段，你每次都要改组件，这个时候你怎么来设计\n\n思路：数据驱动渲染+配置化\n\n配置层：把字段抽象出一套配置文件\n\n业务组件和渲染逻辑层都不需要关心如何配置，而是根据配置自动化地应用\n\n##### 设计一个在线文档协同编辑的方案，需要考虑哪些技术点\n\n##### 设计一套全站点请求耗时统计工具\n\n##### 如何设计一个高可用的B端系统\n\n##### 如果要做一个拖拽式仪表盘Dashboard用户能自己拖拽、组合图表组件展示不同数据源的信息，你会怎么来设计这个系统\n\n我会把这个系统拆成四层：**布局层、组件层、数据层、权限与发布层**，保证既能拖拽搭建，又能稳定扩展。\n 1) 布局层（Layout）\n- Dashboard 的核心产物是一个 **Layout Schema**：  \n    记录每个卡片（Widget）的 `id、位置(x,y)、尺寸(w,h)、层级、响应式断点`。\n- 前端用成熟的栅格拖拽方案（类似 react-grid-layout 这种思想）：拖拽只改 layout，不直接影响数据逻辑。\n- 支持：对齐/吸附、最小尺寸、断点布局（desktop/tablet/mobile）。\n 1) 组件层（Widget/图表物料）\n- 每个图表是一个可注册的 Widget：  \n    `meta(配置面板schema) + render(运行时组件) + dataAdapter(数据适配器)`。\n- 配置面板是 schema-driven：用户选指标、维度、过滤器、样式；平台把它存成 `widgetConfig`。\n1) 数据层（Data Gateway + Query Model）\n- 性能策略：\n- 请求合并：同一数据源相同 query 做 dedupe\n- 缓存：按 query key 缓存 + TTL\n- 并发控制与取消：切过滤器时 cancel 旧请求\n- 大表/高频：优先用聚合接口，必要时异步查询（返回 jobId 轮询）\n 1) 权限与发布\n- 权限到 dashboard / widget / 数据源 / 字段（必要时行级）。\n- 支持“私有/团队共享/公开”，公开也走 token + 限流 + 脱敏策略。\n- 可观测：每个 widget 的 query 耗时、失败率、命中缓存率，方便定位哪个卡片拖慢整页。\n\n这个系统的关键是把复杂度隔离：**布局只是布局、组件只是展示、数据统一走网关、权限和审计在服务端兜底**，这样才能扩展物料和数据源且不失控。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-6",
          "title": "低代码平台",
          "content": "#### 业界主流的实现思路和架构\n\n核心：Schema（DSL） → 编辑器（搭建器） → 运行时引擎（渲染 / 执行） → 扩展机制\n1. Schema / DSL 是什么？不是 JSX，不是模板，而是**纯配置化的 UI / 逻辑描述**。业界 Schema 通常覆盖 5 类：\n\tUI 结构：组件树、布局\n\t组件属性：props、样式、校验\n\t数据源：API、Mock、静态数据\n\t事件：点击、变更、提交\n\t逻辑：条件显隐、联动、流程\n2. 编辑器本质是什么？**一个“操作 Schema 的 UI”**\n\t- 增删改 Schema 节点\n\t- 改节点属性\n\t- 维护组件树结构\n\t常见的实现方式：左中右三栏布局，物料区+画布区+属性区\n\t注意：画布区，编辑时!=运行时\n\t- 组件有「选中态 / hover / 边框」\n\t- 支持拖拽排序（dnd-kit / react-dnd）\n\t- 支持插槽高亮、占位符\n\t业界成熟平台画布区一定是 **双渲染器**。\n\t- 编辑态要**辅助交互**\n\t- 运行态要**极致稳定和性能**\n\n3. 运行时引擎：低码平台的核心，目的：Schema 渲染成组件\n\t- 把 Schema 转成真实 UI（一棵真实的组件树）\n\t- 处理数据流、事件、联动逻辑，要把“页面数据”做成统一的模型\n\t\t- 数据初始化与合并（默认值、URL 参数、预加载数据）\n\t\t- 订阅与派发（哪些组件依赖哪些数据）\n\t- 标准化数据读取路径（`$page.xxx` / `$form.xxx` / `$ds.list.data`）\n\t- 动作系统：动作系统用来描述**用户交互触发的一整套行为流程**，把 schema action 编译/解释成可执行动作：提供动作执行的上下文 ctx（数据、组件引用、路由、权限、埋点）\n\n4. 扩展机制\n\t自定义组件\n\t自定义动作\n\t自定义表单校验\n\n架构：\n1. 编辑器(B端)一个项目，预览/运行时一个项目（最常见、最稳）\n\t- **B 端**：搭建器/编辑器（画布、属性面板、物料管理、权限、发布）\n\t- **运行时**：预览页 + 线上最终页面（同一套 runtime 包）\n\t- 集成方式（iframe / 微前端 / 直挂）\n\t- 优点：编辑器复杂度不会污染运行时；运行时可以做极致性能/体积优化；最利于保证一致性（预览和线上共用 runtime）；**C 端可以换壳**（Next.js / 小程序 / 原生 WebView），但**runtime/渲染引擎/物料协议最好一致**，否则样式/行为一致性很难保证。**\n\t- 缺点：工程上需要共享物料协议、版本管理更严格\n2. 全部一个项目（早期、团队小、迭代快）\n\t- 编辑器和预览都在一个前端项目里\n\t- 运行时作为一个模块被引用\n\t- 优点：开发简单、联调快  \n\t- 缺点：包会越来越大、边界容易糊、后期难维护\n\n#### 怎么保证“预览样式”和“最终生成页面”一致？\n\n核心原则：预览不要走“模拟渲染”，预览必须走“同一套运行时 + 同一份物料 + 同一份主题样式”。\n① 预览和线上共用同一个 Runtime 渲染器（最重要）\n② 物料（组件库）版本锁定：预览用哪个版本，线上就用哪个版本\n③ 主题与样式体系统一：Design Token / CSS 变量化\n\n预览和线上一致性的关键不是“截图对齐”，而是工程上保证它们**同源**：  \n**同一套 runtime、同一套物料版本、同一套主题 token、同一套基础样式和数据请求链路**。  \n只要把版本和环境锁住，一致性就可控。\n\n#### 有哪些性能瓶颈和核心难点\n\n瓶颈 1：Schema 解析 + 组件树构建过于频繁。\n- 节点很多（几百到上千）； props 多、表达式多；布局复杂（表格/表单/动态容器）\n- 如果每次 state 变动都从 root 重新 `render(schema)`，会导致页面频繁的重新渲染\n\n瓶颈2：表达式求值太多：表达式系统主要解决的是**配置里的“动态值”问题**，运行时需要在数据变化时**不断对这些表达式求值**，成熟平台一般会有 **依赖追踪和表达式缓存**\n- 每次 React render 都重新跑 N 个表达式\n- 表达式里还读深层对象、做过滤/排序\n- **解决方向**\n\t- 把表达式变成“计算属性”：依赖没变就不重算（memo）\n\t- 依赖追踪：只在依赖字段变化时更新\n\t- 表达式编译：字符串 → AST → 纯函数（避免重复 parse）\n\n瓶颈 3：数据更新粒度太粗（导致大面积重渲染）\n- 如果数据层是一个大 store，任何字段改动都触发全局订阅，那么：一个输入框 change → 整页组件都 rerender\n- **常用方案**\n\t- 分片 store：按作用域拆（page/form/ds）\n\t- 细粒度订阅：组件只订阅自己依赖的路径\n\t- 类似 mobx 的 derivation，或 proxy track（读取即收集）\n\n瓶颈 4：异步请求与联动风暴\n- 例如：A 字段 change → 触发 3 个请求 → 更新 5 个组件 → 又触发表达式 → 又触发请求…\n- **治理手段**\n\t- request 去重 / 取消（AbortController）\n\t- 防抖节流（输入联动必须）\n\t- “联动图”静态分析：避免循环依赖\n\t- 统一调度队列（batch updates）\n\n#### 为什么同一套 runtime 在 C 端会成为性能瓶颈\n\n线上 C 端确实不会频繁更新 Schema，但低码运行时真正高频变化的是数据层。  \n如果数据更新是粗粒度的，就会导致大量与本次变化无关的组件和表达式被重新计算，这个问题在联动多、表达式多的低码页面里会被成倍放大。\n前面讨论的那些“数据更新粒度粗导致的性能问题”，主要预设的是：  C 端是「复杂、强数据驱动」的页面。\n如果只是典型的活动页（展示为主、交互简单），**大多数情况下确实不会成为核心问题**。\n\n低码 C 端，其实分成两大类\n ① 强数据驱动型（最容易出问题）\n典型特征：\n- 表单多、字段联动多\n- Dashboard / 报表 / BI\n- 多数据源、实时/准实时刷新\n- 复杂条件显示 / 计算\n👉 **前面所有性能讨论，100% 针对这一类。**\n② 展示/活动页型（你说的场景）\n典型特征：\n- 内容以静态展示为主\n- 数据来源少（1–2 个接口）\n- 几乎无复杂联动\n- 交互偏简单（点击跳转、弹窗）\n👉 **这一类页面通常不会被“数据更新粒度”卡死。**\n\n#### 预览页面请求实际数据怎么做鉴权？\n\n配置端：\n**第一步：预览页本身先鉴权**\n- 平台内预览：B端复用公司的 SSO / 登录态（Cookie / OAuth token），预览路由需要登录。\n- 对外分享预览：用**一次性或短期有效的 Preview Token**，链接里带 token 或者扫码授权，且可随时撤销。\n第二步：**权限模型要到“资源级 / 字段级”**\n- 不是“能预览就能查所有数据”，而是按：应用/页面/组件/数据源/字段/行级规则（可选）授权。\n- 对外预览通常只给“只读 + 脱敏 + 限制范围（比如只看最近7天、只看聚合结果）”。\n**第三步：安全细节**\n- Token 短 TTL + 绑定场景（appId/pageId）+ 可撤销\n- 防重放：nonce / jti，必要时绑定 IP/UA（看业务）\n- CORS、CSRF、SameSite、HTTPS 必须到位\n- 全链路日志：谁在什么时候查了什么数据\n#### 业界开源平台或常用方案\n\n阿里 LowCode Engine：目前最“教科书级”的实现\n运行时具体怎么做？\n- Schema → React Element\n- 表达式：字符串表达式 + 运行时解析\n- 动作：事件 → Action Pipeline\n- 强插件化：几乎所有能力都可 Hook\n**优点**\n- 架构清晰\n- 引擎边界非常干净\n**缺点**\n- 表达式 / 动作偏“工程师友好”\n- 对纯业务方不够傻瓜\n\n业界主流低码平台本质都是 **Schema 驱动的运行时引擎**。  \n运行时负责三件核心事情：  \n**根据 Schema 渲染 UI、通过表达式系统做动态计算、通过动作系统执行用户行为。**\n\n成功的平台一般都选择“配置优先，但允许工程师兜底”。\n\n#### 低代码平台如何实现远程组件的动态加载?\n\n低代码平台实现远程加载组件，一般有三个方向：\n\n1. **按需异步加载**：将组件按功能或场景拆分成独立模块，打包成独立的 chunk，通过动态 import 或类似机制在真正使用组件时才加载。这种方式减少了初始包大小，提高加载性能。\n2. **组件独立打包为远程包**：将每个大型组件打包成单独的 npm 包或远程模块，组件之间耦合度低，更新和发布可以独立处理。在运行时，通过动态加载这些包实现按需渲染，保证低代码平台的灵活性和扩展性。\n3. **Webpack 模块联邦**：允许模块在运行时动态加载远程模块或微前端应用，实现模块之间的共享和独立打包。\n\n**总结**：核心思想是 **减少初始加载体积 + 动态按需获取组件**，既能保证性能，也便于扩展和维护。\n\n补充亮点\n- **缓存策略**：远程组件通常会结合浏览器缓存或 CDN，加快再次加载速度。\n- **版本管理**：低代码平台可能需要支持不同版本的组件远程加载，避免依赖冲突。典型做法：\n\t- 每个组件独立发布版本（npm 或私有 registry）\n\t- 通过版本号或 hash 动态加载，支持多版本共存\n- **安全性**：远程加载的组件需要做沙箱隔离，防止组件内部执行影响全局。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-7",
          "title": "前端存储",
          "content": "前端存储 Local storage，session，indexDB，cookie，根据写的倒计时代码，穿插着问的，问的很深",
          "hasAnswer": true
        },
        {
          "id": "open-questions-8",
          "title": "前端调试和单测",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "open-questions-9",
          "title": "前端通信",
          "content": "postmessage\n\nmessagechannel\n\nlocalstorage\n\nurl参数+监听url变化",
          "hasAnswer": true
        },
        {
          "id": "open-questions-10",
          "title": "前端鉴权的几种方式和优缺点",
          "content": "##### Session-Cookie 鉴权（传统主流）\n\n这是最经典的“有状态”鉴权方式。\n\n- **流程**：用户登录成功，服务器创建一个 **Session** 记录并存储在内存/Redis中，同时向浏览器返回一个包含 `SessionID` 的 **Cookie**。后续请求浏览器会自动带上该 Cookie。\n    \n- **优点**：\n    \n    - **安全性高**：敏感数据存在服务端，Cookie 设置 `HttpOnly` 可防 XSS。\n        \n    - **可控性强**：服务端可以随时销毁 Session 强制用户下线。\n        \n- **缺点**：\n    \n    - **扩展性差**：多台服务器时需要做 Session 共享（如同步到 Redis），否则负载均衡会导致登录失效。\n        \n    - **跨端不友好**：原生 App 或小程序对 Cookie 的支持不如浏览器。\n        \n    - **CSRF 风险**：因为依赖 Cookie 自动携带，容易受到 CSRF 攻击。\n\n##### OAuth 2.0 (第三方授权)\n\n这通常用于“第三方登录”（如微信、GitHub 登录）或分布式系统间的权限委派。\n\n- **流程**：\n    1. 用户向授权服务器申请授权。\n    2. 授权服务器返回 **Code (授权码)**。\n    3. 后端用 Code 换取 **Access Token**。\n- **优点**：\n    - **安全性**：用户不需要将密码交给第三方应用。\n    - **细粒度**：可以控制只授权读取头像、不授权发动态等权限。\n- **缺点**：\n    - **逻辑复杂**：需要多次跳转和 Code 换 Token 的过程。\n\n##### SSO (Single Sign-On, 单点登录)\n\n解决“一个公司有多个子系统，登录一次即可访问所有”的需求。\n\n- **实现方式**：\n    \n    - **同父域**：通过设置 Cookie 的 `Domain` 为父域名（如 `.baidu.com`），让子域共享 Cookie。\n        \n    - **跨域**：使用 CAS (Central Authentication Service) 模式。用户重定向到独立的 **认证中心**，登录后携带 Ticket 回跳。\n        \n- **优点**：提升用户体验，统一管理账号。\n    \n- **缺点**：认证中心一旦宕机，所有关联系统全部瘫痪（单点故障）。\n\n#####  JWT (JSON Web Token)？\n\n**J这是“无状态”鉴权的代表，非常适合前后端分离及分布式架构。\n\n- **结构：** 它由三部分组成：`Header`（算法信息）、`Payload`（用户信息，如 user_id）、`Signature`（签名，防止篡改）。\n- **存储：** 前端拿到后，通常不存在 Cookie 里，而是存在 `localStorage` 或 `sessionStorage` 中。\n- **传递：** 发请求时，前端手动把它塞进 HTTP Header 的 `Authorization` 字段里（例如：`Authorization: Bearer <token>`）\n\n##### 为什么 JWT 天然免疫 CSRF？\n\n**原因很简单：CSRF 攻击靠的是浏览器的“自动带 Cookie”机制。**\n\n- **Cookie 机制：** 它是浏览器的**原生行为**。不管你愿意不愿意，只要地址匹配，浏览器就自动帮你贴上 Cookie。黑客就是利用这种“自动”来完成攻击。\n    \n- **JWT 机制：** 它是**手动行为**。存在 `localStorage` 里的 JWT，浏览器绝对不会自动帮你带在 Header 里。必须由你（开发者）写代码 `headers: { 'Authorization': token }` 才能带上去。\n\n当用户点击黑客的 `a.com` 诱导链接时，黑客的脚本无法读取你 `b.com` 域名下的 `localStorage`（受同源策略保护），且浏览器不会自动给跨站请求加上 `Authorization` 头。**既然请求里没有 Token，服务器就会直接拒绝，CSRF 攻击就此失效。**\n\n#### JWT vs Cookie (Session) 深度对比\n\n| **维度**      | **Cookie + Session (传统)**      | **JWT (现代)**                 |\n| ----------- | ------------------------------ | ---------------------------- |\n| **存储位置**    | 服务器存 Session，客户端存 Cookie       | 服务器不存（无状态），客户端存 Token        |\n| **CSRF 防护** | **风险高**，需额外配合 Token 或 SameSite | **天然免疫**，因为不依赖浏览器自动行为        |\n| **水平扩展**    | 较难（多台服务器需要共享 Session）          | **非常容易**（服务器只要有密钥就能解密 Token） |\n| **时效性**     | 可以在服务端随时注销                     | 一旦签发，很难在有效期内提前作废             |\n#### JWT 就绝对安全了吗？（新的挑战）\n\n虽然 JWT 解决了 CSRF，但它引入了新的风险：**XSS 风险。**\n\n- **风险点：** 如果你的页面有 XSS 漏洞，黑客可以运行 JS 代码 `localStorage.getItem('token')`。一旦 Token 被偷走，黑客可以在任何地方冒充你。\n    \n- **对比：** Cookie 如果设置了 `HttpOnly`，JS 是读不到的，所以 Cookie 在防范 XSS 偷取凭证方面比 JWT 强。\n\n#### JWT进阶：双令牌机制 (Access Token + Refresh Token)\n\n**双令牌机制**（Dual Token Mechanism）是为了解决 JWT（JSON Web Token）的一个核心矛盾：**“安全性”与“用户体验”的博弈。**\n\n**双令牌机制的本质**：把“验证频率”和“登录频率”拆分开。\n\n| **令牌名称**                 | **作用**                                   | **有效期**           | **存储位置建议**                       |\n| ------------------------ | ---------------------------------------- | ----------------- | -------------------------------- |\n| **Access Token** (访问令牌)  | 真正的“通行证”，每次请求都携带。安全性高，即使被盗也很快失效。         | **短**（如 15-30 分钟） | 内存 (Vuex/Pinia) 或 SessionStorage |\n| **Refresh Token** (刷新令牌) | 专门用来换取新的 Access Token。只在刷新时才发送一次，暴露频率极低。 | **长**（如 7-14 天）   | LocalStorage 或 HttpOnly Cookie   |\n\n工作流程（无感续期）\n1. **用户登录**：服务端返回两个 Token：`accessToken` 和 `refreshToken`。\n2. **正常访问**：前端将 `accessToken` 放在 Header 里请求数据，后端验证通过。\n3. **令牌过期**：\n    - `accessToken` 过期，后端返回 **401 Unauthorized**（或特定错误码）。\n4. **无感刷新**：\n    - 前端拦截到 401 错误，**不跳转登录页**。\n    - 前端自动发起一个隐藏请求，携带 `refreshToken` 访问“刷新接口”。\n    - 服务端验证 `refreshToken` 有效，颁发一个新的 `accessToken` 给前端。\n5. **重新请求**：前端用新的 `accessToken` 重新发起刚才失败的那个业务请求。用户完全感觉不到中途发生了令牌置换。\n#### 如果 refresh token 也失效了，但你这时挂起了一堆请求，刷新失败了，怎么处理\n\n当 Refresh Token 也失效时，意味着用户必须重新登录。此时核心问题是挂起的一堆请求如何在刷新登录后重试，方案是用一个全局的 **刷新锁** 和一个 **请求队列**。\n\n#### 工程上怎么选登录方案？\n\n- **Session-Cookie**：最成熟，安全性高，但对分布式系统不友好，且存在 CSRF 风险。需要配合 `HttpOnly`、`Secure`、`SameSite=Lax` 以及 `CSRF Token`，全方位防护。\n\n- **JWT**：目前最流行，它是无状态的，易于横向扩展，适合跨端，但要注意 XSS 防护以及 Token 吊销的问题。尤其 **移动端 (App / 小程序)** 首选 **JWT**。因为 App 没有浏览器的 Cookie 限制，JWT 跨域和扩展性极强。\n\n- **OAuth 2.0**：主要用于授权，是实现第三方登录的标准。\n\n- **SSO**：解决多系统间的统一登录问题。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-11",
          "title": "大文件&长列表&大数据&频繁计算等优化场景",
          "content": "##### 大文件上传\n\n##### 长列表渲染\n\n##### 如果你有一个含有数百个项目的数组，你将如何有效地搜索特定项目?\n\n##### 如果现在一个页面要同时展示 300 辆车的实时位置+轨迹，你怎么来优化\n\n数据层面+渲染层面\n\n数据：后续更新只传输增量变化的字段\n\n渲染：分区绘制/懒加载；WebGL/Canvas 渲染；前端聚合（在地图缩放级别较低时，将前端可见的密集点聚合成一个集群图标）；动画优化GPU加速和requestAnimationFrame\n\n**最佳实践组合：** 在后端实现 **视窗过滤** 和 **轨迹简化**，并使用 **WebSocket** 推送增量位置数据。在前端，使用 **WebGL 地图库** (如 Mapbox GL JS) 进行高性能渲染。\n\n\n\n##### js写倒计时组件代码，并优化，长时间怎么解决误差，数据量大怎么办？\n用setTimeout实现setInterva，用requestAnimationFrame实现setTimeout",
          "hasAnswer": true
        },
        {
          "id": "open-questions-12",
          "title": "开放题&场景题",
          "content": "PWA (Progressive Web Apps)了解吗?它的核心技术有哪些。\n\n如何在前端项目中实现国际化和本地化?\n##### 有这样一个场景：如果你从多个系统的 API 拉数据，但这些系统的数据结构不一致，比如 A 系统返回 camelCase、B 系统是 snake_case，还有一些是中文 key，你怎么统一数据结构，来复用\n\n核心思想：在逻辑和外部 API 之间，建立一个专门负责转换的中间层——**适配器 (Adapter)**。每个外部系统都有一个专属的适配器，该适配器只负责：从外部系统获取数据 $\\rightarrow$ 将其转换成规范模型 $\\rightarrow$ 传递给你的应用核心逻辑。\n\n对于 **`camelCase` 和 `snake_case`** 之间的转换，可以使用成熟的库进行自动化处理\n\n对于中文 Key 或需要复杂的**业务值转换**，需要硬编码映射规则，维护一个 JSON 或 YAML **映射文件**",
          "hasAnswer": true
        },
        {
          "id": "open-questions-13",
          "title": "微信登录支付",
          "content": "2025-11-21-22-12-43-image.png\n\n2025-11-21-22-13-18-image.png",
          "hasAnswer": true
        },
        {
          "id": "open-questions-14",
          "title": "微前端",
          "content": "##### 解决：\n多团队共同维护一个大前端项目时，不同团队之前各自维护不同的模块，互相之间又有少量依赖的场景，如何保证项目的长期维护和迭代\n\n##### 技术难点：\n样式隔离，JavaScript 隔离，路由管理和应用切换，公共依赖的打包和互相引用、应用之间事件和数据传输。包括两个角色，主应用和子应用\n\n1. 样式隔离：CSS Modules+CSS-in-JS\n\n2. js隔离：所有微应用共享全局环境（`window` 对象），如果微应用 A 在全局对象上挂载了变量，微应用 B 可能会意外使用或覆盖它。主流方案是：利用 ES6 的 `Proxy` 对象劫持对 `window` 对象的访问。微应用对 `window` 的读写操作都被 `Proxy` 拦截，读操作从全局 `window` 读取，写操作写入到**当前微应用自己的代理对象**中，从而隔离了对真实全局 `window` 的污染\n\n3. 路由管理和应用切换：路由切换时，主应用能正确加载/卸载对应的微应用，并保持 URL 同步。监听 `hashchange` 或 `popstate` 事件，匹配路由，加载/卸载模块\n\n4. 公共依赖：避免每个微应用都打包相同的库。方案两个方向，1是子应用不处理外部模块的打包，主应用负责加载公共包，2是webpack5的联邦模块，允许应用 A **暴露**其内部的模块（如 React 库）给应用 B **消费**，实现真正的运行时共享\n\n5. 事件和数据传输：发布订阅模式/基于全局状态管理\n\n##### 业界常见实现方案：\n\n1. Qiankun：上手难度低，做了css  js隔离，有完整的生命周期钩子，支持多种技术栈。核心是沙箱机制和生命周期管理\n\n2. single-spa：核心作用是作为一个应用路由器（Application Router）和生命周期管理器\n\n3. 联邦模块 (Webpack 5)，只用来处理公共依赖包的情况\n\n**最佳实践**通常是：**使用 Qiankun 或 Single-SPA 来管理应用的隔离和生命周期，同时使用 Webpack 联邦模块来优化公共依赖和公共组件的加载性能。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-15",
          "title": "性能优化",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "open-questions-16",
          "title": "性能监控&错误监控和上报",
          "content": "#### 前端监控系统如何设计?如何上报和分析数据?\n\n一个完整的前端监控系统通常分为三个维度：\n\n- **错误监控：** JS 运行时错误、Promise 未捕获异常、资源加载失败、HTTP 请求错误。\n    \n- **性能监控：** 核心 Web 指标（LCP, FID, CLS）以及传统指标（FP, FCP, TTI）。\n    \n- **行为监控：** 用户路径跟踪\n\n**上报方式：**\n\n- **`navigator.sendBeacon(url, data)`：** **业界首选**。它能在浏览器卸载页面（如关闭标签页）时异步发送数据，不阻塞主线程，不影响下一页面的加载。\n- 普通HTTP请求\n- **Image 对象 (GIF 上报)：** 传统的 `(new Image()).src = 'url?data=...'`。优点是跨域兼容性极好，且请求体积小。\n\n#### 项目报错如何定位\n\n**定位：** 在生产环境，代码是压缩混淆过的（如 `app.js:1:15234`），无法直接阅读。我们需要将报错的堆栈信息（Line, Column）配合 **SourceMap** 文件还原回原始源码。\n\n**Sourcemap 是源码和编译后代码的映射文件**，让浏览器能将压缩混淆后的代码映射回原始源代码。在复杂的现代前端项目中，代码经过构建工具（如 Webpack、Vite）的打包、压缩、混淆，生产环境在监控工具或浏览器控制台中，错误堆栈显示的是 **压缩后的文件名、行号和列号**（例如 `main.js:123:45`）。当浏览器或监控工具遇到一个指向 `main.js:123:45` 的错误时，根据sourcemap 查找对应的 `main.js.map` 文件。这个 `.map` 文件存储了原始代码和压缩代码之间的**映射关系**（即 `main.js` 的第 123 行第 45 列对应于 `src/components/UserForm.vue` 的第 50 行第 10 列）。map文件建议不部署到生产服务器。而是将 `.map` 文件上传到错z误监控平台（如 Sentry）。\n\n#### 除了sourcemap还有什么方法？\n\n**用户行为回溯 (Replay/Breadcrumbs)：** Sentry 等工具会记录用户报错前的点击路径、路由跳转、Console 日志。即使不知道报错的具体代码行，通过看用户的操作轨迹，也能大概猜出是在哪个业务逻辑出错的。\n#### sourcemap带来的安全性怎么办？\n\n**SourceMap 安全问题：** 如果把 `.map` 文件直接发到线上，任何人都可以在控制台看到你的源码。 **解决方案：**\n\n1. **私有化部署：** 将 `.map` 文件上传到内部的监控平台（如 Sentry），不放在 CDN 静态资源服务器上。\n    \n2. **黑白名单限制：** 只有公司内网 IP 才能访问 `.map` 文件。\n    \n3. **构建后删除：** Webpack 编译完成后，脚本自动将 `.map` 移动到安全的地方，并从 dist 目录中删除。\n\n##### 怎么衡量一个页面的渲染速度和性能？你对首屏时间，可交互时间等概念的理解和看法？\n\n- **首次内容渲染 (First Contentful Paint, FCP)：** 浏览器第一次渲染出任何文本、图像或画布的时间。这是用户感知“页面动了”的关键点。\n- **FP (First Paint):** 像素级首次渲染。\n- **LCP (Largest Contentful Paint):** 最大内容绘制。衡量**加载速度**。常用标准：<$2.5s$。\n- **CLS (Cumulative Layout Shift):** 累积布局偏移。衡量**视觉稳定性**（页面跳来跳去吗）。常用标准：<$0.1$。\n- **可交互时间 (Time to Interactive, TTI)：** 页面内容已渲染，且主线程空闲，能响应用户输入的时间。\n- **INP (Interaction to Next Paint):** 交互到下次绘制。衡量**交互延迟**（取代了旧的 FID）。标准：<$200ms$。\n\n**看法：** 我认为 **LCP (Largest Contentful Paint)** 现在比 FCP 更重要，因为它衡量的是页面“主体内容”什么时候出来。\n\n#### 错误监控和报警业界方案\n\n- **sentry**：Sentry 是目前前端监控领域事实上的“行业标准”。有开箱可用的SDK，会记录用户报错前的点击路径、路由跳转、Console 日志；会自动收集浏览器版本、操作系统等上下文信息；支持**数据清洗与聚合**，将成相同的报错聚合起来避免告警风暴；\n- **阿里云 ARMS / 腾讯云 RUM：** 云服务商提供的成熟商业方案，开箱即用。\n- **app 消息报警：** 通常对接 **企微/钉钉/飞书 Webhook**，设置阈值告警（如：某接口报错率 > 5% 立即触发报警）。",
          "hasAnswer": true
        },
        {
          "id": "open-questions-17",
          "title": "海报绘制",
          "content": "##### 1. 客户端方案（最常用）\n\n这类方案直接在用户的浏览器中运行，优点是响应快、不消耗服务器资源。\n\n- **HTML5 Canvas 绘图 (原生)**\n    \n    - **原理：** 使用 `canvas.drawImage()` 将图片、文字手动绘制到画布上，再通过 `canvas.toDataURL()` 生成 Base64 图片。\n    - **缺点：** 手动计算位置非常痛苦，不适合复杂的 DOM 结构。\n\n```\nconst generatePoster = async () => {\n  // 1. 创建canvas\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n\n  // 2. 设置画布尺寸\n  canvas.width = 600;\n  canvas.height = 800;\n\n  try {\n    // 3. 输出图片\n    const dataURL = canvas.toDataURL('image/png');\n    console.log('生成的海报Base64:', dataURL);\n  } catch (err) {\n    console.error('绘制失败', err);\n  }\n};\n```\n\n- **html2canvas (业界主流标准)**\n    \n    - **原理：** 它并不是真正的“截图”，而是通过 **JS 重新渲染**。它会读取 DOM 结构、解析 CSS 样式，然后在 `<canvas>` 上按像素重新画一遍。\n    - **优点：** 使用简单，支持度高。\n    - **缺点：** * **样式兼容性：** 对某些高级 CSS（如 `box-shadow`、某些 `flex` 布局、复杂的 `filter`）支持不完美。\n        - **跨域：** 图片必须支持跨域，否则会报“画布被污染”错误。\n        - **清晰度：** 在高分屏下容易模糊（需要设置 `scale` 参数，配合 `devicePixelRatio` 优化）。\n\n```\nimport html2canvas from 'html2canvas';\n\nconst captureElement = async () => {\n  const element = document.getElementById('poster-area'); // 要截图的 DOM 节点\n  \n  try {\n    const canvas = await html2canvas(element, {\n      useCORS: true,          // 允许跨域图片\n    });\n\n    // 将 canvas 转为图片下载或预览\n    const imageData = canvas.toDataURL('image/png');\n    const link = document.createElement('a');\n    link.href = imageData;\n    link.download = 'screenshot.png';\n    link.click();\n  } catch (error) {\n    console.error('截图失败:', error);\n  }\n};\n```\n\n- **dom-to-image (SVG 方案)**\n    \n    - **原理：** 利用 SVG 的 `<foreignObject>` 特性。它将 DOM 序列化为 XML，放入 SVG 中，再利用浏览器原生的 SVG 渲染引擎。\n    - **优点：** 性能通常优于 html2canvas，生成的图片更接近真实 DOM 效果。\n\n```\nimport domtoimage from 'dom-to-image';\n\nconst captureBySvg = () => {\n  const node = document.getElementById('my-node');\n\n  // 1. 调用插件的方法，把要截图的元素里的内容转成 PNG 格式的字符串 (dataUrl)\n  domtoimage.toPng(node)\n    .then((dataUrl) => {\n      const img = new Image();\n      img.src = dataUrl;\n      document.body.appendChild(img); // 直接展示生成的图片\n    })\n    .catch((error) => {\n      console.error('生成图片出错!', error);\n    });\n};\n```\n### 2. 服务端方案（高还原度）\n\n如果需要 100% 还原页面（包含复杂动画、阴影、外部字体），或者需要批量生成图片，通常采用服务端截图。\n\n- **Puppeteer / Playwright (Headless Browser)**\n    \n    - **原理：** 在 Node.js 服务端运行一个**无头浏览器**（无界面的 Chrome）。\n    - **流程：** 服务端接收请求 -> 浏览器打开指定 URL -> 等待页面加载完成 -> 调用浏览器底层的 `screenshot` API -> 返回图片。\n    - **优点：** **最完美还原**。页面长什么样，截出来就长什么样。\n    - **缺点：** 实现相对复杂，且消耗服务器 CPU/内存资源巨大，并发量大时会有明显的延迟。\n\n### 3. 常见痛点与解决方案\n\n| **痛点**      | **解决方案**                                              |\n| ----------- | ----------------------------------------------------- |\n| **图片模糊**    | 将 Canvas 放大 `window.devicePixelRatio` 倍，再通过 CSS 缩小显示。 |\n| **图片跨域**    | 后端设置 CORS，或者前端配置 `useCORS: true`。                     |\n| **字体丢失**    | 客户端截图通常无法读取系统外的字体，需将字体转为 Base64 嵌入 CSS。               |\n| **滚动内容截不全** | 截图前临时设置 `height: auto` 或克隆一份 DOM 放到屏幕外隐藏位置进行渲染。       |",
          "hasAnswer": true
        },
        {
          "id": "open-questions-18",
          "title": "设计思想",
          "content": "##### 函数式编程？命令式编程？在项目中的应用?\n\n单例模式\n\n工厂模式",
          "hasAnswer": false
        },
        {
          "id": "open-questions-19",
          "title": "跨浏览器 跨终端开发的兼容性处理方案",
          "content": "##### 跨浏览器 跨终端开发的兼容性处理方案\n\n确保同一个网页或Web应用在**不同的浏览器**上和在**不同类型的设备**上都能具有**一致的外观、布局和功能**，提供**良好的用户体验**。\n\n挑战：\n不同浏览器：CSS 渲染差异，JavaScript API 支持度不同\n不同设备：屏幕尺寸与分辨率，输入方式差异，性能与网络条件\n\n主要分两步：  \n 1️⃣ **识别环境**：通过 UA、屏幕尺寸、触控点数等判断设备类型、操作系统和浏览器环境，以便做差异化处理。  \n 2️⃣ **处理兼容性**： \n1) CSS 层面\n- **前缀处理**：使用 autoprefixer 自动加 `-webkit-` 等\n- **现代 CSS 特性降级**：`flex` → `float` fallback\n- **媒体查询**：针对不同屏幕尺寸适配\n 2) JS / API 层面\n- **特性检测**（Feature Detection）：`if ('IntersectionObserver' in window)`\n- **Polyfill**：为不支持的 API 提供替代实现\n- **事件差异处理**：如触屏事件 `touchstart` / `touchmove` vs 鼠标事件 `mousedown` / `mousemove`\n3) **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）\n4) 开发工具链：一些常用的库结合现代化构建工具，自动化进行兼容处理\n```js\n\"@babel/core\": \"^7.20.0\",          // JavaScript 转译\n\"autoprefixer\": \"^10.4.13\",        // CSS 自动前缀\n\"postcss\": \"^8.4.21\",              // CSS 后处理\n\"eslint\": \"^8.30.0\",               // 代码检查\n\"stylelint\": \"^14.16.0\",           // CSS 检查\n```\n\n补充：检测与兼容性查询能力：\n\n```js\nserviceWorker：'serviceWorker' in navigator\nIntersectionObserver：'IntersectionObserver' in window\n响应式图片：<picture> + <source > 等\nwebp：document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0\nCan I Use：caniuse.isSupported(feature, navigator.userAgent)\n```\n\n总体原则和思路：\n\n- **渐进增强**：从基础功能开始，逐步为现代浏览器增强体验\n\n- **优雅降级**：现代功能不可用时，提供可用的降级方案\n\n- **移动优先**：从小屏幕开始设计，逐步适配大屏幕\n\n- **使用标准 API**：优先选择广泛支持的 Web 标准\n\n- **特性检测**：运行时检测浏览器能力，而非浏览器嗅探\n\n- **响应式设计**：使用弹性布局和媒体查询\n\n- **性能考量**：考虑不同设备的性能差异\n\n- **工具自动化**：使用构建工具处理大部分兼容性问题\n\n- **组件库**：使用成熟的 UI 库（如 Ant Design、Material-UI）",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "miniprogram",
      "name": "小程序",
      "questions": [
        {
          "id": "miniprogram-1",
          "title": "小程序登录 支付",
          "content": "小程序登录本质是：\n前端通过 wx.login 获取临时 code，把code发送给后端，后端再通过微信接口换取 openid 和 session_key，并建立自己的业务登录态，通过set-cookie下发token等会话登录态标志。\n- 微信登录 ≠ 业务登录\n- 微信只负责 **身份识别**\n- 业务权限、用户体系仍在自己后端\n\n小程序支付：前端只负责调起支付，所有金额、订单和校验都在后端完成。\n前端向后端发起支付请求\n后端校验订单合法性，然后调用微信「统一下单接口」，得到 **prepay_id**，返回支付参数给前端\n前端通过 wx.requestPayment 调起支付\n用户完成支付后微信异步通知后端，作为支付成功的唯一依据\n支付后 前端应：不直接信任 `success`，再次请求后端",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-2",
          "title": "选框架 uniapp taroapp",
          "content": "总体：需要考虑**技术栈一致性、平台范围、性能边界、团队协作方式**。\n\n1.团队主要技术栈是vue还是react\n2.考量目标平台需求：如果覆盖的平台更广，比如需要发布到 App 端，需要覆盖最多平台，优选 uni-app\n3.考虑业务需求可能的大型复杂交互，比如长列表，结合框架是否有成熟的支持\n3.如果更注重小程序性能 unia-app（taro由于底层基于 React Virtual DOM，相较于原生小程序的渲染可能会有轻微性能损耗，但在绝大多数场景下足够使用。）\n4.生态：**uni-app**：生态集中（插件/组件/工具链/统一 API），交付效率高；**Taro**：更“开放”，更像 Web 工程化；但你可能更需要自己补齐一些工程/规范/组件方案。\n\n更注重H5性能的大型项目 优选taro  由于基于 React 体系，更适合大型项目中的组件化、状态管理和架构规范。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-3",
          "title": "小程序rpx和px在不同手机上有误差",
          "content": "rpx 是小程序里的相对单位，规定屏幕宽度等于 750rpx，不同设备上会根据屏幕宽度换算成不同的 px。\npx 是绝对单位，在不同设备上不自适应；  rpx 是相对单位，理论上 rpx 可以适配不同设备，但在实际渲染时，由于屏幕宽度和 DPR 不同，rpx 换算成 px 时会出现小数，最终需要取整，不同平台的取整和渲染机制也存在差异，因此在不同手机上可能会有细微误差。  误差在小尺寸元素上（尤其是 1rpx 边框）表现最明显，因为取整直接影响了元素的显示或隐藏。\n\n解决：\n避免使用极小的 `rpx` 值。尽量使用偶数的 rpx 值，必要时利用 CSS transform 缩放结合微元素 伪类解决\n尽量用 flex / 自适应布局，减少“精确像素依赖”",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-4",
          "title": "小程序和h5的性能和用户体验差异对比",
          "content": "运行环境差异（最根本）：小程序运行在 **平台容器**（微信 / 支付宝），双线程，沙箱受限，低端机慢；H5 运行在 **浏览器**，浏览器内存大，可用 Worker，所以性能上限高\n\n首次加载：小程序需下载框架和代码包，H5 可按需加载。小程序通过主包限制和分包机制约束体积，H5 则依赖代码分割和浏览器加载能力；\n\n热启动：小程序更快，H5取决于缓存策略\n\n渲染性能：小程序有双线程能避免 JS 阻塞渲染，交互更流畅；H5容易因为 JS 阻塞导致渲染掉帧。\n\n操作DOM：小程序框架底层对DOM 操作有更严格控制，但是频繁地setData也可能会导致性能瓶颈；H5类似的操作DOM可能会导致性能瓶颈，一般要依赖框架的响应式数据更新或者渲染优化。\n\n在页面切换和交互体验上，小程序更稳定，由原生页面栈实现，返回、切换体验稳定状态保留相对自然，但是分包可能轻微延迟；H5 路由切换快，单页应用路由切换 = 组件卸载/挂载，需要通过keep-alive、预加载、状态缓存等方法优化。\n\n生态及api：小程序：依托微信生态丰富，登录、支付等微信能力更流畅，容易接入官方API，用户触达 分享等方面更有微信的优势。H5：浏览器 API功能无限制，技术栈成熟、生态丰富，拉新/留存不如小程序便利",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-5",
          "title": "小程序底层架构详解",
          "content": "小程序采用的是双线程（Dual-Thread）的运行模型，这是其架构的基石。这个模型将页面的逻辑处理和界面渲染分别放在两个独立的运行环境中，通过异步消息通道通信。开发者编写的**逻辑代码**运行在一个根本，是一个没有 DOM 逻辑层和 BOM 的独立环境中。\n\n逻辑层 (JS Thread) 由独立的 JavaScript 引擎 实现 。\n\n渲染层 (View Thread) 基于浏览器的 WebView，负责渲染页面的容器。\n\n（**WebView 是一种宿主环境提供的、内嵌式的浏览器内核功能。它允许应用程序（App）或小程序框架在原生界面中加载和渲染 Web 内容，它包含了浏览器的大部分核心功能，它运行在原生 App 内部，本质上就是一个浏览器内核组件**）\n\n这种分离架构的好处是解决传统 Web 应用的**性能瓶颈**（双线程）和**安全问题**（无法直接操作DOM），同时保证**跨平台能力**（渲染层可以对不同平台做不同的渲染）。\n\n缺点是：增加了一层数据传输，可能带来通信延迟，增加了调试复杂性，增加一定的内存占用；开发者无法使用完整的浏览器 API和一些成熟的web库；频繁调用setData可能会引起性能问题，因为涉及了两个线程之间的**跨线程通信**和**数据处理**",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-6",
          "title": "为什么小程序在复杂业务下更容易保持性能稳定？",
          "content": "小程序在复杂业务下更容易保持性能稳定，核心原因并不只是双线程，而是多重平台约束共同作用的结果。\n\n一方面，小程序采用逻辑线程与渲染线程分离的双线程模型，避免了 JS 执行直接阻塞渲染；另一方面，小程序通过主包大小限制和分包机制，强制将复杂业务拆分到不同页面和分包中，减少单一上下文的复杂度。\n\n同时，小程序以页面为单位管理生命周期和状态，更容易在页面切换时回收资源；而 SPA 运行在单一 JS 上下文中，如果工程拆分和状态管理不当，复杂业务下更容易出现性能退化。\n\n因此，小程序的稳定性更多来自平台约束，而不是单纯的执行效率优势。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-7",
          "title": "小程序没有dom是如何渲染的",
          "content": "小程序没有浏览器 DOM，它采用逻辑层和渲染层分离的双线程架构。逻辑层负责运行 JS 和业务逻辑，渲染层负责根据 WXML 和数据进行视图渲染。开发者通过 setData 更新状态，框架会把数据变更同步到渲染层，由渲染层重新计算并更新 UI。这样的设计可以提升性能稳定性、保证跨平台一致性，但也要求开发者控制 setData 的频率和数据量。\n \n编译阶段：将开发者定义的 WXML/WXSS 转换为渲染指令（类似虚拟DOM的结构对象）和和css\n运行阶段：根据渲染指令（类似VDOM）构建真实DOM，数据发生更新时，先diff然后把增量数据发给渲染层，渲染层精确更新 DOM",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-8",
          "title": "小程序开发中最常见的性能瓶颈是什么？你会怎么定位和优化？",
          "content": "1）逻辑层 ↔ 渲染层通信过多（setData 过频 / 数据量大）\n**现象**\n- 列表滚动卡、交互延迟、页面掉帧\n- 频繁 setData 或一次 setData payload 很大\n**优化**\n- 合并 setData：把多次更新合并成一次\n- 缩小更新范围：只更新必要字段（避免 whole data 替换）\n- 降低频率：节流/批处理（尤其 scroll、drag、实时输入）\n- 列表用 **分页 + 虚拟列表/分片渲染**（长列表核心）\n- 大对象避免频繁深拷贝：尽量扁平化数据结构\n\n2）长列表/复杂节点导致渲染压力大\n**现象**\n- 页面首屏慢、滚动掉帧\n- 节点层级深、wxml 结构复杂\n**定位**\n- 开发者工具看 **渲染耗时、节点数**\n- 观察是否存在“超长列表一次性渲染”\n**优化**\n- 虚拟列表 / 分批渲染（分帧渲染）\n- 减少节点层级、减少不必要的 view 包裹\n- 能用 `hidden` 就别频繁 `wx:if`（避免反复创建销毁）\n- 图片列表：固定尺寸 + 懒加载 + 合理占位\n \n3）图片/资源加载（尤其首屏大图、弱网）\n\n**定位**\n- Network：图片体积、并发、是否命中缓存  \n    **优化**\n- 压缩、裁剪、WebP（看平台支持）\n- 首屏优先：关键图优先，其余懒加载\n- CDN + 缓存策略（本地缓存、版本化 URL）",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-9",
          "title": "说说小程序的性能优化方案",
          "content": "1）小程序最常见的瓶颈\n1. **setData 通信成本**：频率高、数据量大、更新范围大\n2. **渲染压力**：节点数多、层级深、长列表一次性渲染\n3. **首屏慢**：资源大、请求多、逻辑初始化重\n4. **图片与网络**：大图、弱网、并发、缓存不佳\n5. **交互卡顿**：scroll/touch 高频事件 + 频繁 setData\n2）怎么定位（面试要点）\n- 微信开发者工具：**性能面板 / 渲染性能 / Network**  \n    重点看：\n    - setData **次数、单次 payload 大小、耗时**\n    - **渲染耗时、节点数、重排重绘**\n    - 首屏关键请求、图片体积、是否命中缓存\n- **真机测试**（尤其 Android 中低端）：工具数据 + 真实体感一起看\n\n3）**优化**\n1. setData（最关键、最常考）\n\t- 把多次 setData **合并成一次**\n\t- 对高频更新（scroll、drag、input）做 **节流/批处理**\n\t- 避免 `this.setData({ list: newList })` 这种整块替换\n\t- 用路径更新：只改变动字段\n\t    - `this.setData({ ['list[3].checked']: true })`\n\t- 数据结构尽量**扁平化**，减少深层对象整体替换\n2. 渲染优化：\n\t- 长列表：只渲染可视区 + 缓冲区，或首屏先渲染一部分，剩下分帧追加\n\t- 降低节点复杂度，减少 view 套娃，控制层级\n\t- 列表项组件化，但注意组件层级也别过深\n\t- `wx:if` 频繁切换成本高；仅切换显示优先 `hidden`\n\t- 选择合适的滚动容器，避免在 scroll 中频繁触发布局相关逻辑\n3. 首屏优化（用户最敏感）\n\t- 关键接口优先，非关键延后（骨架屏/占位）\n\t- 减少首屏请求数：合并接口、并发控制、缓存\n\t- 图片：压缩/裁剪、固定尺寸、首屏优先加载、其余懒加载\n\t- 静态资源上 CDN，做好缓存版本策略\n4. 交互与动画优化\n\t- 高频事件：节流/防抖，减少 setData\n\t- 动画优先用 **CSS/小程序动画能力**，避免 JS 驱动大量帧更新\n\t- 减少昂贵样式（阴影/滤镜等）在大面积区域使用",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-10",
          "title": "自定义组件和原生组件渲染有什么区别？",
          "content": "**总结：原生组件由客户端原生直接渲染，性能最好但层级受限；自定义组件运行在 WebView 渲染层，灵活但性能和层级不如原生组件。**\n\n小程序中的原生组件由客户端原生直接渲染，不在 WebView 内，性能最好，但存在层级限制，样式和遮罩控制能力有限。\n自定义组件运行在渲染层 WebView 中，参与 WXML 的布局和层级计算，交互和样式更灵活，但性能受 setData 和渲染复杂度影响。实际开发中通常根据性能需求和 UI 复杂度选择合适的组件类型。",
          "hasAnswer": true
        },
        {
          "id": "miniprogram-11",
          "title": "小程序为什么长列表特别容易卡？",
          "content": "核心原因是：节点数量大 + setData 通信和 diff 成本高 + 渲染层重排重绘压力大。核心思路就是减少节点、减少 setData、减少不必要的计算。\n\n1 节点数量爆炸（最直接原因），渲染层需要维护一个**非常大的节点树**\n2 setData 的通信 & diff 成本被放大（核心瓶颈），由于小程序的双线程\n3 如果滚动过程中的频繁更新，触发 setData，会导致JS 线程和渲染线程互相拖慢\n\n和H5对比：\n- H5：\n    - JS 和 DOM 在同一线程\n    - 可以直接操作 DOM\n    - 虚拟列表成熟\n- 小程序：\n    - JS ↔ 渲染层通信，每次更新都有“桥”的成本\n    - 所以 **更怕大数据量**\n\n优化方案：\n1 虚拟列表：只渲染**可视区域 + 缓冲区**\n2 分片 / 分帧渲染：首屏先渲染一部分，剩余用 `setTimeout / requestAnimationFrame` 分批塞\n3 降低 setData 频率：滚动事件节流，- 合并多次更新",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "ai",
      "name": "AI",
      "questions": [
        {
          "id": "ai-1",
          "title": "用过的 AI 大模型，使用方式，用了他们那些功能，觉得 AI 大模型他们存在有什么样的缺点",
          "content": "我主要用过 **通用大模型（Chat 类）+ 编程向模型（Code 类）**，日常是“问题分析 + 代码生成 + 校验优化”结合使用。\n\n**使用方式**\n- 需求理解 / 技术方案拆解（让模型帮我把问题结构化）\n- 写代码骨架 / 示例实现（我负责判断可行性）\n- Debug：解释报错、分析边界 case\n- 文档/注释/测试用例生成\n**常用功能**\n- 多轮对话推理（不是一次性生成）\n- 代码补全 / 重构建议\n- 解释陌生代码或项目结构\n- 对比方案（如性能、可维护性）\n**我看到的主要缺点（重点说这段）**\n1. **幻觉问题**：会“自信地胡说”，尤其是 API、版本差异\n2. **上下文有限**：复杂项目需要我主动裁剪、喂关键信息\n3. **缺乏真实运行反馈**：生成的代码不等于可上线代码\n4. **工程判断不可靠**：架构/边界/取舍仍要人来定\n5. **不会推测交互上下文**：需要依赖程序员的经验",
          "hasAnswer": true
        },
        {
          "id": "ai-2",
          "title": "你对 AI Coding 的理解？",
          "content": "我理解的 AI Coding 不是“替代程序员写代码”，而是**把程序员从低价值的重复劳动中解放出来**。\n\n我把 AI Coding 分成三层能力：\n1. **生成层**：\n    - 写样板代码、CRUD、工具函数\n2. **理解层**：\n    - 拆解需求、解释代码、总结逻辑、帮助我快速上手陌生项目\n3. **协作层（我更看重）**：\n    - 和我一起查问题、分析方案、发现盲点\n但它**不擅长**：\n- 复杂业务建模\n- 架构取舍\n- 非显性需求（性能、稳定性、灰度、回滚）\n- 涉及交互上下文的场景，AI 不会联系上下文和预设用户操作逻辑\n\n所以我把 AI 当成“非常快的初级工程师 + 技术顾问”**，最终决策仍由我负责。",
          "hasAnswer": true
        },
        {
          "id": "ai-3",
          "title": "有没有 最佳实践？",
          "content": "**我总结最佳实践有三点：**\n1. **先给上下文，再让它写**，可以通过配置项目rules来简化流程\n    - 项目背景 / 技术栈 / 约束条件\n    - 不直接丢一句“帮我写代码”\n2. **让 AI 解释它写的代码**\n    - 看它的解释，能快速发现逻辑漏洞或误解\n3. 可以让AI先给出方案，再对他的方案进行选择和优化，再执行\n4. **永远保留人工校验**\n    - 类型检查\n    - 代码review\n    - 单测+自测，尤其关键路径我一定自己过一遍\n\n一句话总结：**AI 负责速度，程序员负责正确性和边界**",
          "hasAnswer": true
        },
        {
          "id": "ai-4",
          "title": "平时的 AI 工作流 是怎样的？",
          "content": "一个典型流程是：\n1. **我先自己分析需求点和方向，捋清楚目标和约束**\n2. 复杂问题先帮我拆步骤 / 给实现思路和方案\n3. **我来判断方案是否合理**\n    - 是否符合现有架构\n    - 是否有性能/安全问题\n4. 再让 AI生成代码，然后review再做针对性调整，优化细节",
          "hasAnswer": true
        },
        {
          "id": "ai-5",
          "title": "用过哪些 AI IDE？差异在哪？",
          "content": "1. Cursor：目前的“全能王者”。**核心功能：**\n\t- **Tab (预测式补全)：** 极其强大的上下文预测，能根据你的逻辑预测下一段代码。\n\t- **产品化程度最高**。它将 AI 深度集成到 UI 层（如下滑提示、浮动按钮），体验远超“编辑器 + 插件”的组合。通过配置cursor rule，结合一系列ai工具快捷键，**Agent 模式**能极大提升效率\n2. **claude code**：运行在终端的“高级机器人”\n\t- **运行在终端，无UI，不限制在项目内，拥有读写文件和执行命令的完整闭环（会请求操作权限）\n\t- **逻辑推理强，处理复杂逻辑能力强\n\t- 自主循环 (Loop)：读代码-分析-修改-验证，自主性比较强\n3. 国内 \n\t1. Trae：**独立的 IDE**，Agent 模式，跨文件的全局重构能力更强，基于Claude GPT 等模型\n\t2. 通义灵码：国内目前生态最成熟、用户量最大的 AI 编程助手，主要以 **IDE 插件**（VS Code, JetBrains）形式存在。对中文 Prompt 的理解非常细腻，单元测试生成、研发文档编写能力好，底层通义千问大模型",
          "hasAnswer": true
        },
        {
          "id": "ai-6",
          "title": "对 Agent / MCP / Tab 补全模型 的理解？",
          "content": "我把它们理解成三种不同抽象层级的 AI 能力。\n1. Tab 补全模型（最低层）\n\t- 基于上下文预测下一段代码\n\t- 适合：\n\t    - 写样板代码\n\t    - 局部修改\n\t- **优点**：快、低打扰\n\t- **缺点**：不理解“任务目标”，尤其没有完整的任务和需求观\n\n2. Agent（任务级）\n\t- 能理解“我要完成一件事”\n\t- 会拆步骤、调用工具、反复修正\n\t- 适合：\n\t    - \n\t    - 重构\n\t    - 批量修改\n\t    - 跨文件操作\n\t- 风险：\n\t    - **权限过大时需要强约束**，尽量结合自定义规则\n\t    - agent生成的代码经常过度（写很多不需要的东西），需要比较细致的review\n\n3. MCP（能力/工具协议层）\n\t- MCP 我更倾向理解为 **“让 AI 安全、可控地接入外部能力的标准接口”**。\n\t    - 规范 AI 能调用什么\n\t    - 能看到什么数据\n\t    - 能做多大范围的事\n\t- **价值在于：**\n\t\t- 降低 Agent 的失控风险\n\t\t- 让 AI 更工程化，而不是玩具化\n\nTab 补全解决“写得快”，Agent 解决“做成事”，MCP 解决“做得安全、可控”。",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "tech-selection",
      "name": "技术选型",
      "questions": [
        {
          "id": "tech-selection-1",
          "title": "框架 vue/react/nextjs",
          "content": "**选型考量维度**：团队主要技术栈、偏中后台还是前台、业务数据和交互复杂性、是否性能要求高、是否交付速度优先、是否有SEO或SSR需求、是否有用到典型库的需求、是否有跨端或多端需求、未来模块会不会持续膨胀、多人并行开发多不多、主要瓶颈是**首屏**还是 **交互响应**还是**列表渲染/大数据量**等\n\n- **Vue**：\n    - 适合：团队 Vue 经验多、交付速度优先\n    - 优点：上手快、约束更强（模板+响应式）、代码风格一致性更好\n    - 风险：大型复杂项目仍需工程规范（状态/依赖/性能边界）\n\n- **React**：\n    - 适合：复杂交互、组件抽象强、团队工程化能力强、、多团队开发跨端生态需要（RN/小程序生态间接）\n    - 优点：组合能力强，生态丰富；复杂场景更“可编程”\n    - 风险：自由度高 => 需要更强规范（状态、目录、Hooks 约束、性能）\n\n- **Next.js**：\n    - 适合：**需要 SEO / 首屏性能 / 内容与交易混合 / 需要 SSR/SSG/ISR** 的 Web\n    - 优点：开箱 SSR/SSG/路由/数据获取/分包优化，工程体系更完整\n    - 风险：服务端成本与复杂度上升；缓存、数据一致性、部署方式要设计\n\n总结：\n做框架选型会先看约束：团队熟悉度和交付周期是底线，然后看业务形态——中后台还是前台内容型，**数据和交互复杂度决定我们更需要‘强约束的规范’还是‘高自由度的组合能力’**。 \n如果是登录后中后台、SEO 不重要、交付优先，通常结合需要面向的端，优先选团队更熟的方案（比如 Vue 或 React），并把工程规范、状态管理、性能治理配套做好。 \n如果是 ToC 内容/交易，对 SEO 和首屏体验有硬要求，会优先考虑 Next.js 这种一体化 SSR/SSG 方案。  \n最后必要时可以提前验证关键风险点，对可能的性能瓶颈提前预估。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-2",
          "title": "模块化方案",
          "content": "- **现代前端默认优先 ESM**\n    - 原因：天然支持静态分析、tree-shaking、按需加载；与 Vite/Rollup/现代浏览器契合\n        \n- **Node 侧 / 老生态**可能仍有 CJS\n    - 场景：历史包、Node 运行环境、某些工具链\n    - 策略：库开发可用 **双产物**（`exports` 同时提供 ESM/CJS）\n        \n- **UMD**：\n    - 场景：要被 script 直接引入、或兼容非常老的环境（现在越来越少）\n        \n- **落地规则**：\n    - 应用项目：ESM + Vite / Webpack5（优先 ESM）\n    - 公共库：ESM 为主，必要时提供 CJS fallback\n    - 关键点：关注 `sideEffects`、`exports`、依赖是否可 tree-shake\n\n**一句结论**：\n- 应用侧统一 ESM；\n- 库侧 ESM 主产物 + 必要的 CJS 兼容，保证 tree-shaking 和生态兼容。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-3",
          "title": "SSR vs CSR vs SSG",
          "content": "**选型考量维度**：是否要 SEO、首屏性能诉求、内容更新频率、个性化程度、后端/缓存能力、部署成本。\n\n- **CSR（纯前端渲染）**\n    - 适合：登录后系统、中后台、强交互应用、SEO 不重要\n    - 优点：架构简单、服务器压力小\n    - 缺点：首屏依赖 JS；SEO 弱\n        \n- **SSR（服务端渲染）**\n    - 适合：SEO 重要、首屏强诉求（电商/内容/营销）\n    - 优点：首屏更快、SEO 更好\n    - 成本：服务端渲染与缓存、数据请求、部署与稳定性更复杂\n        \n- **SSG（静态生成）**\n    - 适合：内容型、更新不频繁（文档、博客、活动页）\n    - 优点：性能最好、成本低（CDN）\n    - 缺点：更新需要重新构建\n        \n- **ISR（增量静态再生）**（以 Next 为代表）\n    - 适合：既要静态性能又要一定实时性（内容更新频繁但可接受延迟）\n\n**一句结论**：\n- 后台/登录态强交互 => CSR；\n- 要 SEO/首屏 => SSR 或 SSG；\n- 内容多且更新可延迟 => SSG/ISR 是性价比最高的。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-4",
          "title": "SPA VS MPA",
          "content": "**选型维度**：页面形态是否强关联、是否需要极致首屏、多入口/多团队协作、SEO、复杂度。\n\n- **SPA**\n    - 适合：强交互、页面间共享状态多（IM、工作台、复杂表单）\n    - 优点：路由切换快、状态共享方便\n    - 缺点：首屏可能更重；路由/状态/性能治理要求更高；需要结合NGINX等配置\n\n- **MPA**\n    - 适合：多入口、页面相对独立（营销站、活动页、老系统渐进改造）\n    - 优点：首屏天然更轻、隔离性好、稳定性强\n    - 缺点：状态共享困难、体验一致性要额外做\n\n**一句结论**：\n- 强交互 + 状态共享多 => SPA；\n- 多入口且相互独立、追求隔离与首屏 => MPA 或多应用架构更合适。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-5",
          "title": "Redux VS Zustand",
          "content": "**选型维度**：状态规模与复杂度、调试与规范性、团队协作、性能、样板代码接受度。\n\n- **Redux（尤其 React Toolkit）**\n    - 适合：大型应用、复杂业务流、强规范团队、需要完整的中间件体系（日志/埋点/异步/回放）\n    - 优点：可预测、生态成熟、调试工具强、团队协作一致性高\n    - 缺点：心智和样板更多（RTK 已明显改善）\n\n- **Zustand**    \n    - 适合：中小型项目、需要更轻量、更少样板、组件局部状态较多\n    - 优点：API 简单、性能好、开发快\n    - 风险：大型项目需要自建规范（store 划分、依赖管理、异步/错误处理约束）\n\n**一句结论**：\n- 状态复杂、多人协作、需要强治理 => Redux/RTK；\n- 追求轻量高效、业务中等 => Zustand，但会配套 store 分层和规范。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-6",
          "title": "Vuex VS Pinia",
          "content": "- **Pinia（Vue3 时代主推）**\n    - 优点：更贴合 Composition API （state/getters/actions 就是一个自然的对象/函数组合）、类型推导更友好、模块化更自然、心智更轻\n    - 适合：新项目、Vue3 项目默认选\n\n- **Vuex**\n\t- 强调**单向数据流**和**严格的状态修改规范（mutation/action/commit/dispatch + module）、相对适合大型项目、但模板代码较多、TS 支持需要额外配置\n    - 策略：渐进迁移：新模块用 Pinia，旧模块逐步替换\n\n**一句结论**：\nVuex 和 Pinia 更像官方状态管理的代际更替：Vue3 之后组合式 API 和 TS 成为主流，Pinia 在类型推导、样板代码、store 组织方式上都更契合官方心智，而且是官方推荐路线；Vuex 主要保留在存量项目或迁移成本高的场景，新项目默认 Pinia 风险最低。",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-7",
          "title": "移动端适配方案(rem/vw/响应式)",
          "content": "**选型维度**：设计稿体系、是否需要等比缩放、是否要支持复杂断点、组件库/业务形态。\n\n- **vw/vh**\n    - 适合：H5 活动页/业务页等比布局\n    - 优点：天然跟随视口，不需要 JS 动态计算 root font-size\n    - 注意：处理极小/极大屏可配合 clamp() 或断点兜底\n\n- **rem（配合动态 root font-size）**\n    - 适合：历史方案、已沉淀一套 rem 工具链（postcss-pxtorem + lib-flexible 等）\n    - 风险：依赖 JS 设置；多端/嵌套容器场景要注意\n\n- **响应式（媒体查询 + flex/grid）**\n    - 适合：需要多断点、Pad/桌面也要兼容的页面\n    - 通常：实际工程中一般会结合上面两种一起用\n\n**一句结论**：\n- 纯移动 H5 我优先 vw + clamp；\n- rem 多用于历史项目或已有体系\n- 结合多端断点 走响应式",
          "hasAnswer": true
        },
        {
          "id": "tech-selection-8",
          "title": "小程序选框架 Uniapp VS Taroapp",
          "content": "**选型维度**：团队技术栈（Vue/React）、目标平台（微信/支付宝/抖音/快应用/H5/App）、生态成熟度、性能与原生能力、长期维护。\n\n- **uni-app**\n    - 适合：团队 Vue 为主、目标平台多（小程序 + H5 + App）且追求一套代码多端\n    - 优点：多端覆盖广、上手快、社区方案多\n    - 风险：遇到深度定制/复杂性能场景时，需要评估桥接和兼容成本\n- **Taro**\n    - 适合：团队 React 为主、希望用 React 心智做小程序多端\n    - 优点：React 生态更好融入；工程化能力强\n    - 风险：复杂场景要关注运行时开销与一些平台差异；仍需规范组件与渲染性能\n\n**一句结论**：\n- 看团队栈：Vue 团队优先 uni-app，React 团队优先 Taro；\n- 结合面向的平台，uniapp支持平台略多；\n- 结合可能需要的第三方能力\n- 必要时提前做关键页面性能验证（长列表、图表、地图等）",
          "hasAnswer": true
        }
      ]
    },
    {
      "id": "teamwork",
      "name": "工作协作",
      "questions": [
        {
          "id": "teamwork-1",
          "title": "如何平衡重构和需求时间冲突",
          "content": "(1) 风险控制\n- **评估重构风险**：提前评估改动对现有业务的影响\n- **保留回滚方案**：必要时做 feature flag 或分支策略\n (2) 渐进式策略\n- **模块化重构**：只重构最影响维护性的模块，减少一次性改动\n- **分阶段迭代**：把重构拆分到多个版本逐步上线\n (3) 团队协作\n- **跨角色沟通**：和产品、测试协商重构计划，保证上线不影响业务\n- **代码 review + 测试覆盖**：确保重构质量\n (4) 工具与实践\n- **使用自动化工具**：静态检查、单元测试、CI/CD 提高重构安全性\n- **记录和文档**：对重构部分做文档说明，方便团队理解和接手\n\n 面试加分点：可以结合自己实际经验举例，比如某个上线紧急需求中，如何渐进式重构，体现“业务优先 + 质量保障 + 团队协作”。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-2",
          "title": "谈谈你对“大前端”的理解",
          "content": "(1) 技术上\n- **多平台统一**：大前端不仅是 Web，还包括小程序、移动端、桌面端（Electron）、后台管理系统等。\n- **前端全栈意识**：涉及前端框架、Node.js、服务端渲染、前端工程化、构建工具等。\n- **微前端 / 组件化 / 工程化**：在大团队、多模块、多项目的环境下，强调可复用、可组合、可扩展。通过微前端架构、共享 NPM 包、组件库统一管理等方式，保证项目整体稳定性和开发效率。\n(2) 工程化和流程\n- **代码规范 & CI/CD**：统一 eslint、prettier、git hook，自动化部署流程，保证团队质量。\n- **版本管理 / 依赖管理**：NPM 包、私有组件库、依赖升级策略。\n- **测试和监控**：单元测试、集成测试、前端性能监控、日志收集等。\n(3) 团队协作和知识管理\n- **文档标准化**：设计规范、接口文档、组件库文档\n- **团队共享和复盘机制**：技术分享会、代码 review 流程、经验沉淀",
          "hasAnswer": true
        },
        {
          "id": "teamwork-3",
          "title": "如何带领一个前端团队?如何提升团队的技术能力",
          "content": "(1) 团队管理\n- **任务分解 & 目标设定**：按能力分配任务，设置短期/长期目标\n- **沟通机制**：定期会议、即时沟通渠道、跨组协作流程\n- **绩效与成长**：明确晋升路径、技术成长规划、code review 作为学习手段\n (2) 技术能力提升\n- **技术分享**：定期分享最新技术、最佳实践或项目经验\n- **代码规范 & 工程化**：推动统一规范、组件化、可复用库\n- **培训与实践**：安排小项目练习、Pair Programming、内部 Hackathon\n- **学习新技术趋势**：关注前端社区、开源项目、前沿框架（React/Next/Vue/微前端等）\n (3) 风险控制与质量保障\n- **重构与迭代策略**：控制大规模重构风险，采用渐进式重构\n- **测试覆盖率**：单元、集成、E2E 测试\n- **性能与监控**：前端性能指标 (FCP/LCP/TTI/FID/INP) 和异常监控\n> 面试加分点：你可以顺便结合“如何带新人上手”和“大前端视角”，说明你不仅懂管理，也懂技术驱动团队。",
          "hasAnswer": true
        },
        {
          "id": "teamwork-4",
          "title": "平时如何学习前端技术？",
          "content": "(1) 系统化学习\n- **专题学习**：对某一块技术（如 React、TypeScript、前端性能优化）系统学习，而不是零散碎片化\n- **做学习计划**：安排周期性学习、练习和总结\n (2) 实践与落地\n- **小项目练习**：练习新框架、新工具或设计模式\n- **复盘总结**：在项目中尝试新技术后，做复盘文档或者分享，巩固理解\n (3) 社交学习\n- **技术分享 / 内部培训**：参加团队分享会、线上/线下 meetup\n- **交流讨论**：通过评论、issue 或社群讨论问题，加深理解\n (4) 利用工具和 AI\n- **查阅资料**：官方文档、源码、GitHub issue\n- **借助 AI 提高效率**：快速定位问题或理解概念，但核心还是自己实践和总结",
          "hasAnswer": true
        },
        {
          "id": "teamwork-5",
          "title": "讲几个你觉得会越来越重要的前端技术？",
          "content": "1.**服务端渲染（SSR）与全栈前端技术**\n- 例如 Next.js、Nuxt.js 等框架，结合 React Server Components 或 Vue 3 的 SSR，可以提升首屏加载速度和 SEO 体验。    \n- 越来越多的项目希望前端不仅负责交互，也能优化性能和 SEO，因此前端对服务端渲染的理解会越来越重要。\n\n2️. **微前端和模块化架构** \n - 随着大型前端项目和多团队协作增多，微前端可以让多个团队独立开发、独立部署，减少耦合。\n - 技术上涉及模块联邦（Module Federation）、Web Components、iframe 沙箱隔离等，这些能力会越来越吃香。     \n\n3️.**前端性能优化与体验监控**\n  - 包括前端性能指标（FCP、LCP、TTI、INP/FID）、懒加载、代码分割、缓存策略、离线体验（PWA）。     \n  - 用户体验要求越来越高，性能优化和监控能力直接影响产品质量和业务指标。\n\n4.**AI 与前端结合**：自动化测试、智能推荐、代码生成工具\n\n5.**TypeScript / 强类型化前端**：在大项目中保证可维护性\n\n6.**WebAssembly**：性能敏感场景（图形、游戏、音视频处理）",
          "hasAnswer": true
        },
        {
          "id": "teamwork-6",
          "title": "说说你的职业发展规划，如何做短期计划和长期规划",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-7",
          "title": "你认为一个优秀的前端架构师/高级工程师需要具备哪些特质?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-8",
          "title": "在你的团队中，你是如何推动技术规范落地和技术选型的?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-9",
          "title": "对于新技术，你是如何学习和评估的",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-10",
          "title": "你认为前端未来3-5年的发展方向是什么?",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-11",
          "title": "讲一个工作中遇到的复杂模块的设计思路、遇到的性能瓶颈及解决方案",
          "content": "",
          "hasAnswer": false
        },
        {
          "id": "teamwork-12",
          "title": "你遇到的最大的技术挑战是什么?从中学习到了什么?",
          "content": "",
          "hasAnswer": false
        }
      ]
    }
  ],
  "generatedAt": "2026-01-10T13:00:05.939Z"
}