规则：

1. **变量提升**：函数声明 > var声明

2. **暂时性死区**：let/const声明前访问报错

3. **箭头函数this**：定义时确定，不会改变

4. **闭包循环**：使用let或IIFE解决

5. **null vs undefined**：默认参数的区别

6. `typeof null === 'object'`（历史遗留问题）

7. 箭头函数没有 `arguments` 对象

8. `bind` 绑定的 `this` 无法被覆盖

9. 默认参数只有 `undefined` 会触发

10. `let` 在 `for` 循环中会为每次迭代创建独立的词法环境，因此闭包捕获的是不同的 i，而不是同一个变量。

11. 只要满足这两点，就是闭包：有函数 + 函数访问了外层作用域里的变量

```
console.log(foo); // ƒ foo() { return 1; }
console.log(bar); // undefined

function foo() { return 1; }
var bar = function() { return 2; };

// 易错：认为 bar 也会提升为函数
// 解释：函数声明整体提升，函数表达式只提升变量声明
```

```
// 产生方式
let a;                    // undefined (未赋值)
let b = null;            // null (主动赋空值)
function c() {}          // 返回 undefined
let d = void 0;          // undefined

// 相等性判断
null == undefined;       // true (抽象相等)
null === undefined;      // false (严格相等)

// 类型检查
typeof null;            // "object" (历史bug)
typeof undefined;       // "undefined"

// 默认参数行为
function foo(a = 1) {
  console.log(a);
}
foo(undefined); // 1 (触发默认值)
foo(null);      // null (不触发默认值)
```

```
// 函数声明（整体提升）
function foo() {}      // 可以在声明前调用

// 函数表达式（只提升变量）
var bar = function() {} // 声明前调用会报错
let baz = () => {}      // 同上
```

```
console.log(typeof a); // function

var a;
function a() {}
var a = 1;

console.log(typeof a); // number
// 易错：认为第二次输出还是 function
// 规则：函数提升优先于变量提升，但赋值会覆盖
```

```
function createFunctions() {
  var result = [];
  for (var i = 0; i < 3; i++) {
    result[i] = function() {
      return i; // 捕获的是变量i，不是i的值
    };
  }
  return result;
}

var funcs = createFunctions();
console.log(funcs[0]()); // 3
console.log(funcs[1]()); // 3
console.log(funcs[2]()); // 3
// 易错：认为会输出 0,1,2
```

```
var a = 10;
function foo() {
  console.log(a);
  var a = 20;
}
foo(); // undefined

// 相当于：
function foo() {
  var a; // 变量提升
  console.log(a); // undefined
  a = 20;
}
```

```
var name = 'Global';
var obj = {
  name: 'Object',
  sayName: function() {
    console.log(this.name);
  }
};

obj.sayName(); // 'Object'
var fn = obj.sayName;
fn(); // 'Global'（非严格模式）或 undefined（严格模式）

// 易错：认为 fn() 也会输出 'Object'
// 规则：this 指向调用者，fn() 相当于 window.fn()
```

```
function foo() {
  console.log(this.value);
}

var obj1 = { value: 'obj1' };
var obj2 = { value: 'obj2' };

var bound = foo.bind(obj1);
bound(); // 'obj1'

bound.call(obj2); // 'obj1'，不是 'obj2'！
// 易错：认为 call 可以覆盖 bind 的绑定
// 规则：bind 绑定的 this 不可更改
```

```
var name = 'Global';
var obj = {
  name: 'Object',
  handleClick: function() {
    console.log(this.name);
  }
};

// 情况1：直接调用
obj.handleClick(); // 'Object'

// 情况2：作为回调
setTimeout(obj.handleClick, 0); // 'Global'

// 情况3：使用箭头函数解决
setTimeout(() => obj.handleClick(), 0); // 'Object'

// 易错点：认为情况2也会输出 'Object'
// 规则：回调函数丢失原始绑定
```

```
function foo(a = 1, b = 2) {
  console.log(a, b);
}

foo(undefined, null);
// 输出：1, null

// 易错点：认为 null 也会触发默认值
// 规则：只有 undefined 会触发默认值，null 被视为有效值
```

```
let x = 1;
function foo(x, y = x + 1) {
  console.log(y);
}

foo(2); // 3，不是 2！
// 易错：认为 y = x + 1 中的 x 是外层的 x
// 规则：默认参数的作用域是独立的，先有的参数可用于后面参数的默认值
```

```
function foo(a, b = 2) {
  console.log(arguments.length);
  console.log(a === arguments[0]);
  console.log(b === arguments[1]);
}

foo(1); 
// 输出：1, true, false
// 易错：认为 arguments[1] 会是 2
// 规则：默认参数不会填充 arguments
```

```
'use strict';
function foo() {
  console.log(this);
}

foo(); // undefined
window.foo(); // window（浏览器）

// 非严格模式：foo() → window
// 严格模式：foo() → undefined
```

```
function Person(name) {
  this.name = name;
  return { name: 'fake' };
}

const p = new Person('real');
console.log(p.name); // 'fake'
// 解释：构造函数如果返回对象，则new表达式返回该对象
```

```
var a = 10

function foo() {
  console.log(this.a)
}

function bar(fn) {
  var a = 20
  fn()
}

bar(foo) // 10 
// bar只是一个执行上下文，但调用方式是普通函数调用，因此 this 指向 window
```
