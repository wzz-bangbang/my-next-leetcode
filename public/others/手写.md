#### 手写useDebounce

```js
import React, { useRef, useCallback } from 'react';

/**
 * useDebouncedFunction Hook
 * @param {Function} callback - 需要防抖的原始函数
 * @param {number} delay - 防抖延迟时间（毫秒）
 * @returns {[Function, Function]} - [防抖后的函数, 取消函数]
 */
function useDebouncedFunction(callback, delay) {
    // 1. 使用 useRef 存储定时器 ID，确保在重渲染时保持引用
    const timerRef = useRef(null);

    // 2. 使用 useCallback 包装返回的函数，确保函数引用稳定，并包含核心防抖逻辑
    const debouncedFunc = useCallback((...args) => {
        // 3. 核心防抖逻辑：清除上一次的定时器
        if (timerRef.current) {
            clearTimeout(timerRef.current);
        }

        // 4. 重新设置定时器
        // 只有当新的定时器执行时，才会调用原始 callback
        timerRef.current = setTimeout(() => {
            // 5. 调用原始函数，并传入所有参数
            callback(...args);
        }, delay);

    // 依赖项：确保 debouncedFunc 始终能拿到最新的 callback 和 delay 值
    }, [callback, delay]);

    // 6. 提供一个手动取消 pending 调用的方法
    const cancel = useCallback(() => {
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }
    }, []);

    // 7. 返回防抖函数和取消函数
    return [debouncedFunc, cancel];
}
```

#### 手写原型继承+组合继承

原型继承

```js
// -------------------- 父类 --------------------
function SuperType(name) {
  this.name = name;
  // 【致命缺陷点】引用类型属性
  this.colors = ["red", "blue", "green"]; 
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

// -------------------- 子类 --------------------
function SubType(name, age) {
  this.age = age;
}

// 核心：让子类原型对象指向父类实例
// 【注意点】这里 SubType.prototype 现在是 SuperType 的一个实例
SubType.prototype = new SuperType(); 

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

// -------------------- 测试 --------------------
const instance1 = new SubType("Instance1", 29);
instance1.colors.push("black"); // 修改 instance1 的 colors

const instance2 = new SubType("Instance2", 23);

console.log(instance1.colors); // 输出: ["red", "blue", "green", "black"]
console.log(instance2.colors); // 输出: ["red", "blue", "green", "black"] 【缺陷：被 instance1 影响了！】
```

组合继承

```js
// -------------------- 父类 --------------------
function SuperType(name) {
  this.name = name;
  // 解决了引用类型共享问题 (通过构造函数赋值，属性实例独占)
  this.colors = ["red", "blue", "green"]; 
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

// -------------------- 子类 --------------------
function SubType(name, age) {
  // 1. 【构造函数借用】：继承属性，并向父类传参
  SuperType.call(this, name); 
  this.age = age;
}

// 2. 【核心优化】：创建父类原型对象的副本，并赋值给子类原型
//    - Object.create(SuperType.prototype)：创建了一个空对象，但它的原型链指向 SuperType.prototype
//    - 这避免了调用 SuperType() 构造函数，从而避免了不必要的属性创建和引用类型共享
SubType.prototype = Object.create(SuperType.prototype); 

// 3. 【构造器指针修正】：将子类构造器指向自身
SubType.prototype.constructor = SubType; 

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

// -------------------- 测试 --------------------
const instanceA = new SubType("Alice", 29);
instanceA.colors.push("black"); // 修改 instanceA 的 colors

const instanceB = new SubType("Bob", 23);

instanceA.sayName();   // 输出: Alice (正确继承方法)
console.log(instanceA.colors); // 输出: ["red", "blue", "green", "black"]
console.log(instanceB.colors); // 输出: ["red", "blue", "green"] 【成功：相互不影响！】
```

#### 实现composel函数，类似于koa的中间件洋葱模型实现composel函数，类似于koa的中间件洋葱模型

```js
// 假设这是你还没写的 compose 函数
// const compose = ... 

const middleware = []

// 中间件 1
middleware.push(async (ctx, next) => {
  console.log(1)
  await next() // 暂停！去执行下一个中间件
  console.log(2)
})

// 中间件 2
middleware.push(async (ctx, next) => {
  console.log(3)
  await next() // 暂停！去执行下一个中间件
  console.log(4)
})

// 中间件 3
middleware.push(async (ctx, next) => {
  console.log(5)
  await next() // 下面没有了，next resolve
  console.log(6)
})

const fn = compose(middleware)

// 启动！
fn({})
```

答案

```js
const compose = (middleware) => {
  return (ctx, next) => {
    const dispatch = (i) => {
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()

      try {
        // 递归核心：当前 fn 执行，第二个参数 next 递归指向 dispatch(i+1)
        return Promise.resolve(fn(ctx, () => dispatch(i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
    return dispatch(0)
  }
}
```

##### Intersection Observer API怎么写

```js
    const ele = xxx
    const io = new IntersectionObserver(
      (entries) => {
        entries.forEach((item) => {
          console.log(item, item.intersectionRect)
          if (item.isIntersecting) {
            console.log('进入视口了')
          } else {
            console.log('----')
          }
        })
      },
      {
        root:,
        rootMargin: '500px 0px 0px 0px',
        threshold: [0, 0.25, 0.5, 0.75, 1]
      }
    )
    // 监听ele元素
    if (ele) {
      io.observe(ele)
    }


// 开始观察,观察多个元素时可以多次调用这个方法
io.observe(element);
// 停止观察
io.unobserve(element);
// 关闭观察器
io.disconnect();    
```

##### 

##### 深拷贝的多种实现方案：

1：JSON.stringify和JSON.parse : 无法复制函数、RegExp、Date 等特殊对象；无法处理循环引用；会丢失 undefined、Symbol 类型的属性；无法复制原型链

2：**Lodash 的 `_.cloneDeep`，

- ✅ 支持绝大多数 JavaScript 类型

- ✅ 处理循环引用

- ✅ 性能优化

- ✅ 良好的浏览器兼容性

3.手写，

注意要判断类型，基础类型/数组/对象/null

一般for (let key in obj) {
if (obj.hasOwnProperty(key)) {

##### 用requestAnimationFrame实现setTimeout

注意step是从初次调用开始算起的完整时间差

##### 并发限制的异步调度器

并发限制的异步调度器:保证同时运行的任务最多有两个，完善代码中Scheduler类，使得以下程序能正确输出

```js
// 完成Scheduler类，使得以下程序能正确输出
class Scheduler {
// Your code
}

const delay = (timeout) =>
  new Promise((resolve) => {
    setTimeout(resolve, timeout)
  })
const scheduler = new Scheduler(2)

const addTask = (time, order) => {
  scheduler.add(() => delay(time)).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(408, '4')
```

答案

我们需要在把任务放入队列时，同时把对应的 `resolve` 方法也存起来。

```js
class Scheduler {
  constructor(max) {
    this.max = max
    this.arr = []
    this.count = 0
  }

  add(task) {
    return new Promise((resolve) => {
      const run = () => {
        if (typeof task === 'function') {
          this.count += 1
          task().then((res) => {
            this.count -= 1
            resolve(res)
            if (this.arr.length > 0) {
              const top = this.arr.shift()
              top() //这里也要注意，top是一个run 函数。不是promise，但是执行完会调之前的resole，直接执行就行
            }
          })
        }
      }
      if (this.count < this.max) {
        run()
      } else {
        this.arr.push(run) //注意这里传run进去而不是task
      }
    })
  }
}
```

初始错误版本

当任务被放入队列（`else` 分支）时，**Promise 被挂起了，但永远不会被 resolve**。

当 `addTask(300, '3')` 被调用时，因为并发满了，它进入 `else`。此时 `add` 方法返回了一个处于 **Pending** 状态的 Promise。外部的 `.then(() => console.log('3'))` 正在等待这个 Promise。

当队列里的任务稍后被取出并执行 `this.add(top)` 时，你实际上是**重新创建了一个新的 Promise**。虽然任务执行了，但那个**新的** Promise 和当初 `addTask(300, '3')` 等待的**旧** Promise 没有任何关系。旧的 Promise 永远没有收到 `resolve` 信号，所以 `'3'` 和 `'4'` 永远不会被打印出来。

```js
add(task) {
    return new Promise((resolve) => {
      if (this.count < this.max) {
        if (typeof task === 'function') {
          this.count += 1
          task().then((res) => {
            this.count -= 1
            resolve(res)
            if (this.arr.length > 0) {
              const top = this.arr.shift()
              this.add(top)
            }
          })
        }
      } else {
        this.arr.push(task)
      }
    })
}
```

##### Object.create()

Object.setPrototypeOf

注意类型判断

##### 手写instanceOf

```javascript
// instanceof 实际是检查原型链
function myInstanceof(obj, constructor) {
  let proto = Object.getPrototypeOf(obj);
  while (proto) {
    if (proto === constructor.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```
