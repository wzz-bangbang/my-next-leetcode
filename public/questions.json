[
  {
    "id": "debounce",
    "title": "防抖",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个防抖函数 debounce，在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。常用于搜索框输入、窗口 resize 等场景。",
    "template": "function debounce(fn, delay) {\n  // 请在此实现防抖函数\n  \n}",
    "testCases": [
      {
        "input": "const log = debounce(() => console.log('called'), 100);\nlog(); log(); log(); // 连续调用3次",
        "expected": "100ms 后只输出一次 'called'",
        "description": "基础防抖：连续调用只执行最后一次"
      },
      {
        "input": "const log = debounce((x) => console.log(x), 100);\nlog(1); log(2); log(3);",
        "expected": "100ms 后输出 3",
        "description": "参数传递：应传递最后一次调用的参数"
      }
    ],
    "solution": "### 核心思路\n\n1. 使用闭包保存定时器 ID\n2. 每次调用时先清除之前的定时器\n3. 重新设置新的定时器\n\n### 关键点\n\n- **this 指向**：使用 `apply` 或 `call` 确保回调函数的 this 指向正确\n- **参数传递**：使用 `...args` 收集参数并传递给原函数\n- **返回值处理**：防抖函数通常不需要返回值，因为是异步执行\n\n### 参考实现\n\n```javascript\nfunction debounce(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n```",
    "followUp": [
      "如何实现「立即执行」版本（leading edge），即第一次调用立即执行，后续调用才防抖？",
      "如何给防抖函数添加 cancel 方法，支持手动取消？",
      "如何实现 maxWait 参数，保证即使持续触发，也会在 maxWait 时间后至少执行一次？"
    ]
  },
  {
    "id": "throttle",
    "title": "节流",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个节流函数 throttle，规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。常用于滚动加载、按钮点击等场景。",
    "template": "function throttle(fn, delay) {\n  // 请在此实现节流函数\n  \n}",
    "testCases": [
      {
        "input": "const log = throttle(() => console.log('scroll'), 100);\n// 在 250ms 内连续调用 10 次",
        "expected": "输出 2-3 次 'scroll'（首次立即执行 + 每 100ms 执行一次）",
        "description": "基础节流：固定时间间隔内只执行一次"
      },
      {
        "input": "const log = throttle((x) => console.log(x), 100);\nlog(1); setTimeout(() => log(2), 50); setTimeout(() => log(3), 150);",
        "expected": "立即输出 1，150ms 时输出 3",
        "description": "参数传递测试"
      }
    ],
    "solution": "### 核心思路\n\n节流有两种常见实现方式：\n\n#### 方式一：时间戳版（首次立即执行）\n\n```javascript\nfunction throttle(fn, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n```\n\n#### 方式二：定时器版（首次延迟执行）\n\n```javascript\nfunction throttle(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        fn.apply(this, args);\n        timer = null;\n      }, delay);\n    }\n  };\n}\n```\n\n### 关键区别\n\n| 版本 | 首次执行 | 停止触发后 |\n|------|----------|------------|\n| 时间戳版 | 立即执行 | 不会执行 |\n| 定时器版 | 延迟执行 | 会执行一次 |",
    "followUp": [
      "如何结合时间戳和定时器，实现「首次立即执行 + 停止后还会执行一次」的完整版？",
      "如何添加 leading 和 trailing 选项控制首尾执行行为？",
      "节流和防抖的应用场景有什么区别？"
    ]
  },
  {
    "id": "currying",
    "title": "函数柯里化",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个 curry 函数，将一个多参数函数转换为一系列单参数函数。例如：curry(add)(1)(2)(3) 等价于 add(1, 2, 3)。",
    "template": "function curry(fn) {\n  // 请在此实现柯里化函数\n  \n}",
    "testCases": [
      {
        "input": "const add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3));",
        "expected": "6",
        "description": "基础柯里化：逐个传参"
      },
      {
        "input": "const add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1, 2)(3));\nconsole.log(curriedAdd(1)(2, 3));",
        "expected": "6\n6",
        "description": "支持一次传多个参数"
      }
    ],
    "solution": "### 核心思路\n\n1. 获取原函数的参数个数 `fn.length`\n2. 返回一个递归函数，收集参数\n3. 当收集的参数数量 >= 原函数参数数量时，执行原函数\n\n### 参考实现\n\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    // 参数够了，执行原函数\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    // 参数不够，返回新函数继续收集\n    return function(...moreArgs) {\n      return curried.apply(this, [...args, ...moreArgs]);\n    };\n  };\n}\n```\n\n### 关键点\n\n- `fn.length` 获取函数形参个数\n- 使用闭包累积参数\n- 支持一次传多个参数的灵活调用方式",
    "followUp": [
      "如何实现支持占位符的柯里化？如 curry(add)(1, _, 3)(2) => 6",
      "柯里化在函数式编程中有哪些实际应用场景？",
      "如何实现反柯里化（uncurry）？"
    ]
  },
  {
    "id": "promise",
    "title": "手写Promise",
    "difficulty": 3,
    "tags": [2],
    "description": "根据 Promise/A+ 规范，实现一个完整的 Promise 类，包括 then、catch、finally 方法，以及 resolve、reject、all、race 等静态方法。"
  },
  {
    "id": "reduce",
    "title": "模拟Array.reduce",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Array.prototype.reduce 方法，对数组中的每个元素执行一个 reducer 函数，将其结果汇总为单个返回值。",
    "template": "Array.prototype.myReduce = function(callback, initialValue) {\n  // 请在此实现 reduce 方法\n  \n};",
    "testCases": [
      {
        "input": "[1, 2, 3, 4].myReduce((acc, cur) => acc + cur, 0)",
        "expected": "10",
        "description": "带初始值的累加"
      },
      {
        "input": "[1, 2, 3, 4].myReduce((acc, cur) => acc + cur)",
        "expected": "10",
        "description": "不带初始值，使用数组第一个元素"
      },
      {
        "input": "[].myReduce((acc, cur) => acc + cur)",
        "expected": "TypeError",
        "description": "空数组无初始值应抛出错误"
      }
    ],
    "solution": "### 核心思路\n\n1. 处理初始值：有则使用，无则取数组第一个元素\n2. 确定遍历起点：有初始值从 0 开始，无则从 1 开始\n3. 遍历数组，调用 callback 累积结果\n\n### 参考实现\n\n```javascript\nArray.prototype.myReduce = function(callback, initialValue) {\n  if (this.length === 0 && initialValue === undefined) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n  \n  let acc = initialValue !== undefined ? initialValue : this[0];\n  let startIndex = initialValue !== undefined ? 0 : 1;\n  \n  for (let i = startIndex; i < this.length; i++) {\n    acc = callback(acc, this[i], i, this);\n  }\n  \n  return acc;\n};\n```\n\n### callback 参数说明\n\n- `accumulator`：累积值\n- `currentValue`：当前元素\n- `index`：当前索引\n- `array`：原数组",
    "followUp": [
      "如何用 reduce 实现 map、filter、flat 等数组方法？",
      "reduceRight 和 reduce 的区别是什么？如何实现？"
    ]
  },
  {
    "id": "promise-race",
    "title": "模拟Promise.race",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Promise.race 方法，返回一个 Promise，一旦迭代器中的某个 Promise 解决或拒绝，返回的 Promise 就会解决或拒绝。"
  },
  {
    "id": "promise-all",
    "title": "模拟Promise.all",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.all 方法，接收一个 Promise 数组，返回一个新的 Promise。当所有 Promise 都成功时返回结果数组，任一失败则立即拒绝。"
  },
  {
    "id": "promise-any",
    "title": "模拟Promise.any",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.any 方法，接收一个 Promise 数组，只要其中一个 Promise 成功，就返回那个成功的 Promise。如果全部失败，则返回一个 AggregateError。"
  },
  {
    "id": "deep-clone",
    "title": "实现深拷贝（Deep Clone）",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深拷贝函数，能够处理对象、数组、Date、RegExp、Map、Set 等类型，并解决循环引用问题。"
  },
  {
    "id": "event-emitter",
    "title": "实现 EventEmitter 类",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个发布订阅模式的 EventEmitter 类，包含 on（订阅）、off（取消订阅）、emit（发布）、once（只订阅一次）等方法。"
  },
  {
    "id": "handwrite-call",
    "title": "手写 call 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.call 方法，在调用一个函数时，可以指定 this 的指向，并传入参数列表。"
  },
  {
    "id": "handwrite-apply",
    "title": "手写 apply 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.apply 方法，与 call 类似，但接收的是参数数组而非参数列表。"
  },
  {
    "id": "handwrite-bind",
    "title": "手写 bind 函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Function.prototype.bind 方法，创建一个新的函数，在调用时设置 this 关键字为提供的值。需要考虑作为构造函数使用的情况。"
  },
  {
    "id": "handwrite-new",
    "title": "手写 new 操作符",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 new 操作符的功能：创建新对象、设置原型链、执行构造函数、返回对象。"
  },
  {
    "id": "array-unique",
    "title": "手写数组去重函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组去重函数，可以使用 Set、filter、reduce 等多种方式实现。考虑对象、NaN 等特殊值的处理。"
  },
  {
    "id": "array-flatten",
    "title": "手写数组扁平化函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组扁平化函数 flatten，将多维数组转换为一维数组。可以指定扁平化的深度。"
  },
  {
    "id": "deep-equal",
    "title": "手写深度比较函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深度比较函数 deepEqual，比较两个值是否完全相等，支持对象、数组、Date、RegExp 等类型的比较。"
  },
  {
    "id": "lru-cache",
    "title": "实现 LRU 缓存机制",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "实现一个 LRU (Least Recently Used) 缓存，支持 get 和 put 操作，当缓存容量达到上限时，删除最近最少使用的数据。要求时间复杂度为 O(1)。"
  },
  {
    "id": "async-concurrency-controller",
    "title": "手写异步并发控制器",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "实现一个异步任务调度器，可以控制同时执行的异步任务数量。当正在执行的任务数小于限制时，立即执行新任务；否则将任务加入等待队列。"
  },
  {
    "id": "class-scheduler",
    "title": "并发限制的异步调度器类",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "并发限制的异步调度器:保证同时运行的任务最多有两个，完善代码中Scheduler类，使得以下程序能正确输出"
  },
  {
    "id": "handwrite-object-assign",
    "title": "手写 Object.assign",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.assign 方法，将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。"
  },
  {
    "id": "handwrite-websocket",
    "title": "手写一个基础的 WebSocket",
    "difficulty": 2,
    "tags": [2],
    "description": "封装一个 WebSocket 类，实现自动重连、心跳检测、消息队列等功能。"
  },
  {
    "id": "postmessage-event-hub",
    "title": "手写基于 postMessage 的事件通信",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个基于 postMessage 的跨窗口/跨 iframe 通信机制，支持消息的发送、接收和回复。"
  },
  {
    "id": "message-channel",
    "title": "MessageChannel 通信",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 MessageChannel API 实现两个独立上下文之间的双向通信，理解端口（port）的概念和使用方式。"
  },
  {
    "id": "myUseUpdate",
    "title": "手写 useUpdate 强制渲染 Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useUpdate Hook，返回一个函数，调用该函数可以强制组件重新渲染。"
  },
  {
    "id": "myUseAsyncEffect",
    "title": "手写 useAsyncEffect Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个支持异步函数的 useAsyncEffect Hook，处理异步操作的清理和竞态条件。"
  },
  {
    "id": "myUseDebounce",
    "title": "手写 useDebounce Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useDebounce Hook，对值或函数进行防抖处理，常用于搜索输入等场景。"
  },
  {
    "id": "myUseInterval",
    "title": "手写 useInterval Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useInterval Hook，封装 setInterval，支持动态修改间隔时间，正确处理清理逻辑。"
  },
  {
    "id": "myUseState",
    "title": "手写 useState Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "模拟实现 React 的 useState Hook，理解闭包、状态管理和触发重渲染的机制。"
  },
  {
    "id": "myUseTimeout",
    "title": "手写 useTimeout Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useTimeout Hook，在指定延迟后执行回调函数。需要正确处理组件卸载时的清理逻辑，以及回调函数或延迟时间变化时的重置行为。"
  },
  {
    "id": "myUseWindowResize",
    "title": "手写 useWindowResize Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useWindowResize Hook，监听窗口大小变化并返回当前的 width 和 height。需要正确添加和移除事件监听器，可选支持防抖优化。"
  },
  {
    "id": "proxy",
    "title": "手写 Proxy 代理",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 Proxy 实现数据响应式，当数据变化时自动触发更新。理解 handler 中的 get、set 等捕获器。"
  },
  {
    "id": "prototype-inheritance",
    "title": "手写原型继承+组合继承",
    "difficulty": 2,
    "tags": [2],
    "description": "实现原型继承和组合继承两种方式。理解原型链继承的缺陷（引用类型共享问题），以及组合继承如何通过构造函数借用和 Object.create 来解决这些问题。"
  },
  {
    "id": "compose-middleware",
    "title": "实现 compose 函数（洋葱模型）",
    "difficulty": 3,
    "tags": [2],
    "description": "实现类似 Koa 的中间件洋葱模型 compose 函数。理解 async/await 与递归调用 next() 的执行顺序。"
  },
  {
    "id": "intersection-observer",
    "title": "Intersection Observer API 使用",
    "difficulty": 1,
    "tags": [2],
    "description": "使用 Intersection Observer API 实现元素可见性检测，常用于懒加载、无限滚动、曝光统计等场景。注意step是从初次调用开始算起的完整时间差。"
  },
  {
    "id": "raf-settimeout",
    "title": "用 requestAnimationFrame 实现 setTimeout",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 requestAnimationFrame 模拟实现 setTimeout 功能，理解两者的区别和执行时机。"
  },
  {
    "id": "object-create",
    "title": "手写 Object.create",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.create 方法，创建一个新对象，使用现有的对象作为新对象的原型。同时理解 Object.setPrototypeOf 的作用。"
  },
  {
    "id": "handwrite-instanceof",
    "title": "手写 instanceof",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 instanceof 操作符，通过遍历原型链检查对象是否是某个构造函数的实例。"
  },
  {
    "id": "ts-partial",
    "title": "实现 Partial<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Partial<T> 类型，将 T 中的所有属性变为可选。这是 TypeScript 内置工具类型之一，理解映射类型和可选修饰符 ? 的使用。"
  },
  {
    "id": "ts-required",
    "title": "实现 Required<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Required<T> 类型，将 T 中的所有属性变为必选。理解 -? 修饰符如何移除可选标记。"
  },
  {
    "id": "ts-readonly",
    "title": "实现 Readonly<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Readonly<T> 类型，将 T 中的所有属性变为只读。理解 readonly 修饰符在映射类型中的应用。"
  },
  {
    "id": "ts-pick",
    "title": "实现 Pick<T, K> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Pick<T, K> 类型，从类型 T 中选取一组属性 K 构造新类型。理解 keyof 和 extends 约束的配合使用。"
  },
  {
    "id": "ts-record",
    "title": "实现 Record<K, T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Record<K, T> 类型，构造一个对象类型，其键名类型为 K，键值类型为 T。常用于创建字典/映射类型。"
  },
  {
    "id": "ts-exclude",
    "title": "实现 Exclude<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Exclude<T, U> 类型，从联合类型 T 中排除那些可以赋值给 U 的类型。理解条件类型的分布式特性。"
  },
  {
    "id": "ts-extract",
    "title": "实现 Extract<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Extract<T, U> 类型，从联合类型 T 中提取那些可以赋值给 U 的类型。与 Exclude 相反，理解条件类型中 extends 的判断逻辑。"
  },
  {
    "id": "ts-omit",
    "title": "实现 Omit<T, K> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Omit<T, K> 类型，从类型 T 中排除一组属性 K。可以基于 Pick 和 Exclude 组合实现，理解工具类型的复合使用。"
  },
  {
    "id": "ts-nonnullable",
    "title": "实现 NonNullable<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 NonNullable<T> 类型，从联合类型 T 中排除 null 和 undefined。常用于处理可能为空的类型。"
  },
  {
    "id": "ts-merge",
    "title": "实现 Merge<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Merge<T, U> 类型，将类型 U 的属性合并到类型 T 中，如果有相同的键则 U 的类型覆盖 T。理解交叉类型与映射类型的区别。"
  },
  {
    "id": "ts-mutable",
    "title": "实现 Mutable<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Mutable<T> 类型，移除 T 中所有属性的 readonly 只读修饰符。理解 -readonly 修饰符的使用，与 Readonly 相反。"
  },
  {
    "id": "ts-tuple-to-union",
    "title": "实现 TupleToUnion<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 TupleToUnion<T> 类型，将元组类型转换为联合类型。例如 [string, number] 转为 string | number。理解元组的索引访问类型。"
  },
  {
    "id": "ts-deep-readonly",
    "title": "实现 DeepReadonly<T> 类型",
    "difficulty": 3,
    "tags": [3],
    "description": "实现一个 DeepReadonly<T> 类型，递归地将 T 中的所有属性（包括嵌套对象）变为只读。理解递归类型和条件类型的结合使用。"
  },
  {
    "id": "ts-return-type",
    "title": "实现 ReturnType<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ReturnType<T> 类型，获取函数类型 T 的返回值类型。理解 infer 关键字在条件类型中推断类型的用法。"
  },
  {
    "id": "ts-parameters",
    "title": "实现 Parameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Parameters<T> 类型，获取函数类型 T 的参数类型，返回一个元组类型。理解 infer 如何推断函数参数。"
  },
  {
    "id": "ts-constructor-parameters",
    "title": "实现 ConstructorParameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ConstructorParameters<T> 类型，获取构造函数类型 T 的参数类型元组。理解 new (...args) => any 构造签名的类型表示。"
  },
  {
    "id": "js-hoisting-function-vs-var",
    "title": "函数声明 vs 函数表达式提升",
    "difficulty": 1,
    "tags": [1],
    "description": "console.log(foo);\nconsole.log(bar);\n\nfunction foo() { return 1; }\nvar bar = function() { return 2; };\n\n// 输出什么？"
  },
  {
    "id": "js-null-vs-undefined",
    "title": "null 和 undefined 的区别",
    "difficulty": 1,
    "tags": [1],
    "description": "let a;\nlet b = null;\nfunction c() {}\nlet d = void 0;\n\nconsole.log(null == undefined);\nconsole.log(null === undefined);\nconsole.log(typeof null);\nconsole.log(typeof undefined);\n\nfunction foo(a = 1) {\n  console.log(a);\n}\nfoo(undefined);\nfoo(null);\n\n// 分别输出什么？"
  },
  {
    "id": "js-hoisting-priority",
    "title": "函数提升优先于变量提升",
    "difficulty": 2,
    "tags": [1],
    "description": "console.log(typeof a);\n\nvar a;\nfunction a() {}\nvar a = 1;\n\nconsole.log(typeof a);\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-closure-loop-var",
    "title": "闭包与 var 循环变量",
    "difficulty": 2,
    "tags": [1],
    "description": "function createFunctions() {\n  var result = [];\n  for (var i = 0; i < 3; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  return result;\n}\n\nvar funcs = createFunctions();\nconsole.log(funcs[0]());\nconsole.log(funcs[1]());\nconsole.log(funcs[2]());\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-var-hoisting-in-function",
    "title": "函数内变量提升",
    "difficulty": 1,
    "tags": [1],
    "description": "var a = 10;\nfunction foo() {\n  console.log(a);\n  var a = 20;\n}\nfoo();\n\n// 输出什么？"
  },
  {
    "id": "js-this-method-vs-function",
    "title": "this 指向：方法调用 vs 普通调用",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  sayName: function() {\n    console.log(this.name);\n  }\n};\n\nobj.sayName();\nvar fn = obj.sayName;\nfn();\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-bind-cannot-override",
    "title": "bind 绑定的 this 不可覆盖",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo() {\n  console.log(this.value);\n}\n\nvar obj1 = { value: 'obj1' };\nvar obj2 = { value: 'obj2' };\n\nvar bound = foo.bind(obj1);\nbound();\nbound.call(obj2);\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-callback-this-lost",
    "title": "回调函数中 this 丢失",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  handleClick: function() {\n    console.log(this.name);\n  }\n};\n\nobj.handleClick();\nsetTimeout(obj.handleClick, 0);\nsetTimeout(() => obj.handleClick(), 0);\n\n// 三次输出分别是什么？"
  },
  {
    "id": "js-default-param-null-undefined",
    "title": "默认参数：null vs undefined",
    "difficulty": 1,
    "tags": [1],
    "description": "function foo(a = 1, b = 2) {\n  console.log(a, b);\n}\n\nfoo(undefined, null);\n\n// 输出什么？"
  },
  {
    "id": "js-default-param-scope",
    "title": "默认参数的作用域",
    "difficulty": 2,
    "tags": [1],
    "description": "let x = 1;\nfunction foo(x, y = x + 1) {\n  console.log(y);\n}\n\nfoo(2);\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-arguments-default-param",
    "title": "arguments 与默认参数",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo(a, b = 2) {\n  console.log(arguments.length);\n  console.log(a === arguments[0]);\n  console.log(b === arguments[1]);\n}\n\nfoo(1);\n\n// 三次输出分别是什么？"
  },
  {
    "id": "js-strict-mode-this",
    "title": "严格模式下的 this",
    "difficulty": 1,
    "tags": [1],
    "description": "'use strict';\nfunction foo() {\n  console.log(this);\n}\n\nfoo();\nwindow.foo();\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-constructor-return-object",
    "title": "构造函数返回对象",
    "difficulty": 2,
    "tags": [1],
    "description": "function Person(name) {\n  this.name = name;\n  return { name: 'fake' };\n}\n\nconst p = new Person('real');\nconsole.log(p.name);\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-callback-context-this",
    "title": "回调函数执行上下文中的 this",
    "difficulty": 2,
    "tags": [1],
    "description": "var a = 10;\n\nfunction foo() {\n  console.log(this.a);\n}\n\nfunction bar(fn) {\n  var a = 20;\n  fn();\n}\n\nbar(foo);\n\n// 输出什么？为什么？"
  },
  {
    "id": "parse-query",
    "title": "实现 parseQuery 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个 parseQuery 函数，输入一个 query 字符串（例如 ?name=Alice&age=20&city=Beijing），返回一个对象 {name: 'Alice', age: '20', city: 'Beijing'}。如果 query 参数中出现重复的 key，value 变成数组。",
    "template": "function parseQuery(queryString) {\n  // 请在此实现 parseQuery 函数\n  \n}",
    "testCases": [
      {
        "input": "parseQuery('?name=Alice&age=20&city=Beijing')",
        "expected": "{ name: 'Alice', age: '20', city: 'Beijing' }",
        "description": "基础解析：解析简单的 query 字符串"
      },
      {
        "input": "parseQuery('?tag=js&tag=ts&tag=react')",
        "expected": "{ tag: ['js', 'ts', 'react'] }",
        "description": "重复 key：相同 key 的值变成数组"
      },
      {
        "input": "parseQuery('?name=Alice&tag=js&tag=ts')",
        "expected": "{ name: 'Alice', tag: ['js', 'ts'] }",
        "description": "混合情况：既有单值也有多值"
      },
      {
        "input": "parseQuery('')",
        "expected": "{}",
        "description": "空字符串：返回空对象"
      }
    ],
    "solution": "### 核心思路\n\n1. 去掉开头的 `?`（如果有）\n2. 按 `&` 分割成键值对数组\n3. 遍历键值对，按 `=` 分割出 key 和 value\n4. 如果 key 已存在，将值转为数组或追加到数组\n\n### 参考实现\n\n```javascript\nfunction parseQuery(queryString) {\n  const result = {};\n  \n  // 去掉开头的 ?\n  const query = queryString.replace(/^\\?/, '');\n  \n  if (!query) return result;\n  \n  // 按 & 分割\n  const pairs = query.split('&');\n  \n  for (const pair of pairs) {\n    const [key, value = ''] = pair.split('=');\n    \n    // 解码 URL 编码的字符\n    const decodedKey = decodeURIComponent(key);\n    const decodedValue = decodeURIComponent(value);\n    \n    if (result.hasOwnProperty(decodedKey)) {\n      // key 已存在，转为数组或追加\n      if (Array.isArray(result[decodedKey])) {\n        result[decodedKey].push(decodedValue);\n      } else {\n        result[decodedKey] = [result[decodedKey], decodedValue];\n      }\n    } else {\n      result[decodedKey] = decodedValue;\n    }\n  }\n  \n  return result;\n}\n```\n\n### 使用 URLSearchParams 的简洁实现\n\n```javascript\nfunction parseQuery(queryString) {\n  const result = {};\n  const params = new URLSearchParams(queryString);\n  \n  for (const [key, value] of params) {\n    if (result.hasOwnProperty(key)) {\n      if (Array.isArray(result[key])) {\n        result[key].push(value);\n      } else {\n        result[key] = [result[key], value];\n      }\n    } else {\n      result[key] = value;\n    }\n  }\n  \n  return result;\n}\n```",
    "followUp": [
      "如何实现反向操作 stringifyQuery，将对象转换为 query 字符串？",
      "如何处理 URL 编码的特殊字符，如 %20、%2B 等？",
      "如何支持嵌套对象的解析，如 ?user[name]=Alice&user[age]=20？"
    ]
  }
]
