[
  {
    "id": "debounce",
    "title": "防抖",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个防抖函数 debounce，在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。常用于搜索框输入、窗口 resize 等场景。"
  },
  {
    "id": "throttle",
    "title": "节流",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个节流函数 throttle，规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。常用于滚动加载、按钮点击等场景。"
  },
  {
    "id": "currying",
    "title": "函数柯里化",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个 curry 函数，将一个多参数函数转换为一系列单参数函数。例如：curry(add)(1)(2)(3) 等价于 add(1, 2, 3)。"
  },
  {
    "id": "promise",
    "title": "手写Promise",
    "difficulty": 3,
    "tags": [2],
    "description": "根据 Promise/A+ 规范，实现一个完整的 Promise 类，包括 then、catch、finally 方法，以及 resolve、reject、all、race 等静态方法。"
  },
  {
    "id": "reduce",
    "title": "模拟Array.reduce",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Array.prototype.reduce 方法，对数组中的每个元素执行一个 reducer 函数，将其结果汇总为单个返回值。"
  },
  {
    "id": "promise-race",
    "title": "模拟Promise.race",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Promise.race 方法，返回一个 Promise，一旦迭代器中的某个 Promise 解决或拒绝，返回的 Promise 就会解决或拒绝。"
  },
  {
    "id": "promise-all",
    "title": "模拟Promise.all",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.all 方法，接收一个 Promise 数组，返回一个新的 Promise。当所有 Promise 都成功时返回结果数组，任一失败则立即拒绝。"
  },
  {
    "id": "promise-any",
    "title": "模拟Promise.any",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.any 方法，接收一个 Promise 数组，只要其中一个 Promise 成功，就返回那个成功的 Promise。如果全部失败，则返回一个 AggregateError。"
  },
  {
    "id": "deep-clone",
    "title": "实现深拷贝（Deep Clone）",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深拷贝函数，能够处理对象、数组、Date、RegExp、Map、Set 等类型，并解决循环引用问题。"
  },
  {
    "id": "event-emitter",
    "title": "实现 EventEmitter 类",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个发布订阅模式的 EventEmitter 类，包含 on（订阅）、off（取消订阅）、emit（发布）、once（只订阅一次）等方法。"
  },
  {
    "id": "handwrite-call",
    "title": "手写 call 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.call 方法，在调用一个函数时，可以指定 this 的指向，并传入参数列表。"
  },
  {
    "id": "handwrite-apply",
    "title": "手写 apply 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.apply 方法，与 call 类似，但接收的是参数数组而非参数列表。"
  },
  {
    "id": "handwrite-bind",
    "title": "手写 bind 函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Function.prototype.bind 方法，创建一个新的函数，在调用时设置 this 关键字为提供的值。需要考虑作为构造函数使用的情况。"
  },
  {
    "id": "handwrite-new",
    "title": "手写 new 操作符",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 new 操作符的功能：创建新对象、设置原型链、执行构造函数、返回对象。"
  },
  {
    "id": "array-unique",
    "title": "手写数组去重函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组去重函数，可以使用 Set、filter、reduce 等多种方式实现。考虑对象、NaN 等特殊值的处理。"
  },
  {
    "id": "array-flatten",
    "title": "手写数组扁平化函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组扁平化函数 flatten，将多维数组转换为一维数组。可以指定扁平化的深度。"
  },
  {
    "id": "deep-equal",
    "title": "手写深度比较函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深度比较函数 deepEqual，比较两个值是否完全相等，支持对象、数组、Date、RegExp 等类型的比较。"
  },
  {
    "id": "lru-cache",
    "title": "实现 LRU 缓存机制",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "实现一个 LRU (Least Recently Used) 缓存，支持 get 和 put 操作，当缓存容量达到上限时，删除最近最少使用的数据。要求时间复杂度为 O(1)。"
  },
  {
    "id": "async-concurrency-controller",
    "title": "手写异步并发控制器",
    "difficulty": 3,
    "tags": [2],
    "description": "实现一个异步任务调度器，可以控制同时执行的异步任务数量。当正在执行的任务数小于限制时，立即执行新任务；否则将任务加入等待队列。"
  },
  {
    "id": "class-scheduler",
    "title": "并发限制的异步调度器类",
    "difficulty": 3,
    "tags": [2],
    "description": "并发限制的异步调度器:保证同时运行的任务最多有两个，完善代码中Scheduler类，使得以下程序能正确输出"
  },
  {
    "id": "handwrite-object-assign",
    "title": "手写 Object.assign",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.assign 方法，将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。"
  },
  {
    "id": "handwrite-websocket",
    "title": "手写一个基础的 WebSocket",
    "difficulty": 2,
    "tags": [2],
    "description": "封装一个 WebSocket 类，实现自动重连、心跳检测、消息队列等功能。"
  },
  {
    "id": "postmessage-event-hub",
    "title": "手写基于 postMessage 的事件通信",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个基于 postMessage 的跨窗口/跨 iframe 通信机制，支持消息的发送、接收和回复。"
  },
  {
    "id": "message-channel",
    "title": "MessageChannel 通信",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 MessageChannel API 实现两个独立上下文之间的双向通信，理解端口（port）的概念和使用方式。"
  },
  {
    "id": "myUseUpdate",
    "title": "手写 useUpdate 强制渲染 Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useUpdate Hook，返回一个函数，调用该函数可以强制组件重新渲染。"
  },
  {
    "id": "myUseAsyncEffect",
    "title": "手写 useAsyncEffect Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个支持异步函数的 useAsyncEffect Hook，处理异步操作的清理和竞态条件。"
  },
  {
    "id": "myUseDebounce",
    "title": "手写 useDebounce Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useDebounce Hook，对值或函数进行防抖处理，常用于搜索输入等场景。"
  },
  {
    "id": "myUseInterval",
    "title": "手写 useInterval Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useInterval Hook，封装 setInterval，支持动态修改间隔时间，正确处理清理逻辑。"
  },
  {
    "id": "myUseState",
    "title": "手写 useState Hook",
    "difficulty": 3,
    "tags": [4],
    "description": "模拟实现 React 的 useState Hook，理解闭包、状态管理和触发重渲染的机制。"
  },
  {
    "id": "proxy",
    "title": "手写 Proxy 代理",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 Proxy 实现数据响应式，当数据变化时自动触发更新。理解 handler 中的 get、set 等捕获器。"
  },
  {
    "id": "prototype-inheritance",
    "title": "手写原型继承+组合继承",
    "difficulty": 2,
    "tags": [2],
    "description": "实现原型继承和组合继承两种方式。理解原型链继承的缺陷（引用类型共享问题），以及组合继承如何通过构造函数借用和 Object.create 来解决这些问题。"
  },
  {
    "id": "compose-middleware",
    "title": "实现 compose 函数（洋葱模型）",
    "difficulty": 3,
    "tags": [2],
    "description": "实现类似 Koa 的中间件洋葱模型 compose 函数。理解 async/await 与递归调用 next() 的执行顺序。"
  },
  {
    "id": "intersection-observer",
    "title": "Intersection Observer API 使用",
    "difficulty": 1,
    "tags": [2],
    "description": "使用 Intersection Observer API 实现元素可见性检测，常用于懒加载、无限滚动、曝光统计等场景。注意step是从初次调用开始算起的完整时间差。"
  },
  {
    "id": "raf-settimeout",
    "title": "用 requestAnimationFrame 实现 setTimeout",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 requestAnimationFrame 模拟实现 setTimeout 功能，理解两者的区别和执行时机。"
  },
  {
    "id": "object-create",
    "title": "手写 Object.create",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.create 方法，创建一个新对象，使用现有的对象作为新对象的原型。同时理解 Object.setPrototypeOf 的作用。"
  },
  {
    "id": "handwrite-instanceof",
    "title": "手写 instanceof",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 instanceof 操作符，通过遍历原型链检查对象是否是某个构造函数的实例。"
  },
  {
    "id": "ts-partial",
    "title": "实现 Partial<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Partial<T> 类型，将 T 中的所有属性变为可选。这是 TypeScript 内置工具类型之一，理解映射类型和可选修饰符 ? 的使用。"
  },
  {
    "id": "ts-required",
    "title": "实现 Required<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Required<T> 类型，将 T 中的所有属性变为必选。理解 -? 修饰符如何移除可选标记。"
  },
  {
    "id": "ts-readonly",
    "title": "实现 Readonly<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Readonly<T> 类型，将 T 中的所有属性变为只读。理解 readonly 修饰符在映射类型中的应用。"
  },
  {
    "id": "ts-pick",
    "title": "实现 Pick<T, K> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Pick<T, K> 类型，从类型 T 中选取一组属性 K 构造新类型。理解 keyof 和 extends 约束的配合使用。"
  },
  {
    "id": "ts-record",
    "title": "实现 Record<K, T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Record<K, T> 类型，构造一个对象类型，其键名类型为 K，键值类型为 T。常用于创建字典/映射类型。"
  },
  {
    "id": "ts-exclude",
    "title": "实现 Exclude<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Exclude<T, U> 类型，从联合类型 T 中排除那些可以赋值给 U 的类型。理解条件类型的分布式特性。"
  },
  {
    "id": "ts-extract",
    "title": "实现 Extract<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Extract<T, U> 类型，从联合类型 T 中提取那些可以赋值给 U 的类型。与 Exclude 相反，理解条件类型中 extends 的判断逻辑。"
  },
  {
    "id": "ts-omit",
    "title": "实现 Omit<T, K> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Omit<T, K> 类型，从类型 T 中排除一组属性 K。可以基于 Pick 和 Exclude 组合实现，理解工具类型的复合使用。"
  },
  {
    "id": "ts-nonnullable",
    "title": "实现 NonNullable<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 NonNullable<T> 类型，从联合类型 T 中排除 null 和 undefined。常用于处理可能为空的类型。"
  },
  {
    "id": "ts-merge",
    "title": "实现 Merge<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Merge<T, U> 类型，将类型 U 的属性合并到类型 T 中，如果有相同的键则 U 的类型覆盖 T。理解交叉类型与映射类型的区别。"
  },
  {
    "id": "ts-mutable",
    "title": "实现 Mutable<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Mutable<T> 类型，移除 T 中所有属性的 readonly 只读修饰符。理解 -readonly 修饰符的使用，与 Readonly 相反。"
  },
  {
    "id": "ts-tuple-to-union",
    "title": "实现 TupleToUnion<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 TupleToUnion<T> 类型，将元组类型转换为联合类型。例如 [string, number] 转为 string | number。理解元组的索引访问类型。"
  },
  {
    "id": "ts-deep-readonly",
    "title": "实现 DeepReadonly<T> 类型",
    "difficulty": 3,
    "tags": [3],
    "description": "实现一个 DeepReadonly<T> 类型，递归地将 T 中的所有属性（包括嵌套对象）变为只读。理解递归类型和条件类型的结合使用。"
  },
  {
    "id": "ts-return-type",
    "title": "实现 ReturnType<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ReturnType<T> 类型，获取函数类型 T 的返回值类型。理解 infer 关键字在条件类型中推断类型的用法。"
  },
  {
    "id": "ts-parameters",
    "title": "实现 Parameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Parameters<T> 类型，获取函数类型 T 的参数类型，返回一个元组类型。理解 infer 如何推断函数参数。"
  },
  {
    "id": "ts-constructor-parameters",
    "title": "实现 ConstructorParameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ConstructorParameters<T> 类型，获取构造函数类型 T 的参数类型元组。理解 new (...args) => any 构造签名的类型表示。"
  },
  {
    "id": "js-hoisting-function-vs-var",
    "title": "函数声明 vs 函数表达式提升",
    "difficulty": 1,
    "tags": [1],
    "description": "console.log(foo);\nconsole.log(bar);\n\nfunction foo() { return 1; }\nvar bar = function() { return 2; };\n\n// 输出什么？"
  },
  {
    "id": "js-null-vs-undefined",
    "title": "null 和 undefined 的区别",
    "difficulty": 1,
    "tags": [1],
    "description": "let a;\nlet b = null;\nfunction c() {}\nlet d = void 0;\n\nconsole.log(null == undefined);\nconsole.log(null === undefined);\nconsole.log(typeof null);\nconsole.log(typeof undefined);\n\nfunction foo(a = 1) {\n  console.log(a);\n}\nfoo(undefined);\nfoo(null);\n\n// 分别输出什么？"
  },
  {
    "id": "js-hoisting-priority",
    "title": "函数提升优先于变量提升",
    "difficulty": 2,
    "tags": [1],
    "description": "console.log(typeof a);\n\nvar a;\nfunction a() {}\nvar a = 1;\n\nconsole.log(typeof a);\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-closure-loop-var",
    "title": "闭包与 var 循环变量",
    "difficulty": 2,
    "tags": [1],
    "description": "function createFunctions() {\n  var result = [];\n  for (var i = 0; i < 3; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  return result;\n}\n\nvar funcs = createFunctions();\nconsole.log(funcs[0]());\nconsole.log(funcs[1]());\nconsole.log(funcs[2]());\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-var-hoisting-in-function",
    "title": "函数内变量提升",
    "difficulty": 1,
    "tags": [1],
    "description": "var a = 10;\nfunction foo() {\n  console.log(a);\n  var a = 20;\n}\nfoo();\n\n// 输出什么？"
  },
  {
    "id": "js-this-method-vs-function",
    "title": "this 指向：方法调用 vs 普通调用",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  sayName: function() {\n    console.log(this.name);\n  }\n};\n\nobj.sayName();\nvar fn = obj.sayName;\nfn();\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-bind-cannot-override",
    "title": "bind 绑定的 this 不可覆盖",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo() {\n  console.log(this.value);\n}\n\nvar obj1 = { value: 'obj1' };\nvar obj2 = { value: 'obj2' };\n\nvar bound = foo.bind(obj1);\nbound();\nbound.call(obj2);\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-callback-this-lost",
    "title": "回调函数中 this 丢失",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  handleClick: function() {\n    console.log(this.name);\n  }\n};\n\nobj.handleClick();\nsetTimeout(obj.handleClick, 0);\nsetTimeout(() => obj.handleClick(), 0);\n\n// 三次输出分别是什么？"
  },
  {
    "id": "js-default-param-null-undefined",
    "title": "默认参数：null vs undefined",
    "difficulty": 1,
    "tags": [1],
    "description": "function foo(a = 1, b = 2) {\n  console.log(a, b);\n}\n\nfoo(undefined, null);\n\n// 输出什么？"
  },
  {
    "id": "js-default-param-scope",
    "title": "默认参数的作用域",
    "difficulty": 2,
    "tags": [1],
    "description": "let x = 1;\nfunction foo(x, y = x + 1) {\n  console.log(y);\n}\n\nfoo(2);\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-arguments-default-param",
    "title": "arguments 与默认参数",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo(a, b = 2) {\n  console.log(arguments.length);\n  console.log(a === arguments[0]);\n  console.log(b === arguments[1]);\n}\n\nfoo(1);\n\n// 三次输出分别是什么？"
  },
  {
    "id": "js-strict-mode-this",
    "title": "严格模式下的 this",
    "difficulty": 1,
    "tags": [1],
    "description": "'use strict';\nfunction foo() {\n  console.log(this);\n}\n\nfoo();\nwindow.foo();\n\n// 两次输出分别是什么？"
  },
  {
    "id": "js-constructor-return-object",
    "title": "构造函数返回对象",
    "difficulty": 2,
    "tags": [1],
    "description": "function Person(name) {\n  this.name = name;\n  return { name: 'fake' };\n}\n\nconst p = new Person('real');\nconsole.log(p.name);\n\n// 输出什么？为什么？"
  },
  {
    "id": "js-callback-context-this",
    "title": "回调函数执行上下文中的 this",
    "difficulty": 2,
    "tags": [1],
    "description": "var a = 10;\n\nfunction foo() {\n  console.log(this.a);\n}\n\nfunction bar(fn) {\n  var a = 20;\n  fn();\n}\n\nbar(foo);\n\n// 输出什么？为什么？"
  }
]
