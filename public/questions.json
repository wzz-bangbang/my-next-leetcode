[
  {
    "id": "debounce",
    "title": "防抖",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个防抖函数 debounce，在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。常用于搜索框输入、窗口 resize 等场景。",
    "template": "function debounce(fn, delay) {\n  // 请在此实现防抖函数\n  \n}",
    "testCases": [
      {
        "input": "const log = debounce(() => console.log('called'), 100);\nlog(); log(); log(); // 连续调用3次",
        "expected": "100ms 后只输出一次 'called'",
        "description": "基础防抖：连续调用只执行最后一次"
      },
      {
        "input": "const log = debounce((x) => console.log(x), 100);\nlog(1); log(2); log(3);",
        "expected": "100ms 后输出 3",
        "description": "参数传递：应传递最后一次调用的参数"
      }
    ],
    "solution": "### 核心思路\n\n1. 使用闭包保存定时器 ID\n2. 每次调用时先清除之前的定时器\n3. 重新设置新的定时器\n\n### 关键点\n\n- **this 指向**：使用 `apply` 或 `call` 确保回调函数的 this 指向正确\n- **参数传递**：使用 `...args` 收集参数并传递给原函数\n- **返回值处理**：防抖函数通常不需要返回值，因为是异步执行\n\n### 参考实现\n\n```javascript\nfunction debounce(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n```",
    "followUp": [
      "如何实现「立即执行」版本（leading edge），即第一次调用立即执行，后续调用才防抖？",
      "如何给防抖函数添加 cancel 方法，支持手动取消？",
      "如何实现 maxWait 参数，保证即使持续触发，也会在 maxWait 时间后至少执行一次？"
    ]
  },
  {
    "id": "throttle",
    "title": "节流",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个节流函数 throttle，规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。常用于滚动加载、按钮点击等场景。",
    "template": "function throttle(fn, delay) {\n  // 请在此实现节流函数\n  \n}",
    "testCases": [
      {
        "input": "const log = throttle(() => console.log('scroll'), 100);\n// 在 250ms 内连续调用 10 次",
        "expected": "输出 2-3 次 'scroll'（首次立即执行 + 每 100ms 执行一次）",
        "description": "基础节流：固定时间间隔内只执行一次"
      },
      {
        "input": "const log = throttle((x) => console.log(x), 100);\nlog(1); setTimeout(() => log(2), 50); setTimeout(() => log(3), 150);",
        "expected": "立即输出 1，150ms 时输出 3",
        "description": "参数传递测试"
      }
    ],
    "solution": "### 核心思路\n\n节流有两种常见实现方式：\n\n#### 方式一：时间戳版（首次立即执行）\n\n```javascript\nfunction throttle(fn, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n```\n\n#### 方式二：定时器版（首次延迟执行）\n\n```javascript\nfunction throttle(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        fn.apply(this, args);\n        timer = null;\n      }, delay);\n    }\n  };\n}\n```\n\n### 关键区别\n\n| 版本 | 首次执行 | 停止触发后 |\n|------|----------|------------|\n| 时间戳版 | 立即执行 | 不会执行 |\n| 定时器版 | 延迟执行 | 会执行一次 |",
    "followUp": [
      "如何结合时间戳和定时器，实现「首次立即执行 + 停止后还会执行一次」的完整版？",
      "如何添加 leading 和 trailing 选项控制首尾执行行为？",
      "节流和防抖的应用场景有什么区别？"
    ]
  },
  {
    "id": "currying",
    "title": "函数柯里化",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个 curry 函数，将一个多参数函数转换为一系列单参数函数。例如：curry(add)(1)(2)(3) 等价于 add(1, 2, 3)。",
    "template": "function curry(fn) {\n  // 请在此实现柯里化函数\n  \n}",
    "testCases": [
      {
        "input": "const add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3));",
        "expected": "6",
        "description": "基础柯里化：逐个传参"
      },
      {
        "input": "const add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1, 2)(3));\nconsole.log(curriedAdd(1)(2, 3));",
        "expected": "6\n6",
        "description": "支持一次传多个参数"
      }
    ],
    "solution": "### 核心思路\n\n1. 获取原函数的参数个数 `fn.length`\n2. 返回一个递归函数，收集参数\n3. 当收集的参数数量 >= 原函数参数数量时，执行原函数\n\n### 参考实现\n\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    // 参数够了，执行原函数\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    // 参数不够，返回新函数继续收集\n    return function(...moreArgs) {\n      return curried.apply(this, [...args, ...moreArgs]);\n    };\n  };\n}\n```\n\n### 关键点\n\n- `fn.length` 获取函数形参个数\n- 使用闭包累积参数\n- 支持一次传多个参数的灵活调用方式",
    "followUp": [
      "如何实现支持占位符的柯里化？如 curry(add)(1, _, 3)(2) => 6",
      "柯里化在函数式编程中有哪些实际应用场景？",
      "如何实现反柯里化（uncurry）？"
    ]
  },
  {
    "id": "promise",
    "title": "手写Promise",
    "difficulty": 3,
    "tags": [2],
    "description": "根据 Promise/A+ 规范，实现一个完整的 Promise 类，包括 then、catch、finally 方法，以及 resolve、reject、all、race 等静态方法。",
    "template": "class MyPromise {\n  constructor(executor) {\n    // 在此实现\n  }\n  \n  then(onFulfilled, onRejected) {\n    // 在此实现\n  }\n  \n  catch(onRejected) {\n    // 在此实现\n  }\n  \n  static resolve(value) {\n    // 在此实现\n  }\n  \n  static reject(reason) {\n    // 在此实现\n  }\n}",
    "solution": "### 答案\n\n```javascript\nclass MyPromise {\n  static PENDING = 'pending';\n  static FULFILLED = 'fulfilled';\n  static REJECTED = 'rejected';\n  \n  constructor(executor) {\n    this.status = MyPromise.PENDING;\n    this.value = undefined;\n    this.reason = undefined;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n    \n    const resolve = (value) => {\n      if (this.status === MyPromise.PENDING) {\n        this.status = MyPromise.FULFILLED;\n        this.value = value;\n        this.onFulfilledCallbacks.forEach(fn => fn());\n      }\n    };\n    \n    const reject = (reason) => {\n      if (this.status === MyPromise.PENDING) {\n        this.status = MyPromise.REJECTED;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn());\n      }\n    };\n    \n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n  \n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n    \n    const promise2 = new MyPromise((resolve, reject) => {\n      if (this.status === MyPromise.FULFILLED) {\n        setTimeout(() => {\n          try {\n            const x = onFulfilled(this.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }\n      \n      if (this.status === MyPromise.REJECTED) {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }\n      \n      if (this.status === MyPromise.PENDING) {\n        this.onFulfilledCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onFulfilled(this.value);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n        this.onRejectedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.reason);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n      }\n    });\n    \n    return promise2;\n  }\n  \n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n  \n  static resolve(value) {\n    if (value instanceof MyPromise) return value;\n    return new MyPromise(resolve => resolve(value));\n  }\n  \n  static reject(reason) {\n    return new MyPromise((_, reject) => reject(reason));\n  }\n}\n\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (promise2 === x) {\n    return reject(new TypeError('Chaining cycle detected'));\n  }\n  if (x instanceof MyPromise) {\n    x.then(resolve, reject);\n  } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n    try {\n      const then = x.then;\n      if (typeof then === 'function') {\n        then.call(x, resolve, reject);\n      } else {\n        resolve(x);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  } else {\n    resolve(x);\n  }\n}\n```\n\n### 解析\n\n#### 核心概念\n\n1. **三种状态**：pending（等待）、fulfilled（成功）、rejected（失败）\n2. **状态不可逆**：只能从 pending 变为 fulfilled 或 rejected\n3. **链式调用**：then 返回新的 Promise\n\n#### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 回调数组 | 处理异步 resolve/reject 的情况 |\n| setTimeout | 确保 then 回调异步执行 |\n| resolvePromise | 处理返回值是 Promise 的情况 |\n| 值穿透 | onFulfilled/onRejected 不是函数时的处理 |",
    "followUp": [
      "如何实现 Promise.all、Promise.race、Promise.allSettled？",
      "如何实现 Promise.finally？",
      "什么是 Promise/A+ 规范？"
    ]
  },
  {
    "id": "reduce",
    "title": "模拟Array.reduce",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Array.prototype.reduce 方法，对数组中的每个元素执行一个 reducer 函数，将其结果汇总为单个返回值。",
    "template": "Array.prototype.myReduce = function(callback, initialValue) {\n  // 请在此实现 reduce 方法\n  \n};",
    "testCases": [
      {
        "input": "[1, 2, 3, 4].myReduce((acc, cur) => acc + cur, 0)",
        "expected": "10",
        "description": "带初始值的累加"
      },
      {
        "input": "[1, 2, 3, 4].myReduce((acc, cur) => acc + cur)",
        "expected": "10",
        "description": "不带初始值，使用数组第一个元素"
      },
      {
        "input": "[].myReduce((acc, cur) => acc + cur)",
        "expected": "TypeError",
        "description": "空数组无初始值应抛出错误"
      }
    ],
    "solution": "### 核心思路\n\n1. 处理初始值：有则使用，无则取数组第一个元素\n2. 确定遍历起点：有初始值从 0 开始，无则从 1 开始\n3. 遍历数组，调用 callback 累积结果\n\n### 参考实现\n\n```javascript\nArray.prototype.myReduce = function(callback, initialValue) {\n  if (this.length === 0 && initialValue === undefined) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n  \n  let acc = initialValue !== undefined ? initialValue : this[0];\n  let startIndex = initialValue !== undefined ? 0 : 1;\n  \n  for (let i = startIndex; i < this.length; i++) {\n    acc = callback(acc, this[i], i, this);\n  }\n  \n  return acc;\n};\n```\n\n### callback 参数说明\n\n- `accumulator`：累积值\n- `currentValue`：当前元素\n- `index`：当前索引\n- `array`：原数组",
    "followUp": [
      "如何用 reduce 实现 map、filter、flat 等数组方法？",
      "reduceRight 和 reduce 的区别是什么？如何实现？"
    ]
  },
  {
    "id": "promise-race",
    "title": "模拟Promise.race",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Promise.race 方法，返回一个 Promise，一旦迭代器中的某个 Promise 解决或拒绝，返回的 Promise 就会解决或拒绝。",
    "template": "Promise.myRace = function(promises) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "Promise.myRace([new Promise(r => setTimeout(() => r(1), 100)), new Promise(r => setTimeout(() => r(2), 50))]).then(console.log)",
        "expected": "2",
        "description": "返回最先完成的 Promise 结果"
      }
    ],
    "solution": "### 答案\n\n```javascript\nPromise.myRace = function(promises) {\n  return new Promise((resolve, reject) => {\n    for (const p of promises) {\n      Promise.resolve(p).then(resolve, reject);\n    }\n  });\n};\n```\n\n### 解析\n\n`Promise.race` 返回最先完成（无论成功或失败）的 Promise 的结果。\n\n#### 实现原理\n\n1. 返回一个新的 Promise\n2. 遍历所有 Promise，给每个都绑定 then\n3. 第一个完成的会调用 resolve 或 reject\n4. 由于 Promise 状态只能改变一次，后续的调用会被忽略\n\n#### 为什么用 Promise.resolve(p) 包装？\n\n```javascript\n// promises 数组中可能包含非 Promise 值\nPromise.race([1, Promise.resolve(2)]);\n// 需要将 1 也转换为 Promise\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 竞态 | 第一个完成的决定最终结果 |\n| Promise.resolve 包装 | 处理非 Promise 值 |\n| 状态不可逆 | 后续结果被忽略 |"
  },
  {
    "id": "promise-all",
    "title": "模拟Promise.all",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.all 方法，接收一个 Promise 数组，返回一个新的 Promise。当所有 Promise 都成功时返回结果数组，任一失败则立即拒绝。",
    "template": "Promise.myAll = function(promises) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "Promise.myAll([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then(console.log)",
        "expected": "[1, 2, 3]",
        "description": "所有成功时返回结果数组"
      },
      {
        "input": "Promise.myAll([Promise.resolve(1), Promise.reject('error'), Promise.resolve(3)]).catch(console.log)",
        "expected": "error",
        "description": "任一失败则立即拒绝"
      }
    ],
    "solution": "### 答案\n\n```javascript\nPromise.myAll = function(promises) {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let count = 0;\n    const len = promises.length;\n    \n    if (len === 0) {\n      return resolve([]);\n    }\n    \n    promises.forEach((p, index) => {\n      Promise.resolve(p).then(\n        (value) => {\n          results[index] = value;  // 保持顺序\n          count++;\n          if (count === len) {\n            resolve(results);\n          }\n        },\n        (reason) => {\n          reject(reason);  // 任一失败立即拒绝\n        }\n      );\n    });\n  });\n};\n```\n\n### 解析\n\n`Promise.all` 等待所有 Promise 都成功，返回结果数组；任一失败则立即拒绝。\n\n#### 实现要点\n\n1. **保持顺序**：`results[index] = value`，不能用 push\n2. **计数完成**：用 count 记录完成数量，而不是 results.length\n3. **快速失败**：任一 reject 立即返回\n4. **空数组处理**：直接 resolve([])\n\n#### 为什么不能用 results.length 判断？\n\n```javascript\n// 异步完成顺序不确定\npromises[2] 可能先完成 → results[2] = value\n// 此时 results.length 是 3，但 results[0] 和 results[1] 还是空的\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 保持顺序 | 用索引赋值，不用 push |\n| 计数器 | 用独立变量计数完成数量 |\n| 快速失败 | 任一失败立即 reject |"
  },
  {
    "id": "promise-any",
    "title": "模拟Promise.any",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Promise.any 方法，接收一个 Promise 数组，只要其中一个 Promise 成功，就返回那个成功的 Promise。如果全部失败，则返回一个 AggregateError。",
    "template": "Promise.myAny = function(promises) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "Promise.myAny([Promise.reject(1), Promise.resolve(2), Promise.reject(3)]).then(console.log)",
        "expected": "2",
        "description": "返回第一个成功的结果"
      }
    ],
    "solution": "### 答案\n\n```javascript\nPromise.myAny = function(promises) {\n  return new Promise((resolve, reject) => {\n    const errors = [];\n    let count = 0;\n    const len = promises.length;\n    \n    if (len === 0) {\n      return reject(new AggregateError([], 'All promises were rejected'));\n    }\n    \n    promises.forEach((p, index) => {\n      Promise.resolve(p).then(\n        (value) => {\n          resolve(value);  // 任一成功立即返回\n        },\n        (reason) => {\n          errors[index] = reason;\n          count++;\n          if (count === len) {\n            reject(new AggregateError(errors, 'All promises were rejected'));\n          }\n        }\n      );\n    });\n  });\n};\n```\n\n### 解析\n\n`Promise.any` 与 `Promise.all` 相反：任一成功则成功，全部失败才失败。\n\n#### 对比 Promise.all 和 Promise.any\n\n| 方法 | 成功条件 | 失败条件 |\n|------|----------|----------|\n| Promise.all | 全部成功 | 任一失败 |\n| Promise.any | 任一成功 | 全部失败 |\n| Promise.race | 第一个完成（无论成功失败） | - |\n\n#### AggregateError\n\n```javascript\n// ES2021 新增的错误类型，用于包装多个错误\nnew AggregateError(errors, message)\n// errors: 错误数组\n// message: 错误消息\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 快速成功 | 任一成功立即 resolve |\n| 收集错误 | 保持错误顺序 |\n| AggregateError | 全部失败时的错误类型 |"
  },
  {
    "id": "deep-clone",
    "title": "实现深拷贝（Deep Clone）",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深拷贝函数，能够处理基本类型、对象、数组，并解决循环引用问题。",
    "template": "function deepClone(obj, map = new WeakMap()) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "const obj = { a: 1, b: { c: 2 } };\nconst cloned = deepClone(obj);\ncloned.b.c = 999;",
        "expected": "obj.b.c 仍然是 2（原对象不受影响）",
        "description": "深拷贝后修改不影响原对象"
      }
    ],
    "solution": "### 答案（基础版）\n\n```javascript\nfunction deepClone(obj, map = new WeakMap()) {\n  // 处理 null 和基本类型\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // 处理循环引用\n  if (map.has(obj)) {\n    return map.get(obj);\n  }\n  \n  // 处理数组和普通对象\n  const cloned = Array.isArray(obj) ? [] : {};\n  map.set(obj, cloned);\n  \n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      cloned[key] = deepClone(obj[key], map);\n    }\n  }\n  \n  return cloned;\n}\n```\n\n### 解析\n\n#### 为什么要判断 `obj === null`？\n\n```javascript\ntypeof null === 'object';  // true（JavaScript 历史遗留 bug）\n\n// 如果不单独判断 null，会走到后面的对象处理逻辑\n// for...in 遍历 null 会报错\n```\n\n#### 为什么用 `for...in` + `hasOwnProperty`？\n\n```javascript\n// for...in 会遍历原型链上的属性\nconst parent = { inherited: 1 };\nconst obj = Object.create(parent);\nobj.own = 2;\n\nfor (const key in obj) {\n  console.log(key);  // 输出: own, inherited\n}\n\n// hasOwnProperty 过滤掉继承的属性\nfor (const key in obj) {\n  if (obj.hasOwnProperty(key)) {\n    console.log(key);  // 只输出: own\n  }\n}\n```\n\n#### 循环引用处理\n\n```javascript\nconst obj = { a: 1 };\nobj.self = obj;  // 循环引用\n\n// 克隆时用 WeakMap 记录已处理对象：\n// 1. 创建 cloned，map.set(obj, cloned)\n// 2. 克隆 obj.self 时发现 map.has(obj)，直接返回 cloned\n```\n\n### 进阶思考\n\n处理特殊类型：\n\n```javascript\n// Date\nif (obj instanceof Date) return new Date(obj);\n\n// RegExp\nif (obj instanceof RegExp) return new RegExp(obj);\n\n// Map\nif (obj instanceof Map) {\n  const cloned = new Map();\n  map.set(obj, cloned);\n  obj.forEach((v, k) => cloned.set(deepClone(k, map), deepClone(v, map)));\n  return cloned;\n}\n\n// Set\nif (obj instanceof Set) {\n  const cloned = new Set();\n  map.set(obj, cloned);\n  obj.forEach(v => cloned.add(deepClone(v, map)));\n  return cloned;\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| null 判断 | typeof null === 'object' |\n| for...in | 遍历对象属性 |\n| hasOwnProperty | 过滤继承属性 |\n| WeakMap | 处理循环引用 |",
    "followUp": [
      "如何处理函数的拷贝？",
      "structuredClone 和手写深拷贝的区别？",
      "JSON.parse(JSON.stringify()) 的局限性？"
    ]
  },
  {
    "id": "event-emitter",
    "title": "实现 EventEmitter 类",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个发布订阅模式的 EventEmitter 类，包含 on（订阅）、off（取消订阅）、emit（发布）、once（只订阅一次）等方法。",
    "template": "class EventEmitter {\n  constructor() {\n    // 在此实现\n  }\n  \n  on(event, callback) {\n    // 在此实现\n  }\n  \n  off(event, callback) {\n    // 在此实现\n  }\n  \n  emit(event, ...args) {\n    // 在此实现\n  }\n  \n  once(event, callback) {\n    // 在此实现\n  }\n}",
    "testCases": [
      {
        "input": "const ee = new EventEmitter();\nee.on('click', (x) => console.log(x));\nee.emit('click', 'hello');",
        "expected": "hello",
        "description": "基础订阅和发布"
      },
      {
        "input": "const ee = new EventEmitter();\nee.once('click', (x) => console.log(x));\nee.emit('click', 1);\nee.emit('click', 2);",
        "expected": "1",
        "description": "once 只触发一次"
      }
    ],
    "solution": "### 答案\n\n```javascript\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n    return this;  // 支持链式调用\n  }\n  \n  off(event, callback) {\n    if (!this.events[event]) return this;\n    \n    if (!callback) {\n      // 没有指定回调，移除该事件所有监听器\n      delete this.events[event];\n    } else {\n      this.events[event] = this.events[event].filter(\n        cb => cb !== callback && cb.originalCallback !== callback\n      );\n    }\n    return this;\n  }\n  \n  emit(event, ...args) {\n    if (!this.events[event]) return false;\n    \n    this.events[event].forEach(callback => {\n      callback.apply(this, args);\n    });\n    return true;\n  }\n  \n  once(event, callback) {\n    const wrapper = (...args) => {\n      callback.apply(this, args);\n      this.off(event, wrapper);\n    };\n    wrapper.originalCallback = callback;  // 保存原始回调，用于 off\n    this.on(event, wrapper);\n    return this;\n  }\n}\n```\n\n### 解析\n\n#### 发布订阅模式\n\n```\n订阅者 A ─┐\n订阅者 B ─┼─→ EventEmitter ←─ 发布者\n订阅者 C ─┘\n\n发布者不需要知道订阅者是谁，通过事件中心解耦\n```\n\n#### 方法说明\n\n| 方法 | 作用 |\n|------|------|\n| on | 添加监听器 |\n| off | 移除监听器 |\n| emit | 触发事件 |\n| once | 只触发一次的监听器 |\n\n#### once 的实现技巧\n\n```javascript\n// 包装原回调，执行后自动移除\nconst wrapper = (...args) => {\n  callback(...args);\n  this.off(event, wrapper);\n};\n// 保存原始回调，以便 off(event, originalCallback) 能正确移除\nwrapper.originalCallback = callback;\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| events 对象 | 存储事件和回调的映射 |\n| 链式调用 | 返回 this |\n| once 实现 | 包装器 + originalCallback |",
    "followUp": [
      "如何实现 removeAllListeners？",
      "如何限制同一事件的最大监听器数量？",
      "与观察者模式的区别是什么？"
    ]
  },
  {
    "id": "handwrite-call",
    "title": "手写 call 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.call 方法，在调用一个函数时，可以指定 this 的指向，并传入参数列表。",
    "template": "Function.prototype.myCall = function(context, ...args) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "function greet(greeting) { return `${greeting}, ${this.name}`; }\nconsole.log(greet.myCall({ name: 'Alice' }, 'Hello'));",
        "expected": "Hello, Alice",
        "description": "基础调用：指定 this 和参数"
      },
      {
        "input": "function test() { return this; }\nconsole.log(test.myCall(null) === globalThis);",
        "expected": "true",
        "description": "context 为 null 时指向全局对象"
      }
    ],
    "solution": "### 答案\n\n```javascript\nFunction.prototype.myCall = function(context, ...args) {\n  // 处理 null 和 undefined\n  context = context ?? globalThis;\n  // 基本类型转为对象\n  context = Object(context);\n  \n  // 使用 Symbol 避免属性冲突\n  const fn = Symbol('fn');\n  context[fn] = this;\n  \n  // 调用函数\n  const result = context[fn](...args);\n  \n  // 删除临时属性\n  delete context[fn];\n  \n  return result;\n};\n```\n\n### 解析\n\n#### 核心原理\n\n利用「谁调用函数，this 就指向谁」的规则：\n\n```javascript\nconst obj = {\n  fn: function() { return this; }\n};\nobj.fn() === obj;  // true\n\n// 所以把函数挂到 context 上，通过 context 调用\ncontext.fn = this;  // this 是要调用的函数\ncontext.fn(...args);  // this 就指向 context 了\n```\n\n#### 为什么用 Symbol？\n\n```javascript\n// 如果用普通字符串作为属性名\ncontext.fn = this;\n// 可能覆盖 context 原有的 fn 属性\n\n// Symbol 是唯一的，不会冲突\nconst fn = Symbol('fn');\ncontext[fn] = this;\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| null/undefined | 转为 globalThis |\n| 基本类型 | Object() 转为包装对象 |\n| Symbol | 避免属性名冲突 |\n| delete | 调用后清理临时属性 |"
  },
  {
    "id": "handwrite-apply",
    "title": "手写 apply 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Function.prototype.apply 方法，与 call 类似，但接收的是参数数组而非参数列表。",
    "template": "Function.prototype.myApply = function(context, args) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "function sum(a, b) { return a + b + this.base; }\nconsole.log(sum.myApply({ base: 10 }, [1, 2]));",
        "expected": "13",
        "description": "基础调用：参数以数组形式传入"
      }
    ],
    "solution": "### 答案\n\n```javascript\nFunction.prototype.myApply = function(context, args = []) {\n  context = context ?? globalThis;\n  context = Object(context);\n  \n  const fn = Symbol('fn');\n  context[fn] = this;\n  \n  const result = context[fn](...args);\n  \n  delete context[fn];\n  \n  return result;\n};\n```\n\n### 解析\n\n`apply` 与 `call` 的唯一区别是参数传递方式：\n\n| 方法 | 参数传递 |\n|------|----------|\n| call | fn.call(ctx, arg1, arg2, arg3) |\n| apply | fn.apply(ctx, [arg1, arg2, arg3]) |\n\n#### 实现区别\n\n```javascript\n// call: 剩余参数\nFunction.prototype.myCall = function(context, ...args) {\n  // ...\n  context[fn](...args);\n};\n\n// apply: 数组参数\nFunction.prototype.myApply = function(context, args = []) {\n  // ...\n  context[fn](...args);  // 展开数组\n};\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| args = [] | 处理不传参数的情况 |\n| ...args | 展开数组作为参数 |"
  },
  {
    "id": "handwrite-bind",
    "title": "手写 bind 函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 Function.prototype.bind 方法，创建一个新的函数，在调用时设置 this 关键字为提供的值。需要考虑作为构造函数使用的情况。",
    "template": "Function.prototype.myBind = function(context, ...args) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "const obj = { name: 'test' };\nfunction greet(msg) { return msg + ', ' + this.name; }\nconst bound = greet.myBind(obj);\nbound('Hello');",
        "expected": "'Hello, test'",
        "description": "绑定 this 并传递参数"
      }
    ],
    "solution": "### 答案\n\n```javascript\nFunction.prototype.myBind = function(context, ...args) {\n  const fn = this;\n  \n  const boundFn = function(...innerArgs) {\n    // 判断是否作为构造函数调用（new 调用）\n    // 如果是 new 调用，this 指向新创建的实例\n    return fn.apply(\n      this instanceof boundFn ? this : context,\n      [...args, ...innerArgs]\n    );\n  };\n  \n  // 维护原型链\n  if (fn.prototype) {\n    boundFn.prototype = Object.create(fn.prototype);\n  }\n  \n  return boundFn;\n};\n```\n\n### 解析\n\n`bind` 方法创建一个新函数，调用时 `this` 被设为指定值，并可预设部分参数。\n\n#### 核心要点\n\n1. **保存原函数引用**：`const fn = this`\n2. **返回新函数**：返回的函数可以继续接收参数\n3. **参数合并**：预设参数 + 调用时参数\n4. **处理 new 调用**：作为构造函数时，`this` 应指向新实例\n\n#### 为什么要判断 `this instanceof boundFn`？\n\n```javascript\nfunction Person(name) { this.name = name; }\nconst BoundPerson = Person.bind({ ignored: true });\n\n// 普通调用\nBoundPerson('Tom');  // this 指向 { ignored: true }\n\n// new 调用\nconst p = new BoundPerson('Tom');  // this 应该指向新实例 p\nconsole.log(p.name);  // 'Tom'\n```\n\n当使用 `new` 调用时：\n- `this instanceof boundFn` 为 `true`\n- 此时应该让 `this` 指向新创建的实例，而非绑定的 context\n\n#### 为什么要设置 prototype？\n\n```javascript\nfunction Person(name) { this.name = name; }\nPerson.prototype.sayHi = function() { return 'Hi, ' + this.name; };\n\nconst BoundPerson = Person.myBind(null);\nconst p = new BoundPerson('Tom');\n\nconsole.log(p.sayHi());  // 'Hi, Tom' - 需要继承原型方法\nconsole.log(p instanceof Person);  // true\n```\n\n设置 `boundFn.prototype = Object.create(fn.prototype)` 确保：\n- 通过 `new boundFn()` 创建的实例能访问原函数的原型方法\n- `instanceof` 判断正确工作\n\n#### 简化版（不考虑 new）\n\n```javascript\nFunction.prototype.myBind = function(context, ...args) {\n  const fn = this;\n  return function(...innerArgs) {\n    return fn.apply(context, [...args, ...innerArgs]);\n  };\n};\n```\n\n#### bind vs call vs apply\n\n| 方法 | 调用时机 | 返回值 |\n|------|----------|--------|\n| call | 立即调用 | 函数执行结果 |\n| apply | 立即调用 | 函数执行结果 |\n| bind | 返回新函数 | 绑定后的新函数 |\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 返回新函数 | 不立即执行，返回绑定后的函数 |\n| 参数合并 | 支持预设参数（柯里化） |\n| new 调用处理 | 作为构造函数时 this 指向新实例 |\n| 原型链维护 | 确保 instanceof 正确工作 |"
  },
  {
    "id": "handwrite-new",
    "title": "手写 new 操作符",
    "difficulty": 2,
    "tags": [2],
    "description": "实现 new 操作符的功能：创建新对象、设置原型链、执行构造函数、返回对象。",
    "template": "function myNew(Constructor, ...args) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "function Person(name) { this.name = name; }\nconst p = myNew(Person, 'Tom');",
        "expected": "p.name === 'Tom'，p instanceof Person === true",
        "description": "模拟 new 操作符创建实例"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction myNew(Constructor, ...args) {\n  // 1. 创建一个新对象，原型指向构造函数的 prototype\n  const obj = Object.create(Constructor.prototype);\n  \n  // 2. 执行构造函数，绑定 this 到新对象\n  const result = Constructor.apply(obj, args);\n  \n  // 3. 如果构造函数返回对象，则返回该对象；否则返回新创建的对象\n  return result instanceof Object ? result : obj;\n}\n```\n\n### 解析\n\n`new` 操作符做了四件事：\n\n1. 创建一个空对象\n2. 将对象的原型指向构造函数的 `prototype`\n3. 执行构造函数，`this` 指向新对象\n4. 返回新对象（除非构造函数返回了一个对象）\n\n#### 详细步骤\n\n```javascript\nfunction myNew(Constructor, ...args) {\n  // 步骤 1 & 2：创建对象并设置原型\n  const obj = Object.create(Constructor.prototype);\n  // 等价于：\n  // const obj = {};\n  // obj.__proto__ = Constructor.prototype;\n  \n  // 步骤 3：执行构造函数\n  const result = Constructor.apply(obj, args);\n  \n  // 步骤 4：处理返回值\n  return result instanceof Object ? result : obj;\n}\n```\n\n#### 为什么要检查返回值？\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  // 没有显式返回，默认返回 undefined\n}\n\nfunction Factory(name) {\n  this.name = name;\n  return { custom: 'object' };  // 返回了一个对象\n}\n\nconst p1 = new Person('Tom');\nconsole.log(p1.name);  // 'Tom' - 返回新创建的实例\n\nconst p2 = new Factory('Tom');\nconsole.log(p2.custom);  // 'object' - 返回构造函数返回的对象\nconsole.log(p2.name);    // undefined - name 属性没了\n```\n\n规则：\n- 构造函数返回**对象**：返回该对象\n- 构造函数返回**原始值**或**不返回**：返回新创建的实例\n\n#### 为什么用 `result instanceof Object`？\n\n```javascript\n// 需要区分对象和原始值\ntypeof {} === 'object'        // true\ntypeof null === 'object'      // true（历史遗留 bug）\ntypeof function(){} === 'function'  // true（不是 'object'）\n\n// instanceof Object 更准确\n{} instanceof Object          // true\nnull instanceof Object        // false\n(() => {}) instanceof Object  // true（函数也是对象）\n```\n\n#### Object.create 做了什么？\n\n```javascript\n// Object.create(proto) 创建一个新对象，其 __proto__ 指向 proto\nconst obj = Object.create(Constructor.prototype);\n\n// 等价于\nconst obj = {};\nObject.setPrototypeOf(obj, Constructor.prototype);\n\n// 或者\nconst obj = {};\nobj.__proto__ = Constructor.prototype;\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Object.create | 创建新对象并设置原型 |\n| apply | 执行构造函数并绑定 this |\n| 返回值检查 | 构造函数返回对象则使用该对象 |\n| instanceof Object | 判断是否为对象（包括函数） |"
  },
  {
    "id": "array-unique",
    "title": "手写数组去重函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组去重函数，可以使用 Set、filter、reduce 等多种方式实现。考虑对象、NaN 等特殊值的处理。",
    "template": "function unique(arr) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "unique([1, 2, 2, 3, 3, 3])",
        "expected": "[1, 2, 3]",
        "description": "基础去重"
      },
      {
        "input": "unique([1, '1', 2, '2'])",
        "expected": "[1, '1', 2, '2']（类型不同不去重）",
        "description": "区分类型"
      }
    ],
    "solution": "### 答案\n\n```javascript\n// 方式一：Set（推荐，最简洁）\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n// 方式二：filter + indexOf\nfunction unique(arr) {\n  return arr.filter((item, index) => arr.indexOf(item) === index);\n}\n\n// 方式三：reduce\nfunction unique(arr) {\n  return arr.reduce((acc, cur) => {\n    if (!acc.includes(cur)) {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n```\n\n### 解析\n\n#### 方式对比\n\n| 方式 | 优点 | 缺点 |\n|------|------|------|\n| Set | 简洁、高效 O(n) | 无法自定义比较逻辑 |\n| filter + indexOf | 直观 | O(n²)，indexOf 对 NaN 返回 -1 |\n| reduce | 灵活 | O(n²)，includes 对 NaN 正确处理 |\n\n#### NaN 的特殊性\n\n```javascript\nNaN === NaN;  // false\nNaN !== NaN;  // true\n\n// indexOf 找不到 NaN\n[NaN, 1].indexOf(NaN);  // -1\n\n// includes 可以找到 NaN\n[NaN, 1].includes(NaN);  // true\n\n// Set 也可以正确处理 NaN\nnew Set([NaN, NaN]);  // Set { NaN }\n```\n\n#### 对象去重问题\n\n```javascript\nconst obj = { a: 1 };\nunique([obj, obj, { a: 1 }]);\n// [{ a: 1 }, { a: 1 }]\n// 因为 obj !== { a: 1 }，引用不同\n\n// 如果需要按内容去重，需要自定义比较\nfunction uniqueByKey(arr, key) {\n  const seen = new Set();\n  return arr.filter(item => {\n    const k = typeof key === 'function' ? key(item) : item[key];\n    if (seen.has(k)) return false;\n    seen.add(k);\n    return true;\n  });\n}\n\nuniqueByKey([{id: 1}, {id: 1}, {id: 2}], 'id');\n// [{id: 1}, {id: 2}]\n```\n\n#### 使用 Map 去重（保留最后出现的）\n\n```javascript\nfunction unique(arr) {\n  const map = new Map();\n  arr.forEach(item => map.set(item, item));\n  return [...map.values()];\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Set | 最简洁，自动处理 NaN |\n| indexOf vs includes | indexOf 对 NaN 返回 -1 |\n| 对象去重 | 默认按引用比较，需自定义逻辑 |"
  },
  {
    "id": "array-flatten",
    "title": "手写数组扁平化函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个数组扁平化函数 flatten，将多维数组转换为一维数组。可以指定扁平化的深度。",
    "template": "function flatten(arr, depth = Infinity) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "flatten([1, [2, [3, [4]]]])",
        "expected": "[1, 2, 3, 4]",
        "description": "完全扁平化"
      },
      {
        "input": "flatten([1, [2, [3, [4]]]], 1)",
        "expected": "[1, 2, [3, [4]]]",
        "description": "指定深度扁平化"
      }
    ],
    "solution": "### 答案\n\n```javascript\n// 方式一：递归（推荐）\nfunction flatten(arr, depth = Infinity) {\n  if (depth < 1) return arr.slice();\n  \n  return arr.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      acc.push(...flatten(cur, depth - 1));\n    } else {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n\n// 方式二：使用原生 flat\nfunction flatten(arr, depth = Infinity) {\n  return arr.flat(depth);\n}\n\n// 方式三：迭代（栈）\nfunction flatten(arr, depth = Infinity) {\n  const stack = arr.map(item => [item, depth]);\n  const result = [];\n  \n  while (stack.length) {\n    const [item, d] = stack.pop();\n    if (Array.isArray(item) && d > 0) {\n      stack.push(...item.map(i => [i, d - 1]));\n    } else {\n      result.push(item);\n    }\n  }\n  \n  return result.reverse();\n}\n```\n\n### 解析\n\n#### 递归思路\n\n1. 遍历数组每个元素\n2. 如果是数组，递归调用并减少深度\n3. 如果不是数组，直接添加到结果\n4. 当 depth 为 0 时，不再展开\n\n#### 深度参数说明\n\n```javascript\nconst arr = [1, [2, [3, [4]]]];\n\nflatten(arr, 1);       // [1, 2, [3, [4]]] - 只展开一层\nflatten(arr, 2);       // [1, 2, 3, [4]] - 展开两层\nflatten(arr, Infinity); // [1, 2, 3, 4] - 完全展开\n```\n\n#### 简化版（完全扁平化）\n\n```javascript\n// 使用 concat + 递归\nfunction flatten(arr) {\n  return arr.reduce((acc, cur) => \n    acc.concat(Array.isArray(cur) ? flatten(cur) : cur)\n  , []);\n}\n\n// 使用 toString（仅限数字/字符串数组）\nfunction flatten(arr) {\n  return arr.toString().split(',').map(Number);\n}\n// 注意：[1, [2, '3']].toString() = '1,2,3'\n```\n\n#### 使用生成器\n\n```javascript\nfunction* flattenGen(arr, depth = Infinity) {\n  for (const item of arr) {\n    if (Array.isArray(item) && depth > 0) {\n      yield* flattenGen(item, depth - 1);\n    } else {\n      yield item;\n    }\n  }\n}\n\nconst flatten = (arr, depth) => [...flattenGen(arr, depth)];\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Array.isArray | 判断是否为数组 |\n| depth 参数 | 控制展开深度 |\n| reduce | 遍历并累积结果 |\n| 递归终止 | depth <= 0 时停止展开 |"
  },
  {
    "id": "deep-equal",
    "title": "手写深度比较函数",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个深度比较函数 deepEqual，比较两个值是否完全相等，支持对象、数组、Date、RegExp 等类型的比较。",
    "template": "function deepEqual(a, b) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "deepEqual({a: 1, b: {c: 2}}, {a: 1, b: {c: 2}})",
        "expected": "true",
        "description": "嵌套对象深度比较"
      },
      {
        "input": "deepEqual({a: 1}, {a: 1, b: 2})",
        "expected": "false（属性数量不同）",
        "description": "属性数量不同返回 false"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction deepEqual(a, b) {\n  // 1. 严格相等（包括 +0 === -0）\n  if (a === b) return true;\n  \n  // 2. 处理 NaN\n  if (Number.isNaN(a) && Number.isNaN(b)) return true;\n  \n  // 3. 处理 null 或非对象\n  if (a === null || b === null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // 4. 处理 Date\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  \n  // 5. 处理 RegExp\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.toString() === b.toString();\n  }\n  \n  // 6. 处理数组\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n  \n  // 7. 比较对象的 key 数量\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  \n  // 8. 递归比较每个属性\n  for (const key of keysA) {\n    if (!keysB.includes(key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n  \n  return true;\n}\n```\n\n### 解析\n\n#### 处理顺序\n\n1. **严格相等**：基本类型和相同引用直接返回 true\n2. **NaN**：`NaN !== NaN`，需要特殊处理\n3. **null**：`typeof null === 'object'`，需要提前排除\n4. **Date/RegExp**：特殊对象类型的比较\n5. **数组/对象**：递归比较属性\n\n#### 特殊值处理\n\n```javascript\n// NaN\nNaN === NaN;  // false\nNumber.isNaN(NaN);  // true\n\n// +0 和 -0\n+0 === -0;  // true\nObject.is(+0, -0);  // false（更严格）\n\n// null\ntypeof null;  // 'object'\nnull === null;  // true\n```\n\n#### 使用 Object.is 的版本\n\n```javascript\nfunction deepEqual(a, b) {\n  // Object.is 处理 NaN 和 +0/-0\n  if (Object.is(a, b)) return true;\n  \n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a === null || b === null) return false;\n  \n  // ... 后续相同\n}\n```\n\n#### 处理循环引用\n\n```javascript\nfunction deepEqual(a, b, seen = new WeakMap()) {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a === null || b === null) return false;\n  \n  // 检查循环引用\n  if (seen.has(a)) return seen.get(a) === b;\n  seen.set(a, b);\n  \n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  \n  for (const key of keysA) {\n    if (!deepEqual(a[key], b[key], seen)) return false;\n  }\n  \n  return true;\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| NaN 处理 | Number.isNaN 或 Object.is |\n| null 检查 | typeof null === 'object' |\n| Date/RegExp | 转换为可比较的值 |\n| 递归比较 | 遍历所有属性 |\n| 循环引用 | WeakMap 记录已比较对象 |"
  },
  {
    "id": "lru-cache",
    "title": "实现 LRU 缓存机制",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "实现一个 LRU (Least Recently Used) 缓存，支持 get 和 put 操作，当缓存容量达到上限时，删除最近最少使用的数据。要求时间复杂度为 O(1)。",
    "template": "class LRUCache {\n  constructor(capacity) {\n    // 在此实现\n  }\n  \n  get(key) {\n    // 在此实现\n  }\n  \n  put(key, value) {\n    // 在此实现\n  }\n}",
    "testCases": [
      {
        "input": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);\ncache.put(3, 3);",
        "expected": "get(1)=1, put(3)后 key=2 被淘汰，get(2)=-1",
        "description": "LRU淘汰最近最少使用的数据"
      }
    ],
    "solution": "### 答案\n\n```javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();  // Map 保持插入顺序\n  }\n  \n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    \n    // 访问后移到最新位置\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    \n    return value;\n  }\n  \n  put(key, value) {\n    // 如果已存在，先删除（为了更新顺序）\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    \n    this.cache.set(key, value);\n    \n    // 超出容量，删除最老的（Map 的第一个元素）\n    if (this.cache.size > this.capacity) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n  }\n}\n```\n\n### 解析\n\nLRU（Least Recently Used）缓存淘汰最近最少使用的数据。\n\n#### 为什么用 Map？\n\n- **Map 保持插入顺序**：第一个元素是最老的，最后一个是最新的\n- **O(1) 操作**：get、set、delete、has 都是 O(1)\n- **keys().next().value**：获取第一个 key（最老的）\n\n#### 核心逻辑\n\n```javascript\n// get 操作：访问后移到最新位置\nget(key) {\n  // 删除再添加 = 移到末尾\n  const value = this.cache.get(key);\n  this.cache.delete(key);\n  this.cache.set(key, value);\n}\n\n// put 操作：添加/更新后检查容量\nput(key, value) {\n  this.cache.delete(key);  // 如果存在先删除\n  this.cache.set(key, value);  // 添加到末尾\n  \n  if (this.cache.size > this.capacity) {\n    // 删除第一个（最老的）\n    this.cache.delete(this.cache.keys().next().value);\n  }\n}\n```\n\n#### 双向链表 + HashMap 实现（经典面试版）\n\n```javascript\nclass Node {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n    \n    // 虚拟头尾节点\n    this.head = new Node(0, 0);\n    this.tail = new Node(0, 0);\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  \n  // 将节点移到头部（最新）\n  moveToHead(node) {\n    this.removeNode(node);\n    this.addToHead(node);\n  }\n  \n  removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  \n  addToHead(node) {\n    node.next = this.head.next;\n    node.prev = this.head;\n    this.head.next.prev = node;\n    this.head.next = node;\n  }\n  \n  removeTail() {\n    const node = this.tail.prev;\n    this.removeNode(node);\n    return node;\n  }\n  \n  get(key) {\n    if (!this.map.has(key)) return -1;\n    const node = this.map.get(key);\n    this.moveToHead(node);\n    return node.value;\n  }\n  \n  put(key, value) {\n    if (this.map.has(key)) {\n      const node = this.map.get(key);\n      node.value = value;\n      this.moveToHead(node);\n    } else {\n      const node = new Node(key, value);\n      this.map.set(key, node);\n      this.addToHead(node);\n      \n      if (this.map.size > this.capacity) {\n        const tail = this.removeTail();\n        this.map.delete(tail.key);\n      }\n    }\n  }\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Map 保持顺序 | 利用 Map 的插入顺序特性 |\n| 删除再添加 | 实现移到末尾的效果 |\n| O(1) 时间复杂度 | Map 或 HashMap + 双向链表 |\n| 淘汰策略 | 删除最老的（Map 第一个元素） |"
  },
  {
    "id": "async-concurrency-controller",
    "title": "手写异步并发控制器",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "实现一个异步任务调度器，可以控制同时执行的异步任务数量。当正在执行的任务数小于限制时，立即执行新任务；否则将任务加入等待队列。",
    "template": "function asyncPool(limit, tasks) {\n  // 在此实现\n  // tasks 是返回 Promise 的函数数组\n  // 返回 Promise，resolve 所有结果\n}",
    "testCases": [
      {
        "input": "const tasks = [\n  () => delay(100, 1),\n  () => delay(50, 2),\n  () => delay(80, 3)\n];\nasyncPool(2, tasks);",
        "expected": "[1, 2, 3]（按原顺序返回结果）",
        "description": "并发数为2，控制同时执行的任务数"
      }
    ],
    "solution": "### 答案\n\n```javascript\nasync function asyncPool(limit, tasks) {\n  const results = [];\n  const executing = new Set();\n  \n  for (const [index, task] of tasks.entries()) {\n    // 包装任务，记录结果\n    const promise = Promise.resolve().then(() => task()).then(\n      result => { results[index] = result; }\n    );\n    \n    executing.add(promise);\n    \n    // 任务完成后从 executing 中移除\n    promise.finally(() => executing.delete(promise));\n    \n    // 达到并发限制，等待任意一个完成\n    if (executing.size >= limit) {\n      await Promise.race(executing);\n    }\n  }\n  \n  // 等待所有剩余任务完成\n  await Promise.all(executing);\n  \n  return results;\n}\n```\n\n### 解析\n\n并发控制的核心是：**控制同时执行的 Promise 数量**。\n\n#### 执行流程\n\n```javascript\n// limit = 2, tasks = [t1, t2, t3, t4]\n\n// 第1次循环：执行 t1，executing = [t1]\n// 第2次循环：执行 t2，executing = [t1, t2]，达到限制\n// await Promise.race([t1, t2]) - 假设 t2 先完成\n// 第3次循环：执行 t3，executing = [t1, t3]\n// await Promise.race([t1, t3]) - 假设 t1 先完成\n// 第4次循环：执行 t4，executing = [t3, t4]\n// 循环结束，await Promise.all([t3, t4])\n```\n\n#### 关键点解析\n\n1. **Promise.race**：等待任意一个 Promise 完成\n2. **Set 存储执行中任务**：方便删除已完成的\n3. **finally 清理**：无论成功失败都从 Set 中移除\n4. **保持结果顺序**：使用 index 确保结果顺序与输入一致\n\n#### 类的实现方式\n\n```javascript\nclass AsyncPool {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.running = 0;\n  }\n  \n  add(task) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ task, resolve, reject });\n      this.run();\n    });\n  }\n  \n  run() {\n    while (this.running < this.limit && this.queue.length) {\n      const { task, resolve, reject } = this.queue.shift();\n      this.running++;\n      \n      Promise.resolve()\n        .then(() => task())\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          this.running--;\n          this.run();\n        });\n    }\n  }\n}\n\n// 使用\nconst pool = new AsyncPool(2);\nPromise.all([\n  pool.add(() => delay(100, 1)),\n  pool.add(() => delay(50, 2)),\n  pool.add(() => delay(80, 3)),\n]).then(console.log);\n```\n\n#### 简化版（使用递归）\n\n```javascript\nfunction asyncPool(limit, tasks) {\n  let index = 0;\n  const results = [];\n  \n  const worker = async () => {\n    while (index < tasks.length) {\n      const i = index++;\n      results[i] = await tasks[i]();\n    }\n  };\n  \n  // 启动 limit 个 worker\n  const workers = Array(Math.min(limit, tasks.length))\n    .fill(null)\n    .map(() => worker());\n  \n  return Promise.all(workers).then(() => results);\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Promise.race | 等待任意一个完成后继续 |\n| Set 管理执行中任务 | 方便添加和删除 |\n| 保持顺序 | 使用 index 记录结果位置 |\n| finally 清理 | 确保任务完成后释放槽位 |"
  },
  {
    "id": "class-scheduler",
    "title": "并发限制的异步调度器类",
    "difficulty": 3,
    "tags": [2, 6],
    "description": "并发限制的异步调度器:保证同时运行的任务最多有两个，完善代码中Scheduler类，使得以下程序能正确输出",
    "template": "class Scheduler {\n  constructor(limit) {\n    this.limit = limit;\n    // 在此实现\n  }\n  \n  add(promiseCreator) {\n    // 在此实现\n  }\n}",
    "testCases": [
      {
        "input": "addTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');",
        "expected": "输出顺序: 2 3 1 4",
        "description": "并发限制为2，按完成顺序输出"
      }
    ],
    "solution": "### 答案\n\n```javascript\nclass Scheduler {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];  // 等待队列\n    this.running = 0;  // 当前运行的任务数\n  }\n  \n  add(promiseCreator) {\n    return new Promise((resolve) => {\n      // 将任务和 resolve 一起存入队列\n      this.queue.push({ promiseCreator, resolve });\n      this.run();\n    });\n  }\n  \n  run() {\n    // 当有空闲槽位且队列不为空时，执行任务\n    while (this.running < this.limit && this.queue.length) {\n      const { promiseCreator, resolve } = this.queue.shift();\n      this.running++;\n      \n      promiseCreator().then((result) => {\n        resolve(result);  // 通知 add 返回的 Promise 完成\n        this.running--;\n        this.run();  // 尝试执行下一个任务\n      });\n    }\n  }\n}\n```\n\n### 解析\n\n这是一个经典的并发限制调度器实现，核心是**队列 + 槽位计数**。\n\n#### 执行流程图解\n\n```\n时间轴(ms):  0    300   500   700   1000\n任务1:      |--------------------| 输出1\n任务2:      |------| 输出2\n任务3:            |---| 输出3\n任务4:                |----| 输出4\n\n输出顺序: 2(500ms) -> 3(800ms) -> 1(1000ms) -> 4(1100ms)\n```\n\n#### 核心设计\n\n1. **队列存储待执行任务**：`{ promiseCreator, resolve }`\n2. **running 计数**：跟踪当前执行中的任务数\n3. **run() 调度**：有空闲槽位时从队列取任务执行\n4. **链式调用**：任务完成后 resolve，减少 running，再次调度\n\n#### 为什么 add 返回 Promise？\n\n```javascript\n// 这样可以链式调用\nscheduler.add(() => fetch(url1)).then(res => console.log(res));\nscheduler.add(() => fetch(url2)).then(res => console.log(res));\n\n// 或者使用 await\nconst result = await scheduler.add(() => fetch(url));\n```\n\n#### 支持错误处理的版本\n\n```javascript\nclass Scheduler {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.running = 0;\n  }\n  \n  add(promiseCreator) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ promiseCreator, resolve, reject });\n      this.run();\n    });\n  }\n  \n  run() {\n    while (this.running < this.limit && this.queue.length) {\n      const { promiseCreator, resolve, reject } = this.queue.shift();\n      this.running++;\n      \n      promiseCreator()\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          this.running--;\n          this.run();\n        });\n    }\n  }\n}\n```\n\n#### 与 asyncPool 的区别\n\n| 特性 | Scheduler | asyncPool |\n|------|-----------|----------|\n| 调用方式 | 逐个 add | 一次传入所有任务 |\n| 返回值 | 每个任务独立的 Promise | 所有结果的数组 |\n| 使用场景 | 动态添加任务 | 批量处理 |\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| queue 队列 | 存储待执行的任务 |\n| running 计数 | 控制并发数量 |\n| run() 调度 | 任务完成后触发下一个 |\n| Promise 包装 | add 返回 Promise 支持链式调用 |"
  },
  {
    "id": "handwrite-object-assign",
    "title": "手写 Object.assign",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.assign 方法，将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。",
    "template": "function myAssign(target, ...sources) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "const target = { a: 1 };\nconst result = myAssign(target, { b: 2 }, { c: 3 });",
        "expected": "result = { a: 1, b: 2, c: 3 }，且 target === result",
        "description": "合并多个对象到目标对象"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction myAssign(target, ...sources) {\n  // target 为 null/undefined 时抛出错误\n  if (target == null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n  \n  // 确保 target 是对象\n  const to = Object(target);\n  \n  for (const source of sources) {\n    // 跳过 null/undefined 源对象\n    if (source == null) continue;\n    \n    // 遍历源对象的可枚举属性\n    for (const key of Object.keys(source)) {\n      to[key] = source[key];\n    }\n  }\n  \n  return to;\n}\n```\n\n### 解析\n\n`Object.assign` 用于对象的浅拷贝和合并。\n\n#### 核心特性\n\n1. **修改目标对象**：直接修改 target，并返回它\n2. **浅拷贝**：只复制属性值，不深拷贝嵌套对象\n3. **后者覆盖前者**：同名属性后面的源覆盖前面的\n4. **跳过 null/undefined**：源对象为 null/undefined 时跳过\n\n#### 浅拷贝问题\n\n```javascript\nconst source = { nested: { a: 1 } };\nconst target = Object.assign({}, source);\n\ntarget.nested.a = 2;\nconsole.log(source.nested.a);  // 2 - 被修改了！\n```\n\n#### 支持 Symbol 的完整版\n\n```javascript\nfunction myAssign(target, ...sources) {\n  if (target == null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n  \n  const to = Object(target);\n  \n  for (const source of sources) {\n    if (source == null) continue;\n    \n    // 复制字符串键\n    for (const key of Object.keys(source)) {\n      to[key] = source[key];\n    }\n    \n    // 复制 Symbol 键\n    for (const sym of Object.getOwnPropertySymbols(source)) {\n      if (Object.prototype.propertyIsEnumerable.call(source, sym)) {\n        to[sym] = source[sym];\n      }\n    }\n  }\n  \n  return to;\n}\n```\n\n#### Object(target) 的作用\n\n```javascript\n// 原始值会被包装成对象\nObject(1);      // Number { 1 }\nObject('abc');  // String { 'abc' }\nObject(true);   // Boolean { true }\n\n// 对象保持不变\nObject({});     // {}\n```\n\n#### 使用场景\n\n```javascript\n// 1. 浅拷贝对象\nconst copy = Object.assign({}, original);\n\n// 2. 合并对象\nconst merged = Object.assign({}, obj1, obj2, obj3);\n\n// 3. 设置默认值\nfunction fn(options) {\n  options = Object.assign({ timeout: 1000 }, options);\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 浅拷贝 | 嵌套对象共享引用 |\n| 返回 target | 修改并返回目标对象 |\n| 跳过 null/undefined | 源对象可以是 null |\n| Object.keys | 只复制可枚举的自有属性 |"
  },
  {
    "id": "handwrite-websocket",
    "title": "手写一个基础的 WebSocket",
    "difficulty": 2,
    "tags": [2],
    "description": "封装一个 WebSocket 类，实现自动重连、心跳检测、消息队列等功能。",
    "template": "class ReconnectingWebSocket {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = options;\n    // 在此实现\n  }\n  \n  connect() {\n    // 在此实现\n  }\n  \n  send(data) {\n    // 在此实现\n  }\n  \n  close() {\n    // 在此实现\n  }\n}",
    "solution": "### 答案\n\n```javascript\nclass ReconnectingWebSocket {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = {\n      reconnectInterval: 3000,    // 重连间隔\n      maxReconnectAttempts: 5,    // 最大重连次数\n      heartbeatInterval: 30000,   // 心跳间隔\n      ...options\n    };\n    \n    this.ws = null;\n    this.reconnectAttempts = 0;\n    this.messageQueue = [];       // 离线消息队列\n    this.heartbeatTimer = null;\n    this.isManualClose = false;   // 是否手动关闭\n    \n    // 事件回调\n    this.onopen = null;\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    \n    this.connect();\n  }\n  \n  connect() {\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onopen = (event) => {\n      console.log('WebSocket 连接成功');\n      this.reconnectAttempts = 0;\n      \n      // 发送离线消息队列\n      this.flushMessageQueue();\n      \n      // 启动心跳\n      this.startHeartbeat();\n      \n      this.onopen?.(event);\n    };\n    \n    this.ws.onmessage = (event) => {\n      // 收到消息重置心跳\n      this.resetHeartbeat();\n      this.onmessage?.(event);\n    };\n    \n    this.ws.onclose = (event) => {\n      console.log('WebSocket 连接关闭');\n      this.stopHeartbeat();\n      \n      // 非手动关闭时尝试重连\n      if (!this.isManualClose) {\n        this.reconnect();\n      }\n      \n      this.onclose?.(event);\n    };\n    \n    this.ws.onerror = (event) => {\n      console.error('WebSocket 错误:', event);\n      this.onerror?.(event);\n    };\n  }\n  \n  reconnect() {\n    if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {\n      console.log('达到最大重连次数，停止重连');\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    console.log(`第 ${this.reconnectAttempts} 次重连...`);\n    \n    setTimeout(() => {\n      this.connect();\n    }, this.options.reconnectInterval);\n  }\n  \n  send(data) {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(typeof data === 'string' ? data : JSON.stringify(data));\n    } else {\n      // 连接未就绪，加入消息队列\n      this.messageQueue.push(data);\n    }\n  }\n  \n  flushMessageQueue() {\n    while (this.messageQueue.length > 0) {\n      const data = this.messageQueue.shift();\n      this.send(data);\n    }\n  }\n  \n  startHeartbeat() {\n    this.heartbeatTimer = setInterval(() => {\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({ type: 'ping' }));\n      }\n    }, this.options.heartbeatInterval);\n  }\n  \n  resetHeartbeat() {\n    this.stopHeartbeat();\n    this.startHeartbeat();\n  }\n  \n  stopHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n  \n  close() {\n    this.isManualClose = true;\n    this.stopHeartbeat();\n    this.ws?.close();\n  }\n}\n```\n\n### 解析\n\n#### 核心功能\n\n1. **自动重连**：连接断开后自动尝试重连\n2. **心跳检测**：定时发送 ping 保持连接活跃\n3. **消息队列**：离线时消息入队，上线后自动发送\n4. **手动关闭**：区分手动关闭和异常断开\n\n#### 心跳检测的作用\n\n```javascript\n// 服务端可能因为长时间无消息而断开连接\n// 定时发送心跳保持连接\n\n// 客户端\nws.send(JSON.stringify({ type: 'ping' }));\n\n// 服务端\nws.on('message', (data) => {\n  const msg = JSON.parse(data);\n  if (msg.type === 'ping') {\n    ws.send(JSON.stringify({ type: 'pong' }));\n  }\n});\n```\n\n#### WebSocket 状态\n\n```javascript\nWebSocket.CONNECTING = 0;  // 连接中\nWebSocket.OPEN = 1;        // 已连接\nWebSocket.CLOSING = 2;     // 关闭中\nWebSocket.CLOSED = 3;      // 已关闭\n```\n\n#### 使用示例\n\n```javascript\nconst ws = new ReconnectingWebSocket('wss://example.com/ws', {\n  reconnectInterval: 5000,\n  maxReconnectAttempts: 10\n});\n\nws.onmessage = (event) => {\n  console.log('收到消息:', event.data);\n};\n\nws.send({ type: 'subscribe', channel: 'chat' });\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 自动重连 | 异常断开时自动重连 |\n| 心跳检测 | 保持连接活跃 |\n| 消息队列 | 离线消息缓存 |\n| readyState | 检查连接状态 |"
  },
  {
    "id": "postmessage-event-hub",
    "title": "手写基于 postMessage 的事件通信",
    "difficulty": 2,
    "tags": [2],
    "description": "实现一个基于 postMessage 的跨窗口/跨 iframe 通信机制，支持消息的发送、接收和回复。",
    "template": "class PostMessageBus {\n  constructor(targetWindow, targetOrigin = '*') {\n    // 在此实现\n  }\n  \n  send(type, data) {\n    // 在此实现\n  }\n  \n  on(type, handler) {\n    // 在此实现\n  }\n  \n  request(type, data) {\n    // 在此实现 - 返回 Promise，等待回复\n  }\n}",
    "solution": "### 答案\n\n```javascript\nclass PostMessageBus {\n  constructor(targetWindow, targetOrigin = '*') {\n    this.targetWindow = targetWindow;\n    this.targetOrigin = targetOrigin;\n    this.handlers = new Map();  // type -> Set<handler>\n    this.pendingRequests = new Map();  // requestId -> { resolve, reject }\n    \n    // 监听消息\n    window.addEventListener('message', this.handleMessage.bind(this));\n  }\n  \n  handleMessage(event) {\n    // 可选：验证来源\n    // if (event.origin !== this.targetOrigin) return;\n    \n    const { type, data, requestId, isResponse } = event.data || {};\n    \n    // 处理响应\n    if (isResponse && requestId) {\n      const pending = this.pendingRequests.get(requestId);\n      if (pending) {\n        pending.resolve(data);\n        this.pendingRequests.delete(requestId);\n      }\n      return;\n    }\n    \n    // 处理请求/普通消息\n    const handlers = this.handlers.get(type);\n    if (handlers) {\n      handlers.forEach(handler => {\n        const result = handler(data, event);\n        \n        // 如果有 requestId，发送响应\n        if (requestId && result !== undefined) {\n          const response = result instanceof Promise ? result : Promise.resolve(result);\n          response.then(res => {\n            event.source.postMessage({\n              type,\n              data: res,\n              requestId,\n              isResponse: true\n            }, event.origin);\n          });\n        }\n      });\n    }\n  }\n  \n  send(type, data) {\n    this.targetWindow.postMessage({ type, data }, this.targetOrigin);\n  }\n  \n  on(type, handler) {\n    if (!this.handlers.has(type)) {\n      this.handlers.set(type, new Set());\n    }\n    this.handlers.get(type).add(handler);\n    \n    // 返回取消订阅函数\n    return () => {\n      this.handlers.get(type)?.delete(handler);\n    };\n  }\n  \n  request(type, data, timeout = 5000) {\n    return new Promise((resolve, reject) => {\n      const requestId = `${Date.now()}-${Math.random()}`;\n      \n      // 设置超时\n      const timer = setTimeout(() => {\n        this.pendingRequests.delete(requestId);\n        reject(new Error('Request timeout'));\n      }, timeout);\n      \n      this.pendingRequests.set(requestId, {\n        resolve: (data) => {\n          clearTimeout(timer);\n          resolve(data);\n        },\n        reject\n      });\n      \n      this.targetWindow.postMessage(\n        { type, data, requestId },\n        this.targetOrigin\n      );\n    });\n  }\n  \n  destroy() {\n    window.removeEventListener('message', this.handleMessage);\n    this.handlers.clear();\n    this.pendingRequests.clear();\n  }\n}\n```\n\n### 解析\n\n#### postMessage 基础\n\n```javascript\n// 发送消息\notherWindow.postMessage(data, targetOrigin);\n\n// 接收消息\nwindow.addEventListener('message', (event) => {\n  event.data;    // 消息内容\n  event.origin;  // 发送方的源\n  event.source;  // 发送方的 window 引用\n});\n```\n\n#### 使用场景\n\n1. **父子 iframe 通信**\n2. **跨标签页通信**（通过 window.open）\n3. **与 Web Worker 通信**\n\n#### 使用示例\n\n```javascript\n// 父页面\nconst iframe = document.getElementById('myIframe');\nconst bus = new PostMessageBus(iframe.contentWindow, '*');\n\nbus.on('getData', (data) => {\n  return { result: 'Hello from parent' };\n});\n\nbus.send('init', { config: {} });\n\n// 子页面 (iframe 内)\nconst bus = new PostMessageBus(window.parent, '*');\n\nbus.on('init', (config) => {\n  console.log('收到初始化配置:', config);\n});\n\nconst result = await bus.request('getData', { id: 1 });\nconsole.log(result);  // { result: 'Hello from parent' }\n```\n\n#### 安全注意事项\n\n```javascript\n// 1. 验证消息来源\nwindow.addEventListener('message', (event) => {\n  if (event.origin !== 'https://trusted-domain.com') return;\n  // ...\n});\n\n// 2. 指定目标源\niframe.contentWindow.postMessage(data, 'https://trusted-domain.com');\n// 而不是 '*'\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| requestId | 用于匹配请求和响应 |\n| event.source | 获取发送方 window 用于回复 |\n| targetOrigin | 安全性：限制接收方 |\n| 超时处理 | 避免 Promise 永不 resolve |"
  },
  {
    "id": "message-channel",
    "title": "MessageChannel 通信",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 MessageChannel API 实现两个独立上下文之间的双向通信，理解端口（port）的概念和使用方式。",
    "template": "// 创建 MessageChannel 并实现双向通信\nfunction setupMessageChannel() {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\n// 创建 MessageChannel 并实现双向通信\nfunction setupMessageChannel() {\n  const channel = new MessageChannel();\n  const port1 = channel.port1;\n  const port2 = channel.port2;\n  \n  // port1 端设置消息处理\n  port1.onmessage = (event) => {\n    console.log('Port1 收到:', event.data);\n    port1.postMessage('Port1 回复: ' + event.data);\n  };\n  \n  // port2 端设置消息处理\n  port2.onmessage = (event) => {\n    console.log('Port2 收到:', event.data);\n  };\n  \n  // 启动端口（使用 onmessage 时自动启动，使用 addEventListener 需要手动 start）\n  // port1.start();\n  // port2.start();\n  \n  return { port1, port2 };\n}\n\n// 使用示例\nconst { port1, port2 } = setupMessageChannel();\nport2.postMessage('Hello from Port2');\n```\n\n### 解析\n\n#### MessageChannel 基础\n\n```javascript\nconst channel = new MessageChannel();\n// channel.port1 和 channel.port2 是一对相连的端口\n// 从 port1 发送的消息只能被 port2 接收，反之亦然\n```\n\n#### 与 postMessage 的区别\n\n| 特性 | postMessage | MessageChannel |\n|------|-------------|----------------|\n| 通信对象 | window/worker | 任意持有端口的对象 |\n| 建立方式 | 需要获取 window 引用 | 创建后传递端口 |\n| 使用场景 | iframe/窗口通信 | Worker/复杂通信 |\n\n#### 传递端口给 iframe\n\n```javascript\n// 父页面\nconst channel = new MessageChannel();\nconst iframe = document.getElementById('myIframe');\n\n// 监听 port1\nchannel.port1.onmessage = (event) => {\n  console.log('父页面收到:', event.data);\n};\n\n// 等 iframe 加载完成后，传递 port2\niframe.onload = () => {\n  iframe.contentWindow.postMessage('init', '*', [channel.port2]);\n};\n\n// 子页面 (iframe)\nwindow.addEventListener('message', (event) => {\n  if (event.data === 'init' && event.ports.length) {\n    const port = event.ports[0];\n    \n    port.onmessage = (e) => {\n      console.log('子页面收到:', e.data);\n    };\n    \n    port.postMessage('Hello from iframe');\n  }\n});\n```\n\n#### 与 Web Worker 通信\n\n```javascript\n// 主线程\nconst worker = new Worker('worker.js');\nconst channel = new MessageChannel();\n\nchannel.port1.onmessage = (event) => {\n  console.log('主线程收到:', event.data);\n};\n\n// 传递 port2 给 Worker\nworker.postMessage({ type: 'init' }, [channel.port2]);\n\n// worker.js\nself.onmessage = (event) => {\n  if (event.data.type === 'init' && event.ports.length) {\n    const port = event.ports[0];\n    \n    port.onmessage = (e) => {\n      console.log('Worker 收到:', e.data);\n      port.postMessage('Worker 回复');\n    };\n  }\n};\n```\n\n#### React 中利用 MessageChannel 实现调度\n\n```javascript\n// React 源码中使用 MessageChannel 实现 scheduler\nconst channel = new MessageChannel();\nconst port = channel.port2;\n\nchannel.port1.onmessage = performWorkUntilDeadline;\n\nfunction schedulePerformWorkUntilDeadline() {\n  port.postMessage(null);  // 触发宏任务\n}\n```\n\n这比 setTimeout(fn, 0) 更快，因为 MessageChannel 没有 4ms 的最小延迟限制。\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| port1/port2 | 一对相连的端口 |\n| transfer | 端口可通过 postMessage 传递 |\n| start() | 使用 addEventListener 时需要手动启动 |\n| 无延迟 | 比 setTimeout 更快的任务调度 |"
  },
  {
    "id": "myUseUpdate",
    "title": "手写 useUpdate 强制渲染 Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useUpdate Hook，返回一个函数，调用该函数可以强制组件重新渲染。",
    "template": "function useUpdate() {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useUpdate() {\n  const [, setState] = useState({});\n  \n  return useCallback(() => {\n    setState({});\n  }, []);\n}\n```\n\n### 解析\n\n`useUpdate` 是一个用于强制组件重新渲染的 Hook。\n\n#### 实现原理\n\n1. **利用 useState 触发重渲染**：React 会在 state 变化时重新渲染组件\n2. **每次传入新对象**：`setState({})` 每次创建新的空对象，引用不同，触发更新\n3. **useCallback 优化**：返回稳定的函数引用，避免不必要的子组件重渲染\n\n#### 为什么用空对象 `{}`？\n\n```javascript\n// 方式一：空对象（推荐）\nsetState({});  // 每次都是新对象，一定触发更新\n\n// 方式二：递增数字\nconst [, setState] = useState(0);\nsetState(n => n + 1);  // 也可以，但有溢出风险（理论上）\n\n// 方式三：取反布尔值\nconst [, setState] = useState(false);\nsetState(b => !b);  // 也可以\n```\n\n#### 使用示例\n\n```javascript\nfunction MyComponent() {\n  const update = useUpdate();\n  const renderCount = useRef(0);\n  renderCount.current++;\n  \n  return (\n    <div>\n      <p>渲染次数: {renderCount.current}</p>\n      <button onClick={update}>强制更新</button>\n    </div>\n  );\n}\n```\n\n#### 为什么需要 useCallback？\n\n```javascript\n// 不使用 useCallback\nfunction useUpdate() {\n  const [, setState] = useState({});\n  return () => setState({});  // 每次渲染都返回新函数\n}\n\n// 使用 useCallback\nfunction useUpdate() {\n  const [, setState] = useState({});\n  return useCallback(() => setState({}), []);  // 返回稳定的函数引用\n}\n```\n\n如果不用 `useCallback`，每次渲染返回的函数引用都不同，可能导致依赖这个函数的子组件或 useEffect 不必要地重新执行。\n\n#### 使用场景\n\n1. **配合 useRef**：ref 变化不会触发渲染，需要手动触发\n2. **外部数据变化**：监听外部状态管理库的变化\n3. **强制刷新**：某些特殊场景需要强制重新渲染\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| setState({}) | 每次传入新对象触发更新 |\n| useCallback | 保持返回函数引用稳定 |\n| 不读取 state | 只用 setState，不需要读取值 |"
  },
  {
    "id": "myUseAsyncEffect",
    "title": "手写 useAsyncEffect Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个支持异步函数的 useAsyncEffect Hook，处理异步操作的清理和竞态条件。",
    "template": "function useAsyncEffect(effect, deps) {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useAsyncEffect(effect, deps) {\n  useEffect(() => {\n    let isCancelled = false;\n    \n    const runEffect = async () => {\n      await effect(() => isCancelled);\n    };\n    \n    runEffect();\n    \n    return () => {\n      isCancelled = true;\n    };\n  }, deps);\n}\n```\n\n### 解析\n\n`useAsyncEffect` 解决了 `useEffect` 不能直接使用 async 函数的问题，同时处理竞态条件。\n\n#### 为什么 useEffect 不能直接用 async？\n\n```javascript\n// 错误写法\nuseEffect(async () => {\n  const data = await fetchData();\n  setData(data);\n}, []);  // async 函数返回 Promise，不是清理函数\n\n// useEffect 期望返回 undefined 或清理函数\n// async 函数隐式返回 Promise，导致警告\n```\n\n#### 竞态条件问题\n\n```javascript\n// 问题场景：快速切换 id\nuseEffect(() => {\n  fetchUser(id).then(user => setUser(user));\n}, [id]);\n\n// id: 1 -> 发起请求 A\n// id: 2 -> 发起请求 B\n// 如果请求 A 比 B 慢，结果会被 A 覆盖（错误）\n```\n\n#### 使用示例\n\n```javascript\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  \n  useAsyncEffect(async (isCancelled) => {\n    const data = await fetchUser(userId);\n    \n    // 检查是否已取消（组件卸载或 deps 变化）\n    if (!isCancelled()) {\n      setUser(data);\n    }\n  }, [userId]);\n  \n  return user ? <div>{user.name}</div> : <div>Loading...</div>;\n}\n```\n\n#### 另一种实现方式（使用 AbortController）\n\n```javascript\nfunction useAsyncEffect(effect, deps) {\n  useEffect(() => {\n    const controller = new AbortController();\n    \n    effect(controller.signal);\n    \n    return () => {\n      controller.abort();\n    };\n  }, deps);\n}\n\n// 使用\nuseAsyncEffect(async (signal) => {\n  try {\n    const data = await fetch(url, { signal });\n    setData(await data.json());\n  } catch (e) {\n    if (e.name !== 'AbortError') throw e;\n  }\n}, [url]);\n```\n\n#### 完整版本（支持清理函数）\n\n```javascript\nfunction useAsyncEffect(effect, deps) {\n  useEffect(() => {\n    let isCancelled = false;\n    let cleanup;\n    \n    const runEffect = async () => {\n      cleanup = await effect(() => isCancelled);\n    };\n    \n    runEffect();\n    \n    return () => {\n      isCancelled = true;\n      if (typeof cleanup === 'function') {\n        cleanup();\n      }\n    };\n  }, deps);\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| isCancelled 标志 | 用于检测 effect 是否应该继续执行 |\n| 竞态条件处理 | 防止过期请求覆盖最新数据 |\n| 清理函数 | 在组件卸载或依赖变化时设置取消标志 |"
  },
  {
    "id": "myUseDebounce",
    "title": "手写 useDebounce Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useDebounce Hook，对值或函数进行防抖处理，常用于搜索输入等场景。",
    "template": "function useDebounce(value, delay) {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n```\n\n### 解析\n\n`useDebounce` 对值进行防抖处理，只有在值停止变化一段时间后才更新。\n\n#### 实现原理\n\n1. **useState 保存防抖后的值**：初始值与传入值相同\n2. **useEffect 监听值变化**：值变化时启动定时器\n3. **清理函数清除定时器**：值再次变化时，清除上一个定时器，重新计时\n4. **延迟后更新**：只有在 delay 时间内值不再变化，才更新 debouncedValue\n\n#### 执行流程\n\n```javascript\n// 假设 delay = 500ms\nvalue: 'a' -> 启动定时器 A\nvalue: 'ab' -> 清除 A，启动定时器 B（100ms 后）\nvalue: 'abc' -> 清除 B，启动定时器 C（50ms 后）\n// 停止输入，500ms 后...\ndebouncedValue: 'abc'  // C 执行，更新值\n```\n\n#### 使用示例\n\n```javascript\nfunction SearchInput() {\n  const [keyword, setKeyword] = useState('');\n  const debouncedKeyword = useDebounce(keyword, 500);\n  \n  // 只有 debouncedKeyword 变化时才发起请求\n  useEffect(() => {\n    if (debouncedKeyword) {\n      searchAPI(debouncedKeyword).then(setResults);\n    }\n  }, [debouncedKeyword]);\n  \n  return (\n    <input\n      value={keyword}\n      onChange={e => setKeyword(e.target.value)}\n      placeholder=\"搜索...\"\n    />\n  );\n}\n```\n\n#### 防抖函数版本（useDebounceFn）\n\n```javascript\nfunction useDebounceFn(fn, delay) {\n  const fnRef = useRef(fn);\n  fnRef.current = fn;  // 保持最新的函数引用\n  \n  const timerRef = useRef(null);\n  \n  const debouncedFn = useCallback((...args) => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n    timerRef.current = setTimeout(() => {\n      fnRef.current(...args);\n    }, delay);\n  }, [delay]);\n  \n  // 组件卸载时清理\n  useEffect(() => {\n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, []);\n  \n  return debouncedFn;\n}\n\n// 使用\nconst debouncedSearch = useDebounceFn((keyword) => {\n  searchAPI(keyword);\n}, 500);\n```\n\n#### useDebounce vs useDebounceFn\n\n| Hook | 用途 | 返回值 |\n|------|------|--------|\n| useDebounce | 防抖值 | 防抖后的值 |\n| useDebounceFn | 防抖函数 | 防抖包装后的函数 |\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| clearTimeout | 清除上一个定时器实现防抖 |\n| 依赖数组 | 包含 value 和 delay |\n| 清理函数 | 防止内存泄漏和过期更新 |"
  },
  {
    "id": "myUseInterval",
    "title": "手写 useInterval Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "实现一个 useInterval Hook，封装 setInterval，支持动态修改间隔时间，正确处理清理逻辑。",
    "template": "function useInterval(callback, delay) {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef(callback);\n  \n  // 保存最新的回调函数\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  \n  // 设置定时器\n  useEffect(() => {\n    if (delay === null) return;  // delay 为 null 时暂停\n    \n    const tick = () => {\n      savedCallback.current();\n    };\n    \n    const id = setInterval(tick, delay);\n    return () => clearInterval(id);\n  }, [delay]);\n}\n```\n\n### 解析\n\n`useInterval` 是 Dan Abramov 推荐的 setInterval Hook 实现，解决了在 React 中使用定时器的常见问题。\n\n#### 为什么不能直接在 useEffect 中用 setInterval？\n\n```javascript\n// 问题代码\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);  // 闭包陷阱！count 永远是 0\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);  // 空依赖数组\n  \n  return <div>{count}</div>;  // 永远显示 1\n}\n```\n\n问题：回调函数中的 `count` 是闭包捕获的初始值 0，不会更新。\n\n#### useRef 解决闭包问题\n\n```javascript\nconst savedCallback = useRef(callback);\n\nuseEffect(() => {\n  savedCallback.current = callback;  // 每次渲染更新为最新的回调\n}, [callback]);\n```\n\n- `savedCallback.current` 始终指向最新的回调函数\n- 定时器调用 `savedCallback.current()` 时，会执行最新的回调\n\n#### 使用示例\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [delay, setDelay] = useState(1000);\n  const [isRunning, setIsRunning] = useState(true);\n  \n  useInterval(() => {\n    setCount(c => c + 1);\n  }, isRunning ? delay : null);  // null 暂停定时器\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setDelay(d => d / 2)}>加速</button>\n      <button onClick={() => setIsRunning(r => !r)}>\n        {isRunning ? '暂停' : '继续'}\n      </button>\n    </div>\n  );\n}\n```\n\n#### 为什么要分离两个 useEffect？\n\n```javascript\n// 第一个 useEffect：更新回调引用\nuseEffect(() => {\n  savedCallback.current = callback;\n}, [callback]);  // callback 变化时更新\n\n// 第二个 useEffect：管理定时器\nuseEffect(() => {\n  // ...\n}, [delay]);  // 只有 delay 变化时才重新设置定时器\n```\n\n分离的好处：\n1. 回调变化不会重新设置定时器\n2. 只有 delay 变化才会清除并重建定时器\n3. 避免不必要的定时器重置\n\n#### delay = null 暂停功能\n\n```javascript\nif (delay === null) return;  // 不设置定时器\n```\n\n通过传入 `null` 可以暂停定时器，传入数字恢复。\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| useRef 保存回调 | 避免闭包陷阱，始终调用最新回调 |\n| delay = null | 实现暂停功能 |\n| 分离 useEffect | 回调更新不重置定时器 |\n| clearInterval | 组件卸载或 delay 变化时清理 |"
  },
  {
    "id": "myUseState",
    "title": "手写 useState Hook",
    "difficulty": 2,
    "tags": [4],
    "description": "模拟实现 React 的 useState Hook，理解闭包、状态管理和触发重渲染的机制。",
    "template": "function useState(initialValue) {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nlet state;  // 存储状态（简化版只支持一个 state）\nlet component;  // 存储组件引用\n\nfunction useState(initialValue) {\n  // 初始化：只在第一次调用时使用 initialValue\n  if (state === undefined) {\n    state = typeof initialValue === 'function' \n      ? initialValue() \n      : initialValue;\n  }\n  \n  const setState = (newValue) => {\n    // 支持函数式更新\n    state = typeof newValue === 'function' \n      ? newValue(state) \n      : newValue;\n    \n    // 触发重新渲染\n    render();\n  };\n  \n  return [state, setState];\n}\n\nfunction render() {\n  // 重新渲染组件\n  component();\n}\n```\n\n### 解析\n\n这是一个简化版的 useState 实现，用于理解 React Hooks 的核心原理。\n\n#### 实现原理\n\n1. **状态存储**：使用模块级变量存储 state\n2. **惰性初始化**：支持函数作为初始值\n3. **函数式更新**：setState 支持传入函数\n4. **触发重渲染**：setState 调用后重新执行组件函数\n\n#### 支持多个 useState 的完整实现\n\n```javascript\nlet states = [];      // 状态数组\nlet stateIndex = 0;   // 当前状态索引\nlet component;\n\nfunction useState(initialValue) {\n  const currentIndex = stateIndex;\n  \n  // 初始化\n  if (states[currentIndex] === undefined) {\n    states[currentIndex] = typeof initialValue === 'function'\n      ? initialValue()\n      : initialValue;\n  }\n  \n  const setState = (newValue) => {\n    states[currentIndex] = typeof newValue === 'function'\n      ? newValue(states[currentIndex])\n      : newValue;\n    \n    render();\n  };\n  \n  stateIndex++;  // 移动到下一个索引\n  return [states[currentIndex], setState];\n}\n\nfunction render() {\n  stateIndex = 0;  // 重置索引！关键步骤\n  component();\n}\n```\n\n#### 为什么 Hooks 必须在顶层调用？\n\n```javascript\n// 错误示例\nfunction MyComponent() {\n  if (condition) {\n    const [a, setA] = useState(0);  // 条件调用！\n  }\n  const [b, setB] = useState(0);\n}\n```\n\n因为 React 依靠**调用顺序**来匹配 state：\n\n```\n第一次渲染：condition = true\n  useState(0) -> states[0] = 0  (a)\n  useState(0) -> states[1] = 0  (b)\n\n第二次渲染：condition = false\n  useState(0) -> states[0] = ???  (应该是 b，但拿到的是 a 的值！)\n```\n\n#### 完整模拟（带 render 函数）\n\n```javascript\nconst React = (function() {\n  let states = [];\n  let stateIndex = 0;\n  \n  function useState(initialValue) {\n    const idx = stateIndex;\n    \n    if (states[idx] === undefined) {\n      states[idx] = typeof initialValue === 'function'\n        ? initialValue()\n        : initialValue;\n    }\n    \n    const setState = (newValue) => {\n      states[idx] = typeof newValue === 'function'\n        ? newValue(states[idx])\n        : newValue;\n    };\n    \n    stateIndex++;\n    return [states[idx], setState];\n  }\n  \n  function render(Component) {\n    stateIndex = 0;\n    const result = Component();\n    return result;\n  }\n  \n  return { useState, render };\n})();\n\n// 使用\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  \n  return {\n    render: () => console.log('Count:', count),\n    click: () => setCount(c => c + 1)\n  };\n}\n\nlet app = React.render(Counter);\napp.render();  // Count: 0\napp.click();\napp = React.render(Counter);\napp.render();  // Count: 1\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 数组存储 state | 按调用顺序存储和读取 |\n| 索引重置 | 每次渲染前重置为 0 |\n| 惰性初始化 | 支持函数作为初始值 |\n| 函数式更新 | setState(prev => newValue) |\n| 顶层调用规则 | 保证调用顺序一致 |"
  },
  {
    "id": "myUseTimeout",
    "title": "手写 useTimeout Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useTimeout Hook，在指定延迟后执行回调函数。需要正确处理组件卸载时的清理逻辑，以及回调函数或延迟时间变化时的重置行为。",
    "template": "function useTimeout(callback, delay) {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useTimeout(callback, delay) {\n  const savedCallback = useRef(callback);\n  \n  // 保存最新的回调函数\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  \n  // 设置定时器\n  useEffect(() => {\n    if (delay === null) return;\n    \n    const id = setTimeout(() => {\n      savedCallback.current();\n    }, delay);\n    \n    return () => clearTimeout(id);\n  }, [delay]);\n}\n```\n\n### 解析\n\n`useTimeout` 封装 setTimeout，在 React 中安全地使用延时执行。\n\n#### 实现原理\n\n1. **useRef 保存回调**：避免闭包陷阱，始终执行最新的回调函数\n2. **清理定时器**：组件卸载或 delay 变化时清除定时器\n3. **delay = null 取消**：传入 null 可以取消定时器\n\n#### 为什么要用 useRef 保存 callback？\n\n```javascript\n// 问题代码\nfunction useTimeout(callback, delay) {\n  useEffect(() => {\n    const id = setTimeout(callback, delay);  // callback 是旧的！\n    return () => clearTimeout(id);\n  }, [delay]);  // 没有依赖 callback\n}\n```\n\n如果 callback 依赖了组件状态，闭包会捕获旧值。使用 useRef 可以保证执行时调用最新的回调。\n\n#### 使用示例\n\n```javascript\nfunction Notification({ message, duration = 3000 }) {\n  const [visible, setVisible] = useState(true);\n  \n  useTimeout(() => {\n    setVisible(false);\n  }, duration);\n  \n  if (!visible) return null;\n  return <div className=\"notification\">{message}</div>;\n}\n```\n\n#### 带返回值的版本（支持手动清除和重置）\n\n```javascript\nfunction useTimeout(callback, delay) {\n  const savedCallback = useRef(callback);\n  const timerRef = useRef(null);\n  \n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  \n  const clear = useCallback(() => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, []);\n  \n  const reset = useCallback(() => {\n    clear();\n    if (delay !== null) {\n      timerRef.current = setTimeout(() => {\n        savedCallback.current();\n      }, delay);\n    }\n  }, [delay, clear]);\n  \n  useEffect(() => {\n    reset();\n    return clear;\n  }, [delay, reset, clear]);\n  \n  return { clear, reset };\n}\n\n// 使用\nfunction Toast({ message }) {\n  const [visible, setVisible] = useState(true);\n  const { clear, reset } = useTimeout(() => setVisible(false), 3000);\n  \n  return visible && (\n    <div \n      onMouseEnter={clear}   // 鼠标悬停时暂停\n      onMouseLeave={reset}   // 鼠标离开时重新计时\n    >\n      {message}\n    </div>\n  );\n}\n```\n\n#### useTimeout vs useInterval\n\n| Hook | 行为 | 执行次数 |\n|------|------|----------|\n| useTimeout | 延迟后执行一次 | 1 次 |\n| useInterval | 每隔一段时间执行 | 多次 |\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| useRef 保存回调 | 避免闭包陷阱 |\n| clearTimeout | 组件卸载时清理 |\n| delay = null | 取消/禁用定时器 |\n| 只执行一次 | 与 useInterval 的区别 |"
  },
  {
    "id": "myUseWindowResize",
    "title": "手写 useWindowResize Hook",
    "difficulty": 1,
    "tags": [4],
    "description": "实现一个 useWindowResize Hook，监听窗口大小变化并返回当前的 width 和 height。需要正确添加和移除事件监听器，可选支持防抖优化。",
    "template": "function useWindowResize() {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\nfunction useWindowResize() {\n  const [size, setSize] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n  \n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  \n  return size;\n}\n```\n\n### 解析\n\n`useWindowResize` 监听窗口大小变化，返回当前的宽高。\n\n#### 实现原理\n\n1. **useState 保存尺寸**：存储 width 和 height\n2. **useEffect 添加监听**：组件挂载时监听 resize 事件\n3. **清理函数移除监听**：组件卸载时移除事件监听器\n4. **SSR 兼容**：检查 window 是否存在\n\n#### SSR 兼容处理\n\n```javascript\n// 服务端渲染时 window 不存在\nconst [size, setSize] = useState({\n  width: typeof window !== 'undefined' ? window.innerWidth : 0,\n  height: typeof window !== 'undefined' ? window.innerHeight : 0,\n});\n```\n\n#### 带防抖的版本\n\n```javascript\nfunction useWindowResize(debounceMs = 0) {\n  const [size, setSize] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n  \n  useEffect(() => {\n    let timeoutId;\n    \n    const handleResize = () => {\n      if (debounceMs > 0) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n          setSize({\n            width: window.innerWidth,\n            height: window.innerHeight,\n          });\n        }, debounceMs);\n      } else {\n        setSize({\n          width: window.innerWidth,\n          height: window.innerHeight,\n        });\n      }\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      clearTimeout(timeoutId);\n    };\n  }, [debounceMs]);\n  \n  return size;\n}\n```\n\n#### 使用示例\n\n```javascript\nfunction ResponsiveComponent() {\n  const { width, height } = useWindowResize();\n  \n  const isMobile = width < 768;\n  const isTablet = width >= 768 && width < 1024;\n  const isDesktop = width >= 1024;\n  \n  return (\n    <div>\n      <p>窗口尺寸: {width} x {height}</p>\n      {isMobile && <MobileLayout />}\n      {isTablet && <TabletLayout />}\n      {isDesktop && <DesktopLayout />}\n    </div>\n  );\n}\n```\n\n#### 返回更多信息的版本\n\n```javascript\nfunction useWindowResize() {\n  const [windowInfo, setWindowInfo] = useState(() => ({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    isMobile: window.innerWidth < 768,\n    isTablet: window.innerWidth >= 768 && window.innerWidth < 1024,\n    isDesktop: window.innerWidth >= 1024,\n  }));\n  \n  useEffect(() => {\n    const handleResize = () => {\n      const width = window.innerWidth;\n      setWindowInfo({\n        width,\n        height: window.innerHeight,\n        isMobile: width < 768,\n        isTablet: width >= 768 && width < 1024,\n        isDesktop: width >= 1024,\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return windowInfo;\n}\n```\n\n#### 性能优化建议\n\n```javascript\n// 1. 使用防抖减少更新频率\nconst size = useWindowResize(100);  // 100ms 防抖\n\n// 2. 使用 useMemo 缓存派生值\nconst { width, height } = useWindowResize();\nconst isMobile = useMemo(() => width < 768, [width]);\n\n// 3. 只在需要时订阅\nfunction useIsMobile() {\n  const { width } = useWindowResize();\n  return width < 768;\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| addEventListener | 组件挂载时添加监听 |\n| removeEventListener | 组件卸载时移除监听 |\n| SSR 兼容 | 检查 window 是否存在 |\n| 防抖优化 | resize 事件触发频繁，建议防抖 |"
  },
  {
    "id": "proxy",
    "title": "手写 Proxy 代理",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 Proxy 实现数据响应式，当数据变化时自动触发更新。理解 handler 中的 get、set 等捕获器。",
    "template": "function reactive(obj, onChange) {\n  // 在此实现\n  // 返回一个代理对象，当属性变化时调用 onChange\n}",
    "testCases": [
      {
        "input": "const state = reactive({ count: 0 }, (key, val) => console.log(key, val));\nstate.count = 1;",
        "expected": "输出 'count' 1，state.count === 1",
        "description": "基本响应式：修改属性触发回调"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction reactive(obj, onChange) {\n  return new Proxy(obj, {\n    get(target, key, receiver) {\n      const value = Reflect.get(target, key, receiver);\n      // 如果值是对象，递归代理\n      if (typeof value === 'object' && value !== null) {\n        return reactive(value, onChange);\n      }\n      return value;\n    },\n    \n    set(target, key, value, receiver) {\n      const oldValue = target[key];\n      const result = Reflect.set(target, key, value, receiver);\n      \n      // 值变化时触发回调\n      if (oldValue !== value) {\n        onChange(key, value, oldValue);\n      }\n      \n      return result;\n    },\n    \n    deleteProperty(target, key) {\n      const result = Reflect.deleteProperty(target, key);\n      onChange(key, undefined);\n      return result;\n    }\n  });\n}\n```\n\n### 解析\n\n`Proxy` 是 ES6 提供的对象代理功能，可以拦截对象的各种操作。\n\n#### Proxy 基本用法\n\n```javascript\nconst proxy = new Proxy(target, handler);\n\n// handler 是一个对象，包含各种捕获器（trap）\nconst handler = {\n  get(target, key, receiver) { },      // 读取属性\n  set(target, key, value, receiver) { }, // 设置属性\n  deleteProperty(target, key) { },      // 删除属性\n  has(target, key) { },                 // in 操作符\n  ownKeys(target) { },                  // Object.keys 等\n  // ... 还有更多\n};\n```\n\n#### 为什么用 Reflect？\n\n```javascript\n// Reflect 提供了与 Proxy 捕获器对应的默认行为\nReflect.get(target, key, receiver);  // 相当于 target[key]\nReflect.set(target, key, value, receiver);  // 相当于 target[key] = value\n\n// receiver 参数很重要，用于正确处理 getter/setter 中的 this\nconst obj = {\n  _value: 1,\n  get value() { return this._value; }\n};\n\nconst proxy = new Proxy(obj, {\n  get(target, key, receiver) {\n    // 如果直接返回 target[key]，getter 中的 this 指向原对象\n    // 使用 Reflect.get 并传入 receiver，this 指向代理对象\n    return Reflect.get(target, key, receiver);\n  }\n});\n```\n\n#### Vue 3 响应式原理简化版\n\n```javascript\nconst targetMap = new WeakMap();\nlet activeEffect = null;\n\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key, receiver) {\n      // 收集依赖\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      const result = Reflect.set(target, key, value, receiver);\n      // 触发更新\n      trigger(target, key);\n      return result;\n    }\n  });\n}\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  dep.add(activeEffect);\n}\n\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  const dep = depsMap.get(key);\n  if (dep) {\n    dep.forEach(effect => effect());\n  }\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| Proxy | 拦截对象操作的元编程 API |\n| Reflect | 提供默认操作的反射 API |\n| receiver | 保持正确的 this 绑定 |\n| 递归代理 | 处理嵌套对象 |"
  },
  {
    "id": "prototype-inheritance",
    "title": "手写原型继承+组合继承",
    "difficulty": 2,
    "tags": [2],
    "description": "实现原型继承和组合继承两种方式。理解原型链继承的缺陷（引用类型共享问题），以及组合继承如何通过构造函数借用和 Object.create 来解决这些问题。",
    "template": "// 实现组合继承\nfunction Parent(name) {\n  this.name = name;\n  this.colors = ['red', 'green'];\n}\n\nParent.prototype.sayName = function() {\n  return this.name;\n};\n\nfunction Child(name, age) {\n  // 在此实现继承\n}\n\n// 在此设置原型链",
    "testCases": [
      {
        "input": "const child = new Child('Tom', 10);\nchild.sayName();\nchild instanceof Parent;",
        "expected": "sayName() 返回 'Tom'，instanceof 返回 true",
        "description": "组合继承：继承实例属性和原型方法"
      }
    ],
    "solution": "### 答案\n\n```javascript\n// 组合继承（寄生组合继承）\nfunction Parent(name) {\n  this.name = name;\n  this.colors = ['red', 'green'];\n}\n\nParent.prototype.sayName = function() {\n  return this.name;\n};\n\nfunction Child(name, age) {\n  // 1. 借用构造函数：继承实例属性\n  Parent.call(this, name);\n  this.age = age;\n}\n\n// 2. 原型链：继承原型方法\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n\n// 子类自己的方法\nChild.prototype.sayAge = function() {\n  return this.age;\n};\n```\n\n### 解析\n\n#### 1. 原型链继承（有缺陷）\n\n```javascript\nChild.prototype = new Parent();\n\n// 问题：引用类型属性被所有实例共享\nconst c1 = new Child();\nconst c2 = new Child();\nc1.colors.push('blue');\nconsole.log(c2.colors); // ['red', 'green', 'blue'] - 被影响了！\n```\n\n#### 2. 构造函数继承（有缺陷）\n\n```javascript\nfunction Child(name) {\n  Parent.call(this, name);\n}\n\n// 问题：无法继承原型方法\nconst c = new Child('Tom');\nc.sayName(); // Error: c.sayName is not a function\n```\n\n#### 3. 组合继承（推荐）\n\n```javascript\nfunction Child(name, age) {\n  Parent.call(this, name);  // 继承实例属性\n  this.age = age;\n}\n\nChild.prototype = Object.create(Parent.prototype);  // 继承原型方法\nChild.prototype.constructor = Child;\n```\n\n结合了两者的优点：\n- 构造函数：每个实例有自己的属性副本\n- 原型链：共享原型方法\n\n#### 为什么用 Object.create 而不是 new Parent？\n\n```javascript\n// 方式一：new Parent()（传统组合继承）\nChild.prototype = new Parent();  // 会执行 Parent 构造函数\n// 问题：Parent 构造函数被调用两次\n\n// 方式二：Object.create（寄生组合继承）\nChild.prototype = Object.create(Parent.prototype);  // 只设置原型链\n// Parent 构造函数只在 Child 内部调用一次\n```\n\n#### 修复 constructor\n\n```javascript\nChild.prototype = Object.create(Parent.prototype);\n// 此时 Child.prototype.constructor === Parent（错误）\n\nChild.prototype.constructor = Child;  // 修复为正确的值\n```\n\n#### ES6 class 继承（语法糖）\n\n```javascript\nclass Parent {\n  constructor(name) {\n    this.name = name;\n    this.colors = ['red', 'green'];\n  }\n  sayName() {\n    return this.name;\n  }\n}\n\nclass Child extends Parent {\n  constructor(name, age) {\n    super(name);  // 等同于 Parent.call(this, name)\n    this.age = age;\n  }\n}\n```\n\n### 关键点\n\n| 继承方式 | 优点 | 缺点 |\n|----------|------|------|\n| 原型链 | 继承原型方法 | 引用类型共享 |\n| 构造函数 | 属性独立 | 无法继承原型方法 |\n| 组合继承 | 两者优点 | Parent 调用两次 |\n| 寄生组合 | 最优方案 | 稍复杂 |"
  },
  {
    "id": "compose-middleware",
    "title": "实现 compose 函数（洋葱模型）",
    "difficulty": 3,
    "tags": [2],
    "description": "实现类似 Koa 的中间件洋葱模型 compose 函数。理解 async/await 与递归调用 next() 的执行顺序。",
    "template": "function compose(middlewares) {\n  // 在此实现\n  // 返回一个函数，接收 context\n}",
    "testCases": [
      {
        "input": "const mw = [\n  async (ctx, next) => { console.log(1); await next(); console.log(4); },\n  async (ctx, next) => { console.log(2); await next(); console.log(3); }\n];\ncompose(mw)({});",
        "expected": "依次输出: 1, 2, 3, 4",
        "description": "洋葱模型：先进后出的执行顺序"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction compose(middlewares) {\n  return function(context) {\n    let index = -1;\n    \n    function dispatch(i) {\n      // 防止多次调用 next\n      if (i <= index) {\n        return Promise.reject(new Error('next() called multiple times'));\n      }\n      index = i;\n      \n      // 获取当前中间件\n      const fn = middlewares[i];\n      \n      // 所有中间件执行完毕\n      if (!fn) {\n        return Promise.resolve();\n      }\n      \n      try {\n        // 执行当前中间件，next 指向下一个中间件\n        return Promise.resolve(fn(context, () => dispatch(i + 1)));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n    \n    return dispatch(0);\n  };\n}\n```\n\n### 解析\n\n洋葱模型是 Koa 框架的核心特性，中间件按**先进后出**的顺序执行。\n\n#### 执行流程图解\n\n```\n请求 →\n     ┌─────────────────────────────────┐\n     │         middleware 1            │\n     │   ┌─────────────────────────┐   │\n     │   │     middleware 2        │   │\n     │   │   ┌─────────────────┐   │   │\n     │   │   │  middleware 3   │   │   │\n     │   │   └─────────────────┘   │   │\n     │   └─────────────────────────┘   │\n     └─────────────────────────────────┘\n← 响应\n\n执行顺序: 1-start → 2-start → 3 → 2-end → 1-end\n```\n\n#### 执行过程分析\n\n```javascript\n// dispatch(0) 执行 middleware[0]\nmiddleware[0](ctx, next) {\n  console.log('1-start');\n  // await next() 就是 await dispatch(1)\n  await dispatch(1);  // 暂停，执行下一个中间件\n  console.log('1-end');  // dispatch(1) 完成后继续\n}\n\n// dispatch(1) 执行 middleware[1]\nmiddleware[1](ctx, next) {\n  console.log('2-start');\n  await dispatch(2);  // 暂停，执行下一个中间件\n  console.log('2-end');  // dispatch(2) 完成后继续\n}\n\n// dispatch(2) 执行 middleware[2]\nmiddleware[2](ctx, next) {\n  console.log('3');\n  // 没有调用 next()，直接返回\n}\n\n// 然后依次返回，执行 2-end, 1-end\n```\n\n#### 为什么要检查 `i <= index`？\n\n```javascript\n// 防止一个中间件多次调用 next\nasync (ctx, next) => {\n  await next();\n  await next();  // 错误！不应该调用两次\n}\n```\n\n#### 简化版（不检查重复调用）\n\n```javascript\nfunction compose(middlewares) {\n  return function(context) {\n    function dispatch(i) {\n      if (i >= middlewares.length) return Promise.resolve();\n      return Promise.resolve(\n        middlewares[i](context, () => dispatch(i + 1))\n      );\n    }\n    return dispatch(0);\n  };\n}\n```\n\n#### 应用场景\n\n```javascript\n// 日志中间件\nconst logger = async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  console.log(`${ctx.method} ${ctx.url} - ${Date.now() - start}ms`);\n};\n\n// 错误处理中间件\nconst errorHandler = async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.status = 500;\n    ctx.body = err.message;\n  }\n};\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 洋葱模型 | 先进后出的执行顺序 |\n| next() | 调用下一个中间件 |\n| await next() | 等待后续中间件执行完成 |\n| Promise | 处理异步中间件 |"
  },
  {
    "id": "intersection-observer",
    "title": "Intersection Observer API 使用",
    "difficulty": 1,
    "tags": [2],
    "description": "使用 Intersection Observer API 实现元素可见性检测，常用于懒加载、无限滚动、曝光统计等场景。",
    "template": "// 实现图片懒加载\nfunction lazyLoadImages() {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```javascript\n// 图片懒加载实现\nfunction lazyLoadImages() {\n  const images = document.querySelectorAll('img[data-src]');\n  \n  const observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      // 元素进入视口\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;  // 加载真实图片\n        img.removeAttribute('data-src');\n        observer.unobserve(img);  // 停止观察该元素\n      }\n    });\n  }, {\n    root: null,           // 视口作为根元素\n    rootMargin: '100px',  // 提前 100px 加载\n    threshold: 0          // 元素一出现就触发\n  });\n  \n  images.forEach(img => observer.observe(img));\n  \n  return observer;  // 返回以便后续清理\n}\n```\n\n### 解析\n\n`IntersectionObserver` 是浏览器提供的 API，用于异步检测元素与视口（或指定祖先元素）的交叉状态。\n\n#### 基本用法\n\n```javascript\nconst observer = new IntersectionObserver(callback, options);\n\n// callback 接收两个参数\nfunction callback(entries, observer) {\n  entries.forEach(entry => {\n    entry.target;           // 被观察的元素\n    entry.isIntersecting;   // 是否进入视口\n    entry.intersectionRatio; // 交叉比例 0-1\n    entry.boundingClientRect; // 元素的位置信息\n  });\n}\n\n// options 配置\nconst options = {\n  root: null,           // 根元素，null 表示视口\n  rootMargin: '0px',    // 根元素的 margin\n  threshold: 0          // 触发回调的交叉比例阈值\n};\n```\n\n#### threshold 详解\n\n```javascript\n// 单个值：交叉比例达到该值时触发\nthreshold: 0      // 一出现就触发\nthreshold: 0.5    // 出现 50% 时触发\nthreshold: 1      // 完全出现时触发\n\n// 数组：每个值都会触发\nthreshold: [0, 0.25, 0.5, 0.75, 1]  // 多个临界点\n```\n\n#### 无限滚动实现\n\n```javascript\nfunction infiniteScroll(loadMore) {\n  const sentinel = document.querySelector('#sentinel');\n  \n  const observer = new IntersectionObserver((entries) => {\n    if (entries[0].isIntersecting) {\n      loadMore();  // 加载更多数据\n    }\n  }, {\n    rootMargin: '100px'  // 提前触发\n  });\n  \n  observer.observe(sentinel);\n}\n\n// HTML: <div id=\"sentinel\"></div> 放在列表底部\n```\n\n#### 曝光统计\n\n```javascript\nfunction trackExposure(elements, onExpose) {\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        onExpose(entry.target);  // 上报曝光\n        observer.unobserve(entry.target);  // 只上报一次\n      }\n    });\n  }, {\n    threshold: 0.5  // 至少 50% 可见才算曝光\n  });\n  \n  elements.forEach(el => observer.observe(el));\n}\n```\n\n#### 与 scroll 事件对比\n\n| 特性 | IntersectionObserver | scroll 事件 |\n|------|---------------------|-------------|\n| 性能 | 高效，浏览器优化 | 需手动节流 |\n| 计算 | 自动计算交叉状态 | 手动计算 getBoundingClientRect |\n| 多元素 | 一个 observer 管理多个 | 每个元素单独处理 |\n| 嵌套滚动 | 支持 | 需要额外处理 |\n\n#### 清理\n\n```javascript\n// 停止观察单个元素\nobserver.unobserve(element);\n\n// 停止所有观察\nobserver.disconnect();\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| isIntersecting | 是否进入视口 |\n| threshold | 触发回调的交叉比例 |\n| rootMargin | 提前/延迟触发的边距 |\n| unobserve | 停止观察已处理的元素 |"
  },
  {
    "id": "raf-settimeout",
    "title": "用 requestAnimationFrame 实现 setTimeout",
    "difficulty": 2,
    "tags": [2],
    "description": "使用 requestAnimationFrame 模拟实现 setTimeout 功能，理解两者的区别和执行时机。",
    "template": "function rafSetTimeout(callback, delay) {\n  // 在此实现\n  // 返回一个 id 用于取消\n}",
    "solution": "### 答案\n\n```javascript\nfunction rafSetTimeout(callback, delay) {\n  const startTime = performance.now();\n  let rafId;\n  \n  function loop(currentTime) {\n    // 检查是否达到延迟时间\n    if (currentTime - startTime >= delay) {\n      callback();\n    } else {\n      rafId = requestAnimationFrame(loop);\n    }\n  }\n  \n  rafId = requestAnimationFrame(loop);\n  \n  // 返回取消函数\n  return () => cancelAnimationFrame(rafId);\n}\n\n// 如果要返回数字 id（兼容 clearTimeout）\nlet idCounter = 0;\nconst rafMap = new Map();\n\nfunction rafSetTimeout(callback, delay) {\n  const id = ++idCounter;\n  const startTime = performance.now();\n  \n  function loop(currentTime) {\n    if (currentTime - startTime >= delay) {\n      callback();\n      rafMap.delete(id);\n    } else {\n      rafMap.set(id, requestAnimationFrame(loop));\n    }\n  }\n  \n  rafMap.set(id, requestAnimationFrame(loop));\n  return id;\n}\n\nfunction rafClearTimeout(id) {\n  if (rafMap.has(id)) {\n    cancelAnimationFrame(rafMap.get(id));\n    rafMap.delete(id);\n  }\n}\n```\n\n### 解析\n\n#### requestAnimationFrame vs setTimeout\n\n| 特性 | setTimeout | requestAnimationFrame |\n|------|------------|----------------------|\n| 执行时机 | 指定延迟后（可能不准确） | 下一帧渲染前（约 16.6ms） |\n| 精度 | 受任务队列影响 | 与屏幕刷新同步 |\n| 后台标签页 | 继续执行 | 暂停执行（省电） |\n| 用途 | 通用延迟 | 动画、渲染相关 |\n\n#### 为什么 setTimeout 不准确？\n\n```javascript\n// setTimeout 的最小延迟\nsetTimeout(fn, 0);  // 实际最小延迟约 4ms（浏览器限制）\n\n// 嵌套 setTimeout 延迟会更大\nsetTimeout(() => {\n  setTimeout(() => {\n    // 第 5 次以后，最小延迟 4ms\n  }, 0);\n}, 0);\n\n// 后台标签页延迟更大\n// Chrome 中后台标签的 setTimeout 最小延迟 1000ms\n```\n\n#### rAF 的执行时机\n\n```javascript\n// rAF 在浏览器下一次重绘之前调用\nrequestAnimationFrame(callback);\n\n// callback 接收一个时间戳参数\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);  // DOMHighResTimeStamp\n});\n```\n\n#### 使用 rAF 实现 setInterval\n\n```javascript\nfunction rafSetInterval(callback, interval) {\n  let lastTime = performance.now();\n  let rafId;\n  \n  function loop(currentTime) {\n    if (currentTime - lastTime >= interval) {\n      callback();\n      lastTime = currentTime;\n    }\n    rafId = requestAnimationFrame(loop);\n  }\n  \n  rafId = requestAnimationFrame(loop);\n  \n  return () => cancelAnimationFrame(rafId);\n}\n```\n\n#### 什么时候用 rAF？\n\n```javascript\n// 1. 动画\nfunction animate() {\n  element.style.transform = `translateX(${x}px)`;\n  x += speed;\n  if (x < target) {\n    requestAnimationFrame(animate);\n  }\n}\n\n// 2. 平滑滚动\nfunction smoothScroll(target) {\n  const start = window.scrollY;\n  const distance = target - start;\n  const duration = 500;\n  let startTime;\n  \n  function step(currentTime) {\n    if (!startTime) startTime = currentTime;\n    const progress = (currentTime - startTime) / duration;\n    \n    if (progress < 1) {\n      window.scrollTo(0, start + distance * easeOutCubic(progress));\n      requestAnimationFrame(step);\n    } else {\n      window.scrollTo(0, target);\n    }\n  }\n  \n  requestAnimationFrame(step);\n}\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| performance.now() | 高精度时间戳 |\n| 递归调用 | 不断检查是否达到延迟 |\n| cancelAnimationFrame | 取消动画帧 |\n| 后台暂停 | rAF 在后台标签页会暂停 |"
  },
  {
    "id": "object-create",
    "title": "手写 Object.create",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 Object.create 方法，创建一个新对象，使用现有的对象作为新对象的原型。同时理解 Object.setPrototypeOf 的作用。",
    "template": "function myCreate(proto, propertiesObject) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "const parent = { greet() { return 'Hi, ' + this.name; } };\nconst child = myCreate(parent);\nchild.name = 'Tom';",
        "expected": "child.greet() 返回 'Hi, Tom'，Object.getPrototypeOf(child) === parent",
        "description": "创建以 parent 为原型的新对象"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction myCreate(proto, propertiesObject) {\n  // proto 必须是 null 或对象\n  if (typeof proto !== 'object' && typeof proto !== 'function') {\n    throw new TypeError('Object prototype may only be an Object or null');\n  }\n  \n  // 创建一个空的构造函数\n  function F() {}\n  \n  // 设置构造函数的原型\n  F.prototype = proto;\n  \n  // 创建新对象\n  const obj = new F();\n  \n  // 如果传入了 propertiesObject，添加属性\n  if (propertiesObject !== undefined) {\n    Object.defineProperties(obj, propertiesObject);\n  }\n  \n  // 处理 proto 为 null 的情况\n  if (proto === null) {\n    obj.__proto__ = null;\n  }\n  \n  return obj;\n}\n```\n\n### 解析\n\n`Object.create()` 创建一个新对象，使用现有对象作为新对象的原型。\n\n#### 核心原理\n\n```javascript\nfunction myCreate(proto) {\n  function F() {}       // 1. 创建空构造函数\n  F.prototype = proto;  // 2. 原型指向 proto\n  return new F();       // 3. new 创建实例\n}\n\n// new F() 的过程：\n// 1. 创建空对象 {}\n// 2. 设置 {}.__proto__ = F.prototype（即 proto）\n// 3. 执行 F()（空函数，什么都不做）\n// 4. 返回 {}\n```\n\n#### 为什么要用空构造函数？\n\n```javascript\n// 直接设置 __proto__ 会有性能问题\nconst obj = {};\nobj.__proto__ = proto;  // 不推荐，性能差\n\n// 使用空构造函数是标准做法\nfunction F() {}\nF.prototype = proto;\nconst obj = new F();\n```\n\n#### 第二个参数 propertiesObject\n\n```javascript\n// propertiesObject 是属性描述符对象\nconst obj = Object.create(proto, {\n  name: {\n    value: 'Tom',\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  age: {\n    value: 20,\n    writable: false\n  }\n});\n```\n\n#### Object.create(null) 的用途\n\n```javascript\n// 创建一个没有原型的纯净对象\nconst dict = Object.create(null);\n\nconsole.log(dict.toString);  // undefined（没有继承任何方法）\nconsole.log('toString' in dict);  // false\n\n// 适合用作纯粹的字典/映射\ndict['key'] = 'value';\n// 不用担心 key 与原型方法冲突\n```\n\n#### Object.create vs Object.setPrototypeOf\n\n```javascript\n// Object.create: 创建新对象并设置原型\nconst obj = Object.create(proto);\n\n// Object.setPrototypeOf: 修改已存在对象的原型\nconst obj = {};\nObject.setPrototypeOf(obj, proto);\n\n// 两者结果相同，但 setPrototypeOf 性能较差\n// 因为它会使对象的内部优化失效\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 空构造函数 | 标准的原型设置方式 |\n| F.prototype = proto | 设置新对象的原型 |\n| Object.create(null) | 创建无原型的纯净对象 |\n| propertiesObject | 属性描述符，用于定义属性 |"
  },
  {
    "id": "handwrite-instanceof",
    "title": "手写 instanceof",
    "difficulty": 1,
    "tags": [2],
    "description": "实现 instanceof 操作符，通过遍历原型链检查对象是否是某个构造函数的实例。",
    "template": "function myInstanceof(obj, Constructor) {\n  // 在此实现\n}",
    "testCases": [
      {
        "input": "function Person() {}\nconst p = new Person();\nmyInstanceof(p, Person);\nmyInstanceof(p, Object);",
        "expected": "两个都返回 true",
        "description": "检查对象是否在构造函数的原型链上"
      }
    ],
    "solution": "### 答案\n\n```javascript\nfunction myInstanceof(obj, Constructor) {\n  // 处理原始值\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return false;\n  }\n  \n  // 获取构造函数的原型\n  const prototype = Constructor.prototype;\n  \n  // 获取对象的原型\n  let proto = Object.getPrototypeOf(obj);\n  \n  // 沿原型链查找\n  while (proto !== null) {\n    if (proto === prototype) {\n      return true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  \n  return false;\n}\n```\n\n### 解析\n\n`instanceof` 检查构造函数的 `prototype` 属性是否出现在对象的原型链上。\n\n#### 原型链示意图\n\n```javascript\nfunction Person() {}\nconst p = new Person();\n\n// p 的原型链：\n// p.__proto__ → Person.prototype\n// Person.prototype.__proto__ → Object.prototype\n// Object.prototype.__proto__ → null\n\np instanceof Person;  // true，Person.prototype 在链上\np instanceof Object;  // true，Object.prototype 在链上\np instanceof Array;   // false，Array.prototype 不在链上\n```\n\n#### 核心逻辑\n\n```javascript\n// 检查 Constructor.prototype 是否在 obj 的原型链上\nfunction myInstanceof(obj, Constructor) {\n  let proto = obj.__proto__;  // 或 Object.getPrototypeOf(obj)\n  \n  while (proto) {\n    if (proto === Constructor.prototype) {\n      return true;\n    }\n    proto = proto.__proto__;\n  }\n  \n  return false;\n}\n```\n\n#### 为什么要处理原始值？\n\n```javascript\n// 原始值没有原型链（或被自动装箱）\n'hello' instanceof String;  // false\nnew String('hello') instanceof String;  // true\n\n1 instanceof Number;  // false\nnew Number(1) instanceof Number;  // true\n\n// null 和 undefined 总是返回 false\nnull instanceof Object;  // false\nundefined instanceof Object;  // false\n```\n\n#### Object.getPrototypeOf vs __proto__\n\n```javascript\n// 推荐使用 Object.getPrototypeOf\nObject.getPrototypeOf(obj);  // 标准方法\n\n// __proto__ 是非标准但广泛支持的\nobj.__proto__;  // 不推荐在生产代码中使用\n\n// 两者结果相同\nObject.getPrototypeOf(obj) === obj.__proto__;  // true\n```\n\n#### instanceof 的局限性\n\n```javascript\n// 1. 不能检测原始值\ntypeof 'hello' === 'string';  // true\n'hello' instanceof String;    // false\n\n// 2. 跨 iframe 问题\n// iframe 中的 Array 与主窗口的 Array 不同\niframeArray instanceof Array;  // 可能为 false\nArray.isArray(iframeArray);    // 推荐方式\n\n// 3. 可以被 Symbol.hasInstance 修改\nclass MyClass {\n  static [Symbol.hasInstance](obj) {\n    return typeof obj === 'string';\n  }\n}\n'hello' instanceof MyClass;  // true\n```\n\n### 关键点\n\n| 要点 | 说明 |\n|------|------|\n| 原型链查找 | 沿 __proto__ 链向上查找 |\n| Constructor.prototype | 检查这个是否在链上 |\n| 原始值处理 | 原始值直接返回 false |\n| null 终点 | 原型链以 null 结尾 |"
  },
  {
    "id": "ts-partial",
    "title": "实现 Partial<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Partial<T> 类型，将 T 中的所有属性变为可选。这是 TypeScript 内置工具类型之一，理解映射类型和可选修饰符 ? 的使用。",
    "template": "type MyPartial<T> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype MyPartial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n### 解析\n\n`Partial<T>` 是 TypeScript 最常用的内置工具类型之一，它将类型 T 的所有属性变为可选。\n\n#### 实现原理\n\n1. **`keyof T`**：获取类型 T 的所有键名组成的联合类型\n2. **`[P in keyof T]`**：映射类型语法，遍历 T 的所有键\n3. **`?`**：可选修饰符，将属性标记为可选\n4. **`T[P]`**：索引访问类型，获取 T 中键 P 对应的值类型\n\n#### 使用示例\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype PartialUser = MyPartial<User>;\n// 等价于：\n// {\n//   name?: string;\n//   age?: number;\n//   email?: string;\n// }\n\n// 可以只传部分属性\nconst user: PartialUser = { name: 'Alice' }; // OK\n```\n\n#### 映射类型基本语法\n\n```typescript\ntype MappedType<T> = {\n  [P in keyof T]: T[P];  // 基本映射，原样复制\n};\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `keyof T` | 获取 T 的所有键名联合类型 |\n| `[P in K]` | 遍历联合类型 K 中的每个成员 |\n| `?` | 将属性变为可选 |\n| `T[P]` | 获取 T 中 P 键对应的类型 |"
  },
  {
    "id": "ts-required",
    "title": "实现 Required<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Required<T> 类型，将 T 中的所有属性变为必选。理解 -? 修饰符如何移除可选标记。",
    "template": "type MyRequired<T> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype MyRequired<T> = {\n  [P in keyof T]-?: T[P];\n};\n```\n\n### 解析\n\n`Required<T>` 是 `Partial<T>` 的反向操作，它将类型 T 的所有可选属性变为必选。\n\n#### 实现原理\n\n关键在于 **`-?`** 修饰符：\n\n- **`?`**：添加可选修饰符\n- **`-?`**：移除可选修饰符（将属性变为必选）\n\n同理，还有 `-readonly` 可以移除只读修饰符。\n\n#### 使用示例\n\n```typescript\ninterface Config {\n  host?: string;\n  port?: number;\n  debug?: boolean;\n}\n\ntype RequiredConfig = MyRequired<Config>;\n// 等价于：\n// {\n//   host: string;\n//   port: number;\n//   debug: boolean;\n// }\n\n// 必须提供所有属性\nconst config: RequiredConfig = {\n  host: 'localhost',\n  port: 3000,\n  debug: true\n}; // OK\n\n// const bad: RequiredConfig = { host: 'localhost' }; // Error!\n```\n\n#### 修饰符操作\n\n```typescript\n// 添加修饰符\ntype Add = { [P in keyof T]?: T[P] };      // 添加 ?\ntype Add2 = { readonly [P in keyof T]: T[P] }; // 添加 readonly\n\n// 移除修饰符\ntype Remove = { [P in keyof T]-?: T[P] };      // 移除 ?\ntype Remove2 = { -readonly [P in keyof T]: T[P] }; // 移除 readonly\n```\n\n### 关键点\n\n| 修饰符 | 作用 |\n|--------|------|\n| `?` | 添加可选 |\n| `-?` | 移除可选（变必选） |\n| `readonly` | 添加只读 |\n| `-readonly` | 移除只读 |"
  },
  {
    "id": "ts-readonly",
    "title": "实现 Readonly<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Readonly<T> 类型，将 T 中的所有属性变为只读。理解 readonly 修饰符在映射类型中的应用。",
    "template": "type MyReadonly<T> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n```\n\n### 解析\n\n`Readonly<T>` 将类型 T 的所有属性变为只读，防止属性被重新赋值。\n\n#### 实现原理\n\n在映射类型中使用 **`readonly`** 修饰符，为每个属性添加只读标记。\n\n#### 使用示例\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype ReadonlyUser = MyReadonly<User>;\n// 等价于：\n// {\n//   readonly name: string;\n//   readonly age: number;\n// }\n\nconst user: ReadonlyUser = { name: 'Alice', age: 25 };\n// user.name = 'Bob'; // Error: Cannot assign to 'name' because it is a read-only property\n```\n\n#### readonly vs const\n\n```typescript\n// const 用于变量\nconst arr = [1, 2, 3];\narr.push(4); // OK，可以修改数组内容\narr = [];    // Error，不能重新赋值\n\n// readonly 用于属性\ninterface Obj {\n  readonly arr: number[];\n}\nconst obj: Obj = { arr: [1, 2, 3] };\nobj.arr.push(4); // OK，可以修改数组内容（浅只读）\nobj.arr = [];    // Error，不能重新赋值属性\n```\n\n#### 注意：浅只读\n\n`Readonly<T>` 只是浅只读，嵌套对象的属性仍然可以修改：\n\n```typescript\ninterface Nested {\n  user: { name: string };\n}\n\nconst obj: Readonly<Nested> = { user: { name: 'Alice' } };\nobj.user.name = 'Bob'; // OK，嵌套属性可以修改\n// obj.user = { name: 'Bob' }; // Error，顶层属性不能修改\n```\n\n如需深层只读，需要实现 `DeepReadonly<T>`。\n\n### 关键点\n\n| 特性 | 说明 |\n|------|------|\n| `readonly` | 添加只读修饰符 |\n| 浅只读 | 只影响顶层属性 |\n| 编译时检查 | 运行时仍可修改 |"
  },
  {
    "id": "ts-pick",
    "title": "实现 Pick<T, K> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Pick<T, K> 类型，从类型 T 中选取一组属性 K 构造新类型。理解 keyof 和 extends 约束的配合使用。",
    "template": "type MyPick<T, K> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype MyPick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n```\n\n### 解析\n\n`Pick<T, K>` 从类型 T 中选取指定的属性 K，构造一个新类型。\n\n#### 实现原理\n\n1. **`K extends keyof T`**：约束 K 必须是 T 的键名（或键名的联合类型）\n2. **`[P in K]`**：只遍历 K 中的键，而不是所有键\n3. **`T[P]`**：获取 T 中对应键的值类型\n\n#### 使用示例\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype UserBasic = MyPick<User, 'id' | 'name'>;\n// 等价于：\n// {\n//   id: number;\n//   name: string;\n// }\n\nconst user: UserBasic = {\n  id: 1,\n  name: 'Alice'\n}; // OK\n```\n\n#### 类型约束的作用\n\n```typescript\n// 如果不加 extends keyof T 约束：\ntype BadPick<T, K> = { [P in K]: T[P] };\ntype Test = BadPick<User, 'invalid'>; // 不会报错，但结果不正确\n\n// 加上约束后：\ntype GoodPick<T, K extends keyof T> = { [P in K]: T[P] };\ntype Test2 = GoodPick<User, 'invalid'>; // Error: Type '\"invalid\"' does not satisfy the constraint 'keyof User'\n```\n\n#### Pick vs Omit\n\n```typescript\n// Pick: 选取指定属性\ntype Picked = Pick<User, 'id' | 'name'>; // { id, name }\n\n// Omit: 排除指定属性（Pick 的反向操作）\ntype Omitted = Omit<User, 'id' | 'name'>; // { email, age }\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `K extends keyof T` | K 必须是 T 的键名 |\n| `[P in K]` | 只遍历 K 中的键 |\n| `keyof T` | T 的所有键名联合类型 |"
  },
  {
    "id": "ts-record",
    "title": "实现 Record<K, T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 Record<K, T> 类型，构造一个对象类型，其键名类型为 K，键值类型为 T。常用于创建字典/映射类型。",
    "template": "type MyRecord<K, T> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype MyRecord<K extends keyof any, T> = {\n  [P in K]: T;\n};\n```\n\n### 解析\n\n`Record<K, T>` 构造一个对象类型，其键名为 K 中的每个成员，值类型都是 T。\n\n#### 实现原理\n\n1. **`K extends keyof any`**：约束 K 必须是可以作为对象键的类型（`string | number | symbol`）\n2. **`[P in K]`**：遍历 K 中的每个成员作为键名\n3. **`T`**：每个键对应的值类型都是 T\n\n#### 为什么是 `keyof any`？\n\n```typescript\ntype KeyType = keyof any; // string | number | symbol\n```\n\n`keyof any` 返回所有可以作为对象键的类型，这确保了 K 只能是有效的键类型。\n\n#### 使用示例\n\n```typescript\n// 创建字典类型\ntype UserRole = 'admin' | 'user' | 'guest';\ntype RolePermissions = MyRecord<UserRole, string[]>;\n// 等价于：\n// {\n//   admin: string[];\n//   user: string[];\n//   guest: string[];\n// }\n\nconst permissions: RolePermissions = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n};\n```\n\n#### 常见用法\n\n```typescript\n// 1. 创建枚举映射\ntype StatusMap = Record<'pending' | 'success' | 'error', number>;\n\n// 2. 创建动态键对象\ntype StringMap = Record<string, unknown>;\n\n// 3. 创建 ID 映射\ntype UserMap = Record<number, User>;\n```\n\n#### Record vs 索引签名\n\n```typescript\n// Record 方式\ntype Dict1 = Record<string, number>;\n\n// 索引签名方式\ntype Dict2 = { [key: string]: number };\n\n// 两者基本等价，但 Record 可以使用联合类型作为键\ntype Dict3 = Record<'a' | 'b', number>; // { a: number; b: number }\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `keyof any` | `string \\| number \\| symbol` |\n| `[P in K]` | 遍历 K 中的每个成员 |\n| 统一值类型 | 所有键的值类型相同 |"
  },
  {
    "id": "ts-exclude",
    "title": "实现 Exclude<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Exclude<T, U> 类型，从联合类型 T 中排除那些可以赋值给 U 的类型。理解条件类型的分布式特性。",
    "template": "type MyExclude<T, U> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyExclude<T, U> = T extends U ? never : T;\n```\n\n### 解析\n\n`Exclude<T, U>` 从联合类型 T 中排除可以赋值给 U 的类型成员。\n\n#### 实现原理\n\n这里利用了**条件类型的分布式特性**：\n\n当 T 是联合类型时，`T extends U ? X : Y` 会自动分发到联合类型的每个成员上分别计算。\n\n#### 分布式执行过程\n\n```typescript\ntype Result = MyExclude<'a' | 'b' | 'c', 'a'>;\n\n// 分发执行：\n// = ('a' extends 'a' ? never : 'a') | ('b' extends 'a' ? never : 'b') | ('c' extends 'a' ? never : 'c')\n// = never | 'b' | 'c'\n// = 'b' | 'c'\n```\n\n#### 使用示例\n\n```typescript\ntype T1 = MyExclude<'a' | 'b' | 'c', 'a'>;        // 'b' | 'c'\ntype T2 = MyExclude<'a' | 'b' | 'c', 'a' | 'b'>;  // 'c'\ntype T3 = MyExclude<string | number | boolean, string>; // number | boolean\n```\n\n#### 分布式条件类型的条件\n\n分布式特性只在以下条件满足时生效：\n\n1. 条件类型中的被检查类型是**裸类型参数**（naked type parameter）\n2. 被检查的类型是**联合类型**\n\n```typescript\n// 裸类型参数 - 会分发\ntype Dist<T> = T extends string ? 'yes' : 'no';\ntype R1 = Dist<string | number>; // 'yes' | 'no'\n\n// 非裸类型参数 - 不会分发\ntype NoDist<T> = [T] extends [string] ? 'yes' : 'no';\ntype R2 = NoDist<string | number>; // 'no'\n```\n\n#### Exclude vs Extract\n\n```typescript\n// Exclude: 排除能赋值给 U 的类型\ntype E = Exclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'\n\n// Extract: 提取能赋值给 U 的类型（相反操作）\ntype Ex = Extract<'a' | 'b' | 'c', 'a' | 'b'>; // 'a' | 'b'\n```\n\n### 关键点\n\n| 概念 | 说明 |\n|------|------|\n| 分布式条件类型 | 联合类型会自动分发计算 |\n| `never` | 在联合类型中会被忽略 |\n| 裸类型参数 | 没有被包装的类型参数 |"
  },
  {
    "id": "ts-extract",
    "title": "实现 Extract<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Extract<T, U> 类型，从联合类型 T 中提取那些可以赋值给 U 的类型。与 Exclude 相反，理解条件类型中 extends 的判断逻辑。",
    "template": "type MyExtract<T, U> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyExtract<T, U> = T extends U ? T : never;\n```\n\n### 解析\n\n`Extract<T, U>` 从联合类型 T 中提取可以赋值给 U 的类型成员，与 `Exclude` 相反。\n\n#### 实现原理\n\n同样利用**条件类型的分布式特性**：\n\n- 如果 T 的成员可以赋值给 U，保留该成员（返回 `T`）\n- 否则排除该成员（返回 `never`）\n\n#### 分布式执行过程\n\n```typescript\ntype Result = MyExtract<'a' | 'b' | 'c', 'a' | 'b'>;\n\n// 分发执行：\n// = ('a' extends 'a' | 'b' ? 'a' : never) | ('b' extends 'a' | 'b' ? 'b' : never) | ('c' extends 'a' | 'b' ? never : never)\n// = 'a' | 'b' | never\n// = 'a' | 'b'\n```\n\n#### 使用示例\n\n```typescript\ntype T1 = MyExtract<'a' | 'b' | 'c', 'a' | 'f'>;  // 'a'\ntype T2 = MyExtract<string | number | boolean, string | number>; // string | number\ntype T3 = MyExtract<string | (() => void), Function>; // () => void\n```\n\n#### Extract vs Exclude 对比\n\n```typescript\ntype Union = 'a' | 'b' | 'c';\ntype Target = 'a' | 'b';\n\n// Extract: 保留能赋值给 Target 的\ntype Extracted = Extract<Union, Target>; // 'a' | 'b'\n\n// Exclude: 排除能赋值给 Target 的\ntype Excluded = Exclude<Union, Target>; // 'c'\n\n// 它们的结果互补\n// Extracted | Excluded = Union\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 提取函数类型\ntype Funcs = Extract<string | number | (() => void) | (() => string), Function>;\n// () => void | () => string\n\n// 2. 提取对象类型\ntype Objects = Extract<string | { a: 1 } | { b: 2 }, object>;\n// { a: 1 } | { b: 2 }\n\n// 3. 提取特定字符串\ntype Events = 'onClick' | 'onBlur' | 'value' | 'disabled';\ntype EventHandlers = Extract<Events, `on${string}`>; // 'onClick' | 'onBlur'\n```\n\n### 关键点\n\n| 类型 | 作用 |\n|------|------|\n| `Extract<T, U>` | 提取 T 中能赋值给 U 的类型 |\n| `Exclude<T, U>` | 排除 T 中能赋值给 U 的类型 |\n| 互补关系 | Extract + Exclude = 原联合类型 |"
  },
  {
    "id": "ts-omit",
    "title": "实现 Omit<T, K> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Omit<T, K> 类型，从类型 T 中排除一组属性 K。可以基于 Pick 和 Exclude 组合实现，理解工具类型的复合使用。",
    "template": "type MyOmit<T, K> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyOmit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\n或者不依赖 Pick 和 Exclude 的原生实现：\n\n```typescript\ntype MyOmit<T, K extends keyof any> = {\n  [P in keyof T as P extends K ? never : P]: T[P];\n};\n```\n\n### 解析\n\n`Omit<T, K>` 从类型 T 中排除指定的属性 K，是 `Pick` 的反向操作。\n\n#### 实现原理（组合方式）\n\n1. **`keyof T`**：获取 T 的所有键名\n2. **`Exclude<keyof T, K>`**：从所有键名中排除 K 中的键\n3. **`Pick<T, ...>`**：从 T 中选取剩余的键\n\n```typescript\n// 拆解过程\ntype User = { id: number; name: string; age: number };\ntype ToOmit = 'id';\n\n// Step 1: keyof User = 'id' | 'name' | 'age'\n// Step 2: Exclude<'id' | 'name' | 'age', 'id'> = 'name' | 'age'\n// Step 3: Pick<User, 'name' | 'age'> = { name: string; age: number }\n```\n\n#### 原生实现解析\n\n使用 **键重映射（Key Remapping）** 语法（TS 4.1+）：\n\n```typescript\ntype MyOmit<T, K> = {\n  [P in keyof T as P extends K ? never : P]: T[P];\n};\n```\n\n- `as P extends K ? never : P`：如果 P 是要排除的键，映射为 `never`（被移除）\n\n#### 使用示例\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\ntype PublicUser = MyOmit<User, 'password'>;\n// { id: number; name: string; email: string }\n\ntype UserWithoutAuth = MyOmit<User, 'password' | 'email'>;\n// { id: number; name: string }\n```\n\n#### Pick vs Omit\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Pick: 选取指定属性（白名单）\ntype Picked = Pick<User, 'id' | 'name'>; // { id, name }\n\n// Omit: 排除指定属性（黑名单）\ntype Omitted = Omit<User, 'email'>; // { id, name }\n\n// 两者结果相同，但语义不同\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `Pick` + `Exclude` | 组合实现 Omit |\n| `as` 键重映射 | TS 4.1+ 的原生实现方式 |\n| `K extends keyof any` | K 可以是任意键（不限于 T 的键） |"
  },
  {
    "id": "ts-nonnullable",
    "title": "实现 NonNullable<T> 类型",
    "difficulty": 1,
    "tags": [3],
    "description": "实现一个 NonNullable<T> 类型，从联合类型 T 中排除 null 和 undefined。常用于处理可能为空的类型。",
    "template": "type MyNonNullable<T> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyNonNullable<T> = T extends null | undefined ? never : T;\n```\n\n或者使用 `Exclude`：\n\n```typescript\ntype MyNonNullable<T> = Exclude<T, null | undefined>;\n```\n\n### 解析\n\n`NonNullable<T>` 从联合类型 T 中排除 `null` 和 `undefined`，确保类型不为空。\n\n#### 实现原理\n\n利用**条件类型的分布式特性**，将联合类型中的 `null` 和 `undefined` 过滤掉。\n\n#### 执行过程\n\n```typescript\ntype Result = MyNonNullable<string | null | undefined>;\n\n// 分发执行：\n// = (string extends null | undefined ? never : string)\n//   | (null extends null | undefined ? never : null)\n//   | (undefined extends null | undefined ? never : undefined)\n// = string | never | never\n// = string\n```\n\n#### 使用示例\n\n```typescript\ntype T1 = MyNonNullable<string | null>;           // string\ntype T2 = MyNonNullable<string | null | undefined>; // string\ntype T3 = MyNonNullable<string | number | null>;  // string | number\ntype T4 = MyNonNullable<null | undefined>;        // never\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 处理可选属性\ninterface User {\n  name: string;\n  email?: string | null;\n}\n\nfunction sendEmail(email: NonNullable<User['email']>) {\n  // email 的类型是 string，不是 string | null | undefined\n  console.log(email.toLowerCase());\n}\n\n// 2. 配合类型守卫\nfunction processValue<T>(value: T): NonNullable<T> {\n  if (value === null || value === undefined) {\n    throw new Error('Value cannot be null or undefined');\n  }\n  return value as NonNullable<T>;\n}\n\n// 3. 数组过滤\nconst arr: (string | null | undefined)[] = ['a', null, 'b', undefined];\nconst filtered: string[] = arr.filter((x): x is string => x != null);\n```\n\n#### 与其他工具类型对比\n\n```typescript\n// NonNullable: 排除 null 和 undefined\ntype A = NonNullable<string | null>; // string\n\n// Exclude: 可以排除任意类型\ntype B = Exclude<string | number | null, null>; // string | number\n\n// Required: 将属性变为必选（不同维度）\ntype C = Required<{ a?: string }>; // { a: string }\n```\n\n### 关键点\n\n| 概念 | 说明 |\n|------|------|\n| 分布式条件类型 | 对联合类型的每个成员分别判断 |\n| `null \\| undefined` | TypeScript 中的空值类型 |\n| 实际就是 `Exclude` | `NonNullable<T>` = `Exclude<T, null \\| undefined>` |"
  },
  {
    "id": "ts-merge",
    "title": "实现 Merge<T, U> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Merge<T, U> 类型，将类型 U 的属性合并到类型 T 中，如果有相同的键则 U 的类型覆盖 T。理解交叉类型与映射类型的区别。",
    "template": "type Merge<T, U> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype Merge<T, U> = {\n  [P in keyof T | keyof U]: P extends keyof U\n    ? U[P]\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n```\n\n或者使用 `Omit` 的简洁写法：\n\n```typescript\ntype Merge<T, U> = Omit<T, keyof U> & U;\n```\n\n### 解析\n\n`Merge<T, U>` 将两个类型合并，相同键名时 U 的类型覆盖 T 的类型。\n\n#### 实现原理\n\n1. **`keyof T | keyof U`**：获取 T 和 U 所有键名的联合\n2. **条件判断**：如果键存在于 U 中，取 U 的类型；否则取 T 的类型\n\n#### 为什么不能直接用 `T & U`？\n\n交叉类型 `T & U` 对于相同键名会**合并类型**，而不是覆盖：\n\n```typescript\ntype T = { a: string; b: number };\ntype U = { b: string; c: boolean };\n\n// 交叉类型：b 变成 number & string = never\ntype Intersection = T & U;\n// { a: string; b: never; c: boolean }\n\n// Merge：b 被 U 覆盖\ntype Merged = Merge<T, U>;\n// { a: string; b: string; c: boolean }\n```\n\n#### 使用示例\n\n```typescript\ninterface DefaultConfig {\n  host: string;\n  port: number;\n  debug: boolean;\n}\n\ninterface UserConfig {\n  port: string;  // 覆盖为 string 类型\n  timeout: number;\n}\n\ntype FinalConfig = Merge<DefaultConfig, UserConfig>;\n// {\n//   host: string;\n//   port: string;     // 被 UserConfig 覆盖\n//   debug: boolean;\n//   timeout: number;  // 新增\n// }\n```\n\n#### 简洁写法解析\n\n```typescript\ntype Merge<T, U> = Omit<T, keyof U> & U;\n```\n\n1. `Omit<T, keyof U>`：从 T 中移除与 U 相同的键\n2. `& U`：合并 U 的所有属性\n\n这样相同键只会存在 U 的版本。\n\n#### Merge vs 交叉类型 vs Object.assign\n\n| 操作 | 相同键处理 |\n|------|----------|\n| `T & U` | 类型合并（可能变成 never） |\n| `Merge<T, U>` | U 覆盖 T |\n| `Object.assign(t, u)` | 运行时 U 覆盖 T |\n\n### 关键点\n\n| 概念 | 说明 |\n|------|------|\n| `keyof T \\| keyof U` | 两个类型的所有键名 |\n| U 优先 | 相同键名时 U 的类型覆盖 T |\n| 交叉类型的局限 | 相同键会合并类型而非覆盖 |"
  },
  {
    "id": "ts-mutable",
    "title": "实现 Mutable<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Mutable<T> 类型，移除 T 中所有属性的 readonly 只读修饰符。理解 -readonly 修饰符的使用，与 Readonly 相反。",
    "template": "type Mutable<T> = {\n  // 在此实现\n}",
    "solution": "### 答案\n\n```typescript\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n```\n\n### 解析\n\n`Mutable<T>` 是 `Readonly<T>` 的反向操作，它移除类型 T 所有属性的 `readonly` 修饰符。\n\n#### 实现原理\n\n使用 **`-readonly`** 修饰符移除只读标记：\n\n- **`readonly`**：添加只读修饰符\n- **`-readonly`**：移除只读修饰符（使属性可写）\n\n#### 使用示例\n\n```typescript\ninterface ReadonlyUser {\n  readonly id: number;\n  readonly name: string;\n  readonly email: string;\n}\n\ntype MutableUser = Mutable<ReadonlyUser>;\n// 等价于：\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n// }\n\nconst user: MutableUser = { id: 1, name: 'Alice', email: 'a@b.com' };\nuser.name = 'Bob'; // OK，可以修改\n```\n\n#### Readonly vs Mutable\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Readonly: 添加 readonly\ntype RO = Readonly<User>;\n// { readonly id: number; readonly name: string }\n\n// Mutable: 移除 readonly\ntype MU = Mutable<RO>;\n// { id: number; name: string }\n\n// 互为逆操作\ntype Original = Mutable<Readonly<User>>; // 回到原始类型\n```\n\n#### 修饰符操作总结\n\n```typescript\n// 可选修饰符\ntype AddOptional<T> = { [P in keyof T]?: T[P] };     // 添加 ?\ntype RemoveOptional<T> = { [P in keyof T]-?: T[P] }; // 移除 ?\n\n// 只读修饰符\ntype AddReadonly<T> = { readonly [P in keyof T]: T[P] };  // 添加 readonly\ntype RemoveReadonly<T> = { -readonly [P in keyof T]: T[P] }; // 移除 readonly\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 创建可修改的副本\nconst frozenConfig: Readonly<Config> = Object.freeze({ ... });\nconst editableConfig: Mutable<typeof frozenConfig> = { ...frozenConfig };\n\n// 2. 状态管理中的草稿\ninterface State {\n  readonly user: User;\n  readonly loading: boolean;\n}\n\nfunction createDraft(state: State): Mutable<State> {\n  return { ...state };\n}\n```\n\n### 关键点\n\n| 修饰符 | 作用 |\n|--------|------|\n| `readonly` | 添加只读 |\n| `-readonly` | 移除只读 |\n| `?` | 添加可选 |\n| `-?` | 移除可选 |"
  },
  {
    "id": "ts-tuple-to-union",
    "title": "实现 TupleToUnion<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 TupleToUnion<T> 类型，将元组类型转换为联合类型。例如 [string, number] 转为 string | number。理解元组的索引访问类型。",
    "template": "type TupleToUnion<T extends readonly any[]> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype TupleToUnion<T extends readonly any[]> = T[number];\n```\n\n### 解析\n\n`TupleToUnion<T>` 将元组类型转换为其所有元素类型的联合类型。\n\n#### 实现原理\n\n使用 **`T[number]`** 索引访问类型：\n\n- `T` 是一个元组类型（本质是数组）\n- `number` 作为索引，表示\"所有数字索引\"\n- `T[number]` 获取元组中所有元素类型的联合\n\n#### 执行过程\n\n```typescript\ntype Tuple = [string, number, boolean];\n\ntype Result = TupleToUnion<Tuple>;\n// T[number] = Tuple[0] | Tuple[1] | Tuple[2]\n// = string | number | boolean\n```\n\n#### 使用示例\n\n```typescript\ntype T1 = TupleToUnion<[string, number]>;        // string | number\ntype T2 = TupleToUnion<[1, 2, 3]>;               // 1 | 2 | 3\ntype T3 = TupleToUnion<['a', 'b', 'c']>;         // 'a' | 'b' | 'c'\ntype T4 = TupleToUnion<[string, string]>;        // string\ntype T5 = TupleToUnion<[]>;                       // never（空元组）\n```\n\n#### 为什么 `T[number]` 有效？\n\n在 TypeScript 中：\n\n```typescript\n// 数组/元组的类型定义本质上是这样的：\ninterface Array<T> {\n  [index: number]: T;\n  length: number;\n  // ...\n}\n\n// 对于元组 [string, number, boolean]：\n// 0 -> string\n// 1 -> number\n// 2 -> boolean\n\n// T[number] 获取所有数字索引对应的类型的联合\n```\n\n#### 元组 vs 数组\n\n```typescript\n// 元组：固定长度，每个位置类型可以不同\ntype Tuple = [string, number];  // 长度为 2\n\n// 数组：不定长度，所有元素类型相同\ntype Arr = string[];  // 任意长度\n\n// TupleToUnion 对数组也有效\ntype ArrUnion = TupleToUnion<string[]>;  // string\n```\n\n#### readonly 修饰符\n\n模板中使用 `readonly any[]` 是为了兼容只读元组：\n\n```typescript\nconst tuple = ['a', 'b'] as const;  // readonly ['a', 'b']\ntype T = TupleToUnion<typeof tuple>; // 'a' | 'b'\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `T[number]` | 获取数组/元组所有元素类型的联合 |\n| `T[0]` | 获取第一个元素的类型 |\n| `readonly any[]` | 兼容普通数组和只读数组 |"
  },
  {
    "id": "ts-deep-readonly",
    "title": "实现 DeepReadonly<T> 类型",
    "difficulty": 3,
    "tags": [3],
    "description": "实现一个 DeepReadonly<T> 类型，递归地将 T 中的所有属性（包括嵌套对象）变为只读。理解递归类型和条件类型的结合使用。",
    "template": "type DeepReadonly<T> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype DeepReadonly<T> = T extends object\n  ? T extends Function\n    ? T\n    : { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  : T;\n```\n\n### 解析\n\n`DeepReadonly<T>` 递归地将类型 T 的所有属性（包括嵌套对象）变为只读。\n\n#### 实现原理\n\n1. **判断是否为对象**：`T extends object`\n2. **排除函数类型**：函数也是 object，但不需要递归处理\n3. **递归处理**：对每个属性应用 `DeepReadonly`\n\n#### 为什么要排除 Function？\n\n```typescript\n// 函数也是 object\ntypeof (() => {}) === 'object'  // false（typeof 返回 'function'）\n// 但在类型系统中：\ntype Test = (() => void) extends object ? 'yes' : 'no';  // 'yes'\n```\n\n如果不排除函数，函数类型会被错误地处理。\n\n#### 使用示例\n\n```typescript\ninterface User {\n  name: string;\n  profile: {\n    age: number;\n    address: {\n      city: string;\n      zip: number;\n    };\n  };\n  tags: string[];\n}\n\ntype ReadonlyUser = DeepReadonly<User>;\n// {\n//   readonly name: string;\n//   readonly profile: {\n//     readonly age: number;\n//     readonly address: {\n//       readonly city: string;\n//       readonly zip: number;\n//     };\n//   };\n//   readonly tags: readonly string[];\n// }\n\nconst user: ReadonlyUser = { ... };\n// user.name = 'Bob';                    // Error\n// user.profile.age = 30;                // Error\n// user.profile.address.city = 'NYC';    // Error\n```\n\n#### Readonly vs DeepReadonly\n\n```typescript\ninterface Nested {\n  user: { name: string };\n}\n\n// Readonly: 只处理顶层\ntype Shallow = Readonly<Nested>;\nconst a: Shallow = { user: { name: 'Alice' } };\na.user.name = 'Bob';  // OK，嵌套属性可修改\n\n// DeepReadonly: 递归处理所有层级\ntype Deep = DeepReadonly<Nested>;\nconst b: Deep = { user: { name: 'Alice' } };\n// b.user.name = 'Bob';  // Error，嵌套属性也不可修改\n```\n\n#### 处理数组的版本\n\n```typescript\ntype DeepReadonly<T> = T extends object\n  ? T extends Function\n    ? T\n    : T extends readonly (infer U)[]\n    ? readonly DeepReadonly<U>[]\n    : { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  : T;\n```\n\n这个版本特别处理数组，确保 `string[]` 变成 `readonly string[]`。\n\n### 关键点\n\n| 概念 | 说明 |\n|------|------|\n| 递归类型 | 类型定义中引用自身 |\n| 条件类型 | 根据类型判断返回不同结果 |\n| 排除函数 | 避免错误处理函数类型 |\n| `T extends object` | 判断是否为对象类型 |"
  },
  {
    "id": "ts-return-type",
    "title": "实现 ReturnType<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ReturnType<T> 类型，获取函数类型 T 的返回值类型。理解 infer 关键字在条件类型中推断类型的用法。",
    "template": "type MyReturnType<T extends (...args: any) => any> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : never;\n```\n\n### 解析\n\n`ReturnType<T>` 获取函数类型 T 的返回值类型。\n\n#### 实现原理\n\n使用 **`infer`** 关键字在条件类型中推断返回值类型：\n\n1. **`T extends (...args: any) => infer R`**：检查 T 是否是一个函数类型\n2. **`infer R`**：在返回值位置声明一个类型变量 R，让 TypeScript 自动推断\n3. **`? R : never`**：如果 T 是函数类型，返回推断出的 R；否则返回 never\n\n#### infer 关键字详解\n\n`infer` 只能在条件类型的 `extends` 子句中使用，用于声明一个待推断的类型变量：\n\n```typescript\n// infer 的位置决定了推断什么\nT extends (...args: any) => infer R  // R 是返回值类型\nT extends (...args: infer P) => any  // P 是参数类型\nT extends Array<infer U>             // U 是数组元素类型\nT extends Promise<infer V>           // V 是 Promise 解析后的类型\n```\n\n#### 使用示例\n\n```typescript\ntype T1 = MyReturnType<() => string>;           // string\ntype T2 = MyReturnType<() => void>;             // void\ntype T3 = MyReturnType<(x: number) => boolean>; // boolean\ntype T4 = MyReturnType<() => Promise<number>>;  // Promise<number>\ntype T5 = MyReturnType<typeof Math.random>;     // number\n\n// 获取异步函数的返回值\ntype AsyncFn = () => Promise<{ data: string }>;\ntype T6 = MyReturnType<AsyncFn>;  // Promise<{ data: string }>\n\n// 配合 Awaited 获取 Promise 内部类型\ntype T7 = Awaited<MyReturnType<AsyncFn>>;  // { data: string }\n```\n\n#### 泛型约束的作用\n\n```typescript\n// 有约束：T 必须是函数类型\ntype MyReturnType<T extends (...args: any) => any> = ...;\nMyReturnType<string>;  // Error: Type 'string' does not satisfy the constraint\n\n// 无约束：任何类型都可以传入\ntype BadReturnType<T> = T extends (...args: any) => infer R ? R : never;\nBadReturnType<string>;  // never（不报错，但结果无意义）\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 获取工厂函数的产出类型\nfunction createUser() {\n  return { id: 1, name: 'Alice' };\n}\ntype User = ReturnType<typeof createUser>;\n// { id: number; name: string }\n\n// 2. 获取 React Hook 的返回类型\ntype UseStateReturn = ReturnType<typeof useState<number>>;\n// [number, Dispatch<SetStateAction<number>>]\n\n// 3. 获取异步函数处理后的类型\ntype GetData = () => Promise<{ items: string[] }>;\ntype Data = Awaited<ReturnType<GetData>>;  // { items: string[] }\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `infer R` | 声明待推断的类型变量 |\n| `(...args: any) => any` | 函数类型的通用表示 |\n| `typeof fn` | 获取函数的类型 |\n| 泛型约束 | 确保 T 是有效的函数类型 |"
  },
  {
    "id": "ts-parameters",
    "title": "实现 Parameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 Parameters<T> 类型，获取函数类型 T 的参数类型，返回一个元组类型。理解 infer 如何推断函数参数。",
    "template": "type MyParameters<T extends (...args: any) => any> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n```\n\n### 解析\n\n`Parameters<T>` 获取函数类型 T 的参数类型，返回一个元组。\n\n#### 实现原理\n\n使用 **`infer`** 在参数位置推断类型：\n\n1. **`T extends (...args: infer P) => any`**：检查 T 是否是函数类型\n2. **`infer P`**：在参数位置声明类型变量 P，推断所有参数类型\n3. **返回 P**：P 是一个包含所有参数类型的元组\n\n#### 使用示例\n\n```typescript\ntype T1 = MyParameters<() => void>;                    // []\ntype T2 = MyParameters<(a: string) => void>;           // [string]\ntype T3 = MyParameters<(a: string, b: number) => void>; // [string, number]\ntype T4 = MyParameters<(a: string, b?: number) => void>; // [string, number?]\ntype T5 = MyParameters<(...args: number[]) => void>;   // number[]\n\n// 获取内置函数的参数类型\ntype T6 = MyParameters<typeof Math.max>;   // number[]\ntype T7 = MyParameters<typeof parseInt>;   // [string, number?]\n```\n\n#### Parameters vs ReturnType\n\n```typescript\ntype Fn = (a: string, b: number) => boolean;\n\ntype Params = Parameters<Fn>;     // [string, number] - 参数类型元组\ntype Return = ReturnType<Fn>;     // boolean - 返回值类型\n```\n\n两者都使用 `infer`，只是推断的位置不同：\n\n```typescript\n// Parameters: infer 在参数位置\nT extends (...args: infer P) => any\n\n// ReturnType: infer 在返回值位置\nT extends (...args: any) => infer R\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 创建相同参数签名的函数\nfunction original(a: string, b: number, c: boolean) {\n  return { a, b, c };\n}\n\nfunction wrapper(...args: Parameters<typeof original>) {\n  console.log('Before call');\n  const result = original(...args);\n  console.log('After call');\n  return result;\n}\n\n// 2. 提取第一个参数类型\ntype FirstParam<T extends (...args: any) => any> = Parameters<T>[0];\ntype First = FirstParam<(a: string, b: number) => void>;  // string\n\n// 3. 提取最后一个参数类型（更复杂）\ntype LastParam<T extends (...args: any) => any> = \n  Parameters<T> extends [...any[], infer L] ? L : never;\ntype Last = LastParam<(a: string, b: number) => void>;  // number\n\n// 4. 构建函数重载\ntype Callback = Parameters<typeof addEventListener>[1];\n```\n\n#### 元组的索引访问\n\n```typescript\ntype Fn = (a: string, b: number, c: boolean) => void;\ntype Params = Parameters<Fn>;  // [string, number, boolean]\n\ntype First = Params[0];   // string\ntype Second = Params[1];  // number\ntype Third = Params[2];   // boolean\n\n// 获取参数数量\ntype Count = Params['length'];  // 3\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `infer P` | 在参数位置推断类型 |\n| 返回元组 | 结果是参数类型的有序组合 |\n| `P[0]` | 获取第一个参数类型 |\n| `P['length']` | 获取参数数量 |"
  },
  {
    "id": "ts-constructor-parameters",
    "title": "实现 ConstructorParameters<T> 类型",
    "difficulty": 2,
    "tags": [3],
    "description": "实现一个 ConstructorParameters<T> 类型，获取构造函数类型 T 的参数类型元组。理解 new (...args) => any 构造签名的类型表示。",
    "template": "type MyConstructorParameters<T extends abstract new (...args: any) => any> = // 在此实现",
    "solution": "### 答案\n\n```typescript\ntype MyConstructorParameters<T extends abstract new (...args: any) => any> = \n  T extends abstract new (...args: infer P) => any ? P : never;\n```\n\n### 解析\n\n`ConstructorParameters<T>` 获取构造函数类型 T 的参数类型，返回一个元组。\n\n#### 实现原理\n\n与 `Parameters<T>` 类似，但针对的是**构造函数**而非普通函数：\n\n1. **`new (...args: any) => any`**：构造函数的类型表示\n2. **`abstract new`**：兼容抽象类的构造函数\n3. **`infer P`**：推断构造函数的参数类型\n\n#### 构造签名 vs 调用签名\n\n```typescript\n// 调用签名（普通函数）\ntype CallSignature = (...args: any) => any;\n\n// 构造签名（构造函数，用 new 调用）\ntype ConstructSignature = new (...args: any) => any;\n\n// 抽象构造签名（包括抽象类）\ntype AbstractConstructSignature = abstract new (...args: any) => any;\n```\n\n#### 使用示例\n\n```typescript\nclass User {\n  constructor(public name: string, public age: number) {}\n}\n\ntype T1 = MyConstructorParameters<typeof User>;  // [string, number]\n\n// 内置类型\ntype T2 = MyConstructorParameters<typeof Date>;    // [value?: string | number | Date]\ntype T3 = MyConstructorParameters<typeof RegExp>;  // [pattern: string | RegExp, flags?: string]\ntype T4 = MyConstructorParameters<typeof Error>;   // [message?: string]\ntype T5 = MyConstructorParameters<typeof Array>;   // [arrayLength?: number]\n```\n\n#### 为什么要用 `abstract new`？\n\n```typescript\nabstract class Animal {\n  constructor(public name: string) {}\n  abstract speak(): void;\n}\n\nclass Dog extends Animal {\n  speak() { console.log('Woof!'); }\n}\n\n// 如果不用 abstract new，无法处理抽象类\ntype WithAbstract = MyConstructorParameters<typeof Animal>;  // [string] ✓\n\n// 使用 new (...args: any) => any 会报错\n// Type 'typeof Animal' does not satisfy the constraint 'new (...args: any) => any'\n```\n\n#### ConstructorParameters vs Parameters\n\n```typescript\nclass Example {\n  constructor(a: string, b: number) {}\n  method(x: boolean): void {}\n}\n\n// ConstructorParameters: 获取构造函数参数\ntype CtorParams = ConstructorParameters<typeof Example>;  // [string, number]\n\n// Parameters: 获取普通函数/方法参数\ntype MethodParams = Parameters<Example['method']>;  // [boolean]\n```\n\n#### 实际应用场景\n\n```typescript\n// 1. 工厂函数保持类型安全\nfunction createInstance<T extends new (...args: any) => any>(\n  Ctor: T,\n  ...args: ConstructorParameters<T>\n): InstanceType<T> {\n  return new Ctor(...args);\n}\n\nconst user = createInstance(User, 'Alice', 25);  // User 类型\n\n// 2. 依赖注入容器\ntype Constructor<T = any> = new (...args: any[]) => T;\n\nclass Container {\n  resolve<T extends Constructor>(token: T): InstanceType<T> {\n    const params = this.resolveDependencies(token);\n    return new token(...params);\n  }\n}\n\n// 3. 混入（Mixin）模式\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n\nfunction Timestamped<TBase extends GConstructor>(Base: TBase) {\n  return class extends Base {\n    timestamp = Date.now();\n  };\n}\n```\n\n#### 相关工具类型\n\n```typescript\n// InstanceType: 获取构造函数的实例类型\ntype Instance = InstanceType<typeof User>;  // User\n\n// ConstructorParameters: 获取构造函数参数\ntype Params = ConstructorParameters<typeof User>;  // [string, number]\n```\n\n### 关键点\n\n| 语法 | 含义 |\n|------|------|\n| `new (...args: any) => any` | 构造函数类型 |\n| `abstract new` | 兼容抽象类 |\n| `typeof Class` | 获取类的构造函数类型 |\n| `InstanceType<T>` | 获取构造函数的实例类型 |"
  },
  {
    "id": "js-hoisting-function-vs-var",
    "title": "函数声明 vs 函数表达式提升",
    "difficulty": 1,
    "tags": [1],
    "description": "console.log(foo);\nconsole.log(bar);\n\nfunction foo() { return 1; }\nvar bar = function() { return 2; };\n\n// 输出什么？",
    "template": "console.log(foo);\nconsole.log(bar);\n\nfunction foo() { return 1; }\nvar bar = function() { return 2; };",
    "solution": "### 答案\n\n```\n[Function: foo]\nundefined\n```\n\n### 解析\n\n这道题考察的是 JavaScript 中**函数声明**和**函数表达式**的提升（hoisting）区别。\n\n#### 1. 函数声明会整体提升\n\n```javascript\nfunction foo() { return 1; }\n```\n\n函数声明会被**完整地提升**到作用域顶部，包括函数名和函数体。所以在代码执行前，`foo` 已经是一个完整的函数了。\n\n#### 2. 函数表达式只提升变量声明\n\n```javascript\nvar bar = function() { return 2; };\n```\n\n这是一个**函数表达式**，本质上是一个变量赋值语句。`var bar` 会被提升，但赋值操作 `= function() {...}` 不会提升。所以在赋值之前，`bar` 的值是 `undefined`。\n\n#### 代码的实际执行顺序\n\n```javascript\n// 提升阶段\nvar bar;                           // 变量声明提升\nfunction foo() { return 1; }       // 函数声明整体提升\n\n// 执行阶段\nconsole.log(foo);                  // [Function: foo]\nconsole.log(bar);                  // undefined\nbar = function() { return 2; };    // 此时才赋值\n```\n\n### 关键点\n\n| 类型 | 提升内容 | 提升后的值 |\n|------|----------|------------|\n| 函数声明 | 整个函数 | 完整的函数对象 |\n| var 函数表达式 | 仅变量名 | undefined |\n| let/const 函数表达式 | 不可访问（TDZ） | ReferenceError |"
  },
  {
    "id": "js-null-vs-undefined",
    "title": "null 和 undefined 的区别",
    "difficulty": 1,
    "tags": [1],
    "description": "let a;\nlet b = null;\nfunction c() {}\nlet d = void 0;\n\nconsole.log(null == undefined);\nconsole.log(null === undefined);\nconsole.log(typeof null);\nconsole.log(typeof undefined);\n\nfunction foo(a = 1) {\n  console.log(a);\n}\nfoo(undefined);\nfoo(null);\n\n// 分别输出什么？",
    "template": "let a;\nlet b = null;\nfunction c() {}\nlet d = void 0;\n\nconsole.log(null == undefined);\nconsole.log(null === undefined);\nconsole.log(typeof null);\nconsole.log(typeof undefined);\n\nfunction foo(a = 1) {\n  console.log(a);\n}\nfoo(undefined);\nfoo(null);",
    "solution": "### 答案\n\n```\ntrue\nfalse\nobject\nundefined\n1\nnull\n```\n\n### 解析\n\n#### 1. 相等性比较\n\n```javascript\nconsole.log(null == undefined);   // true\nconsole.log(null === undefined);  // false\n```\n\n- **宽松相等 `==`**：`null` 和 `undefined` 被认为是相等的（这是 JS 规范的特殊规定）\n- **严格相等 `===`**：类型不同，所以不相等（`null` 是 `object` 类型，`undefined` 是 `undefined` 类型）\n\n#### 2. typeof 操作符\n\n```javascript\nconsole.log(typeof null);       // 'object'\nconsole.log(typeof undefined);  // 'undefined'\n```\n\n- `typeof null` 返回 `'object'` 是 JavaScript 的一个**历史遗留 bug**。在 JS 最初的实现中，值以 32 位存储，前 3 位表示类型标签，`000` 表示对象，而 `null` 的所有位都是 0，所以被错误地判断为对象。\n- `typeof undefined` 正常返回 `'undefined'`\n\n#### 3. 默认参数行为\n\n```javascript\nfunction foo(a = 1) {\n  console.log(a);\n}\nfoo(undefined);  // 1\nfoo(null);       // null\n```\n\n- **`undefined` 会触发默认值**：当参数为 `undefined` 时，会使用默认值 `1`\n- **`null` 不会触发默认值**：`null` 是一个明确的值，表示\"空\"，不会触发默认参数\n\n### 关键点\n\n| 特性 | null | undefined |\n|------|------|-----------|  \n| 含义 | 有意的空值 | 未定义/缺失 |\n| typeof | 'object'（历史bug） | 'undefined' |\n| == 比较 | 相等 | 相等 |\n| === 比较 | 不相等 | 不相等 |\n| 触发默认参数 | 否 | 是 |"
  },
  {
    "id": "js-hoisting-priority",
    "title": "函数提升优先于变量提升",
    "difficulty": 2,
    "tags": [1],
    "description": "console.log(typeof a);\n\nvar a;\nfunction a() {}\nvar a = 1;\n\nconsole.log(typeof a);\n\n// 两次输出分别是什么？",
    "template": "console.log(typeof a);\n\nvar a;\nfunction a() {}\nvar a = 1;\n\nconsole.log(typeof a);",
    "solution": "### 答案\n\n```\nfunction\nnumber\n```\n\n### 解析\n\n这道题考察的是**函数提升优先于变量提升**的规则。\n\n#### 提升规则\n\n1. **函数声明会被完整提升**，包括函数名和函数体\n2. **变量声明只提升声明**，不提升赋值\n3. **函数声明优先于变量声明**：当函数和变量同名时，函数声明会覆盖变量声明（但不会覆盖变量赋值）\n\n#### 代码的实际执行顺序\n\n```javascript\n// 提升阶段（编译阶段）\nfunction a() {}    // 函数声明提升\nvar a;             // 变量声明提升，但因为 a 已经存在（是函数），所以这行被忽略\n\n// 执行阶段\nconsole.log(typeof a);  // 'function'，此时 a 是函数\na = 1;                   // 赋值操作，a 被重新赋值为 1\nconsole.log(typeof a);  // 'number'，此时 a 是数字\n```\n\n#### 为什么第一次输出 'function'？\n\n在提升阶段：\n- `function a() {}` 被提升\n- `var a;` 虽然也被提升，但由于同名的函数声明已经存在，**变量声明不会覆盖函数声明**\n\n所以在第一次 `console.log` 时，`a` 仍然是函数。\n\n#### 为什么第二次输出 'number'？\n\n`var a = 1;` 中的赋值操作 `a = 1` 是在执行阶段进行的，它会**覆盖**之前的函数，所以第二次输出时 `a` 是数字。\n\n### 关键点\n\n| 情况 | 结果 |\n|------|------|\n| 同名函数声明和变量声明 | 函数声明优先 |\n| 同名函数声明和变量赋值 | 变量赋值会覆盖函数 |\n| 多个同名函数声明 | 后面的覆盖前面的 |"
  },
  {
    "id": "js-closure-loop-var",
    "title": "闭包与 var 循环变量",
    "difficulty": 2,
    "tags": [1],
    "description": "function createFunctions() {\n  var result = [];\n  for (var i = 0; i < 3; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  return result;\n}\n\nvar funcs = createFunctions();\nconsole.log(funcs[0]());\nconsole.log(funcs[1]());\nconsole.log(funcs[2]());\n\n// 输出什么？为什么？",
    "template": "function createFunctions() {\n  var result = [];\n  for (var i = 0; i < 3; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  return result;\n}\n\nvar funcs = createFunctions();\nconsole.log(funcs[0]());\nconsole.log(funcs[1]());\nconsole.log(funcs[2]());",
    "solution": "### 答案\n\n```\n3\n3\n3\n```\n\n### 解析\n\n这是一道经典的**闭包陷阱题**，考察 `var` 变量的作用域和闭包的特性。\n\n#### 为什么都输出 3？\n\n1. **`var` 没有块级作用域**：`var i` 声明的变量 `i` 属于整个 `createFunctions` 函数作用域，而不是循环的块级作用域\n\n2. **闭包引用的是变量本身，而非值**：每个匿名函数 `function() { return i; }` 形成了闭包，它们都引用同一个变量 `i`\n\n3. **函数调用时才读取 `i` 的值**：当循环结束后，`i` 的值已经变成了 `3`。此时调用任何一个函数，都会读取到 `i` 的当前值 `3`\n\n#### 执行过程\n\n```javascript\n// 循环执行：\ni = 0 → 创建 result[0] = function() { return i; }\ni = 1 → 创建 result[1] = function() { return i; }\ni = 2 → 创建 result[2] = function() { return i; }\ni = 3 → 循环结束\n\n// 调用函数时：\nfuncs[0]() → return i → i 是 3 → 输出 3\nfuncs[1]() → return i → i 是 3 → 输出 3\nfuncs[2]() → return i → i 是 3 → 输出 3\n```\n\n### 解决方案\n\n#### 方案一：使用 `let`（推荐）\n\n```javascript\nfor (let i = 0; i < 3; i++) {\n  result[i] = function() { return i; };\n}\n```\n\n`let` 有块级作用域，每次循环都会创建一个新的 `i`。\n\n#### 方案二：使用 IIFE（立即执行函数）\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  result[i] = (function(j) {\n    return function() { return j; };\n  })(i);\n}\n```\n\n通过 IIFE 创建新的作用域，把当前的 `i` 值传入。\n\n### 关键点\n\n| 关键字 | 作用域 | 循环中的行为 |\n|--------|--------|------------|\n| var | 函数作用域 | 所有闭包共享同一个变量 |\n| let | 块级作用域 | 每次迭代创建新的变量 |"
  },
  {
    "id": "js-var-hoisting-in-function",
    "title": "函数内变量提升",
    "difficulty": 1,
    "tags": [1],
    "description": "var a = 10;\nfunction foo() {\n  console.log(a);\n  var a = 20;\n}\nfoo();\n\n// 输出什么？",
    "template": "var a = 10;\nfunction foo() {\n  console.log(a);\n  var a = 20;\n}\nfoo();",
    "solution": "### 答案\n\n```\nundefined\n```\n\n### 解析\n\n这道题考察的是 **`var` 变量在函数作用域内的提升**。\n\n#### 为什么不是输出 10？\n\n很多人会认为，既然全局有 `var a = 10`，那么 `console.log(a)` 应该输出 `10`。但实际上输出的是 `undefined`。\n\n原因：**函数内部的 `var a` 声明会被提升到函数顶部**，这导致函数内部的 `a` 遮蔽了全局的 `a`。\n\n#### 代码的实际执行顺序\n\n```javascript\nvar a = 10;\n\nfunction foo() {\n  var a;              // 变量声明被提升到函数顶部\n  console.log(a);     // 此时 a 是 undefined\n  a = 20;             // 赋值操作在原位置执行\n}\n\nfoo();\n```\n\n#### 变量查找规则\n\nJavaScript 引擎在执行 `console.log(a)` 时：\n\n1. 先在当前作用域（foo 函数）查找 `a`\n2. 找到了（因为 `var a = 20` 的声明被提升了）\n3. 但此时只有声明，还没有赋值，所以值是 `undefined`\n4. **不会再去外层作用域查找**\n\n### 如何访问全局的 a？\n\n```javascript\nvar a = 10;\nfunction foo() {\n  console.log(window.a);  // 10 - 通过 window 对象访问\n  var a = 20;\n}\nfoo();\n```\n\n### 关键点\n\n- `var` 声明会被提升到**当前函数作用域**的顶部\n- 内部变量会**遮蔽**外部同名变量\n- 只有声明被提升，赋值不会提升"
  },
  {
    "id": "js-this-method-vs-function",
    "title": "this 指向：方法调用 vs 普通调用",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  sayName: function() {\n    console.log(this.name);\n  }\n};\n\nobj.sayName();\nvar fn = obj.sayName;\nfn();\n\n// 两次输出分别是什么？",
    "template": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  sayName: function() {\n    console.log(this.name);\n  }\n};\n\nobj.sayName();\nvar fn = obj.sayName;\nfn();",
    "solution": "### 答案\n\n```\nObject\nGlobal\n```\n\n### 解析\n\n这道题考察的是 JavaScript 中 **`this` 的指向规则**。`this` 的值取决于**函数的调用方式**，而不是函数定义的位置。\n\n#### 第一次调用：`obj.sayName()`\n\n```javascript\nobj.sayName();  // 输出 'Object'\n```\n\n这是**方法调用**模式：`对象.方法()`\n\n- 当函数作为对象的方法被调用时，`this` 指向**调用该方法的对象**\n- 所以 `this` 指向 `obj`，`this.name` 是 `'Object'`\n\n#### 第二次调用：`fn()`\n\n```javascript\nvar fn = obj.sayName;  // 把方法赋值给变量\nfn();                   // 输出 'Global'\n```\n\n这是**普通函数调用**模式\n\n- 当函数被直接调用（不是作为对象的方法）时，`this` 指向**全局对象**（非严格模式下是 `window`）\n- `var name = 'Global'` 会在全局对象上创建 `name` 属性\n- 所以 `this.name` 是 `window.name`，即 `'Global'`\n\n### this 指向规则总结\n\n| 调用方式 | this 指向 | 示例 |\n|----------|-----------|------|\n| 方法调用 | 调用方法的对象 | `obj.fn()` → `this` 是 `obj` |\n| 普通调用 | 全局对象/undefined | `fn()` → `this` 是 `window` |\n| call/apply | 第一个参数 | `fn.call(obj)` → `this` 是 `obj` |\n| bind | 绑定的对象 | `fn.bind(obj)()` → `this` 是 `obj` |\n| new 调用 | 新创建的对象 | `new Fn()` → `this` 是新对象 |\n| 箭头函数 | 定义时的外层 this | 不受调用方式影响 |\n\n### 如何保持 this 指向 obj？\n\n```javascript\n// 方法1：使用 bind\nvar fn = obj.sayName.bind(obj);\nfn();  // 'Object'\n\n// 方法2：使用箭头函数\nvar obj = {\n  name: 'Object',\n  sayName: () => console.log(this.name)  // 注意：这里 this 是外层作用域的 this\n};\n```"
  },
  {
    "id": "js-bind-cannot-override",
    "title": "bind 绑定的 this 不可覆盖",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo() {\n  console.log(this.value);\n}\n\nvar obj1 = { value: 'obj1' };\nvar obj2 = { value: 'obj2' };\n\nvar bound = foo.bind(obj1);\nbound();\nbound.call(obj2);\n\n// 两次输出分别是什么？",
    "template": "function foo() {\n  console.log(this.value);\n}\n\nvar obj1 = { value: 'obj1' };\nvar obj2 = { value: 'obj2' };\n\nvar bound = foo.bind(obj1);\nbound();\nbound.call(obj2);",
    "solution": "### 答案\n\n```\nobj1\nobj1\n```\n\n### 解析\n\n这道题考察的是 **`bind` 方法绑定 `this` 后不可被覆盖**的特性。\n\n#### `bind` 的特性\n\n`bind()` 方法创建一个新函数，当这个新函数被调用时，它的 `this` 值**永久地**绑定到 `bind()` 的第一个参数。\n\n```javascript\nvar bound = foo.bind(obj1);\n```\n\n此时 `bound` 函数的 `this` 已经被**硬绑定**到 `obj1`，后续无论用什么方式调用，都无法改变这个绑定。\n\n#### 第一次调用：`bound()`\n\n```javascript\nbound();  // 输出 'obj1'\n```\n\n普通调用，`this` 是 `bind` 绑定的 `obj1`。\n\n#### 第二次调用：`bound.call(obj2)`\n\n```javascript\nbound.call(obj2);  // 仍然输出 'obj1'\n```\n\n虽然使用了 `call` 尝试将 `this` 指向 `obj2`，但因为 `bound` 是通过 `bind` 创建的，`this` 已经被硬绑定到 `obj1`，**无法被 `call`、`apply` 或其他方式覆盖**。\n\n### `bind` 的内部实现原理\n\n```javascript\nFunction.prototype.myBind = function(context, ...args) {\n  const fn = this;\n  return function(...innerArgs) {\n    // 始终使用 context 作为 this，忽略调用时的 this\n    return fn.apply(context, [...args, ...innerArgs]);\n  };\n};\n```\n\n可以看到，返回的新函数在调用时，**总是**使用 `context`（即 `bind` 的第一个参数）作为 `this`，而不会理会调用时传入的 `this`。\n\n### this 绑定优先级\n\n从高到低：\n\n1. **new 绑定** - `new Fn()` 会创建新对象作为 `this`\n2. **显式绑定（bind）** - 硬绑定，不可被 call/apply 覆盖\n3. **隐式绑定** - `obj.fn()`\n4. **默认绑定** - 普通调用\n\n### 注意事项\n\n- `bind` 返回的函数如果作为构造函数使用（`new bound()`），`this` 会指向新创建的对象，这是唯一能\"打破\" bind 绑定的情况\n- 多次 `bind` 只有第一次有效：`fn.bind(obj1).bind(obj2)()` 中 `this` 是 `obj1`"
  },
  {
    "id": "js-callback-this-lost",
    "title": "回调函数中 this 丢失",
    "difficulty": 2,
    "tags": [1],
    "description": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  handleClick: function() {\n    console.log(this.name);\n  }\n};\n\nobj.handleClick();\nsetTimeout(obj.handleClick, 0);\nsetTimeout(() => obj.handleClick(), 0);\n\n// 三次输出分别是什么？",
    "template": "var name = 'Global';\nvar obj = {\n  name: 'Object',\n  handleClick: function() {\n    console.log(this.name);\n  }\n};\n\nobj.handleClick();\nsetTimeout(obj.handleClick, 0);\nsetTimeout(() => obj.handleClick(), 0);",
    "solution": "### 答案\n\n```\nObject\nGlobal\nObject\n```\n\n### 解析\n\n这道题考察的是**回调函数中 `this` 丢失**的经典问题，以及如何用箭头函数解决。\n\n#### 第一次调用：`obj.handleClick()`\n\n```javascript\nobj.handleClick();  // 输出 'Object'\n```\n\n- 这是**方法调用**，`this` 指向调用它的对象 `obj`\n- 所以 `this.name` 是 `'Object'`\n\n#### 第二次调用：`setTimeout(obj.handleClick, 0)`\n\n```javascript\nsetTimeout(obj.handleClick, 0);  // 输出 'Global'\n```\n\n- `obj.handleClick` 被作为**回调函数**传递给 `setTimeout`\n- 传递的只是函数的**引用**，丢失了与 `obj` 的关联\n- `setTimeout` 在执行回调时，是以**普通函数调用**的方式执行的\n- 所以 `this` 指向全局对象 `window`，`this.name` 是 `'Global'`\n\n**等价于：**\n```javascript\nvar callback = obj.handleClick;  // 只是获取函数引用\nsetTimeout(callback, 0);          // callback() 普通调用\n```\n\n#### 第三次调用：`setTimeout(() => obj.handleClick(), 0)`\n\n```javascript\nsetTimeout(() => obj.handleClick(), 0);  // 输出 'Object'\n```\n\n- 这里传递的是一个**箭头函数**，箭头函数内部调用了 `obj.handleClick()`\n- 当箭头函数执行时，`obj.handleClick()` 仍然是**方法调用**的形式\n- 所以 `this` 指向 `obj`，`this.name` 是 `'Object'`\n\n### 解决 this 丢失的方法\n\n#### 方法1：使用箭头函数包装（如第三次调用）\n```javascript\nsetTimeout(() => obj.handleClick(), 0);\n```\n\n#### 方法2：使用 bind 绑定\n```javascript\nsetTimeout(obj.handleClick.bind(obj), 0);\n```\n\n#### 方法3：将方法定义为箭头函数\n```javascript\nvar obj = {\n  name: 'Object',\n  handleClick: () => console.log(this.name)  // 注意：此时 this 是外层作用域的 this\n};\n```\n\n### 关键点\n\n| 场景 | this 指向 |\n|------|-----------|  \n| `obj.method()` | obj |\n| `setTimeout(obj.method, 0)` | window |\n| `setTimeout(() => obj.method(), 0)` | obj |\n| `setTimeout(obj.method.bind(obj), 0)` | obj |"
  },
  {
    "id": "js-default-param-null-undefined",
    "title": "默认参数：null vs undefined",
    "difficulty": 1,
    "tags": [1],
    "description": "function foo(a = 1, b = 2) {\n  console.log(a, b);\n}\n\nfoo(undefined, null);\n\n// 输出什么？",
    "template": "function foo(a = 1, b = 2) {\n  console.log(a, b);\n}\n\nfoo(undefined, null);",
    "solution": "### 答案\n\n```\n1 null\n```\n\n### 解析\n\n这道题考察的是 ES6 **默认参数**对 `undefined` 和 `null` 的不同处理方式。\n\n#### 默认参数的触发规则\n\n**只有当参数值严格等于 `undefined` 时，才会使用默认值。**\n\n- `undefined` → 触发默认值\n- `null` → 不触发默认值（`null` 是一个有效的值）\n- 不传参数 → 等同于传 `undefined`，触发默认值\n\n#### 代码分析\n\n```javascript\nfunction foo(a = 1, b = 2) {\n  console.log(a, b);\n}\n\nfoo(undefined, null);\n```\n\n1. **参数 `a`**：传入 `undefined`\n   - `undefined === undefined` 为 `true`\n   - 触发默认值，`a = 1`\n\n2. **参数 `b`**：传入 `null`\n   - `null === undefined` 为 `false`\n   - 不触发默认值，`b = null`\n\n所以输出 `1 null`。\n\n### 更多示例\n\n```javascript\nfunction test(x = 'default') {\n  console.log(x);\n}\n\ntest();           // 'default' - 不传参数，等同于传 undefined\ntest(undefined);  // 'default' - undefined 触发默认值\ntest(null);       // null - null 不触发默认值\ntest(0);          // 0 - 0 是有效值，不触发默认值\ntest('');         // '' - 空字符串是有效值，不触发默认值\ntest(false);      // false - false 是有效值，不触发默认值\n```\n\n### null 和 undefined 的语义区别\n\n| 值 | 语义 | 触发默认参数 |\n|----|------|-------------|\n| `undefined` | 未定义、缺失、未赋值 | 是 |\n| `null` | 有意的空值、\"没有对象\" | 否 |\n\n### 关键点\n\n- 默认参数只针对 `undefined`，不针对 `null` 或其他假值（falsy values）\n- 这与 `||` 操作符不同：`(a || 1)` 会把 `0`、`''`、`false`、`null`、`undefined` 都当作需要使用默认值的情况\n- ES2020 的 `??`（空值合并运算符）只对 `null` 和 `undefined` 生效，与默认参数的行为更接近"
  },
  {
    "id": "js-default-param-scope",
    "title": "默认参数的作用域",
    "difficulty": 2,
    "tags": [1],
    "description": "let x = 1;\nfunction foo(x, y = x + 1) {\n  console.log(y);\n}\n\nfoo(2);\n\n// 输出什么？为什么？",
    "template": "let x = 1;\nfunction foo(x, y = x + 1) {\n  console.log(y);\n}\n\nfoo(2);",
    "solution": "### 答案\n\n```\n3\n```\n\n### 解析\n\n这道题考察的是 ES6 **默认参数的作用域**问题。\n\n#### 为什么是 3 而不是 2？\n\n很多人可能会误以为 `y = x + 1` 中的 `x` 是外层的 `let x = 1`，所以 `y` 应该是 `2`。但实际上输出是 `3`。\n\n#### 默认参数的作用域规则\n\n当使用默认参数时，参数列表会形成一个**独立的作用域**。在这个作用域中：\n\n1. 参数按照**从左到右**的顺序被初始化\n2. 后面的参数可以引用前面已初始化的参数\n3. 但**不能**引用函数体内的变量\n\n#### 代码执行过程\n\n```javascript\nlet x = 1;  // 全局作用域的 x\n\nfunction foo(x, y = x + 1) {\n  // 参数作用域：\n  // 1. x = 2（传入的值）\n  // 2. y = x + 1 = 2 + 1 = 3（这里的 x 是参数 x，不是全局的 x）\n  \n  console.log(y);  // 3\n}\n\nfoo(2);\n```\n\n#### 作用域链\n\n```\n全局作用域 (x = 1)\n    ↓\n参数作用域 (x = 2, y = x + 1 = 3)  ← 默认参数在这里求值\n    ↓\n函数体作用域\n```\n\n在计算 `y = x + 1` 时，会先在**参数作用域**查找 `x`，找到了参数 `x = 2`，所以 `y = 3`。\n\n### 更多示例\n\n#### 示例1：默认参数引用后面的参数（报错）\n\n```javascript\nfunction bar(a = b, b = 1) {}\nbar();  // ReferenceError: b is not defined\n```\n\n因为参数是从左到右初始化的，`a = b` 执行时 `b` 还未初始化。\n\n#### 示例2：默认参数引用函数体内变量（报错）\n\n```javascript\nfunction baz(a = inner) {\n  let inner = 1;\n}\nbaz();  // ReferenceError: inner is not defined\n```\n\n默认参数作用域无法访问函数体内的变量。\n\n### 关键点\n\n| 规则 | 说明 |\n|------|------|\n| 参数独立作用域 | 默认参数在一个独立的作用域中求值 |\n| 从左到右初始化 | 后面的参数可以引用前面的参数 |\n| 不能引用函数体变量 | 默认参数无法访问函数体内声明的变量 |"
  },
  {
    "id": "js-arguments-default-param",
    "title": "arguments 与默认参数",
    "difficulty": 2,
    "tags": [1],
    "description": "function foo(a, b = 2) {\n  console.log(arguments.length);\n  console.log(a === arguments[0]);\n  console.log(b === arguments[1]);\n}\n\nfoo(1);\n\n// 三次输出分别是什么？",
    "template": "function foo(a, b = 2) {\n  console.log(arguments.length);\n  console.log(a === arguments[0]);\n  console.log(b === arguments[1]);\n}\n\nfoo(1);",
    "solution": "### 答案\n\n```\n1\ntrue\nfalse\n```\n\n### 解析\n\n这道题考察的是 **`arguments` 对象**与**默认参数**的关系。\n\n#### `arguments` 对象的特性\n\n`arguments` 是一个**类数组对象**，包含传递给函数的**实际参数**。\n\n- `arguments.length` 表示**实际传入**的参数个数\n- `arguments[i]` 表示第 `i` 个**实际传入**的参数\n- 默认参数**不会**影响 `arguments` 的内容\n\n#### 代码分析\n\n```javascript\nfunction foo(a, b = 2) {\n  console.log(arguments.length);   // 1\n  console.log(a === arguments[0]); // true\n  console.log(b === arguments[1]); // false\n}\n\nfoo(1);  // 只传了一个参数\n```\n\n##### 1. `arguments.length` → `1`\n\n```javascript\nfoo(1);  // 只传入了 1 个参数\n```\n\n虽然函数有 2 个形参，但只传入了 1 个实参，所以 `arguments.length` 是 `1`。\n\n##### 2. `a === arguments[0]` → `true`\n\n```javascript\na = 1;            // 传入的值\narguments[0] = 1; // 第一个实际参数\na === arguments[0] // true\n```\n\n`a` 和 `arguments[0]` 都是 `1`，所以相等。\n\n##### 3. `b === arguments[1]` → `false`\n\n```javascript\nb = 2;                    // 使用了默认值\narguments[1] = undefined; // 没有传第二个参数\nb === arguments[1]        // 2 === undefined → false\n```\n\n- `b` 使用了默认值 `2`\n- `arguments[1]` 是 `undefined`（因为没有传第二个参数）\n- 所以 `2 === undefined` 为 `false`\n\n### arguments 与参数的关系\n\n| 场景 | 非严格模式 | 严格模式/有默认参数 |\n|------|-----------|-------------------|\n| 修改参数会影响 arguments | 是 | 否 |\n| 修改 arguments 会影响参数 | 是 | 否 |\n\n**重要**：当函数使用了默认参数、解构参数或剩余参数时，`arguments` 和形参之间的\"绑定\"会被解除。\n\n### 关键点\n\n- `arguments.length` 反映**实际传入**的参数数量，不包括默认值\n- `arguments` 对象不受默认参数影响\n- 推荐使用剩余参数 `...args` 代替 `arguments`"
  },
  {
    "id": "js-strict-mode-this",
    "title": "严格模式下的 this",
    "difficulty": 1,
    "tags": [1],
    "description": "'use strict';\nfunction foo() {\n  console.log(this);\n}\n\nfoo();\nwindow.foo();\n\n// 两次输出分别是什么？",
    "template": "'use strict';\nfunction foo() {\n  console.log(this);\n}\n\nfoo();\nwindow.foo();",
    "solution": "### 答案\n\n```\nundefined\nWindow 对象\n```\n\n### 解析\n\n这道题考察的是**严格模式（strict mode）**下 `this` 的行为。\n\n#### 严格模式对 this 的影响\n\n在**非严格模式**下，普通函数调用时 `this` 默认指向全局对象（浏览器中是 `window`）。\n\n在**严格模式**下，普通函数调用时 `this` 不会自动绑定到全局对象，而是保持 `undefined`。\n\n#### 第一次调用：`foo()`\n\n```javascript\nfoo();  // 输出 undefined\n```\n\n- 这是**普通函数调用**\n- 严格模式下，`this` 不会自动指向 `window`，而是 `undefined`\n\n#### 第二次调用：`window.foo()`\n\n```javascript\nwindow.foo();  // 输出 Window 对象\n```\n\n- 这是**方法调用**，`foo` 作为 `window` 对象的方法被调用\n- 无论是否严格模式，方法调用时 `this` 都指向调用它的对象\n- 所以 `this` 指向 `window`\n\n### 严格模式 vs 非严格模式\n\n| 调用方式 | 非严格模式 | 严格模式 |\n|----------|-----------|----------|\n| `foo()` | window | undefined |\n| `window.foo()` | window | window |\n| `obj.foo()` | obj | obj |\n| `new foo()` | 新对象 | 新对象 |\n\n### 为什么严格模式要改变这个行为？\n\n1. **安全性**：避免意外修改全局对象\n2. **可预测性**：`this` 的值更加明确\n3. **错误检测**：更容易发现 `this` 使用错误\n\n### 注意事项\n\n```javascript\n'use strict';\n\nfunction foo() {\n  console.log(this);  // undefined\n}\n\n// 以下都会让 this 指向 window\nwindow.foo();     // window\nfoo.call(window); // window\nfoo.apply(window);// window\nfoo.bind(window)(); // window\n```\n\n### 关键点\n\n- 严格模式下，普通函数调用 `this` 是 `undefined`，不会自动绑定到全局对象\n- 方法调用不受严格模式影响，`this` 仍然指向调用对象\n- 箭头函数不受严格模式影响，因为它没有自己的 `this`"
  },
  {
    "id": "js-constructor-return-object",
    "title": "构造函数返回对象",
    "difficulty": 2,
    "tags": [1],
    "description": "function Person(name) {\n  this.name = name;\n  return { name: 'fake' };\n}\n\nconst p = new Person('real');\nconsole.log(p.name);\n\n// 输出什么？为什么？",
    "template": "function Person(name) {\n  this.name = name;\n  return { name: 'fake' };\n}\n\nconst p = new Person('real');\nconsole.log(p.name);",
    "solution": "### 答案\n\n```\nfake\n```\n\n### 解析\n\n这道题考察的是 **`new` 操作符**的工作原理，特别是构造函数返回值的处理规则。\n\n#### `new` 操作符的工作流程\n\n1. 创建一个新的空对象\n2. 将这个对象的 `__proto__` 指向构造函数的 `prototype`\n3. 执行构造函数，`this` 指向这个新对象\n4. **判断返回值**：\n   - 如果构造函数返回一个**对象**，则返回这个对象（覆盖默认行为）\n   - 如果返回**原始值**或**不返回**，则返回新创建的对象\n\n#### 代码分析\n\n```javascript\nfunction Person(name) {\n  this.name = name;        // 在新对象上设置 name = 'real'\n  return { name: 'fake' }; // 返回一个新对象\n}\n\nconst p = new Person('real');\nconsole.log(p.name);  // 'fake'\n```\n\n1. `new` 创建了一个新对象，`this` 指向它\n2. `this.name = 'real'` 在新对象上设置了属性\n3. 但是构造函数返回了 `{ name: 'fake' }`\n4. 因为返回的是一个**对象**，所以 `p` 指向的是这个返回的对象，而不是 `new` 创建的那个\n5. 所以 `p.name` 是 `'fake'`\n\n### 返回值规则详解\n\n```javascript\n// 返回对象 → 使用返回的对象\nfunction A() { return { x: 1 }; }\nnew A();  // { x: 1 }\n\n// 返回数组（数组也是对象）→ 使用返回的数组\nfunction B() { return [1, 2, 3]; }\nnew B();  // [1, 2, 3]\n\n// 返回函数（函数也是对象）→ 使用返回的函数\nfunction C() { return function() {}; }\nnew C();  // function() {}\n\n// 返回原始值 → 忽略返回值，使用 new 创建的对象\nfunction D() { this.x = 1; return 'string'; }\nnew D();  // { x: 1 }\n\n// 返回 null → 忽略（null 虽然 typeof 是 object，但这里被当作原始值）\nfunction E() { this.x = 1; return null; }\nnew E();  // { x: 1 }\n\n// 不返回 → 使用 new 创建的对象\nfunction F() { this.x = 1; }\nnew F();  // { x: 1 }\n```\n\n### 关键点\n\n| 返回值类型 | new 的结果 |\n|-----------|------------|\n| 对象（非 null） | 返回的对象 |\n| 数组 | 返回的数组 |\n| 函数 | 返回的函数 |\n| 原始值（string, number, boolean） | new 创建的对象 |\n| null | new 创建的对象 |\n| undefined / 不返回 | new 创建的对象 |"
  },
  {
    "id": "js-callback-context-this",
    "title": "回调函数执行上下文中的 this",
    "difficulty": 2,
    "tags": [1],
    "description": "var a = 10;\n\nfunction foo() {\n  console.log(this.a);\n}\n\nfunction bar(fn) {\n  var a = 20;\n  fn();\n}\n\nbar(foo);\n\n// 输出什么？为什么？",
    "template": "var a = 10;\n\nfunction foo() {\n  console.log(this.a);\n}\n\nfunction bar(fn) {\n  var a = 20;\n  fn();\n}\n\nbar(foo);",
    "solution": "### 答案\n\n```\n10\n```\n\n### 解析\n\n这道题综合考察了**作用域**、**执行上下文**和 **`this` 指向**。很多人可能会混淆这几个概念。\n\n#### 为什么不是 20？\n\n常见的误解是认为：\n- `foo` 在 `bar` 内部被调用\n- `bar` 内部有 `var a = 20`\n- 所以 `foo` 会访问到这个 `a`\n\n这是**错误的理解**！`this.a` 和作用域中的变量 `a` 是完全不同的概念。\n\n#### 关键区别\n\n| 概念 | 说明 |\n|------|------|\n| **作用域（Scope）** | 变量查找规则，在函数**定义时**确定 |\n| **执行上下文（Execution Context）** | 函数执行时的环境 |\n| **this** | 函数**调用时**决定，与作用域无关 |\n\n#### 代码分析\n\n```javascript\nvar a = 10;  // 全局变量，也是 window.a = 10\n\nfunction foo() {\n  console.log(this.a);  // this 是什么？\n}\n\nfunction bar(fn) {\n  var a = 20;  // 局部变量，与 this.a 无关！\n  fn();        // 普通函数调用，this 指向 window\n}\n\nbar(foo);\n```\n\n1. `bar(foo)` 调用时，`foo` 作为参数传入\n2. `fn()` 是一个**普通函数调用**（不是方法调用）\n3. 普通函数调用时，`this` 指向全局对象 `window`\n4. `this.a` 就是 `window.a`，即 `10`\n\n#### `var a = 20` 为什么没用？\n\n`bar` 函数内部的 `var a = 20` 只是一个**局部变量**，它：\n- 不会修改 `window.a`\n- 不会影响 `this.a`\n- 只能通过作用域链访问（如果 `foo` 直接写 `console.log(a)` 也访问不到，因为 `foo` 是在全局定义的）\n\n### 对比：如果是访问作用域中的变量\n\n```javascript\nvar a = 10;\n\nfunction foo() {\n  console.log(a);  // 没有 this，通过作用域链查找\n}\n\nfunction bar(fn) {\n  var a = 20;\n  fn();\n}\n\nbar(foo);  // 输出 10\n```\n\n即使是作用域查找，结果也是 `10`！因为 `foo` 在**全局作用域定义**，它的作用域链只能访问全局的 `a`，无法访问 `bar` 内部的 `a`。\n\n### 关键点\n\n- `this` 由**调用方式**决定，与定义位置、执行位置无关\n- `fn()` 是普通调用，`this` 指向全局对象\n- 函数内部的局部变量不会影响 `this` 上的属性\n- 作用域是**静态的**（词法作用域），在定义时确定"
  },
  {
    "id": "parse-query",
    "title": "实现 parseQuery 函数",
    "difficulty": 1,
    "tags": [2],
    "description": "实现一个 parseQuery 函数，输入一个 query 字符串（例如 ?name=Alice&age=20&city=Beijing），返回一个对象 {name: 'Alice', age: '20', city: 'Beijing'}。如果 query 参数中出现重复的 key，value 变成数组。",
    "template": "function parseQuery(queryString) {\n  // 请在此实现 parseQuery 函数\n  \n}",
    "testCases": [
      {
        "input": "parseQuery('?name=Alice&age=20&city=Beijing')",
        "expected": "{ name: 'Alice', age: '20', city: 'Beijing' }",
        "description": "基础解析：解析简单的 query 字符串"
      },
      {
        "input": "parseQuery('?tag=js&tag=ts&tag=react')",
        "expected": "{ tag: ['js', 'ts', 'react'] }",
        "description": "重复 key：相同 key 的值变成数组"
      },
      {
        "input": "parseQuery('?name=Alice&tag=js&tag=ts')",
        "expected": "{ name: 'Alice', tag: ['js', 'ts'] }",
        "description": "混合情况：既有单值也有多值"
      },
      {
        "input": "parseQuery('')",
        "expected": "{}",
        "description": "空字符串：返回空对象"
      }
    ],
    "solution": "### 核心思路\n\n1. 去掉开头的 `?`（如果有）\n2. 按 `&` 分割成键值对数组\n3. 遍历键值对，按 `=` 分割出 key 和 value\n4. 如果 key 已存在，将值转为数组或追加到数组\n\n### 参考实现\n\n```javascript\nfunction parseQuery(queryString) {\n  const result = {};\n  \n  // 去掉开头的 ?\n  const query = queryString.replace(/^\\?/, '');\n  \n  if (!query) return result;\n  \n  // 按 & 分割\n  const pairs = query.split('&');\n  \n  for (const pair of pairs) {\n    const [key, value = ''] = pair.split('=');\n    \n    // 解码 URL 编码的字符\n    const decodedKey = decodeURIComponent(key);\n    const decodedValue = decodeURIComponent(value);\n    \n    if (result.hasOwnProperty(decodedKey)) {\n      // key 已存在，转为数组或追加\n      if (Array.isArray(result[decodedKey])) {\n        result[decodedKey].push(decodedValue);\n      } else {\n        result[decodedKey] = [result[decodedKey], decodedValue];\n      }\n    } else {\n      result[decodedKey] = decodedValue;\n    }\n  }\n  \n  return result;\n}\n```\n\n### 使用 URLSearchParams 的简洁实现\n\n```javascript\nfunction parseQuery(queryString) {\n  const result = {};\n  const params = new URLSearchParams(queryString);\n  \n  for (const [key, value] of params) {\n    if (result.hasOwnProperty(key)) {\n      if (Array.isArray(result[key])) {\n        result[key].push(value);\n      } else {\n        result[key] = [result[key], value];\n      }\n    } else {\n      result[key] = value;\n    }\n  }\n  \n  return result;\n}\n```",
    "followUp": [
      "如何实现反向操作 stringifyQuery，将对象转换为 query 字符串？",
      "如何处理 URL 编码的特殊字符，如 %20、%2B 等？",
      "如何支持嵌套对象的解析，如 ?user[name]=Alice&user[age]=20？"
    ]
  }
]
