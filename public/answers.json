{
  "throttle": "// 立即执行的节流，用时间戳更方便\nconst mythrollet=(fn,delay)=>{\n  let lasttime=0\n  let realArgs\n  let context\n  return function (...args) {\n    context=this\n    realArgs=args\n    const now=Date.now()\n    // console.log(now,args,lasttime)\n    if(now-lasttime>delay){\n      lasttime=now\n      fn.apply(context,realArgs)\n    }\n  }\n}\n\n\n// 不立即执行的节流\nconst mythrollet2=(fn,delay)=>{\n  let timer\n  let realArgs\n  let context\n  return function (...args) {\n    context=this\n    realArgs=args\n    if(!timer){\n      timer=setTimeout(()=>{\n        timer=null\n        fn.apply(context,realArgs)\n      },delay)\n    }\n  }\n}\n\nconst test=(num)=>{\n  console.log(num)\n}\n\nconst t=mythrollet(test,500)\nt(1)\nt(2)\nt(3)\nsetTimeout(()=>{\n  t(5)\n},1000)",
  "currying": "function myCurry(fn,...prev){\n  function func(...args){\n    // console.log(fn.length,'-',args.length)\n    // 参数不够\n    if(fn.length>(args.length+prev.length)){\n      return myCurry(func,...args)\n    }else{\n      // 参数够了\n      // console.log('111')\n      return fn(...prev,...args)\n    }\n  }\n  return func\n}\n\nconst test=(a,b,c)=>{\n  console.log(a+b+c)\n}\n\nconst t1=myCurry(test)\nconst t2=t1(1)\nt2(2,3)",
  "debounce": "function myDebounce(fn,delay) {\n  let timer\n  let context\n  return function (...args) {\n    context=this\n    // console.log(timer,...args)\n    if(timer){\n      clearTimeout(timer)\n    }\n    timer=setTimeout(()=>{\n      // 这里不要用clearTimeout，不会清除timer这个变量值，只是清掉了计时器\n      timer = null; \n      fn.apply(context,args)\n      // console.log('---',timer)\n    },delay)\n  }\n}\n\nconst test=(t)=>{\n  console.log(t)\n}\nconst dTest=myDebounce(test,1000)\ndTest('1')\ndTest('2')\ndTest('3')\n\nsetTimeout(()=>{\n  dTest('?')\n},1500)",
  "handwrite-call": "function myCall(context,...args){\n  // console.log(args)\n  context=context||window\n\n  const mySymbol=Symbol(); \n  context[mySymbol]=this\n  const res=context[mySymbol](...args)\n\n  delete context[mySymbol]\n  return res\n}\nFunction.prototype.myCall=myCall\n\nvar test='test'\nfunction func(tmp){\n  console.log(this.test,tmp)\n}\nfunc('?')\nconst obj={\n  test:'testtttt'\n}\n// func.call(obj,'????')\nfunc.myCall(obj,'????')",
  "handwrite-apply": "const myApply=(context,arg)=>{\n  context=context||window\n  const mySymbol=Symbol()\n  context[mySymbol]=this\n  console.log(typeof this)\n  \n  const res=context[mySymbol](...(arg||[]))\n  delete context[mySymbol]\n  return res\n}\nFunction.prototype.myApply=myApply\n\nvar test='test'\nfunction func(tmp){\n  console.log(this.test,tmp)\n}\n// func('?')\nconst obj={\n  test:'testtttt'\n}\nfunc.apply(obj,['????'])\nfunc.myApply(obj,['????'])\n",
  "handwrite-bind": "function myBind(context,...args){\n  const self=this\n  return function(...newArgs){\n    return self.apply(context,[...args,...newArgs])\n  }\n}\n\nFunction.prototype.myBind=myBind\n\n\nfunction func(...args){\n  console.log(this.test,...args)\n}\n// func('1','2')\nconst obj1={\n  test:'tes111'\n}\nconst obj2={\n  test:'tes222'\n}\nconst t=func.bind(obj1,'1')\nt('2')\nconst t2=t.bind(obj2,'1')\nt2('2')\nconst tt=func.myBind(obj1,'111')\ntt('222')\nconst tt2=tt.myBind(obj2,'111')\ntt2('222')\n",
  "deep-equal": "function deepCompare(obj1,obj2) {\n  // function symbol 简单类型\n  if(obj1===obj2){\n    return true\n  }\n  if(obj1==null||obj2==null){\n    return obj1===obj2\n  }\n  if(typeof obj1!==typeof obj2){\n    return false\n  }\n  if(typeof obj1==='object'){\n    if(obj1 instanceof Date){\n      return obj1.getTime()===obj2.getTime()\n    }\n    if(obj1 instanceof RegExp){\n      return obj1.toString()===obj2.toString()\n    }\n    if(Array.isArray(obj1)!==Array.isArray(obj2)){\n      return false\n    }\n    const keys1=Object.keys(obj1)\n    const keys2=Object.keys(obj2)\n    if(keys1.length!==keys2.length){\n      return false\n    }\n    for(let key of keys1){\n      // console.log(key,obj1[key],obj2[key])\n      if(!keys2.includes(key)||!deepCompare(obj1[key],obj2[key])){\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nconst obj1={\n  t:0,\n  tt:'2',\n  ttt:{\n    t0:'1'\n  }\n}\nconst obj2={\n  t:0,\n  tt:'2',\n  ttt:{\n    t0:'1'\n  }\n}\ndeepCompare(obj1,obj2)",
  "array-unique": "// 简单类型数组\nfunction filter(array){\n  return Array.from(new Set(array))\n}\n// 复杂类型数组-比较内存指向\nfunction filter2(array){\n  return array.reduce((acc,cur)=>{\n    if(acc.indexOf(cur)===-1){\n      acc.push(cur)\n    }\n  },[])\n}\n// 复杂类型数组-比较具体值\n需要引用deepcompare\n",
  "array-flatten": "function flat(array){\n  return array.reduce((acc,cur)=>{\n    if(Array.isArray(cur)){\n      acc=acc.concat(flat(cur))\n    }else{\n      acc.push(cur)\n    }\n    return acc\n  },[])\n}\n\nconst test=[1,2,3,4,[5,6,[7]]]\nconsole.log(flat(test))",
  "deep-clone": "function deepClone(obj){\n  if(obj==null||typeof obj !=='object'||obj instanceof Function){\n    return obj\n  }\n  let target\n  \n    if(obj instanceof Date){\n       target=new Date(obj)\n    }else if(obj instanceof RegExp){\n      target=new RegExp(obj)\n    }else if(Array.isArray(obj)){\n      target=[]\n      target=obj.map((t,i)=> deepClone(t))\n    }else{\n      target={}\n      for(let key of Object.keys(obj)){\n        target[key]=deepClone(obj[key])\n      }\n    }\n  return target\n}",
  "event-emitter": "class EventEmitter{\n  private onceListenerMap\n  private listenerMap\n  constructor(){\n    this.listenerMap=new Map()\n    this.onceListenerMap=new Map()\n  }\n\n  on(event,listener,once){\n    if(!(listener instanceof Function)){\n      return \n    }\n    const map=once?this.onceListenerMap:this.listenerMap\n    const list=map.get(event)\n    if(list){\n      list.push(listener)\n    }else{\n      map.set(event,[listener])\n    }\n  }\n  emit(event,...args){\n    const list=this.listenerMap.get(event)||[]\n    const onceList=this.onceListenerMap.get(event)||[]\n    list.forEach((func)=>{\n        func(...args)\n    })\n    onceList.forEach((func)=>{\n        func(...args)\n    })\n    this.onceListenerMap.set(event,[])\n  }\n  off(event,listener){\n    let list=this.listenerMap.get(event)||[]\n    let ind=list.indexOf(listener)\n    if(ind>-1){\n      list.splice(ind,1)\n    }\n    list=this.onceListenerMap.get(event)||[]\n    if(ind>-1){\n      list.splice(ind,1)\n    }\n  }\n  once(event,listener){\n    this.on(event,listener,true)\n  }\n}",
  "handwrite-new": "function myNew(constructor,...args){\n  const obj=Object.create(constructor.prototype)\n  // obj.__proto__=constructor.prototype\n  const res=constructor.apply(obj,args)\n  if(res&&typeof res==='object'&&!(res instanceof Function)){\n    return res\n  }else {\n    return obj\n  }\n}\n\nfunction Test(name){\n  this.name=name\n}\n\nconst t=myNew(Test,'t')\nconsole.log(t)",
  "lru-cache": "// 实现一个LRU缓存类，支持：\n// get(key)：如果key存在，返回对应值并标记为最近使用\n// put(key, value)：如果key存在则更新，否则插入；如果容量已满则淘汰最久未使用的数据\n// 例：\n// 缓存容量：3\n// 操作序列：A → B → C → A → D → B → E\n// 缓存变化：\n// A        → A,B    → A,B,C → B,C,A → C,A,D → A,D,B → D,B,E\n// (插入A)   (插入B)  (插入C) (访问A) (插入D,淘汰B) (访问B) (插入E,淘汰C)\n\n// 注意：Map 会保持键的插入顺序，这是 ES6 Map 的一个重要特性\nclass LRU{\n  constructor(cacheCount){\n    this.map=new Map()\n    this.cacheCount=cacheCount\n  }\n  get(key){\n    const val=this.map.get(key)\n    if(val){\n      this.map.set(key,val)\n      return val \n    }\n    return null\n  }\n  put(key,value){\n    if(!this.map.get(key)){\n      if(this.map.size>=this.cacheCount){\n        const tmp=this.map.keys().next().value\n        this.map.delete(tmp)\n      }\n    }\n    this.map.set(key,value)\n    // console.log(this.cacheList)\n  }\n}\n\nconst test=new LRU(5)\ntest.put('a',1)\ntest.put('b',2)\ntest.put('c',3)\nconsole.log(test.get('a'))\ntest.put('d',4)\ntest.put('e',5)\ntest.put('f',6)\nconsole.log(test.get('a'))\nconsole.log(test.get('b'))\nconsole.log(test.get('f'))",
  "async-concurrency-controller": "// arr：promise的数组\n// max：最大并发数\nasync function asyncWorker(arr,max){\n  return new Promise((resolve)=>{\n    const result=[]\n    let running=0 //当前正在执行的数量\n    let maxInd=0 //当前已经开始的最大ind\n    let doneCount=0 //已完成的数量\n    // const func=(ind)=>{ \n    // 不能这么写，核心在于不应该把ind传进去，会导致并发控制失效\n    const func=()=>{\n      if(maxInd>=arr.length) return\n      // 数量超出\n      if(running>=max) return\n      const ind=maxInd++\n      // console.log(ind)\n      running++\n      arr[ind].then((res)=>{\n        result[ind]=res\n      }).catch((err)=>{\n        result[ind]=err\n      }).finally(()=>{\n        running--\n        doneCount++\n        // console.log('done',ind,result)\n        if(doneCount<arr.length){\n          func()\n        }else{\n          resolve(result)\n        }\n      })\n    }\n  \n    new Array(max).fill(0).map((_,ind)=>func())\n  }).then((res)=>{\n    // console.log(res)\n    return res\n  })\n}\n\nconst test=(k)=> new Promise((resolve)=>{\n  setTimeout(()=>{\n    resolve(k)\n  },k*1000)\n})\nconst test1=(k)=> new Promise((resolve,reject)=>{\n  setTimeout(()=>{\n    reject(k)\n  },k*1000)\n})\nconst arr=[\n  test(4),test(2),test(5),test(3),test1(6),test1(1)\n]\nasyncWorker(arr,2)",
  "myUseUpdate": "export default function useUpdate(){\n  const [_,setState]=useState({})\n  return useCallback(()=>setState({}),[])\n}\n\n// useReducer 的 dispatch 触发重新渲染\n// dispatch 永远是稳定的引用, 不会导致子组件多余 re-render\nexport default function useUpdate(){\n  const [_,dispatch]=useReducer(()=>({}),{})\n  return dispatch\n}",
  "myUseAsyncEffect": "//这个版本实现了清理函数，但是没实现竞态消除\nexport default function useAsyncEffect(fn,deps,callback){\n  const time=useRef()\n  useEffect(()=>{\n    if(typeof fn === 'function' && typeof callback==='function'){\n      const func=async ()=>{\n        try{\n          const result = await fn()\n          if(time.current){\n            callback(result)\n          }\n        }catch(){\n          // \n        }\n      }\n      func()\n      time.current=Date.now()\n\n      return ()=>{\n        time.current=null\n      }\n    }\n  },deps)\n}\n\n//竞态消除\nexport default function useAsyncEffect(fn,deps,callback){\n  const time=useRef()\n  useEffect(()=>{\n    time.current=Date.now()\n    const currentTime=time.current\n    if(typeof fn === 'function' && typeof callback==='function'){\n      const func=async ()=>{\n        try{\n          const result = await fn()\n          if(time.current===currentTime){\n            callback(result)\n          }\n        }catch(){\n          // \n        }\n      }\n      func()\n\n      return ()=>{\n        // currentTime本来就是局部变量所以不用消除了\n      }\n    }\n  },deps)\n}",
  "myUseDebounce": "export default function useDebounce(fn,delay){\n  const timer=useRef()\n  const func=useCallback(()=>{\n    if(timer.current){\n      clearTimeout(timer.current)\n    }\n    timer.current=setTimeout(()=>{\n        fn()\n        timer.current = null;\n    },delay)\n  },[delay,fn])\n\n  useEffect(()=>{\n    return ()=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n    }\n  },[])\n  return func\n}\n//带参数和返回\nexport default function useDebounce2(fn,delay){\n  const timer=useRef()\n  const func=useCallback((...args)=>{\n    // 这里要用promise，因为settimeout直接返回，外层获取不到\n    return new Promise((resolve)=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n      timer.current=setTimeout(()=>{\n        const res=fn(...args)\n        timer.current = null;\n        resolve(res)\n      },delay)\n    })\n  },[delay,fn])\n\n  useEffect(()=>{\n    return ()=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n    }\n  },[])\n  return func\n}\n\n\n\n/**\n * useDebouncedFunction Hook\n * @param {Function} callback - 需要防抖的原始函数\n * @param {number} delay - 防抖延迟时间（毫秒）\n * @returns {[Function, Function]} - [防抖后的函数, 取消函数]\n */\nfunction useDebouncedFunction(callback, delay) {\n    // 1. 使用 useRef 存储定时器 ID，确保在重渲染时保持引用\n    const timerRef = useRef(null);\n\n    // 2. 使用 useCallback 包装返回的函数，确保函数引用稳定，并包含核心防抖逻辑\n    const debouncedFunc = useCallback((...args) => {\n        // 3. 核心防抖逻辑：清除上一次的定时器\n        if (timerRef.current) {\n            clearTimeout(timerRef.current);\n        }\n\n        // 4. 重新设置定时器\n        // 只有当新的定时器执行时，才会调用原始 callback\n        timerRef.current = setTimeout(() => {\n            // 5. 调用原始函数，并传入所有参数\n            callback(...args);\n        }, delay);\n\n    // 依赖项：确保 debouncedFunc 始终能拿到最新的 callback 和 delay 值\n    }, [callback, delay]);\n\n    // 6. 提供一个手动取消 pending 调用的方法\n    const cancel = useCallback(() => {\n        if (timerRef.current) {\n            clearTimeout(timerRef.current);\n            timerRef.current = null;\n        }\n    }, []);\n\n    // 7. 返回防抖函数和取消函数\n    return [debouncedFunc, cancel];\n}",
  "myUseInterval": "function useInterval(fn,delay){\n  const timer=useRef()\n  //useRef 保存最新 fn，每次外层组件重新渲染会生成新的fn\n  const func=useRef(fn)\n  useEffect(()=>{\n    func.current=fn\n  },[fn])\n  \n  useEffect(()=>{\n      timer.current=setInterval(()=>{\n        func.current()\n      },delay)\n    \n    return ()=>{\n      if(timer.current){\n        clearInterval(timer.current)\n      }\n    }\n  },[delay])\n\n}",
  "myUseState": "// 全局变量，模拟当前渲染的组件状态\nlet hooks = [];\nlet hookIndex = 0;\n\nfunction useState(initVal){\n  const curInd=hookIndex\n  const setState=(newVal)=>{\n    hooks[curInd].state=newVal\n    render()\n  }\n  return [hooks[curInd].state,setState]\n}\n\n// 模拟 render\nlet App;\nfunction render() {\n  hookIndex = 0;    // 每次渲染 hookIndex 重置\n  App = Counter(); //Counter 是使用的组件，这里省略了\n}\n",
  "prototype-inheritance": "// -------------------- 父类 --------------------\nfunction SuperType(name) {\n  this.name = name;\n  // 【致命缺陷点】引用类型属性\n  this.colors = [\"red\", \"blue\", \"green\"]; \n}\n\nSuperType.prototype.sayName = function() {\n  console.log(this.name);\n};\n\n// -------------------- 子类 --------------------\nfunction SubType(name, age) {\n  this.age = age;\n}\n\n// 核心：让子类原型对象指向父类实例\n// 【注意点】这里 SubType.prototype 现在是 SuperType 的一个实例\nSubType.prototype = new SuperType(); \n\nSubType.prototype.sayAge = function() {\n  console.log(this.age);\n};\n\n// -------------------- 测试 --------------------\nconst instance1 = new SubType(\"Instance1\", 29);\ninstance1.colors.push(\"black\"); // 修改 instance1 的 colors\n\nconst instance2 = new SubType(\"Instance2\", 23);\n\nconsole.log(instance1.colors); // 输出: [\"red\", \"blue\", \"green\", \"black\"]\nconsole.log(instance2.colors); // 输出: [\"red\", \"blue\", \"green\", \"black\"] 【缺陷：被 instance1 影响了！】\n```\n\n组合继承\n\n```js\n// -------------------- 父类 --------------------\nfunction SuperType(name) {\n  this.name = name;\n  // 解决了引用类型共享问题 (通过构造函数赋值，属性实例独占)\n  this.colors = [\"red\", \"blue\", \"green\"]; \n}\n\nSuperType.prototype.sayName = function() {\n  console.log(this.name);\n};\n\n// -------------------- 子类 --------------------\nfunction SubType(name, age) {\n  // 1. 【构造函数借用】：继承属性，并向父类传参\n  SuperType.call(this, name); \n  this.age = age;\n}\n\n// 2. 【核心优化】：创建父类原型对象的副本，并赋值给子类原型\n//    - Object.create(SuperType.prototype)：创建了一个空对象，但它的原型链指向 SuperType.prototype\n//    - 这避免了调用 SuperType() 构造函数，从而避免了不必要的属性创建和引用类型共享\nSubType.prototype = Object.create(SuperType.prototype); \n\n// 3. 【构造器指针修正】：将子类构造器指向自身\nSubType.prototype.constructor = SubType; \n\nSubType.prototype.sayAge = function() {\n  console.log(this.age);\n};\n\n// -------------------- 测试 --------------------\nconst instanceA = new SubType(\"Alice\", 29);\ninstanceA.colors.push(\"black\"); // 修改 instanceA 的 colors\n\nconst instanceB = new SubType(\"Bob\", 23);\n\ninstanceA.sayName();   // 输出: Alice (正确继承方法)\nconsole.log(instanceA.colors); // 输出: [\"red\", \"blue\", \"green\", \"black\"]\nconsole.log(instanceB.colors); // 输出: [\"red\", \"blue\", \"green\"] 【成功：相互不影响！】",
  "compose-middleware": "const compose = (middleware) => {\n  return (ctx, next) => {\n    const dispatch = (i) => {\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n\n      try {\n        // 递归核心：当前 fn 执行，第二个参数 next 递归指向 dispatch(i+1)\n        return Promise.resolve(fn(ctx, () => dispatch(i + 1)))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n    return dispatch(0)\n  }\n}\n\n// 测试\nconst middleware = []\nmiddleware.push(async (ctx, next) => {\n  console.log(1)\n  await next()\n  console.log(2)\n})\nmiddleware.push(async (ctx, next) => {\n  console.log(3)\n  await next()\n  console.log(4)\n})\nmiddleware.push(async (ctx, next) => {\n  console.log(5)\n  await next()\n  console.log(6)\n})\n\nconst fn = compose(middleware)\nfn({}) // 输出: 1 3 5 6 4 2",
  "intersection-observer": "const ele = document.querySelector('#target')\n\nconst io = new IntersectionObserver(\n  (entries) => {\n    entries.forEach((item) => {\n      console.log(item, item.intersectionRect)\n      if (item.isIntersecting) {\n        console.log('进入视口了')\n      } else {\n        console.log('离开视口了')\n      }\n    })\n  },\n  {\n    root: null, // 默认是 viewport\n    rootMargin: '500px 0px 0px 0px',\n    threshold: [0, 0.25, 0.5, 0.75, 1]\n  }\n)\n\n// 监听元素\nif (ele) {\n  io.observe(ele)\n}\n\n// 停止观察\n// io.unobserve(ele)\n\n// 关闭观察器\n// io.disconnect()",
  "handwrite-instanceof": "// instanceof 实际是检查原型链\nfunction myInstanceof(obj, constructor) {\n  let proto = Object.getPrototypeOf(obj);\n  while (proto) {\n    if (proto === constructor.prototype) return true;\n    proto = Object.getPrototypeOf(proto);\n  }\n  return false;\n}\n\n// 测试\nconsole.log(myInstanceof([], Array)) // true\nconsole.log(myInstanceof([], Object)) // true\nconsole.log(myInstanceof({}, Array)) // false",
  "class-scheduler": "class Scheduler {\n  constructor(max) {\n    this.max = max\n    this.arr = []\n    this.count = 0\n  }\n\n  add(task) {\n    return new Promise((resolve) => {\n      const run = () => {\n        if (typeof task === 'function') {\n          this.count += 1\n          task().then((res) => {\n            this.count -= 1\n            resolve(res)\n            if (this.arr.length > 0) {\n              const top = this.arr.shift()\n              top() //这里也要注意，top是一个run 函数。不是promise，但是执行完会调之前的resole，直接执行就行\n            }\n          })\n        }\n      }\n      if (this.count < this.max) {\n        run()\n      } else {\n        this.arr.push(run) //注意这里传run进去而不是task\n      }\n    })\n  }\n}\n\n// 初始错误版本\n\n// 当任务被放入队列（`else` 分支）时，**Promise 被挂起了，但永远不会被 resolve**。\n\n// 当 `addTask(300, '3')` 被调用时，因为并发满了，它进入 `else`。此时 `add` 方法返回了一个处于 **Pending** 状态的 Promise。外部的 `.then(() => console.log('3'))` 正在等待这个 Promise。\n\n// 当队列里的任务稍后被取出并执行 `this.add(top)` 时，你实际上是**重新创建了一个新的 Promise**。虽然任务执行了，但那个**新的** Promise 和当初 `addTask(300, '3')` 等待的**旧** Promise 没有任何关系。旧的 Promise 永远没有收到 `resolve` 信号，所以 `'3'` 和 `'4'` 永远不会被打印出来。\n\n\n// add(task) {\n//     return new Promise((resolve) => {\n//       if (this.count < this.max) {\n//         if (typeof task === 'function') {\n//           this.count += 1\n//           task().then((res) => {\n//             this.count -= 1\n//             resolve(res)\n//             if (this.arr.length > 0) {\n//               const top = this.arr.shift()\n//               this.add(top)\n//             }\n//           })\n//         }\n//       } else {\n//         this.arr.push(task)\n//       }\n//     })\n// }\n\n  "
}