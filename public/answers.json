{
  "throttle": "// 立即执行的节流，用时间戳更方便\nconst mythrollet=(fn,delay)=>{\n  let lasttime=0\n  let realArgs\n  let context\n  return function (...args) {\n    context=this\n    realArgs=args\n    const now=Date.now()\n    // console.log(now,args,lasttime)\n    if(now-lasttime>delay){\n      lasttime=now\n      fn.apply(context,realArgs)\n    }\n  }\n}\n\n\n// 不立即执行的节流\nconst mythrollet2=(fn,delay)=>{\n  let timer\n  let realArgs\n  let context\n  return function (...args) {\n    context=this\n    realArgs=args\n    if(!timer){\n      timer=setTimeout(()=>{\n        timer=null\n        fn.apply(context,realArgs)\n      },delay)\n    }\n  }\n}\n\nconst test=(num)=>{\n  console.log(num)\n}\n\nconst t=mythrollet(test,500)\nt(1)\nt(2)\nt(3)\nsetTimeout(()=>{\n  t(5)\n},1000)",
  "currying": "function myCurry(fn,...prev){\n  function func(...args){\n    // console.log(fn.length,'-',args.length)\n    // 参数不够\n    if(fn.length>(args.length+prev.length)){\n      return myCurry(func,...args)\n    }else{\n      // 参数够了\n      // console.log('111')\n      return fn(...prev,...args)\n    }\n  }\n  return func\n}\n\nconst test=(a,b,c)=>{\n  console.log(a+b+c)\n}\n\nconst t1=myCurry(test)\nconst t2=t1(1)\nt2(2,3)",
  "debounce": "function myDebounce(fn,delay) {\n  let timer\n  let context\n  return function (...args) {\n    context=this\n    // console.log(timer,...args)\n    if(timer){\n      clearTimeout(timer)\n    }\n    timer=setTimeout(()=>{\n      // 这里不要用clearTimeout，不会清除timer这个变量值，只是清掉了计时器\n      timer = null; \n      fn.apply(context,args)\n      // console.log('---',timer)\n    },delay)\n  }\n}\n\nconst test=(t)=>{\n  console.log(t)\n}\nconst dTest=myDebounce(test,1000)\ndTest('1')\ndTest('2')\ndTest('3')\n\nsetTimeout(()=>{\n  dTest('?')\n},1500)",
  "handwrite-call": "function myCall(context,...args){\n  // console.log(args)\n  context=context||window\n\n  const mySymbol=Symbol(); \n  context[mySymbol]=this\n  const res=context[mySymbol](...args)\n\n  delete context[mySymbol]\n  return res\n}\nFunction.prototype.myCall=myCall\n\nvar test='test'\nfunction func(tmp){\n  console.log(this.test,tmp)\n}\nfunc('?')\nconst obj={\n  test:'testtttt'\n}\n// func.call(obj,'????')\nfunc.myCall(obj,'????')",
  "handwrite-apply": "const myApply=(context,arg)=>{\n  context=context||window\n  const mySymbol=Symbol()\n  context[mySymbol]=this\n  console.log(typeof this)\n  \n  const res=context[mySymbol](...(arg||[]))\n  delete context[mySymbol]\n  return res\n}\nFunction.prototype.myApply=myApply\n\nvar test='test'\nfunction func(tmp){\n  console.log(this.test,tmp)\n}\n// func('?')\nconst obj={\n  test:'testtttt'\n}\nfunc.apply(obj,['????'])\nfunc.myApply(obj,['????'])\n",
  "handwrite-bind": "function myBind(context,...args){\n  const self=this\n  return function(...newArgs){\n    return self.apply(context,[...args,...newArgs])\n  }\n}\n\nFunction.prototype.myBind=myBind\n\n\nfunction func(...args){\n  console.log(this.test,...args)\n}\n// func('1','2')\nconst obj1={\n  test:'tes111'\n}\nconst obj2={\n  test:'tes222'\n}\nconst t=func.bind(obj1,'1')\nt('2')\nconst t2=t.bind(obj2,'1')\nt2('2')\nconst tt=func.myBind(obj1,'111')\ntt('222')\nconst tt2=tt.myBind(obj2,'111')\ntt2('222')\n",
  "deep-equal": "function deepCompare(obj1,obj2) {\n  // function symbol 简单类型\n  if(obj1===obj2){\n    return true\n  }\n  if(obj1==null||obj2==null){\n    return obj1===obj2\n  }\n  if(typeof obj1!==typeof obj2){\n    return false\n  }\n  if(typeof obj1==='object'){\n    if(obj1 instanceof Date){\n      return obj1.getTime()===obj2.getTime()\n    }\n    if(obj1 instanceof RegExp){\n      return obj1.toString()===obj2.toString()\n    }\n    if(Array.isArray(obj1)!==Array.isArray(obj2)){\n      return false\n    }\n    const keys1=Object.keys(obj1)\n    const keys2=Object.keys(obj2)\n    if(keys1.length!==keys2.length){\n      return false\n    }\n    for(let key of keys1){\n      // console.log(key,obj1[key],obj2[key])\n      if(!keys2.includes(key)||!deepCompare(obj1[key],obj2[key])){\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nconst obj1={\n  t:0,\n  tt:'2',\n  ttt:{\n    t0:'1'\n  }\n}\nconst obj2={\n  t:0,\n  tt:'2',\n  ttt:{\n    t0:'1'\n  }\n}\ndeepCompare(obj1,obj2)",
  "array-unique": "// 简单类型数组\nfunction filter(array){\n  return Array.from(new Set(array))\n}\n// 复杂类型数组-比较内存指向\nfunction filter2(array){\n  return array.reduce((acc,cur)=>{\n    if(acc.indexOf(cur)===-1){\n      acc.push(cur)\n    }\n  },[])\n}\n// 复杂类型数组-比较具体值\n需要引用deepcompare\n",
  "array-flatten": "function flat(array){\n  return array.reduce((acc,cur)=>{\n    if(Array.isArray(cur)){\n      acc=acc.concat(flat(cur))\n    }else{\n      acc.push(cur)\n    }\n    return acc\n  },[])\n}\n\nconst test=[1,2,3,4,[5,6,[7]]]\nconsole.log(flat(test))",
  "deep-clone": "function deepClone(obj){\n  if(obj==null||typeof obj !=='object'||obj instanceof Function){\n    return obj\n  }\n  let target\n  \n    if(obj instanceof Date){\n       target=new Date(obj)\n    }else if(obj instanceof RegExp){\n      target=new RegExp(obj)\n    }else if(Array.isArray(obj)){\n      target=[]\n      target=obj.map((t,i)=> deepClone(t))\n    }else{\n      target={}\n      for(let key of Object.keys(obj)){\n        target[key]=deepClone(obj[key])\n      }\n    }\n  return target\n}",
  "event-emitter": "class EventEmitter{\n  private onceListenerMap\n  private listenerMap\n  constructor(){\n    this.listenerMap=new Map()\n    this.onceListenerMap=new Map()\n  }\n\n  on(event,listener,once){\n    if(!(listener instanceof Function)){\n      return \n    }\n    const map=once?this.onceListenerMap:this.listenerMap\n    const list=map.get(event)\n    if(list){\n      list.push(listener)\n    }else{\n      map.set(event,[listener])\n    }\n  }\n  emit(event,...args){\n    const list=this.listenerMap.get(event)||[]\n    const onceList=this.onceListenerMap.get(event)||[]\n    list.forEach((func)=>{\n        func(...args)\n    })\n    onceList.forEach((func)=>{\n        func(...args)\n    })\n    this.onceListenerMap.set(event,[])\n  }\n  off(event,listener){\n    let list=this.listenerMap.get(event)||[]\n    let ind=list.indexOf(listener)\n    if(ind>-1){\n      list.splice(ind,1)\n    }\n    list=this.onceListenerMap.get(event)||[]\n    if(ind>-1){\n      list.splice(ind,1)\n    }\n  }\n  once(event,listener){\n    this.on(event,listener,true)\n  }\n}",
  "handwrite-new": "function myNew(constructor,...args){\n  const obj=Object.create(constructor.prototype)\n  // obj.__proto__=constructor.prototype\n  const res=constructor.apply(obj,args)\n  if(res&&typeof res==='object'&&!(res instanceof Function)){\n    return res\n  }else {\n    return obj\n  }\n}\n\nfunction Test(name){\n  this.name=name\n}\n\nconst t=myNew(Test,'t')\nconsole.log(t)",
  "lru-cache": "// 实现一个LRU缓存类，支持：\n// get(key)：如果key存在，返回对应值并标记为最近使用\n// put(key, value)：如果key存在则更新，否则插入；如果容量已满则淘汰最久未使用的数据\n// 例：\n// 缓存容量：3\n// 操作序列：A → B → C → A → D → B → E\n// 缓存变化：\n// A        → A,B    → A,B,C → B,C,A → C,A,D → A,D,B → D,B,E\n// (插入A)   (插入B)  (插入C) (访问A) (插入D,淘汰B) (访问B) (插入E,淘汰C)\n\n// 注意：Map 会保持键的插入顺序，这是 ES6 Map 的一个重要特性\nclass LRU{\n  constructor(cacheCount){\n    this.map=new Map()\n    this.cacheCount=cacheCount\n  }\n  get(key){\n    const val=this.map.get(key)\n    if(val){\n      this.map.set(key,val)\n      return val \n    }\n    return null\n  }\n  put(key,value){\n    if(!this.map.get(key)){\n      if(this.map.size>=this.cacheCount){\n        const tmp=this.map.keys().next().value\n        this.map.delete(tmp)\n      }\n    }\n    this.map.set(key,value)\n    // console.log(this.cacheList)\n  }\n}\n\nconst test=new LRU(5)\ntest.put('a',1)\ntest.put('b',2)\ntest.put('c',3)\nconsole.log(test.get('a'))\ntest.put('d',4)\ntest.put('e',5)\ntest.put('f',6)\nconsole.log(test.get('a'))\nconsole.log(test.get('b'))\nconsole.log(test.get('f'))",
  "async-concurrency-controller": "// arr：promise的数组\n// max：最大并发数\nasync function asyncWorker(arr,max){\n  return new Promise((resolve)=>{\n    const result=[]\n    let running=0 //当前正在执行的数量\n    let maxInd=0 //当前已经开始的最大ind\n    let doneCount=0 //已完成的数量\n    // const func=(ind)=>{ \n    // 不能这么写，核心在于不应该把ind传进去，会导致并发控制失效\n    const func=()=>{\n      if(maxInd>=arr.length) return\n      // 数量超出\n      if(running>=max) return\n      const ind=maxInd++\n      // console.log(ind)\n      running++\n      arr[ind].then((res)=>{\n        result[ind]=res\n      }).catch((err)=>{\n        result[ind]=err\n      }).finally(()=>{\n        running--\n        doneCount++\n        // console.log('done',ind,result)\n        if(doneCount<arr.length){\n          func()\n        }else{\n          resolve(result)\n        }\n      })\n    }\n  \n    new Array(max).fill(0).map((_,ind)=>func())\n  }).then((res)=>{\n    // console.log(res)\n    return res\n  })\n}\n\nconst test=(k)=> new Promise((resolve)=>{\n  setTimeout(()=>{\n    resolve(k)\n  },k*1000)\n})\nconst test1=(k)=> new Promise((resolve,reject)=>{\n  setTimeout(()=>{\n    reject(k)\n  },k*1000)\n})\nconst arr=[\n  test(4),test(2),test(5),test(3),test1(6),test1(1)\n]\nasyncWorker(arr,2)",
  "use-update": "export default function useUpdate(){\n  const [_,setState]=useState({})\n  return useCallback(()=>setState({}),[])\n}\n\n// useReducer 的 dispatch 触发重新渲染\n// dispatch 永远是稳定的引用, 不会导致子组件多余 re-render\nexport default function useUpdate(){\n  const [_,dispatch]=useReducer(()=>({}),{})\n  return dispatch\n}",
  "use-async-effect": "//这个版本实现了清理函数，但是没实现竞态消除\nexport default function useAsyncEffect(fn,deps,callback){\n  const time=useRef()\n  useEffect(()=>{\n    if(typeof fn === 'function' && typeof callback==='function'){\n      const func=async ()=>{\n        try{\n          const result = await fn()\n          if(time.current){\n            callback(result)\n          }\n        }catch(){\n          // \n        }\n      }\n      func()\n      time.current=Date.now()\n\n      return ()=>{\n        time.current=null\n      }\n    }\n  },deps)\n}\n\n//竞态消除\nexport default function useAsyncEffect(fn,deps,callback){\n  const time=useRef()\n  useEffect(()=>{\n    time.current=Date.now()\n    const currentTime=time.current\n    if(typeof fn === 'function' && typeof callback==='function'){\n      const func=async ()=>{\n        try{\n          const result = await fn()\n          if(time.current===currentTime){\n            callback(result)\n          }\n        }catch(){\n          // \n        }\n      }\n      func()\n\n      return ()=>{\n        // currentTime本来就是局部变量所以不用消除了\n      }\n    }\n  },deps)\n}",
  "use-debounce": "export default function useDebounce(fn,delay){\n  const timer=useRef()\n  const func=useCallback(()=>{\n    if(timer.current){\n      clearTimeout(timer.current)\n    }\n    timer.current=setTimeout(()=>{\n        fn()\n        timer.current = null;\n    },delay)\n  },[delay,fn])\n\n  useEffect(()=>{\n    return ()=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n    }\n  },[])\n  return func\n}\n//带参数和返回\nexport default function useDebounce2(fn,delay){\n  const timer=useRef()\n  const func=useCallback((...args)=>{\n    // 这里要用promise，因为settimeout直接返回，外层获取不到\n    return new Promise((resolve)=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n      timer.current=setTimeout(()=>{\n        const res=fn(...args)\n        timer.current = null;\n        resolve(res)\n      },delay)\n    })\n  },[delay,fn])\n\n  useEffect(()=>{\n    return ()=>{\n      if(timer.current){\n        clearTimeout(timer.current)\n      }\n    }\n  },[])\n  return func\n}",
  "use-interval": "function useInterval(fn,delay){\n  const timer=useRef()\n  //useRef 保存最新 fn，每次外层组件重新渲染会生成新的fn\n  const func=useRef(fn)\n  useEffect(()=>{\n    func.current=fn\n  },[fn])\n  \n  useEffect(()=>{\n      timer.current=setInterval(()=>{\n        func.current()\n      },delay)\n    \n    return ()=>{\n      if(timer.current){\n        clearInterval(timer.current)\n      }\n    }\n  },[delay])\n\n}",
  "use-mini-state": "// 全局变量，模拟当前渲染的组件状态\nlet hooks = [];\nlet hookIndex = 0;\n\nunction useState(initVal){\n  const curInd=hookIndex\n  const setState=(newVal)=>{\n    hooks[curInd].state=newVal\n    render()\n  }\n  return [hooks[curInd].state,setState]\n}\n\n// 模拟 render\nlet App;\nfunction render() {\n  hookIndex = 0;    // 每次渲染 hookIndex 重置\n  App = Counter(); //Counter 是使用的组件，这里省略了\n}\n"
}